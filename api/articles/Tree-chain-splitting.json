{"title":"树链剖分中的边权变点权","uid":"f5e27344f2b5924049019b3fd3c25797","slug":"Tree-chain-splitting","date":"2022-01-08T09:08:01.000Z","updated":"2022-06-06T07:01:16.466Z","comments":true,"path":"api/articles/Tree-chain-splitting.json","keywords":"HerikoDeltana,HRiver2,","cover":[],"content":"<p>「浅谈树链剖分中的边权变点权」</p>\r\n<span id=\"more\"></span>\r\n<!-- toc -->\r\n<h2 id=\"前言\">前言</h2>\r\n<p>因为我只会轻重链剖分，所以下面都是说的轻重链剖分。</p>\r\n<p>发现自己会写这个也有很长时间了，所以来水丶东西。</p>\r\n<p>最近写了好两个，稍微借题来搞一搞，估计篇幅会很短，因为主要是简单说一说思路啥的。</p>\r\n<h2 id=\"思路\">思路</h2>\r\n<p>首先，都知道树链剖分是用来维护一棵树上的结点信息的一种思想，而对于一些题，我们需要维护树上的边权，于是我们就需要将边权等效替换到点权上。</p>\r\n<p>貌似这样的题在洛谷上的评级都是紫，但是其实没那么难（话说你谷评级啥时候准过。。）</p>\r\n<p>首先简单画棵树：</p>\r\n<p><img src=\"/gallery/Tree-chain-splitting/1.png\"></p>\r\n<p>显然如果我们要把边权变为点权，需要把权值化到边的两端。</p>\r\n<p>而因为一个结点会出现对应多条边的情况，所以我们将权值放到深度浅的结点是不合适的，于是我们把他放在深度深的那个点：</p>\r\n<p><img src=\"/gallery/Tree-chain-splitting/2.png\"></p>\r\n<p>于是我们就可以进行快乐的操作了。</p>\r\n<h2 id=\"实现\">实现</h2>\r\n<p>线段树部分显然是不用动了，因为我们不需要对线段树做出特定的要求，换句话说，如果写树状数组或者珂朵莉树的话也是可以用的。</p>\r\n<p>于是就来看前置的两个 <code>DFS</code>\r\n和后面的树链部分需要作何修改。</p>\r\n<h3 id=\"dfs\">DFS</h3>\r\n<p>首先，因为我们要重新划归权值到点上，所以我们需要建立一个映射到点上的权值数组，这个直接在遍历的时候建立即可。</p>\r\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">void DFS1(int x,int fath)\n{\n    sz[x]=1,fa[x]=fath;\n\n    for(int i(head[x]);i;i=r[i].nex)\n    {\n        int y(r[i].to),v(r[i].val);\n\n        if(y==fath)\n            continue;\n\n        dep[y]=dep[x]+1;\n        tmp[y]=v;//这里 tmp 就是。\n        DFS1(y,x);\n        sz[x]+=sz[y];\n\n        if(sz[y]&gt;sz[son[x]])\n            son[x]=y;\n    }\n}</code></pre>\r\n<p>然后，因为我们还需要建立原树结点到线段树上的结点的映射，所以方便起见把权值也映射过去（</p>\r\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">void DFS2(int x,int tp)\n{\n    top[x]=tp,id[x]=++cnt,antid[cnt]=x,a[cnt]=tmp[x];//这里的 a 就是。\n\n    if(son[x])\n        DFS2(son[x],tp);\n\n    for(int i(head[x]);i;i=r[i].nex)\n    {\n        int y(r[i].to);\n\n        if(y==fa[x] or y==son[x])\n            continue;\n\n        DFS2(y,y);\n    }\n}</code></pre>\r\n<h3 id=\"树链部分\">树链部分</h3>\r\n<p>需要注意到的是我们询问一段路径上的边权最大值的时候，由于我们把权值全部下方到深度深的结点，所以路径上最浅结点的权值是不能计算在内的：</p>\r\n<p><img src=\"/gallery/Tree-chain-splitting/3.png\"></p>\r\n<p>于是我们把原本修改和查询中最后在一条链上的情况稍作修改，即从\r\n<code>Modify(1,id[x],id[y],v);</code> 和\r\n<code>Query(1,id[x],id[y]);</code> 变为\r\n<code>Modify(1,id[x]+1,id[y],v);</code> 和\r\n<code>Query(1,id[x]+1,id[y]);</code>.</p>\r\n<p>全部代码即为：</p>\r\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">I void MTree(int x,int y,int val)\n{\n    while(top[x]!=top[y])\n    {\n        if(dep[top[x]]&lt;dep[top[y]])\n            swap(x,y);\n\n        Modify(1,id[top[x]],id[x],val);\n        x=fa[top[x]];\n    }\n\n    if(dep[x]&gt;dep[y])\n        swap(x,y);\n\n    Modify(1,id[x]+1,id[y],val);\n}\n\nI int QTree(int x,int y)\n{\n    int res(0);\n\n    while(top[x]!=top[y])\n    {\n        if(dep[top[x]]&lt;dep[top[y]])\n            swap(x,y);\n\n        res+=Query(1,id[top[x]],id[x]);\n        x=fa[top[x]];\n    }\n\n    if(dep[x]&gt;dep[y])\n        swap(x,y);\n\n    res+=Query(1,id[x]+1,id[y]);\n\n    Heriko res;\n}</code></pre>\r\n<h2 id=\"例题\">例题</h2>\r\n<p><a href=\"https://www.luogu.com.cn/problem/P1505\">洛谷 | P1505 旅游\r\n[国家集训队]</a></p>\r\n<blockquote>\r\n<p>Time: 1s | Memory: 256Mb</p>\r\n</blockquote>\r\n<p>这道题就需要用到上面的操作把边权下放到点权。</p>\r\n<p>当然，因为这个题的特殊性（需要维护最大值、最小值、区间和），所以代码会很长（（</p>\r\n<p>不过还是不难的，线段树多复制几个函数分别维护即可。</p>\r\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;stdio.h&gt;\n#include &lt;cmath&gt;\n#include &lt;algorithm&gt;\n#include &lt;cstring&gt;\n\n#define Heriko return\n#define Deltana 0\n#define Romanno 1\n#define S signed\n#define LL long long\n#define R register\n#define I inline\n#define CI const int\n#define mkp(a,b) make_pair(a,b)\n#define mst(a,b) memset(a,b,sizeof(a))\n#define ON std::ios::sync_with_stdio(false);cin.tie(0)\n#define Files() freopen(\"RNMTQ.in\",\"r\",stdin);freopen(\"RNMTQ.out\",\"w\",stdout)\n\nusing namespace std;\n\ntemplate&lt;typename J&gt;\nI void fr(J &amp;x)\n{\n    short f(1);\n    x=0;\n    char c(getchar());\n\n    while(c&lt;'0' or c&gt;'9')\n    {\n        if(c=='-')\n            f=-1;\n        \n        c=getchar();\n    }\n\n    while(c&gt;='0' and c&lt;='9') \n    {\n        x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^=48);\n        c=getchar();\n    }\n   \n    x*=f;\n}\n\ntemplate&lt;typename J&gt;\nI void fw(J x,bool k)\n{\n    if(x&lt;0)\n        x=-x,putchar('-');\n\n    static short stak[35];\n    short top(0);\n\n    do\n    {\n        stak[top++]=x%10;\n        x/=10;\n    }\n    while(x);\n\n    while(top)\n        putchar(stak[--top]+'0');\n\n    k?puts(\"\"):putchar(' ');\n}\n\ntemplate&lt;typename J&gt;\nI J Hmax(const J &amp;x,const J &amp;y)\n{\n    Heriko x&gt;y?x:y;\n}\n\ntemplate&lt;typename J&gt;\nI J Hmin(const J &amp;x,const J &amp;y)\n{\n    Heriko x&lt;y?x:y;\n}\n\nCI MXX(2e5+1),INF(0x7fffffff);\n\nstruct Edge\n{\n    int nex,to,val;\n}\n\nr[MXX&lt;&lt;1];\n\nint rcnt,head[MXX];\n\nI void Add(int x,int y,int z)\n{\n    r[++rcnt]=(Edge){head[x],y,z},head[x]=rcnt;\n    r[++rcnt]=(Edge){head[y],x,z},head[y]=rcnt;\n}\n\nint tmp[MXX],cnt,a[MXX],sz[MXX],fa[MXX],dep[MXX],son[MXX],top[MXX],id[MXX],antid[MXX];\n\nvoid DFS1(int x,int fath)\n{\n    sz[x]=1,fa[x]=fath;\n\n    for(int i(head[x]);i;i=r[i].nex)\n    {\n        int y(r[i].to),v(r[i].val);\n\n        if(y==fath)\n            continue;\n\n        dep[y]=dep[x]+1;\n        tmp[y]=v;\n        DFS1(y,x);\n        sz[x]+=sz[y];\n\n        if(sz[y]&gt;sz[son[x]])\n            son[x]=y;\n    }\n}\n\nvoid DFS2(int x,int tp)\n{\n    top[x]=tp,id[x]=++cnt,antid[cnt]=x,a[cnt]=tmp[x];\n\n    if(son[x])\n        DFS2(son[x],tp);\n\n    for(int i(head[x]);i;i=r[i].nex)\n    {\n        int y(r[i].to);\n\n        if(y==fa[x] or y==son[x])\n            continue;\n\n        DFS2(y,y);\n    }\n}\n\n#define lc(x) (x&lt;&lt;1)\n#define rc(x) (x&lt;&lt;1|1)\n\nstruct Node\n{\n    int l,r,tg,mx,mi,v;\n}\n\nt[MXX&lt;&lt;2];\n\nI void Pushup(int x)\n{\n    t[x].mi=Hmin(t[lc(x)].mi,t[rc(x)].mi);\n    t[x].mx=Hmax(t[lc(x)].mx,t[rc(x)].mx);\n    t[x].v=t[lc(x)].v+t[rc(x)].v;\n}\n\nI void Cover(int x)\n{\n    t[x].tg^=1;\n    t[x].v=-t[x].v;\n    t[x].mi=-t[x].mi;\n    t[x].mx=-t[x].mx;\n    swap(t[x].mi,t[x].mx);\n}\n\nI void Pushdown(int x)\n{\n    if(!t[x].tg)\n        Heriko;\n\n    Cover(lc(x));\n    Cover(rc(x));\n    t[x].tg=0;\n}\n\nvoid Build(int x,int l,int r)\n{\n    t[x].l=l,t[x].r=r,t[x].tg=0;\n\n    if(l==r)\n    {\n        t[x].v=t[x].mi=t[x].mx=a[l];\n\n        Heriko;\n    }\n\n    int mid((l+r)&gt;&gt;1);\n    Build(lc(x),l,mid);\n    Build(rc(x),mid+1,r);\n    Pushup(x);\n}\n\nvoid ModifyOne(int x,int pos,int val)\n{\n    if(t[x].l==t[x].r)\n    {\n        t[x].mx=t[x].mi=t[x].v=val;\n\n        Heriko;\n    }\n\n    Pushdown(x);\n    int mid((t[x].l+t[x].r)&gt;&gt;1);\n\n    if(pos&lt;=mid)\n        ModifyOne(lc(x),pos,val);\n\n    if(pos&gt;mid)\n        ModifyOne(rc(x),pos,val);\n\n    Pushup(x);\n}\n\nvoid ModifyAll(int x,int lx,int rx)\n{\n    if(lx&lt;=t[x].l and t[x].r&lt;=rx)\n    {\n        Cover(x);\n\n        Heriko;\n    }\n\n    Pushdown(x);\n    int mid((t[x].l+t[x].r)&gt;&gt;1);\n    \n    if(lx&lt;=mid)\n        ModifyAll(lc(x),lx,rx);\n\n    if(rx&gt;mid)\n        ModifyAll(rc(x),lx,rx);\n\n    Pushup(x);\n}\n\nint QueryMax(int x,int lx,int rx)\n{\n    if(lx&lt;=t[x].l and t[x].r&lt;=rx)\n        Heriko t[x].mx;\n\n    Pushdown(x);\n    int res(-INF),mid((t[x].l+t[x].r)&gt;&gt;1);\n\n    if(lx&lt;=mid)\n        res=Hmax(res,QueryMax(lc(x),lx,rx));\n\n    if(rx&gt;mid)\n        res=Hmax(res,QueryMax(rc(x),lx,rx));\n\n    Heriko res;\n}\n\nint QueryMin(int x,int lx,int rx)\n{\n    if(lx&lt;=t[x].l and t[x].r&lt;=rx)\n        Heriko t[x].mi;\n\n    Pushdown(x);\n    int res(INF),mid((t[x].l+t[x].r)&gt;&gt;1);\n\n    if(lx&lt;=mid)\n        res=Hmin(res,QueryMin(lc(x),lx,rx));\n\n    if(rx&gt;mid)\n        res=Hmin(res,QueryMin(rc(x),lx,rx));\n\n    Heriko res;\n}\n\nint QuerySum(int x,int lx,int rx)\n{\n    if(lx&lt;=t[x].l and t[x].r&lt;=rx)\n        Heriko t[x].v;\n\n    Pushdown(x);\n    int res(0),mid((t[x].l+t[x].r)&gt;&gt;1);\n\n    if(lx&lt;=mid)\n        res+=QuerySum(lc(x),lx,rx);\n\n    if(rx&gt;mid)\n        res+=QuerySum(rc(x),lx,rx);\n\n    Heriko res;\n}\n\nI void MTree(int x,int y)\n{\n    while(top[x]!=top[y])\n    {\n        if(dep[top[x]]&lt;dep[top[y]])\n            swap(x,y);\n\n        ModifyAll(1,id[top[x]],id[x]);\n        x=fa[top[x]];\n    }\n\n    if(dep[x]&gt;dep[y])\n        swap(x,y);\n\n    if(x!=y)\n        ModifyAll(1,id[x]+1,id[y]);\n}\n\nI int QTreeMax(int x,int y)\n{\n    int res(-INF);\n\n    while(top[x]!=top[y])\n    {\n        if(dep[top[x]]&lt;dep[top[y]])\n            swap(x,y);\n\n        res=Hmax(res,QueryMax(1,id[top[x]],id[x]));\n        x=fa[top[x]];\n    }\n\n    if(dep[x]&gt;dep[y])\n        swap(x,y);\n\n    if(x!=y)\n        res=Hmax(res,QueryMax(1,id[x]+1,id[y]));\n\n    Heriko res;\n}\n\nI int QTreeMin(int x,int y)\n{\n    int res(INF);\n\n    while(top[x]!=top[y])\n    {\n        if(dep[top[x]]&lt;dep[top[y]])\n            swap(x,y);\n\n        res=Hmin(res,QueryMin(1,id[top[x]],id[x]));\n        x=fa[top[x]];\n    }\n\n    if(dep[x]&gt;dep[y])\n        swap(x,y);\n\n    if(x!=y)\n        res=Hmin(res,QueryMin(1,id[x]+1,id[y]));\n\n    Heriko res;\n}\n\nI int QTreeSum(int x,int y)\n{\n    int res(0);\n\n    while(top[x]!=top[y])\n    {\n        if(dep[top[x]]&lt;dep[top[y]])\n            swap(x,y);\n\n        res+=QuerySum(1,id[top[x]],id[x]);\n        x=fa[top[x]];\n    }\n\n    if(dep[x]&gt;dep[y])\n        swap(x,y);\n\n    if(x!=y)\n        res+=QuerySum(1,id[x]+1,id[y]);\n\n    Heriko res;\n}\n\nint n,m;\n\npair&lt;int,int&gt; E[MXX];\n\nS main()\n{\n    Files();\n\n    fr(n);\n\n    for(int i(1);i&lt;n;++i)\n    {\n        int x,y,z;\n        fr(x),fr(y),fr(z);\n        Add(x+1,y+1,z);\n        E[i].first=x+1,E[i].second=y+1;\n    }\n\n    fr(m);\n    DFS1(1,0);\n    DFS2(1,1);\n    Build(1,1,n);\n\n    while(m--)\n    {\n        char opt[10];\n        int x,y;\n        scanf(\"%s\",opt+1),fr(x),fr(y);\n\n        if(opt[1]=='C')\n        {\n            if(dep[E[x].first]&gt;dep[E[x].second])\n                ModifyOne(1,id[E[x].first],y);\n            else\n                ModifyOne(1,id[E[x].second],y);\n        }\n        else if(opt[1]=='N')\n            MTree(x+1,y+1);\n        else if(opt[1]=='S')\n            fw(QTreeSum(x+1,y+1),1);\n        else if(opt[1]=='M' and opt[2]=='A')\n            fw(QTreeMax(x+1,y+1),1);\n        else if(opt[1]=='M' and opt[2]=='I')\n            fw(QTreeMin(x+1,y+1),1);\n    }\n\n    Heriko Deltana;\n}</code></pre>\r\n<p>关于这道题做完之后在<a href=\"https://www.cnblogs.com/HRiver2/p/HR2note18-2.html\">杂题记录</a>里的感想：</p>\r\n<blockquote>\r\n<p>我在上个题的时候曾经说过：</p>\r\n<blockquote>\r\n<p>不得不说虽然长是长了点，树剖还是好玩的，对于我这种没有脑子的人来说，不用想就能打的东西太好了。</p>\r\n</blockquote>\r\n<p>确实，于是这个题的代码长度就成为了我目前为止通过代码中最长的，415\r\n行，7Kb。（当然，和我码风有空行有关系）</p>\r\n<div data-align=\"center\">\r\n<p><img src=\"https://s2.loli.net/2022/01/08/HfWucPEMZjRCyaT.png\"></p>\r\n</div>\r\n<p>树剖部分基本是一遍写对的，最后错了半天是因为题目说的边的编号要是\r\n<span class=\"math inline\"><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.186ex\" xmlns=\"http://www.w3.org/2000/svg\" width=\"9.403ex\" height=\"1.692ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -666 4156 748\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mn\"><path data-c=\"30\" d=\"M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(777.8,0)\"><path data-c=\"223C\" d=\"M55 166Q55 241 101 304T222 367Q260 367 296 349T362 304T421 252T484 208T554 189Q616 189 655 236T694 338Q694 350 698 358T708 367Q722 367 722 334Q722 260 677 197T562 134H554Q517 134 481 152T414 196T355 248T292 293T223 311Q179 311 145 286Q109 257 96 218T80 156T69 133Q55 133 55 166Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1833.6,0)\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(2655.8,0)\"><path data-c=\"2212\" d=\"M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(3656,0)\"><path data-c=\"31\" d=\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"></path></g></g></g></svg></mjx-container></span>，但是我读入的时候忘了\r\n+1，害的我把前面的重新看了一遍。。</p>\r\n<p>但是还好这是 7Kb 的树剖而不是其它别的什么鬼东西。</p>\r\n</blockquote>\r\n<h2 id=\"终声\">终声</h2>\r\n<p>水完力（</p>\r\n","text":"「浅谈树链剖分中的边权变点权」...","link":"","photos":[],"count_time":{"symbolsCount":"9.2k","symbolsTime":"8 mins."},"categories":[{"name":"OI-Algorithm","slug":"OI-Algorithm","count":10,"path":"api/categories/OI-Algorithm.json"}],"tags":[{"name":"OI","slug":"OI","count":26,"path":"api/tags/OI.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">思路</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#dfs\"><span class=\"toc-text\">DFS</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A0%91%E9%93%BE%E9%83%A8%E5%88%86\"><span class=\"toc-text\">树链部分</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BE%8B%E9%A2%98\"><span class=\"toc-text\">例题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%88%E5%A3%B0\"><span class=\"toc-text\">终声</span></a></li></ol>","author":{"name":"Heriko Deltana","slug":"blog-author","avatar":"https://s2.loli.net/2022/06/18/b2uURvwiFghrGxB.jpg","link":"/","description":"ねぇねぇねぇ","socials":{"github":"https://github.com/HRiver2","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/gallery/bilibili-brands.svg","link":"https://space.bilibili.com/507947803"},"Luogu":{"icon":"/gallery/user-solid.svg","link":"https://www.luogu.com.cn/user/407417"}}}},"mapped":true,"prev_post":{"title":"李超线段树","uid":"d02391e4e5b05700cce339d30dcd4af4","slug":"Li-Chao-Tree","date":"2022-01-23T00:23:57.000Z","updated":"2022-06-06T06:58:25.097Z","comments":true,"path":"api/articles/Li-Chao-Tree.json","keywords":"HerikoDeltana,HRiver2,","cover":[],"text":"「李超线段树浅学浅记。」...","link":"","photos":[],"count_time":{"symbolsCount":"4.5k","symbolsTime":"4 mins."},"categories":[{"name":"OI-Algorithm","slug":"OI-Algorithm","count":10,"path":"api/categories/OI-Algorithm.json"}],"tags":[{"name":"OI","slug":"OI","count":26,"path":"api/tags/OI.json"}],"author":{"name":"Heriko Deltana","slug":"blog-author","avatar":"https://s2.loli.net/2022/06/18/b2uURvwiFghrGxB.jpg","link":"/","description":"ねぇねぇねぇ","socials":{"github":"https://github.com/HRiver2","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/gallery/bilibili-brands.svg","link":"https://space.bilibili.com/507947803"},"Luogu":{"icon":"/gallery/user-solid.svg","link":"https://www.luogu.com.cn/user/407417"}}}}},"next_post":{"title":"平面最近点对","uid":"059d3957398e3d8d567699f700b617cb","slug":"Narest-points","date":"2022-01-04T09:16:17.000Z","updated":"2022-06-06T06:59:01.466Z","comments":true,"path":"api/articles/Narest-points.json","keywords":"HerikoDeltana,HRiver2,","cover":null,"text":"「平面最近点对」...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[{"name":"OI-Algorithm","slug":"OI-Algorithm","count":10,"path":"api/categories/OI-Algorithm.json"}],"tags":[{"name":"OI","slug":"OI","count":26,"path":"api/tags/OI.json"}],"author":{"name":"Heriko Deltana","slug":"blog-author","avatar":"https://s2.loli.net/2022/06/18/b2uURvwiFghrGxB.jpg","link":"/","description":"ねぇねぇねぇ","socials":{"github":"https://github.com/HRiver2","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/gallery/bilibili-brands.svg","link":"https://space.bilibili.com/507947803"},"Luogu":{"icon":"/gallery/user-solid.svg","link":"https://www.luogu.com.cn/user/407417"}}}}}}