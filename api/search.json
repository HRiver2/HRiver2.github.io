[{"id":"1b49c4826a19ccfde100a44c13b19833","title":"并非底色","content":"「1，2，3」\r\n\r\n\r\n\r\n首先声明，这篇文章不存在与我有关的现实意义，是被迫为某些正能量稿准备。但是也发上来留存一下。\r\n如果某一天我能顺从心意地写出来很阳光的文字，那么那一天世界因为暴雨回到了\r\n2021 年之前。\r\n\r\n或许我们在这里并不需要一个 H2/H3 标题。\r\n近日听到友人在谈论颜色的问题，谈论自己的颜色。\r\n于我而言，我的颜色是什么呢？\r\n\r\n大抵每个人都会有自己的底色，我暂且认为是自己喜欢的颜色吧。\r\n所以我的底色，大概就是很淡的蓝色，近似于 #F0F8FF.\r\n这里面包含了我对于青春所有的美好的期许和回忆，所以它是浅淡的、轻轻的蓝色。\r\n它代表着我的笑，我的理想，我的梦，是我的最初。\r\n\r\n然后，世界从来不是一个人的故事，我们生活在一个熙熙攘攘的世界，所以，我们也会染上别人的颜色。\r\n染上热情的橙色，染上温柔的粉色，染上坚定的青色。\r\n渐渐的，我们不再只是自己的底色，我们青春的颜色也越来越具象。\r\n我们也会因为各种事情为自己染色。\r\n所立下的誓言，所经历的困难，所忍受的不公，所哭过的，所笑过的，一切的一切，都是已经是颜色的一部分。\r\n于是我们的颜色中蕴含了我们的一切过去。\r\n\r\n所以我的颜色不是哪一种确定的颜色，现在不是，以后也不会是，只要我还在前进着。\r\n","slug":"Color","date":"2024-10-19T17:07:44.000Z","categories_index":"Nothing","tags_index":"Me","author_index":"Heriko Deltana"},{"id":"c92997897e88b4b84676da79befca607","title":"三年飞渡","content":"「2021.1.23 → 2024.6.10」\r\n\r\n\r\nAlongLight\r\n三年飞渡\r\n我的高中时光，准确来说是 2021.1.23 → 2024.6.10\r\n所以，准确来说，是三年半。\r\n这个标题对应的文章本应更早一些出现在这个世界上的，但是我好像忘了写了？好像不是。\r\n不，好像不是我不知道该怎么写，明白了，是堂堂拖延症（）\r\n于是现在也还是不知道怎么写，但是我想写点什么，要不然总是觉得少点什么，毕竟我这种人吧，虽然写不出来什么高深或者优美的文字，却总是想着写点什么好似给自己一个安心药一样，所以就会下面的文字。\r\n有考虑到内容会相当的具体真实所以做一些省略以保护隐私，但是我寻思了我已经被开的到处都是盒了还怕这个吗，所以直接开写！\r\n\r\n何为三年飞渡？\r\n这源自于一个很简单的意思：初中部和高中部之间以一架卿云桥相连，从初中到高中，需要过这个桥，大概就是飞渡吧。\r\n但是这个过程并不是跨过这座桥就完成了，于是就有了这三年飞渡。\r\n\r\n何为 AlongLight?\r\nA longlight / Along the light.\r\n01 渡\r\n虽然回顾之前自己写的东西很羞耻，尤其是高一之前的文章，但是还是让我们来看看那个时候我是怎么写的吧：\r\n\r\n\r\n标题为何我也不知\r\n\r\n\r\n标题为何我也不知\r\n说实话，听广播的时候挺激动的 （话说前一天晚上还觉得无所谓来着）\r\n激动的把某人衣服快拽黑了 感觉非常抱歉（）\r\n老师宣读之前吊胃口时间有点长 读到我之前的时间也有点长 总是还是来了\r\n（贡献了某袖子，淦）\r\n给班里说一句话的时候，的确有点着急，\r\n再加上本身我语文不行，反正表意很不明确\r\n晚上睡不着，不是激动 应该就是怀念1班的同学们\r\n感觉没好好说再见 （不过好像也还能偷着来看看？）\r\n天泽（滞碍），张张，兴华，迪哥，阿仲，小杰，托🥚，普林，宗林，公子，花（huan）生……\r\n当然人很多，有些我也没想好怎么给个别人说，就先埋藏在我心中吧\r\n⊙ω⊙，等你们放假了再传达一下，反正&gt;\r\n有些是真的留念（才半天就这样了啊喂你个憨批(´இ皿இ｀)）\r\n仔细来想， （基本）上和所有的同学 都有着美好的回忆（吧）\r\n个人感觉，我的偏执，轻浮\r\n都是你们陪着我打磨没的（当然可能还有(´இ皿இ｀)）\r\n我的每次低谷，巅峰，都有你们陪着\r\n想到课本的一句话\r\nwe are going to separate way now\r\n我们将在接下来的半年，走不同的道路，但我们目标相同，\r\n愿和你们，卿云桥那边见。\r\n2021.1.23\r\n\r\n\r\n可以看出来，那个时候……怎么说呢，好青春的文笔？好像只能这样说了。写东西的风格转变，大概涉及到一个性格的转变吧，这个后面会说。\r\n让我们把视线投向比 2021.1.23\r\n更早的地方吧，看看飞渡之前的我经历了什么。\r\n自信心就是从这里开始丧失的。\r\n数学真是伴随我中学六年的 Nightmere\r\n啊，我的自信最佳破壁者。作为初中部的一员，最希望的显然是进入高中部，毕竟是这里最好的高中之一了，而实验班是第一个机会。即使六年多过去了，我依然记得当时我被告知参加实验班考试的入场券，即初三实验班考试前各次考试都能进成绩级部\r\n400\r\n名，一个并不是很困难的目标，对于大部分前列学生来说，当然也包括我。当然后来我才知道，决定能不能去考的决定权在班主任那里。\r\n对于初三的我来说，让我平均成绩正常的唯一方法，就是数学稳定 140\r\n以上，毕竟初中的时候，大家都拉不开差距，我是实打实的有着数学上的波动性，于是就给自己上压力了。可惜我脆弱的心理承受能力无法让我顶住自己加上的压力，于是就有了期中模拟的优异和正式期中的炸裂，期中的炸裂来自于考数学时脑子里全是纷乱的杂音，就像是有万个人在说话，我明白那是自己深层的意识在说话，但是我无法控制，现在想来，那可能是一些不好的事情的起始吧。\r\n期中之后心情不是很好，因为我很难相信，也很难让别人相信，我在考场上是被自己脑内的弹幕击垮的。这种程度的名次浮动并不会影响那个入场券，只是会影响我的自信罢了。\r\n“可是一切都已结束了啊。”\r\n这是我在月考结束后写在一个不知道现在放在哪的本子上的第一句话，也是唯一一句话。原因也可以想到了，月考的到来显然比我从消极中恢复更快，于是我考出了初中数学新低，并且自己把自己的入场券踹飞了。\r\n与其说因为失去实验班的机会而写下这些，不如说是因为我从我的初三看不到未来，我看不到中考能赢的机会。不过后来的也是获得了去考的机会，最终以倒数第二个被念名进入了实验班。就像是前面写的一样。\r\n想来那个时候真的是 E\r\n人吧，过了一小会就把自己的难受全部埋在土里了，活跃而多言，纯正的\r\nENFP，不带一点假吧。于是度过了到目前唯一一个有女生送礼物的圣诞节，度过了一段感觉很奇妙的同桌时光，当然，那也是我在初中教室里的最后时光。\r\n然后就是正式开始了三年飞渡。\r\n我是带着剩余了 50%\r\n的自信进入实验班的，因为我知道我相比真正前排的人，还差的远。这样的心态的好处是让我在垫底位置锻炼出了很高的抗压能力，但缺点就是削减自信，让我的心里逐渐积累了一些不好的东西，开始为一颗炸弹做引线。\r\n但是幸好我还有 OI，在 OI\r\n前期的世界里，我天性中对于代码和科技的热情让我能找回一些状态。可惜去了\r\nOI 之后，我依然是垫底，我的自信依旧被稳定削掉，趋近于\r\n0，但是毕竟小班时期的生活还是比较自在舒适的，除了考推荐生需要有点压力以外，我可以把时间放在自己想要的地方。那个时候应该是正儿八经的\r\nENFP 吧，按照现在的标准，现在的我大概身上还存在着 40%\r\n左右的那时的我吧。\r\n按照当时来看，21\r\n年的暑假应该是我美好高中生活的开始。当然，从现在来看，那是我三年半的生活中为数不多的高光，真是讽刺啊，高中最高光的时候出现在还没正式上高中的时候。\r\n这个暑假，让我越来越觉得所谓运气守恒定律是真的存在的。首先是在暑假的三段\r\nOI 课程中成绩逐步提高，第三次课最后一次考试还侥幸来到了\r\nRank2，在未来的各种队✌前面，拿到了自己第一次也是最后一次因为 OI\r\n获得的奖品。其次，在考试的同一天，这辈子没有中奖过的我居然在 B\r\n站抽中了一个 648？最后，在这个暑假我认识了我最好的学长，🐑🍑🐟。\r\n可以说，这是我在整个高中时期最快乐的一段日子了。或许也是因为以后再也没有过事情顺利心情也好心理状态也正常的时候了吧，对这段时间总是很怀念。\r\n02 21.11.04\r\n但是某种意义上来说，所有的负面情绪，也是在前面那段时间积存下来的。毕竟负面情绪这些东西啊，并不会自己消失，它或许一时间没有出现，但是每当某些机关被触发的时候它们就会出现，并让眼前染上静默的黑色。\r\n如今已经快过去三年，让如今的我再去回想，已经无法想起这一切如何而起，但是却还能感受到当时把我世界冲垮的那股洪流。三年之后的今天，依旧没有根治的方法，我只能告诉自己不要陷入幽微，控制自己不再深入的想。因为这是一个无底洞，我是想不完的。最让人恐惧的是，这三年，我为了不让自己再次掉进去，在这个深洞周围建立了围墙，可是啊，围墙越高，这个洞就相应的越深。\r\n为什么是这一天呢？我不知道。就像为什么下一天就下雪了一样，我无法知晓。\r\n有时候我在想这是否是我自己太过任性，自己故意让自己陷入忧郁的思绪之中。好像还挺有道理的，毕竟只要自己不想就不会有这件事情啊，毕竟只有自己才能让自己陷入幽微和幽静。但是这没道理啊，这些东西一直都存在着，它们已经是我的一部分，我永远无法和它们切割了。\r\n这个过程，我很幸运能有人倾听我，愿意接受我所说的话，我的这份，算是……感激吗？可以说是这三年飞渡中最重要的感情了。毕竟，这三年我并没有发展任何的恋爱情愫什么的，所以这一份就是最重要的感情了吧。\r\n关于这点，大概是吧，我不知道，或许也不会知道，所以不确定的东西就不写了，毕竟用了很长一段时间也没有想明白，也许我需要一个更长的视角去看，或许十年？我知道的，你很聪明的，看了就明白我在说你的，虽然我觉得你不会来看，因为于你我并不特殊，而你于我确实特殊。\r\n我好烦不对等，或者说我是在害怕已经存在的不对等。\r\n记忆掩埋在白雪中了吗，现在再回忆，我回忆不出一点愤怒和悲伤，只是会让我眼前的世界染上静默的黑色。这一份，可以说是心理上的问题吗，就跟随我至今。\r\n但就像是我在某份”奏折“中所写的那样，最后我们都是自己走出来的。\r\n是啊，毕竟所谓心理医生，我没有在状态很差的时候去见过，他又如何能检验出来呢。更何况，我每天都在以\r\n10%\r\n的自己对待外界，除非我自己说出来，别人又如何理解我呢。所以那个时候是不是抑郁了什么的并不重要了，以后也不会有机会给我的之前下这个定义的。\r\n不过还真应该感谢一下自己胡思乱想的大脑，如果不是想到我妈，我大概已经成为日新楼下抹去的一个过去。\r\n\r\n一组有趣的数据，来自 16personality：\r\n\r\n2021.12 : 71% e + 29% i\r\n2022.3 : 51% e + 49% i\r\n2022.5 : 40% e + 60% i\r\n2023.7 : 32% e + 68% i\r\n2024.5 : 22% e + 78% i\r\n2024.9 : 31% e + 69% i\r\n\r\n很大的变化，于是我从 ENFP 变成了\r\nINFP，已经成为那个在破冰团建的时候除了自我介绍蹦出来四句话以外一句话都说不了的人了。\r\n那天之后，我最初是想要 cancel\r\n之前的自己，把自己大脑中的很多东西归为空白。但是后来我发现那是不可能的啊，我已经作为一个实体存在于这个世界上数年了，除非我突然消失，我所想的都不会出现啊。\r\n所以当时为什么会想着自杀呢。所以当时为什么会想着自杀呢？所以当时为什么会想着自杀呢。所以当时为什么会想着自杀呢？\r\n”对于我自己而言，我已经没有存在的意义了啊。“\r\n所以为什么我最后还是收回了迈向空中的腿呢？所以为什么我最后还是收回了迈向空中的腿呢。所以为什么我最后还是收回了迈向空中的腿呢？所以为什么我最后还是收回了迈向空中的腿呢。\r\n”对于别人而言，我居然还有存在的意义啊。“\r\n于是我才发现，我活着，真的不是只为了自己而活着。虽然有点像是被身旁的世界困住了，但是感谢那个时候的自己吧。\r\n所以自那以后每年的生日愿望都是，活到下次生日。\r\n2022.3：活到 17.\r\n2023.3：活到 18.\r\n2024.3：活到 19.\r\n很喜欢 25h 那种相互拯救的剧情，但是毕竟我并没有一个无人的\r\nSEKAI，我只有一个到处是人现实。\r\n03 Re\r\n于是从 21 年之后就会每年纪念一下\r\n1104，虽然对于现在的我来说，真的只是一个纪念而已。经过了 22\r\n年底疫情时段的洗礼之后，我似乎已经完全想明白了，我需要自己，我需要自己向前走，任何时候都需要。\r\n我真的想明白了吗，大概是吧，至少从那一段被关在外地学校里的时候我所想到的，就只是这些。那个时候疫情的阴影远大于奥赛对于我的意义，备考集训的时候想的最多的是能不能不被封到平邑然后回家。当在\r\nNOIP2022 考场罚坐 3.5h\r\n出来之后，我的第一想法不是自己能不能拿到省一，而是我想抓紧回家。终于在家门口下车之后，我才感觉到莫名的放心，理论上应该是很重要的自己是不是省一的事情没有怎么去想。\r\n所以到底什么是重要的，只有我自己认定了之后才能明白啊。\r\n其实我是一个严重的经验论、结果论和守恒论的受害者，每次有相似的事情的时候都会去想之前的经验和结果。就像是奥赛的第一年后段并不顺利，于是我整个第二年的经验和情绪都不是很积极，还好最后有积极的心理暗示，让我挂分也保留住了省一。\r\n但是很多事情并不是两次就完事的啊，比如说考试。\r\n纵观我的成绩起伏曲线，其实会有一个很有趣的现象：上升和下降都是连续几次的，就算到了最后高三三模连考趋近于稳定的时候，也是如此规律。\r\n其实这很好解释：上次考试的结果会让我在意上次考试前的经验和事件，但是那些经验和事件最终导向的是上次的结果，所以迎接下次考试的时候的心理状态就是完全建立在上一次的结果上的。于是就有了考好一次之后连续的考好和考差一次之后连续的考差。\r\n当然，后面这种情况占绝大多数。再加上我们班确实是仙之人兮列如麻，所以总体来说我这三年的消极情绪还是挺多的。所以有时候也觉得自己挺不容易的，毕竟经常垫底偶尔中游的情况下还能有着相对正常的心态，大概已经很不容易了。\r\n在高三最后那一段时间会想，如果当时我选择离开这个班，去到一个普通班，会不会好一点呢？\r\n其实留在这个班大概是自己干过的，之前的自己最不敢做的事情吧。\r\n\r\n\r\n硫球星观测枢 2022.9.15\r\n终归还得是自己创造。\r\n\r\n这个事情，分为两个阶段，和我的一个任性，我想了想还是决定要写一下这一段大概影响了我之后时光的事，是我认为我在这三年中遇见的最奇怪的事情，也是我遇到的最任性的我。从那之后，我再也没那么为了自己的任性做过这么多事情。\r\n32 和 33\r\n要重新分班，要分为继续学奥赛和放弃奥赛转而专心学习文化课的两个班。但是这个分班的时间卡在\r\n9\r\n月，对于其他奥赛来说可能正好，因为数物化可以打三年，故这个分班不会影响任何人的后期学习；而生物奥赛虽然只能打两年，但是他们考试集中在\r\n4 月到 8 月，也不会影响奥赛后的学习。\r\n可是 OI 不一样啊，NOI 在暑假举办注定常规高中 OIer\r\n的寿命只有两年，和生物一样。但是 CSP 和 NOIP 在 9 ~ 11 月，而省选在次年\r\n4 月，这意味着如果决定在高二冲击奥赛而 NOIP\r\n成绩未能够格进入省队的话，会在 12 月回归文化课。\r\n那么如果这个人在奥赛班，那么他将无处上课，除非老师愿意给这几个人单开一个班的课，这可能性很小；如果这个人在非奥赛班，那么他一定会\r\nNOIP\r\n前面临无法专心冲击奥赛，并且在回归文化课之后和班里进度严重脱节。\r\n22\r\n年的分班还有一个特别之处：班主任。虽然这一点在高三的时候也变的无可厚非。\r\n大家公认的是 ，而大家一直在猜测 szy\r\n带文化课，lzh带奥赛，但是最后反转了，32 奥赛 szy，33 文化课 lzh.\r\n其实我只是想要一个安全的奥赛备考环境，所以我肯定是优先想要去奥赛班，但是这个分配权并不在我这里。于是很自然的，我最一开始被分到了\r\n33，按照当时的说法，我的奥赛生涯就要在那里结束了，但是我甚至还在停课阶段，这我不能接受。\r\n但是现状是 32 人数明显多于 33，并不好再转入。\r\n但是我并不想这样，我的 OI 生涯还没结束。\r\n但是我还有一点任性的愿望没有达成，我想继续在一个班。\r\n于是在宣布完分班结果的 1 分钟后，我去找了\r\nszy，告诉他我在停课冲击奥赛（当然，现在来看大概是冲击第一年自己因为近似抑郁丢掉的省一），告诉他我想要去奥赛班。\r\n大概当时 szy\r\n也没有考虑特别多后来的事情，就本着原则上没问题的情况下让我搬着桌子去 32\r\n了。\r\n但是显然这个事情并没有这么容易就结束，这只是过了班主任这一关。很快，级部主任就否定了我的请求，他的理由是\r\n32 人太多了。\r\n其实在前一段时间的幽微之后，我已经基本丧失了面对面和别人主动交谈的能力（直到现在也是很受影响），能去和\r\nszy 说这个事情，本身就已经超过了我自己对自己的能力预期。\r\n放在原来的我，遇到级部主任否决，肯定就不再作为了，毕竟这很难去改变了。但是啊，我的任性不允许我就这样放弃，因为我很看重。\r\n于是我决定要去和级部主任谈一谈，不过不抱着让他改变想法的希望。\r\n我的表述是：“级部和我们之间的通知总是由班主任代传，我并不能知道为什么级部要坚持这么做，我今天到来，只是为了知道级部真正的原因，而不是为了改变级部的想法。”\r\n我永远忘不了在路上和 szy\r\n聊的时候的场景，他问我为什么要这么坚持，他问我关于信奥的时间规划。于是我才知道，原来，信息奥赛在你历二设立了快十年了，实验班班主任和级部主任都不知道信息奥赛的安排。\r\n那一瞬间，我有点无力，毕竟历二 OI\r\n确实没什么成绩，还是时间安排最麻烦和特殊的一个，我现在要去争取的，真的只是基于我自己的执念，和任性的愿望。OI，根本不是支持我的要求的理由。\r\n和级部主任聊的具体过程就不写了，简而言之就是：\r\n\r\n如果一个班人太多一个班人太少会造成教学资源浪费。\r\n没关系你可以不停课学奥赛。\r\n往届级部处理方法是胡闹（之前级部是将信息退役选手先放回普通班跟课程，然后高三的时候再调回原班级）\r\n很高兴你的目标是来明白级部的想法，这件事情不是你的错。\r\n你们实验班通校的人太多给级部造成了太多麻烦，有些同学早上随随便便就直接去餐厅了（我遵纪守法上早自习，与我无关，因为我是通校的所以就扯到了？但是这些事情跟我没关系。）\r\n级部的决定不会改变。\r\n\r\n顺便提一句，他第一次干级部主任（当然后来也没再继续干了），之前也没管过奥赛，并且他奉行奥赛和文化课分离，从不管奥赛的事情。这倒是没错，但是他确实也一点都不知道奥赛是什么情况，更不用说实验班班主任都不知道具体情况的信奥了。\r\n基本的礼貌还是有的，毕竟这件事情谁急了都没用。\r\n我正常的离开了级部办公室，但是回到奥赛室我无法再保持正常。这种感觉极其难受，因为我不想留在这个班的最大原因并不是班主任的差别，能说的是我的奥赛，不能说的是我想和你在一个班。\r\n这篇文章暂且是写给我自己看的，所以请那个”你“原谅，当然，如果你真的来看，肯定会知道说的是你的。对不起，我无法面对，过去，现在，和未来的自己如何看待这一切。\r\n好乱啊写的，我们继续。\r\n如果我没记错的话，回奥赛室之后，应该是我在高中唯一一次在别人面前哭。说来也奇怪，小学时的爱哭鬼，自从小学毕业典礼出乎意料的没哭之后，初中毕业典礼没哭之后，就没再外人面前怎么哭过了。\r\n我哭因为我痛恨自己什么都做不到。\r\n我哭因为我难受有一半是因为自己的任性，只能自己收在心里。\r\n我哭因为这世界居然荒唐到 OI 赛制安排班主任和级部都不知道。\r\n我哭因为我想哭。\r\n所以我哭完了，也就不哭了，因为再哭也于事无补。\r\n最后估计是看我们确实不想在他班里呆着，lzh 最后说，那你就去 32\r\n吧。大概是班主任们都同意了，感谢，于是我度过了第一阶段，于是就有了前面观测枢里面写的那句话。\r\n当然，这一切都还没有结束，事情总是不那么容易的。不过挺有意思的是，我这一件事解决之后，其它想要转班的，无论是\r\n32 转 33 还是 33 转 32，也随之解决了。也对，本来就不是多大的事情啊。\r\n顺应当时其它转班的同学的描述，转班是因为不适应班主任风格。当时觉得自己的奇怪的任性的愿望就这样完成了，还真的是个小小的奇迹。\r\n不过大概我真的只有这一次勇气去争取了，虽然现在来看，不知道自己到底争取了什么，好像都是别人发挥决定性作用，我反而是某种催化剂，换句话来说，事情的走向完全不由我控制。\r\n第二阶段就没有这么多的事情了，因为一切都很巧合，或许是我的运气都点到这里了，又或者是之前的第一阶段的争取为第二阶段建立了关键性基础。\r\nNOIP2022 结束后，我们最一开始是被通知要不然去\r\n33，要不然被永久调到普通班，还是挺正常的要求，毕竟我们这一届信息省队可以说是寄了，所以所有人都回来了，而为我们单开一个班的可能性不大。\r\n我的态度也不差这一次了，即使改变不了什么我也不接受这个决定，所以我当时在群里表态的时候只有三个字，不接受。最后的结果是确实为我们单开了一个班，感谢各位老师为我们加工作量的无私精神。\r\n当然，这显然不是我三个字导致的就我推测，大概有以下几个原因。首先，家长施压；其次，我们这批人里存在\r\nhyl 这种很有希望裸分 tp\r\n的，实验班没理由放弃；然后，疫情导致数学联赛延期到 NOIP 同一时间节点，32\r\n班存在一些数学奥赛的人，故班里人数确实也来到了将近二十个，不是很少了；最后，大概\r\nszy 心软了，就认可了我的没有太多理由的执念。\r\n感谢这一切的机缘巧合，让我留在了 32.\r\n那么回到前面的问题，我后悔留在实验班吗？\r\n我记得我曾经给过一个答案，现在依然适用：可能我去了普通班心理压力会小一点，但是没有实验班的节奏逼着走，按照我的性子，肯定会掉队的，而在普通班掉队也不会垫底，所以大概也不会更好吧。\r\n而 23\r\n年上半年这一段小班时光，基本上是给了我一个宽松的环境恢复自己的文化课。\r\n不过这一切，为了最初的那个任性的原因，好像，是为了什么呢。\r\n我好像总是在假设有人会读这篇，但是大概率不是自己写的长文章，不会有几个人看完吧，反正我很少读完别人的长文章，尤其是自述类的。但或许我不能按照自己来推算别人。\r\n现在再想高三大概真的很无聊，影响我的基本就是做题考试和成绩，可这一切在高考后一点意义都没有了，我现在再去回忆，除了一叠一叠的卷子，我完全想不到有什么好说的。高三的感觉很奇怪，我不喜欢整个高三，但是其实也没什么好讨厌的东西。毕竟我是要高考的，逃了中考，逃不了高考。\r\n最喜欢的事情大概是放学的时候抬头望着夜空，幸好唐冶的光污染没有那么严重，只要云散去，就会有星星。有时候觉得自己生活的空间除了现实世界的具象以外，还有很大成分的自己的想象。OI\r\n逐月纪、观测枢，我所向往的星空，我所喜欢的星空，并不是现实中漆黑背景中孤独的固液气态星球的集合体，而是我幻想中的光伴银蓝色的银河🌌。\r\n有时候我就是这样的吧，害怕失去，所以不敢尝试。但是我并不这样对待高三，因为这不是适合我存在的地方。\r\n三年的飞渡，一旦落地，再回头望去，一路的沉浮，都已经归于平静，都已经化作一座座里程碑，很幸运，我的墓碑没有在其中。大概，能活着结束这\r\n1234 天的旅程，就已经是我这三年飞渡最好的结局了。\r\n至于为什么启程，为什么任性，为什么结束，都交给时间去回答吧，当局者迷，时间能冲刷掉所有短视的看法，留下最终是岁月的足迹。\r\n所以我写这篇文章是为了什么呢？是为了结束我的一个时代，我视角下的高中时代。\r\nHeriko Deltana.\r\n","slug":"AlongLight","date":"2024-09-30T07:25:15.000Z","categories_index":"About Me","tags_index":"Me","author_index":"Heriko Deltana"},{"id":"e1eb6a41a280feea1d6f45fdf073aaca","title":"今天我将进行一项前所未有的挑战","content":"「今天我将进行一项前所未有的挑战。」\r\n\r\n\r\n今天我将进行一项前所未有的挑战。\r\n我早就18岁了，是时候有人在受健忘症的影响下看完败犬女主太多了的第十二集了。\r\n我能逆转吗？\r\n我能做到吗？\r\n说这个之前，我们先讨论一个问题：\r\n\r\n我现在已经81岁了，是时候有人在受健忘症的影响下看完第十二集了。\r\n我能逆转吗？\r\n我能做到吗？\r\n现在啊，你要知道现在，Windows11都已经粉墨登场3年有余了，为什么大家还在说着Win8的传奇呢？\r\n要了解这个事情我就需要给大家解释一下了：\r\n\r\n今天我将进行一项前所未有的挑战。\r\n我是温水和彦已经19年了，是时候有人在受健忘症的影响下坐完第十二集的摩天轮了。\r\n我能逆转吗？\r\n我能不做到吗？\r\n现在啊，你要知道现在，Windows11都已经粉墨登场3年有余了，为什么大家还在说着Win8的传奇呢？\r\n要了解这件事，我就要打开我的体操服早濑邮箱了啊，里面有什么呢？\r\n啊井芹，啊八奈见…\r\n啊对对，工作的时候要称植物，啊对，植物！\r\nso we have uh，啊，啊杏菜，啊仁菜，啊，啊，啊这不重要，重要的是：\r\n\r\n今天我将进行一项前所未有的挑战。\r\n我是八奈见杏菜已经24年了，是时候有人在受健忘症的影响下坐完第十二集的冠军摩天轮了。\r\n我能逆转吗？\r\n我能做到吗？\r\n我能冠军吗？\r\n我能不被双败淘汰吗？\r\n现在啊，你要知道现在，we have aaaa aaa\r\nA什么来着，啊对，我们有大份饭团，嗯，米饭！不对不对不对，啊是的是的是的，啊不对不对不对，我们长期素食，啊，我们有大份的素面，啊素面，对，素面！\r\n这我就要打开我的手机发出一条SNS了：\r\n我的男友已经出社会了，我的男友很有钱，去家庭餐厅都不用优惠券的那种，所以今天畅玩卷就包在我的身上了，啊不是小白脸，不是因为他是小白脸，而是因为他看到我这么大气，他也会重新爱上我。\r\n啊虽然他很害羞，平时表现的很冷淡，但他会偷偷牵我的手，说“只有今天哦”之类的。约会就是这样，光是待在一起就会很满足。\r\n我们在朋友的建议下先去了游乐园，后去了博物馆，毕竟我男友是个学识渊博，在外资企业上班的菁英。我的男友很擅长射靶，十连十环也不在话下，去射击礼品的时候我们总是满载而归，今天也是如此哦。\r\n他说他射过真的家伙，他目前被外派到外资企业的海外总公司美国啊纽约啊之类的那一带，所以一天到晚都在射击场射击。\r\n后来我们去一起买买吃吃，一起坐了摩天轮哦～\r\n因为我们是远距离恋爱，所以平常很难见面，而且因为有时差，所以都很忙，互相回信息也很不容易，但我们两个很努力的培养感情，我们感情很好哦，而且…\r\n今天我将进行一项前所未有的挑战。\r\n我是冠亚季军长椅已经3年了，是时候有人在受健忘症的影响下坐完第十二集的摩天轮了。\r\n现在啊，你要知道现在，这些番剧，啊，总是会漏一些东西，啊，但是你说这个，啊，冠军长椅，亚军长椅，都是可能，啊，去…去死的东西。\r\n但是就像温水君会撒谎了一样，冠军长椅是谁啊？真不熟，啊，真不熟，我只知道在第十二集中有着冠军摩天轮，对，冠军摩天轮。\r\n那么这个时候我就要问了啊，那么我请问了，温水同学：\r\n\r\n我是温水佳树已经12年了，是时候有人在受健忘症的影响下偷偷跟随拍摄第十二集的摩天轮了。\r\n我能逆转吗？\r\n我当姑姑吗？\r\n我能做到吗？\r\n我能上场吗？\r\n我能不被ban吗？\r\n要回答这些问题我们就得来看了，首先呢，我认为哥哥需要一个妹妹。你知道的，我一直都是哥哥的好妹妹，我和八奈见姐姐也一直是好朋友，小鞠和柠檬也强的可怕，我已经迫不及待想要加入了，至于温水和彦，我助我好运。\r\n那么小权酱有时候就要问了：\r\n\r\nWindows8已经发布99年了，是时候有人在受健忘症的影响下感受Win8的力量了。\r\n我能够输吗？\r\n我能不赢吗？\r\n我能逆转吗？\r\n我能做到吗？\r\n现在啊，现在按照八奈见杏菜-周防有希二分法，啊一共是分为两种，偷腥猫和青梅竹马，啊但是我们考虑这个佳树作为首ban青梅竹马，这个老八啊，简直就是自己定义下的石头go？啊不是，是偷腥猫，啊，喵喵！\r\n首先要给大家介绍一下啊，介绍一下WindowsXP，WindowsVista，啊不是，是Win8。为什么我们说Win8是真的呢？首先啊，到底是谁出去和别人玩心里还想着老八啊？到底是谁想被施展游园会魔法啊？是谁说着草芥却也有种试探温水的感觉，嘴上说着这样的话，但是眼睛却偷偷瞥着温水，期待他对此的反应​啊？Windows\r\n8或者抽象，但是Win8如何不Win？以上问题，我请问了？\r\n\r\n今天我将进行一项前所未有的挑战。\r\n我是谁啊，是时候有人在受健忘症的影响下完成什么来着？\r\n我不知道啊？\r\n我能知道吗？\r\n我能逆转吗？\r\n我能做到吗？\r\n几百遍，又大了几百遍，沉默的电话沉默，在那想你的✌ooo这身体已戒不了你那乱动的手指？弹着钢琴却时刻挑逗我↑的贝斯…\r\n那么我就有一个问题想知道了：我睡觉之前，啊，都写了些什么呢？\r\n这就要打开我的文本了。\r\n易大山！直接硬控清场，什么实力我不多说，11集没有冠军长椅？什么冠军长椅，真不熟吧，接下来走向我，将是冠军摩天轮！\r\n没有一刻为假男友假约会悲伤，现在到达战场的是，魅魔形态的温水，嗯，1vn残局宛如一决开大拉人一般的单点突破！\r\n所以我饿请问了：\r\n\r\n今天我将进行一项前所未有的挑战。\r\n败犬女主太多了！已经七卷了，是时候有人在受冠军摩天轮的影响下开始第二季了！\r\n我能做到吗？\r\n我能逆转吗？\r\n听到了吗雨森，听到了吗A-1，听到了吗，啊！听到了吗雨森，听到了吗A-1，听到了吗，啊！听到了吗雨森，听到了吗A-1，听到了吗，啊！听到了吗雨森，听到了吗A-1，听到了吗，啊！听到了吗雨森，听到了吗A-1，听到了吗，啊！\r\n小心思，啊，小心思，你这被子就是被温水和彦害了，想要假扮男朋友于是带着温水出去，拍照里要有男生所以拍摄全部的温水君，啊。\r\n太有游园会魔法了八奈见杏菜，你们有没有这样的老八啊？真是杏杏又菜菜啊？\r\n\r\n换句话来说了，今天我将进行一项前所未有的挑战。\r\n我是谁啊已经998244353年了，是时候有人在受健忘症的影响下坐完第十二集的摩天轮了？\r\n这个雨森的原创会啊，真的好啊，观众只需要看原创会并且期待第二季就行了，而雨森老登考虑的就多了。\r\n什么八奈见男朋友因为每次都是出社会的他付钱，所以偶尔也八奈见来出钱什么的。你要知道，每次都出钱的就是温水啊，所以这次万元钞就是来回请的啊。\r\n什么冷淡还害羞，不是温水是谁，第四集的偷偷牵手历历在目啊历历在目！\r\n什么“说只有今天之类的”和温水开头同意假男友计划说的“只有这一次”，真是让人Win8到不能自拔啊？？\r\n还有所谓销建公司，销建，读音就是败犬啊！你说是吧温水部长？到底是谁在领导着我们石蕗的败犬组织啊？\r\n你们有没有这样的暗示啊？真的暗暗又示示啊。\r\n那么我请问了：\r\n\r\n第十二集已经播出好几个小时了，是时候有人在受健忘症的影响下合理输出我的文本了，欧欧。\r\nGood Morning！\r\n有时候老马天爱星就要问了：我当年带的是什么人，现在你们是什么人，一个一个一个，有一个算一个，都是干嘛的，啊？你说你让老八防温水偷跑，啊，她防的住吗？她没那个能力你知道吧，输完柠檬输小鞠，接下来该没人输了。哦谢天谢地所以要奋起直追了，要易大山摩天轮封神了，哦哦哦哦哦哦对的对的对的，哦不对不对不对，我是老马啊，我送围巾呢，我围巾呢\r\n","slug":"Unprecedented-Challenges","date":"2024-09-29T01:41:00.000Z","categories_index":"UKE","tags_index":"UKE","author_index":"Heriko Deltana"},{"id":"8b6fa26fae20036bf07fb3b7eac5e80f","title":"初学 HTML 笔记","content":"「什么是 HTML 啊我请问了？」\r\n\r\n\r\n\r\n跟随 MDN WEB DOCS\r\n学习\r\n\r\n01 基础\r\n主体上跟随 MDN 学习，所以内容会是接近的，现在这一部分对应着 HTML\r\n基础。\r\n当然还有非常易懂的学长的 PPT.\r\n一张网页基本元素&amp;结构\r\n12345678910&lt;!DOCTYPE html&gt;&lt;html lang = \"zh-CN\"&gt;    &lt;head&gt;        &lt;meta charset = \"utf-8\"/&gt;        &lt;meta name = \"viewport\" content = \"width=device-width\"/&gt;        &lt;title&gt;Title&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;/body&gt;&lt;/html&gt;\r\n\r\n&lt;!DOCTYPE html&gt;\r\n文档类型，告诉浏览器如何解析网页，保证文档的正常读取。\r\n&lt;html&gt; 这个元素是网页的顶层容器，唯一的根元素。\r\n\r\nlang 属性表示网页内容的默认语言，比如\r\nzh-CN、en-US 等。\r\n\r\n&lt;head&gt;\r\n元素是一个容器元素，用于放置网站的元信息，其中内容一般不会出现在用户可见的网页上。\r\n\r\n&lt;meta charset = \"utf-8\"/&gt; 该元素指明你的文档使用\r\nUTF-8\r\n字符编码，以它为编码可以避免以后的某些问题，你的网页不会因为未被识别而被显示为乱码。\r\n&lt;meta name = \"viewport\" content = \"width=device-width\"/&gt;\r\n视口元素可以确保页面以视口宽度进行渲染，避免移动端浏览器上因页面过宽导致缩放，利好多端用户的浏览。\r\n&lt;title&gt;\r\n元素用于指定网页的标题，其中设置的内容会出现在浏览器的标题栏。\r\n\r\n&lt;body&gt; 元素则是希望用户看见的内容。\r\n\r\n语义结构\r\n123456789101112&lt;body&gt;  &lt;header&gt;页眉&lt;/header&gt;  &lt;nav&gt;导航栏&lt;/nav&gt;  &lt;main&gt;    &lt;aside&gt;侧边栏&lt;aside&gt;    &lt;article&gt;      &lt;h1&gt;文章标题&lt;/h2&gt;    &lt;/article&gt;    &lt;section&gt;&lt;/section&gt;  &lt;/main&gt;  &lt;footer&gt;页尾&lt;/footer&gt;&lt;/body&gt;\r\n通用属性\r\n\r\nid 属性指定元素额外标识符\r\nclass 属性对网页元素进行分类\r\nstyle 属性用来指定当前元素样式（CSS）\r\ndata-* 属性存放自定义数据\r\n\r\n比如：\r\n12345&lt;ol class=\"list\"&gt;  &lt;li class=\"list-item\" id=\"list-item-1\"&gt; item 1 &lt;/li&gt;  &lt;li class=\"list-item list-item-active\" style=\"color: blue\"&gt; item 2 &lt;/li&gt;  &lt;li class=\"list-item\"&gt; item 3 &lt;/li&gt;&lt;/ol&gt;\r\n\r\n\r\nitem 1\r\n\r\n\r\nitem 2\r\n\r\n\r\nitem 3\r\n\r\n\r\n块级元素和行内元素\r\n元素分为两大块：block 块级元素和 inline 行内元素。\r\n\r\nblock：默认占据一个独立的区域，在网页上会自动另起一行，占据 100%\r\n的宽度。\r\ninline：默认与其他元素在同一行，不会产生换行。\r\n\r\nHTML 元素\r\n以这一句为例：\r\n1&lt;p class = \"editor-note\" id = \"paragraph-fox\"&gt;The quick brown fox jumps over the lazy dog.&lt;/p&gt;\r\n\r\n&lt;p class = \"editor-note\" id = \"paragraph-fox\"&gt;：开始标签。\r\n\r\np：标签/元素名称。\r\nclass = \"editor-note\"：元素的一个属性，形式为\r\nkey = \"value\"，id = \"paragraph-fox\"\r\n同理。\r\n\r\nThe quick brown fox jumps over the lazy dog.：内容。\r\n&lt;/p&gt;：结束标签。\r\n\r\n嵌套\r\n元素也可以嵌套，比如：\r\n1&lt;p&gt; My cat is &lt;strong&gt;very&lt;/strong&gt; grumpy.&lt;/p&gt;\r\n\r\nMy cat is very grumpy.\r\n\r\n注释\r\n123&lt;!--hide and seek--&gt;\r\n图像\r\n1&lt;img src = \"https://pic.imgdb.cn/item/66f2473ef21886ccc08288cc.png\" alt = \"Where is my image???\"/&gt;\r\n\r\nsrc 后面跟着图片的地址，alt\r\n后面跟着图片描述。\r\n标题\r\n12&lt;h1&gt;一级标题&lt;/h1&gt;&lt;h2&gt;二级标题&lt;/h2&gt;\r\n以此类推，一直到 &lt;h6&gt;\r\n列表\r\n分为有序列表和无序列表，分别为 &lt;ol&gt; 和\r\n&lt;ul&gt;，使用例：\r\n123456789101112131415161718&lt;p&gt;Good Morning! there is something only Apple can do:&lt;/p&gt;&lt;ul&gt;  &lt;li&gt;&lt;strong&gt;60Hz&lt;/strong&gt; Screen On iPhone 16&lt;/li&gt;  &lt;li&gt;Slower charging speed on Apple Watch S10&lt;/li&gt;  &lt;li&gt;Only &lt;strong&gt;27W&lt;/strong&gt; on iPhone 16&lt;/li&gt;  &lt;li&gt;iPhone 16 start with &lt;strong&gt;128GB&lt;/strong&gt; SKU&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Only Apple Can Do!&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Good Morning, there is something only Google can deliver:&lt;/p&gt;&lt;ol&gt;  &lt;li&gt;Tensor G4, just like Kirin 9010, how?&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;Only Google Can Deliver!&lt;/strong&gt;&lt;/p&gt;\r\n\r\nGood Morning! there is something only Apple can do:\r\n\r\n\r\n\r\n60Hz Screen On iPhone 16\r\n\r\n\r\nSlower charging speed on Apple Watch S10\r\n\r\n\r\nOnly 27W on iPhone 16\r\n\r\n\r\niPhone 16 start with only 128GB SKU\r\n\r\n\r\n\r\nOnly Apple Can Do!\r\n\r\n\r\nGood Morning, there is something only Google can deliver:\r\n\r\n\r\n\r\nTensor G4's performance level just like Sanctioned Kirin 9010.\r\nhow? why?\r\n\r\n\r\n\r\nOnly Google Can Deliver!\r\n\r\n链接\r\n1&lt;a href = \"https://hriver2.github.io/\"&gt;Heriko Deltana's Blog&lt;/a&gt;\r\nHeriko Deltana's Blog\r\n而 target\r\n属性可以指定在哪里打开链接，比如，target = \"_blank\"\r\n即为在新标签页打开。\r\n\r\n_self 当前页面加载。（默认）\r\n_blank\r\n通常在新标签页打开，但用户可以通过配置选择在新窗口打开。\r\n_parent\r\n当前浏览环境的父级浏览上下文。如果没有父级框架，行为与\r\n_self 相同。\r\n_top\r\n最顶级的浏览上下文（当前浏览上下文中最“高”的祖先）。如果没有祖先，行为与\r\n_self 相同。\r\n\r\n表格\r\n123456789101112131415161718192021222324252627&lt;table&gt;  &lt;thead&gt;    &lt;tr&gt;      &lt;th&gt;1&lt;/th&gt;      &lt;th&gt;2&lt;/th&gt;      &lt;th&gt;3&lt;/th&gt;      &lt;th&gt;4&lt;/th&gt;      &lt;th&gt;5&lt;/th&gt;    &lt;/tr&gt;  &lt;/thead&gt;  &lt;tbody&gt;    &lt;tr&gt;      &lt;th&gt;Why?&lt;/th&gt;      &lt;td&gt;Only&lt;/td&gt;      &lt;td&gt;Apple&lt;/td&gt;      &lt;td&gt;Can&lt;/td&gt;      &lt;td&gt;Do&lt;/td&gt;    &lt;/tr&gt;  &lt;/tbody&gt;  &lt;tr&gt;    &lt;th&gt;Why not?&lt;/th&gt;    &lt;td&gt;Only&lt;/td&gt;    &lt;td&gt;Google&lt;/td&gt;    &lt;td&gt;Can&lt;/td&gt;    &lt;td&gt;Deliver&lt;/td&gt;  &lt;/tr&gt;&lt;/table&gt;\r\n\r\n\r\n\r\n\r\n1\r\n\r\n\r\n2\r\n\r\n\r\n3\r\n\r\n\r\n4\r\n\r\n\r\n5\r\n\r\n\r\n\r\n\r\n\r\n\r\nWhy?\r\n\r\n\r\nOnly\r\n\r\n\r\nApple\r\n\r\n\r\nCan\r\n\r\n\r\nDo\r\n\r\n\r\n\r\n\r\n\r\nWhy not?\r\n\r\n\r\nOnly\r\n\r\n\r\nGoogle\r\n\r\n\r\nCan\r\n\r\n\r\nDeliver\r\n\r\n\r\n\r\n\r\n&lt;table&gt; 是一个块级容器元素，表格的容器。\r\n&lt;caption&gt; 总是 &lt;table&gt;\r\n里面的第一个子元素，表示表格的标题，但是非必须（比如上面的例子里面就没有）。\r\n&lt;tr&gt; 元素表示表格的一行\r\n&lt;th&gt; 和 &lt;td&gt;\r\n用于定义表格的单元格。前者是标题单元格，后者是数据单元格。\r\n&lt;thead&gt; 元素定义了一组定义表格的列头的行。\r\n&lt;tbody&gt;\r\n元素封装了一系列表格的行（&lt;tr&gt;\r\n元素），代表了它们是表格（&lt;table&gt;）主要内容的组成部分。\r\n\r\n通常 HTML 表格需要 CSS 进行修饰，比如：\r\n123456789table {  border-collapse: collapse;  background-color: lightblue;}td,th {  border: 1px solid black;  padding: 10px 20px;}\r\n\r\n  table {\r\n    border-collapse: collapse;\r\n    background-color: lightblue;\r\n  }\r\n  td,\r\n  th {\r\n    border: 1px solid black;\r\n    padding: 10px 20px;\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n1\r\n\r\n\r\n2\r\n\r\n\r\n3\r\n\r\n\r\n4\r\n\r\n\r\n5\r\n\r\n\r\n\r\n\r\n\r\n\r\nWhy?\r\n\r\n\r\nOnly\r\n\r\n\r\nApple\r\n\r\n\r\nCan\r\n\r\n\r\nDo\r\n\r\n\r\n\r\n\r\n\r\nWhy not?\r\n\r\n\r\nOnly\r\n\r\n\r\nGoogle\r\n\r\n\r\nCan\r\n\r\n\r\nDeliver\r\n\r\n\r\n\r\n表单\r\n12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=\"en-US\"&gt;\t&lt;head&gt;\t\t&lt;meta charset=\"utf-8\" /&gt;\t\t&lt;title&gt;My first HTML form&lt;/title&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;form action=\"/my-handling-form-page\" method=\"post\" name=\"FORMx\"&gt;\t\t\t&lt;ul&gt;\t\t\t\t&lt;li&gt;\t\t\t\t\t&lt;label for=\"name\"&gt;Name:&lt;/label&gt;\t\t\t\t\t&lt;input type=\"text\" id=\"name\" name=\"user_name\" /&gt;\t\t\t\t&lt;/li&gt;\t\t\t\t&lt;li&gt;\t\t\t\t\t&lt;label for=\"mail\"&gt;E-mail:&lt;/label&gt;\t\t\t\t\t&lt;input type=\"email\" id=\"mail\" name=\"user_mail\" /&gt;\t\t\t\t&lt;/li&gt;\t\t\t\t&lt;li&gt;\t\t\t\t\t&lt;label for=\"msg\"&gt;Message:&lt;/label&gt;\t\t\t\t\t&lt;textarea id=\"msg\" name=\"user_message\"&gt;&lt;/textarea&gt;\t\t\t\t&lt;/li&gt;\t\t\t\t&lt;li class=\"button\"&gt;\t\t\t\t\t&lt;button type=\"submit\"&gt;Send your message&lt;/button&gt;\t\t\t\t&lt;/li&gt;\t\t\t&lt;/ul&gt;\t\t&lt;/form&gt;\t&lt;/body&gt;&lt;/html&gt;\r\n&lt;!DOCTYPE html&gt;\r\n\r\n\r\n\r\n\r\nMy first HTML form\r\n\r\n\r\n\r\n\r\n\r\n\r\nName:\r\n\r\n\r\n\r\nE-mail:\r\n\r\n\r\n\r\nMessage:\r\n\r\n\r\n\r\n\r\nSend your message\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n&lt;form&gt; 容器元素，用于定义一个表单\r\n\r\naction 属性用于指定服务器接受数据的 URL\r\nname 属性指定表单的名称，唯一非必须\r\ntarget 在哪个窗口展示数据\r\nmethod 提交数据的 HTTP 方法，一般是 \"get\"\r\n或 \"post\"\r\n\r\n&lt;label&gt; 行内元素，提供表单控件的文字说明\r\n\r\nfor 属性指定关联控件的 id 属性\r\n\r\n&lt;button&gt;\r\n标签会生成一个可以点击的按钮，没有默认行为\r\n\r\ntype 属性：\"submit\"，\"reset\"\r\n和 \"button\"\r\n\r\n&lt;select&gt; 下拉菜单\r\n\r\nmultiple 属性用于指定是否允许多选\r\n\r\n&lt;option&gt; 元素为可以用于\r\n&lt;select&gt; 的选项\r\n\r\nvalue 属性用于指定值\r\nselected 属性用于指定是否为默认选中\r\n\r\n\r\n其他\r\n\r\n&lt;br/&gt; 换行\r\n&lt;hr&gt; 水平线\r\n&lt;video&gt; 视频\r\n&lt;audio&gt; 音频\r\n&lt;embed&gt; 用于嵌入外部内容\r\n\r\n","slug":"LearnHTML","date":"2024-09-24T04:56:53.000Z","categories_index":"Web","tags_index":"HTML","author_index":"Heriko Deltana"},{"id":"07b5ec5dba824198315e432082ca79d6","title":"INTO/2 THE STARLIGHT","content":"「Tracya and Synya」\r\n\r\n\r\n施工中，还没写完/还没开始写\r\n写在前面\r\n关于封面图片\r\n与内容无关，找了一张之前存的图，Pid 119683453.\r\n如果以后有符合内容的图之后会换掉，但是前提是我会画，现在来看我不会画。\r\n关于 Tracya 和 Synya\r\n主人公大概是和大概是主人公\r\n设定图因为我不会画所以咕了，故暂采取地表最强大的渲染模式：大脑空想。\r\n因为我也没怎么看过怎么使用文字具体描述 OC，所以我将使用资料式列表法\r\n(｡･∀･)ﾉﾞ\r\nTracya\r\n性别：女\r\n年龄：15\r\n头发：长发，浅蓝（#79d1ff），头发末端为深蓝（#6495ed），顺发无卷，长度到大腿。\r\n衣着：卫衣。\r\nSynya\r\n性别：女\r\n年龄：14\r\n头发：短发，白，头发末端为浅粉（#ff80bf），稍卷，长度到肩膀。\r\n衣着：风衣。\r\nChapter01 星轨交织之时\r\n“人真是奇怪啊，明明对天体一窍不通还是喜欢画星轨吗？”\r\n“所以啊，星星的轨迹也会交织吗？”\r\n\r\nTracya\r\n擅长的，自言自语，用手指在窗户上勾画出星轨，像是把这些没有什么意义的话化为画。\r\nTracya\r\n想，人大概总是很矛盾的吧，就像自己，对于天体一窍不通，却总是想着寻找星星的轨迹，即使自己知道寰宇中的行星不是沿着自己手指划出的曲线行进的。\r\n“但是，但是这些轨迹终究还是有着某种艺术意义的吧？就像是最简单的一个星球，她的色彩也是有着观赏性质的吧？”\r\n或许是有力的自我对前题反驳，但是 Tracya\r\n毕竟不是艺术家，她只是普通的，也只能普通地仰望星空的人，这种自我辩论大概永远不会结束。\r\n所谓天才在左，疯子在右，幸好 Tracya\r\n并不在两级，于是这一场自我辩论会一直进行下去。\r\n不过无论如何，Tracya\r\n就是很喜欢仰望星空的感觉，毕竟星河是那样的美好，银与灰蓝与邃黑的交织并不炫彩过头以至于炫目，反而淡与明亮总是让人心中平静，感受寰宇星河的辽阔。是啊，毕竟星海是那样的美好，不像无限灰的现实。\r\n毕竟就算是宇宙中的暗物质存在，也是遥不可及啊。\r\n毕竟是宇宙的秘密的话，也是不可触及啊。\r\n毕竟是微弱生命的仰望啊，不会引人注意啊。\r\n毕竟与星星之间是无数光年的距离，就算是一光年，也是不可到达的啊。\r\n宇宙中的暗物质，是不是就是一个个吞噬现实的黑洞组成的呢？\r\n吞噬现实的黑洞，是不是就是一个个被现实吞噬的人构成的呢？\r\nTracya\r\n在星的平静中又一次睡着了，手指划出一道星轨，与之前画出的椭圆星轨无限接近，最终交织。\r\n“所以啊，星星的轨迹也会交织吗？”\r\n或许会有解答。\r\nChapter02 劣等星·上等星\r\n星星根据亮度的不同，是有着不同等级的，星等。\r\n劣等星只能让遥望的人知道那里有它的存在，但是光泽暗淡几乎不可见\r\nChapter03 天台·长夜·群星\r\n03\r\nChapter04\r\n天台之上是群星·天台之下是深渊\r\n04\r\nChapter05 深渊末端的虚无\r\n05\r\nChapter06 六兆年零一夜\r\n06\r\nChapter07\r\n月下观星的约定·愿杳春风如夏花\r\n07\r\nChapter08 很奇妙吧？万有引力\r\n08\r\nChapter09 星雪夜谁的梦语\r\n09\r\nChapter10 二次流星如雨滴落\r\n10\r\nChapter11 愿逐月华流照君\r\n11\r\nChapter12 若能变成彗星\r\n12\r\nChapter13\r\n愿我如星君如月·夜夜流光相皎洁\r\n13\r\nChapter14 未定·未来·未有之夏\r\n14\r\n记在后面\r\n关于写这些最初的想法\r\n因为想写了。\r\n一些小标题相关信息\r\n","slug":"In2-The-Starlight","date":"2024-06-24T15:03:04.000Z","categories_index":"Original Stories","tags_index":"Story","author_index":"Heriko Deltana"},{"id":"2de5937415685df0adc7bdd2b775d09f","title":"18 次回环之日","content":"「倘若在第 6575 个清晨醒来」\r\n\r\n\r\n01\r\n2024-03-01\r\n今年没有按照阴历发，法定年龄毕竟是按照公历走的，于是就按照 3.1\r\n发了。\r\n好像成年确实是一个值得多写一点的事情，但是真正开写的时候，又踟蹰而不知何处写起了。\r\n但是总之是要写的，总之是要写的，于是就在正月十五写下吧，因为 18\r\n之前没别的假期了（\r\n但是似乎 Blog 发布日期有点问题，不知道为什么会显示成\r\n3.29，不过无所谓了：）\r\n02\r\n\r\n什么是成长呢？\r\n\r\n这大概是我在一个月之前意识到自己快要成人的时候，脑海中浮现的问题。\r\n我的天呐孩子，这是一个好问题，你该如何回答呢？\r\n如果是回看过去的一年，我在疫情后醒来，过往三年的磨难，无论是现实性的还是精神性的，都已经成为了过去，成为了我的一部分，成为了今天的我的一部分，我在唯一我存在的时代存在着，走过了唯一的\r\n2023 年。\r\n如果是回看过去的三年，我在高中的历程，现在已经快到了结尾，但是真正的「高中学习」也只进行了一年。\r\n有时总会想起之前自己做的事情，少数在现在看起来还是可以接受的，但是大多数，尤其是距离现在时间久远的事情，总会觉得自己当时太过于天真，或者说，当时做事情的时候欠思考，再或者说，当时做的事情并不符合我现在的思维。\r\n这三年，或者说是从 19\r\n年以来的四年，见证了我性格和思维的巨大转变。\r\n刚才所说的，“当时做的事情并不符合我现在的思维”，多半是现在觉得自己当时真的好\r\noutgoing，有一种做事情完全不注意后果的样子，而现在，已经基本完全转变成了，所谓的，“I\r\n人”。四年来逐渐走向内向的态势已经很明显了，这一切的源头是什么呢？是年龄递增带来的副作用吗？是作为\r\nOIer\r\n时的精神孤岛的隔绝效果吗？我不知道，但是这大概已经成为了现实，至少站在今天的节点上，离开了熟悉的人，我已经是基本哑巴了（\r\n另一个有意思的现象也能显示，最初还是 ENFP-T，后来变成 E/I\r\n对半分，现在已经是 INFP 了（\r\n好吧，和成长扯远了有点，但是这大概就是我能想到的感受。就是当感受到和之前已经发生了很大的变化，但是我们却又是一个人，我们的精神内核可能已经换了壳，但是还是一样的质的时候，这种变化与存留，大概就是我感受到的成长吧。\r\n最终没能回答这个问题，但是这并不是一个有答案的问题。\r\n03\r\n不知道为什么，我想到了一些事情。我想到了，人的生离死别带来的痛苦和长久的影响，我想到了，在天井想要迈出那一步时脑海中的撕裂感，我想到了，人的情感纠缠终究是人类最伟大的天赋，也是人类最伟大的诅咒。\r\n作为一个观测者，见证了许多；作为一个亲历者，感受了很多，大概就是我对于自己记忆中画面的印象。不知道从何时开始，大概从小时就习惯于将一个东西无尽的想象下去，多数时候是把自己带到其中的一个人去，少数时候只是空想，就像是空气中的浮尘在想象的宇宙中浮沉。\r\n但是我总觉得自己现在或许想象力不太充分了，是因为长大了吗。\r\n想起来小时候自己能对着桌子上的一堆乐高，依靠自己的想象玩好几个小时，现在，依然可以从一个\r\nF1 Game Career 存档中的一些数据和结果在自己想象中构思出无数场虚拟的\r\nGrand Prix，好像，我也没有变化多少。\r\n04\r\n我一直没有办法直面死和生。我总是想到，一个游戏的存档结束了，只是一次游戏结束了，我仍然会回到现实之中。可如果现实结束了，人大概就没有办法再「重新登录」了吧。\r\n所以总感觉挺虚无吧，一切的终点，唯一我存在的时代。\r\n现在想来，没有准备好提前到达一段旅程的终点，大抵是【？】之后我能走到今天的最大原因吧，或许，人真的觉得自己到了最后一次思考的时候，才能感受到这个世界的美好和自己还没看见的美好吗。\r\n人的生命真的很脆弱吧，不知道去年高考后那个所谓的，已成永恒的，我并不认识的学长，是怎么想的呢；不知道姑爷爷眼睁睁地看着癌症逐渐夺去自己时，是怎么想的呢；不知道，这今年我所知道的那些不幸离开我身旁的人，是怎么想的呢。\r\n我大概永远是一个感性的人，我写到这里，我想到他们，泪水会自己流下，为什么呢，为什么会有泪水呢。\r\n05\r\n但是毕竟是第十八个回环之日，还是写一些展望吧，虽然我永远不知道我在写东西的时候有什么逻辑可言（\r\n首先最重要的事情显然是高考，希望高考能考好吧。\r\n其次，希望能找到未来自己真正想做的事情吧，今年想到未来的时候，总觉得有些空洞，大概是我的内心已经中空了三年了。但是未来总会到来，我相信我也总能找到自己的那片星空。\r\n在第 6575\r\n个清晨醒来，我依旧是那个我，寻光的目光不会消散，我会奏明自己的天空。\r\n","slug":"18th","date":"2024-02-29T16:00:18.000Z","categories_index":"About Me","tags_index":"Me","author_index":"Heriko Deltana"},{"id":"8dff51300b1f2041902371968cc82152","title":"Oppenheimer","content":"「普罗米修斯从众神那里窃取了火种并将其送给了人类，为此，他被锁在岩石上，遭受永世的折磨」\r\n\r\n\r\n","slug":"Oppenheimer","date":"2023-12-31T10:53:11.000Z","categories_index":"Comment","tags_index":"Movie","author_index":"Heriko Deltana"},{"id":"563fb0c3b30aff29500e14f77cbc5aa8","title":"2023。2024：","content":"「又是那句话，一切过往，皆为序章……」\r\n\r\n\r\n前言\r\n因为已经很久没有写一些东西了，所以提前开了这个坑，想让自己写一些什么。\r\n但是好像我倾向于在明年 18 的时候再写回顾，于是这里回顾 2023\r\n发生的事情的性质会少一点。\r\n标题为什么长得这么奇怪，继续看就能明白了（\r\n终章是「。」\r\n创建这个 Post 是 12.29，但是正式写是 12.31，于是确实是 2023\r\n年的终章了。\r\n于是我倾向于用一个句号，「。」.\r\nNew Version\r\n\r\n因为觉得自己当时写的太过于抽象，所以稍微重新写了一些，不那么抽象，但是依旧不太能具体阅读的样子（\r\n\r\n「总的来讲，是很好的时光，是很快的一年，是变化的世界」\r\n很新，是狠心的一章之始。\r\n最终 OI 与疫情都停在了 2022，于是 2023\r\n是时光新的一站。正如我之前所说过的，在时间的距离上，我总觉得 18-19\r\n是一年，20-22 也只想是一年，2023 到至今又是新的一年。\r\n现在回想，2023\r\n像是没有什么大事，于是她很快，很快的从我身边溜走了。但或许因为她刚刚离开，却又是新鲜的记忆，再一次想，是一段很好的时光。\r\n或许不再分心 OI 和 whk，又或是单纯的在 whk 的考试多了，2023\r\n或许是我高中 whk\r\n最好的一年。不过当然，也发现了自己的上限确实不太高，但是还是有一点光亮在等着我吧。当然在这个班里，这种光或许只是一片黑光，而数学和物理持续的低迷也近乎要扼杀这一点点黑色的光。但我已经追光很久了，能有一点，更应该追一追吧，我还要高考，于是我没有选择。\r\n高三和之前的差别超出了想象，大概是因为整个班管理风格的变动和学习任务真的加多了吧。很遗憾的是我到现在也没有完整的理解这些，但是大概是适应了吧。\r\n于是也写不出更多了，看看 2024 如何开展吧。\r\nOld Version\r\n\r\n以下是最初更新的抽象东西。\r\n\r\n简单一想\r\n大概想一下今年是什么样子的吧。\r\n\r\n后疫情时代的第一年，后奥赛时代的第一年。还真有意思啊，我的奥赛生涯被疫情完整的涵盖了，于是我两年的四场考试，除去取消的\r\nCSP-S2 2022，居然都是在不同的考场考的。\r\n\r\n今年一年没出 JN。实际上，去年 10.1 从 LC 回来之后就再也没去过 LC\r\n了，去年 11.26 从 pyyz 回来之后，就再也没出过济南了。\r\n上半年的主要原因还是随着高三的临近，假期越来越少，时间也越来越短了。而下半年主要是高三之后家里和我都不想让我再因为往返\r\nLC 和 JN\r\n耗费精力了（虽然好像我作为一个坐车的，也不会有太多精力消耗（（\r\n\r\n今年（部分时候）是 whk 最好的一年。\r\n因为不学奥赛了？因为学 whk 了？\r\n不是，因为我精神状态好多了。\r\n锐评 2023\r\n\r\n评判标准是我现在现想到什么就写什么（\r\n\r\n\r\n好书目：人教版语文系列。因为今年课外阅读量 near\r\n0，于是我选择了伟大的语文课本，因为起码强过缺乏深度的英语课本（\r\n好电影：奥本海默 ＆\r\n流浪地球2。因为我实在是没法把他俩放到同一个平台上比较，于是并列吧。\r\n差电影：满江红。因为就是依托，从剧情到人物塑造再到视觉效果，都是依托。\r\n新游戏：这很难评价，但是最后还是给了「重返未来：1999」。因为我确实没玩什么别的新游戏，虽然……1999\r\n机制确实毛病不小，但是英配整体设计还是给力的。\r\n有用的东西：反正不是我）\r\n没用的东西：我。\r\n好的体育竞技团队：RedBull Racing。因为在 F1\r\n的统治表现。\r\n难绷体育竞技团队：Tyloo。一年三次变阵，答辩都不敢这样便，甚至把\r\n5YCLONE 买过来也能寄（？难道真的是风水差？\r\n最佳歌曲：Black Glow - Albemuth。今年最 impressive\r\n的。\r\n\r\n明天是「：」\r\n明天是明年，明年是明天，于是我倾向于写一个冒号，「：」.\r\n其实我对新年没有太多期望，但是毕竟也是新的开始，而 2024\r\n这个数字我看起来就舒服，远远强于\r\n2021、2022、2023，不知道为什么，于是依旧希望明年是个好年。\r\n但是哪年不是个好年呢，哪年不是个坏年呢。\r\n今年或许就是将之前有点「非黑即白」的世界观纠正回来的一年。\r\n这是最好的时代，这也是最差的时代，因为这是我存在的时代，不是我的时代，但是是少数我存在的时代。\r\n于是，2024，高考顺利！\r\n","slug":"ciallo2024","date":"2023-12-29T15:10:00.000Z","categories_index":"About Me","tags_index":"Me","author_index":"Heriko Deltana"},{"id":"c9ef932ee8f6452af5064850d2deeb59","title":"Manacher","content":"「求最长回文子串，Manacher.」\r\n\r\n\r\n\r\n前言\r\n虽然已经从 OI\r\n中退役一段时间了，但是再捡起一些东西也是不错的消遣。\r\n\r\n源自我在博客园上写的的 Manacher.\r\n\r\n问题描述\r\n给定一个长度为  的字符串 ，求其最长回文子串。\r\n\r\n举例：设 ，则其最长回文子串为 ，长度为 。\r\n\r\nBrute Force 解决方案\r\n看到这个题之后我们能够大致判断出来在最坏情况之下，时间复杂度应当是是\r\n 的。\r\n考虑到回文串的性质，我们朴素的想法就是枚举一个中心\r\n\r\n然后不断的扩张两端直到不符合回文串的要求。\r\n然后有伪代码如下：\r\n：\r\n（参考 Dfkuaid 的伪代码）[1]\r\n大概这就是第一眼看到这个问题之后的所有朴素想法了罢，感觉这个 BF 做是\r\n\r\n的问题，貌似也没有什么线性复杂度的做法？\r\n但是前人已经为我们留下了 \r\n的伟大做法！那就是本文的主题：.\r\nManacher\r\n在说 Manacher 之前，我们先进一步研究回文串的性质。\r\n进一步理解\r\n我们来考虑一个回文串到底是可以用什么样的信息来表示。\r\n来回望一下上面的 BF\r\n过程，因为回文串是对称的，所以我们主要关注的就是中心和半径长度，于是乎我们就从这里下手去表示一个回文串。\r\n首先我们注意到奇数串的中心是一个确切的在字符串中的位置，而偶数串的中心是在两个位置之间，无法统一的来表示。\r\n于是我们就考虑如何进行一些神妙操作之后把偶数串和奇数串统一起来，于是我们就迎来了\r\nManacher 算法的第一步。\r\n转化\r\n实际上，将奇数串和偶数串统一起来很简单，我们只需要原有的字符串的基础上进行一个简单的修改即可：在字符串的开头和结尾以及每两个字符之间都加上一个无关字符。\r\n\r\n由于 OI\r\n中的大部分的字符串问题都是和字母数字相关，于是这里的无关字符我就采用的是\r\n#，当然具体情况具体选择无关字符即可。\r\n\r\n这一步操作之后，不管你原来字符串里的回文串是奇数串还是偶数串，都变成奇数串的样子了（\r\n比如：\r\n\r\n就变成了\r\n\r\n原串的最大回文子串是：\r\n\r\n这是一个偶数串，而现在就是：\r\n\r\n这是一个奇数串。\r\n同时，为了方便我们枚举半径长度而不越界，我们可以在进行完上述操作之后的新字符串上再进行一次操作：在字符串的头和尾再加上两个互不相同的无关字符。\r\n在这里这里选取的是 $ 和 ^。\r\n于是上面那个串就变成了 $#a#b#d#f#e#t#t#e#f#d#b#^。\r\n于是乎我们就把字符串的格式都统一了起来，然后就可以进行操作了！\r\n定义一些东西......\r\n\r\n定义 p[i] 为以 i\r\n为中心的最长回文串长度。\r\n定义 id\r\n表示当前位置加上该位置最长回文半径可覆盖的范围最远的位置。[1]（感性理解一下，不知道该怎么形容更加合适，推荐结合下面的代码手模理解）\r\n定义 mx 表示 id 加上 p[id]\r\n之后的距离，也就是以 id\r\n为中心最长的回文串的右边界。\r\n\r\n然后如何操作 ?\r\n先把上图的所有东西都在这里放出来罢：\r\n[1]\r\n如果如上图一样，我们假定枚举的 i &lt; mx ，那么以\r\ni 为中心的回文串只有如下两种情况：\r\n\r\n完全被 mx 的对称点和 mx 包含。\r\n右端超出 mx 的范围。\r\n\r\n假设我们是从左到右有序枚举的 i，那么 i 关于\r\nid 的对称点 i' 的 p[i']\r\n显然是已经求出的。\r\n而我们根据 mx 和 id 的定义又能知道\r\nmx 的对称点 mx'\r\n为边界构成的字符串必然是一个回文串。\r\n因为对于我们枚举到 i 的时候，i' 和\r\nid 的各项数据我们都是已经求出的，于是我们可以借助\r\n它们来继续合理接续。\r\n如下图，若以 i' 为中心的最长回文串的左端不能够到达\r\nmx' ，那么以 i\r\n为中心的最长回文串也一定不会覆盖 mx。\r\n[1]\r\n反之，若其左端超过了 mx'，那么 i\r\n的回文串的右端不会超出 mx。\r\n如下图，紫红涩的那一段一定不是相同的，因为如果她们相同，mx\r\n还能继续向右扩展，这与 mx 的定义相悖，所以 那么\r\ni 的回文串的右端不会超出 mx。\r\n[1]\r\n剩下的就是其左端和 mx' 重合的情况，那么显然如下图一样\r\np[i] 可以继续伸展。\r\n[1]\r\n于是就有如下核心代码：\r\n12345678910if(i &lt; mx)    p[i] = Hmin(p[(id &lt;&lt; 1) - i], mx - i);else    p[i] = 1;while(s[i - p[i]] == s[i + p[i]])    ++ p[i];if(i + p[i] &gt; mx)    id = i, mx = i + p[i];\r\nCode\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;bits/stdc++.h&gt;#define Heriko return#define Yoisaki return#define Deltana 0#define Romanno 1#define Kanade 1#define S signed#define LL long long#define DB double#define R register#define I inline#define CI const int#define CL const long long#define mkp(a, b) make_pair(a, b)#define mst(a, b) memset(a, b, sizeof(a))#define ON std::ios::sync_with_stdio(false);cin.tie(0)#define Files() freopen(\"RNMTQ.in\", \"r\", stdin);freopen(\"RNMTQ.out\", \"w\", stdout)using namespace std;template&lt;typename J&gt;I void fr(J &amp;x) {    short f(1);    x = 0;    char c(getchar());    while(c &lt; '0' or c &gt; '9') {        if(c == '-')            f = -1;                c = getchar();    }    while(c &gt;= '0' and c &lt;= '9') {        x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^= 48);        c = getchar();    }       x *= f;}template&lt;typename J&gt;I void fw(J x, bool k) {    if(x &lt; 0)        x = -x, putchar('-');    static short stak[35];    short top(0);    do {        stak[top ++] = x % 10;        x /= 10;    }    while(x);    while(top)        putchar(stak[-- top] + '0');    k ? puts(\"\") : putchar(' ');}template&lt;typename J&gt;I J Hmax(const J &amp;x, const J &amp;y) {    Heriko x &gt; y ? x : y;}template&lt;typename J&gt;I J Hmin(const J &amp;x, const J &amp;y) {    Heriko x &lt; y ? x : y;}CI MXX(2.3e7);int ans, p[MXX], l;char org[MXX], s[MXX];I void Into() {    s[l ++] = '$', s[l ++ ] = '#';    while(cin &gt;&gt; s[l])         s[++ l] = '#', ++ l;    s[l ++] = '^', s[l] = '\\0';}I void Manacher() {    int id(0), mx(0);    for(int i(0); i &lt; l; ++ i) {        if(i &lt; mx)            p[i] = Hmin(p[(id &lt;&lt; 1) - i], mx - i);        else            p[i] = 1;                while(s[i - p[i]] == s[i + p[i]])            ++ p[i];        if(i + p[i] &gt; mx)            id = i, mx = i + p[i];        ans = Hmax(ans, p[i] - 1);    }}S main() {    ON, Into();    Manacher();    cout &lt;&lt; ans;    Heriko Deltana;}\r\n复杂度相关\r\n因为在计算一个特定位置的答案时我们总会运行朴素算法，所以一眼看去该算法的时间复杂度为线性的事实并不显然。\r\n然而更仔细的分析显示出该算法具有线性复杂度。此处我们需要指出，计算 Z 函数的算法\r\n和该算法较为类似，并同样具有线性时间复杂度。\r\n实际上，注意到朴素算法的每次迭代均会使  增加 1 ，以及 \r\n在算法运行过程中从不减小。这两个观察告诉我们朴素算法总共会进行  次迭代。\r\nManacher 算法的另一部分显然也是线性的，因此总复杂度为  。[2]\r\n因此 \r\n是确实是很优秀的字符串算法。\r\n\r\n\r\n\r\n参考资料\r\n\r\n[1] [字符串入门]Manacher\r\n算法 —— Dfkuaid\r\n[2] 字符串 —\r\nManacher —— OI-Wiki\r\n\r\n","slug":"Manacher","date":"2023-08-18T14:48:08.000Z","categories_index":"OI-Algorithm","tags_index":"OI","author_index":"Heriko Deltana"},{"id":"1a5ef9433614d51cc2de1e4fc349210c","title":"17 次回环之日","content":"「化作回忆的过去，尚未成文的未来」\r\n\r\n\r\n启\r\n其实距离十七次回环之日的到来，还有一个月的时间。但是这次不得不早写一会了，毕竟现在已经退役没有每天写一点的机会了。\r\n\r\n最初这一段是 1.31 写的：）\r\n\r\n今年比较有意思，闰二月，但是总不能过两次，所以按照第一个过好了（\r\n首先，既然能出现这些字，那么说明去年定下的唯一目标达成了。\r\n然后就是惯例的去回看过去的一年。\r\n忆\r\n在最起初想起要写这篇的时候，第一个能感受到的就是现在的精神状态要比去年好的多。\r\n其实去年在写 16\r\n的时候感觉是很清楚精神状态变差的始源的，并且知道为什么。但是经历了一年，再站在新的节点回望的时候，一切好像又不是那么的清晰，不过对于现在的我而言那些究竟是什么已经不重要了。\r\n任何时刻回望过去都是不一样的过去，所以这就是成长吗，随着时间曝光的叠加，记忆的模糊，忘却的清晰的新的时间节点上的自己。\r\n\r\n年初还是延续了去年的分裂。\r\n元旦发烧时感觉世界的撕裂与崩溃，对新年能有新运的渴望；元宵时情绪波动下对着\r\nDon't Never Around 谱面的宣泄，告示着 22\r\n年底力提升的开始；一次故意的考试成绩。\r\n我现在再回想，这一切都太过混乱，但是当时或许就是如此混乱，我太迷茫了。\r\n寒假里最终没有写多少的作业，可能隐隐预示着开学考试的成绩，于是做出之前性格不会做的事情，故意考差。原因也很简单，就是想看故意考差和正常考砸有什么区别，是否会有老师或者同学注意到。但是显然最后，学校里并没有人给我提起成绩的事情。但是目标也算是达成了，不知为何的行为，或许只会得到自己不知为何的结果。\r\n\r\n当然不会真的有人拿开学考试成绩说事吧（）\r\n\r\n而开学考的结束，意味着 2022 前两个月的流去。\r\n三月开头是阳历和阴历生日，那一个周因为短时期内没再有考试的压力，整个人状态比较放松，于是也就第一次把回环日写的像是旧岁回忆的\r\n16，在宿舍累起来比我还高的纸巾，和迄今为止最后一次去 maimai.\r\n那个周我真的好开心，因为我从来没收到过这么多人的生日祝福，于是当时写\r\n16\r\n的时候心情不错，但是还是写出了一些比较痛苦的回忆。不过可能多亏了写了出来，我现在已经不再总是惦记着它们了。\r\n所以写出来总是好的（\r\n\r\n但是随着三月三十的疫情网课开始，精神内耗又开始了，怎么说呢，四月前半是我这些年精神内耗最严重的时间段，不知道为什么，不知道。\r\n所以今年四月时期写的东西也是非常的抽象，也是经历了自己到现在都无法解释，但是就是那样做了的事情。可能还是对自己的迷茫吧，毕竟\r\n21\r\n年对精神上的冲击，让我真的找不到自己是什么。但是也幸好只有那半个月，后半个月我使用「我超，原」大法把自己的注意力转移了相当大一部分。\r\n今年的五月也算是不错的，有一次非常遗憾的期中考试，语数英挺好的但是物化生全寄了（其实和\r\n20 年刚回来的期中考试类似，但是那次语数英之外没那么寄\r\nヾ(•ω•)o`），有一次 APIO 的 Cu，拿到了自己 OI\r\n生涯唯一的牌子（虽然是线上的（\r\n本来一切发展的都挺好的，但是期末考试又考砸了\r\n_(:з)∠)_，考数学之前一天晚上肚子疼睡不着就寄了 40 分（\r\n因为这个成绩非常的不好看，而且当时 whxt\r\n给我最一开始说的级次是一千多，我直接痛苦面具了一晚上，然后 ysa\r\n把我从大厕所拽回宿舍阳台，聊了好久……怎么说呢，还是感觉真的很感谢自己身边总是有人在那里，这也是我去年崩溃之后逐渐明白的，人与人的世界。\r\n第二天不知道什么情况，wxm 给了张纸条，上面写着要\r\nにっこり。由于是一张便利贴，我就把他折起来贴到饭卡套内侧了，每次拿出来的时候，就会看到にっこり，然后想起来我身边的大家。\r\n\r\n虽然这样写总是有种什么奇怪的什么荔枝水文的成分，但是爷语文作文不行不会写别的：）反正意思对就是了（（\r\n然后不知道为什么这两天把那张便利贴搞丢了，md...\r\n\r\n不过很让我欣慰的一点是今年下半年拿出这张纸的时候心情都挺好的，没到很需要这张纸发挥作用的时候（\r\n\r\n于是随文化课上还有很大的遗憾，但是我还是开始了自己第二年的联赛，当然目标也很明确，就是省一然后退役，不再考虑省选。但是由于将近半年的荒废，我\r\nOI 能力大减，所以最后停课时间也是从七月中旬一直延续到了十一月底，即 NOIP\r\n2022 结束。\r\n今年停课整个状态都挺好的，自从 J\r\n去了初中之后，大家都挺好的，乐，下午五点的活动没少了打篮球（\r\n但是疫情的影响还是今年的重点，与之相关的就是 CSP-S2\r\n的取消和数学高联的延期延到和 NOIP 一起（\r\n过程其实很还算可以，整体水平显然是比去年高的，最后去掉写挂的东西，在场上罚坐三个半小时之后，也算是勉强拿上了省一。\r\n最后也算是沾了数学的光留在了\r\n32，所以我觉得算是很幸运了，再加上考完联赛回来正好是去年年末疫情高峰期的起始，直接回家就是网课状态，给了我一个非常充足的奥赛回文化课的缓冲时间，当然，也让我近身感受了疫情，包括但不限于在\r\npyyz 的封闭，全家两个人一起阳啥的。\r\n不过有一点可能我自己都没想到，我去年最后一次做 OI 题就是 NOIP2022\r\n了，在那之后直到现在，我还没做过任何新题，毕竟退役了（\r\n有关 NOIP 2022\r\n的最大的感受，是我终于从平邑回到了家，其余感受都没这个强烈，联赛前的最大愿望也是正常的回到家。\r\n但也正是在 pyyz\r\n的那十天让我似乎找到了心态调整的方法，不过仍需验证。\r\n最后这一年在一个月网课六次返校通知中结束了。\r\n望\r\n其实这一年真的满是周折，但是最终在 23\r\n年也已经过去一个月的时候再去回念，好像也没有什么很特殊的，毕竟每年都有很多起伏，15\r\n岁是精神曲折，16 岁是外界波折。\r\n那么对于 17，有什么展望呢……\r\n其实还是先让自己好好的活到 18\r\n吧，然后……希望自己这一岁能想之前一样全面吧，不缺高，也不缺低。正因为每一年都是极其特殊的一年，每一岁都是人生关键的一岁，所以就让它顺其自然吧。\r\n未来尚未写成之前，我永远不会知道我的未来是什么展开，不过也不必现在就知道，因为当能总结一段时间的时候，这段时间都已经成为了过去的回忆，而未来终将未知而永恒。\r\n\r\n由于现在周中并没有机会去写这些，所以这一篇其实是 23.2.18\r\n写成（即生日前的那个周六），之后可能还和 16\r\n次回环之日一样稍作修改，但是大概就是这样了罢。\r\n\r\n","slug":"17th","date":"2023-02-20T16:00:17.000Z","categories_index":"About Me","tags_index":"Me","author_index":"Heriko Deltana"},{"id":"43bbef0ba752218cacd14514159801b8","title":"NOIP 2022","content":"「Say GoodBye.」\r\n\r\n\r\n前言\r\n因为是 11.22\r\n开始写的，所以前面的都是回忆内容，但尽量去还原一下当时的情景吧。\r\nDay -15 ~ -10\r\n因为 12 号要去平邑集训，所以回家力。\r\n但是没想到等到 12\r\n号的时候说因为疫情推迟了去的时间，于是一次又一次的连续推迟，在家呆了六天。\r\n终于定下来是 17 号去平邑了。\r\n但是集训先是从 15 号开始了，每天上午一场考试。\r\n其实经历完正睿的二十连测之后我感觉还挺不错的，因为今年至少能部分保证场切一道多。\r\n但是这两天的题确实我不太会，甚至没有场切一道题（\r\nDay -9\r\n本来记的是中午两点走，但是快一点的时候才发现是看错了，应该是一点去，于是匆忙的收拾好了行李。\r\n一共 11\r\n个人从济南出发去平邑，坐的小巴，有点挤，幸好在走之前把手机充满了电，于是就听了一路歌。\r\n刚进入 pyyz 校园的时候，发现真的好大，还和 zyc 说着“真就哪都比 lcez\r\n强”，于是……\r\n我们都没想到这个 pyyz 中里面……基础设施好离谱……\r\n于是条件突然就变得艰苦了起来））\r\n机房键盘手感还行，但是我的这个键盘支架断了一个（？\r\n电脑是 Win7，i3-9100 + 8G，完全强于\r\nlcez，但是屏幕色准非常离谱，整体泛白，但是问题不大。\r\n电脑里有 VSCode（无插件）、Subline 和 Dev C++，鉴定为比 lcez\r\n三楼机子强（去年四楼有 VSCode）\r\n晚上睡觉有亿点冷，于是加加加加衣服。\r\n说起来搞笑，最一开始我们来的时候床上并没有垫子，一度认为我们要在木板上睡觉，还好最后去统一拿了。\r\n宿舍没有信号也没有电，阳台没有窗户，只有防盗窗，鉴定为：监狱配置（\r\nDay -8 ~ -4\r\n连着上午考试下午讲题，除了 Day -4（上午考一场下午考一场）\r\n整体体验非常拉稀，至今一道题都没有场切过（Day -5 T1\r\n场切了，但是交错了程序/hsh）\r\n感觉自己离着 1= 又远了，寄。\r\n心态不太好，不是很乐观。\r\n疫情这几天也在逐渐的严重，临沂还有，但是济南和聊城都在比较快的增长，有点担心。\r\n那么今天就写到这里吧，随缘，随缘。\r\nDay -3\r\n因为昨天考了两场，今天是下午考试。\r\n今天题比较的水啊，因为基本人均 T1，zyb\r\n十分钟就直接干掉了，菜如我也二十多分钟切掉了。\r\n因为今天给了大样例所以场上就基本可以保证 T1\r\n对了，专门警惕了一下不要交错。\r\nT2 发现了是树上背包，但是不太会拆点做啊，扔了。\r\nT3\r\n发现了一点性质，糊了一个构造上去，但是显然还少一些细节，但是至少有分，最后变成\r\n20.\r\n今天是第一次分数超越 100，泪目。\r\n明天就要封考场了，给我们找了个什么地方我也不知道，但是说是有插座可以用自己的电脑，所以或许明天又能用上自己的电脑了（\r\n\r\n今天 NOI 官网发出通知说如果 NOIP 不能举办可能要变成 2023.3 的\r\nNOIP-Spring，不能举办的省份需要在 25 号 10 点之前通知 CCF.\r\n也就是说 25 号应该就能知道哪些省份举办了。\r\n不太知道有啥好说的，也不知道希不希望它延期。\r\nB 站私信又成为了学校内外的小窗，乐（\r\n今天初中和高一高二都回家上网课，高三和生物、数学、信息奥赛留校。\r\n据说济南可能封城……这样可能考完也回不去了？\r\n现在一切都未知啊，只能看这两天的进展了。\r\n那么，就写这些吧。\r\nDay -2 ~ -1\r\n考前最后两天没有再安排讲课，每天放了一套题，然后就是上自习，不过终于可以用自己的电脑了（\r\n但是依然是没有网（虽然学校里确实有一个网，但是大家都连不太上（\r\n其实感觉每天除了第一道题我看了看之外就没太管那两套题）\r\n其实这两天主要还是看了看板子，那 AI 生成了一点图\r\n考前一天晚上十点半就上床关灯了，结果到了十二点多我和 xsh\r\n还起来上厕所（（\r\nxsh 一晚上上了六次，我四次（\r\nDay 1\r\n早上 pyyz 跑操，他们吹哨的声音吓我一跳，于是我左腿抽筋了（（（\r\n七点起的，起来之后其实就有点迷茫不知道该干啥，于是随便吃了饭做了核酸就进了考场。\r\n进去之后就简单的坐下来了，也没再去配置 VSCode/Sublime，懒了，就用\r\nDevC++ 吧。\r\n然后我看电脑上的表到了 8:31\r\n还没有密码条，我就有点惊讶了，于是等老师写，然后老师写了个\r\nsolo@2022\r\n然后考场的各位一顿试发现不管是\r\nsolo@2022、Solo@2022、SOlO@2022、S0l0@2022\r\n还是 SOl0@2022 都打不开（\r\n然后我看老师不慌不忙的样子问了一句现在几点了，然后，他非常平静的给我说\r\n8:35 了……\r\n我的评价是：抽象。\r\n然后大约 8:37 的时候有个老师跑过来在电脑上写下了\r\nbiu#2019miss，看起来意思是 NOIP2019 被宇宙射线整没了）\r\n然后发现 solo@2022\r\n是题面的密码，科幻，我还是第一次见这种事情。\r\n于是我开始看题的时候就 8:45 了，不过最后考试时间往后延了 10\r\n分钟。\r\n发现 T1 好长，有点科幻，于是先把四个题都读了一遍，然后回来开\r\nT1，做了一会发现记录一下行列上多少个连续的 0\r\n就行了，于是写了一个小时写完了一个  的 T1.\r\n然后就是比较无聊的 T234 瞎写乱搞。\r\n然后罚坐了 2.5h，因为我是真的能力就在那个地方了，没法子。\r\n考试最后几分钟数着自己生涯的最后一段时间，但是感觉自己尽力了，水平就这样，也没有什么遗憾了。\r\n最后\r\n真的是最后了，OI 生涯的最后。\r\n没有什么要说的了其实，如果这几天想起来了再补吧。\r\n本身就不是实力选手，退役才是正路吧。\r\n最后转一下我在 SOJ 发的两年时间漂浮的一些感想。\r\n两年漂浮的一些感想。\r\n水平本来就那个样。\r\n也没啥了，退役，退役，不过如果网课继续的话可能再给学弟学妹们搬几道题，如果你们有比赛可以拿我号垫分。\r\n之前我供的题如果你们要加题解了也可以用我号加，总之，就是公开了，别乱搞就行。\r\n\r\n就是说什么呢，我其实是没有什么沉淀的东西可以拿出来分享的，于是我建议你真的想要学到有用的东西，先去看\r\nzyc 写的和 fys\r\n写的，然后我这些可以当做依托答辩看。\r\n因为本身我不是脑袋很灵光的那种，很多东西我也不懂，我也不会。\r\n然后我其实入 OI 也比较晚，所以很多事情看的不如各位明白。\r\n但是对自己有一个清楚的水平判断我觉得还是挺重要的，当你在前进的时候，也应当想一想，看一看周围，对自己有个了解。\r\n如果是像我一样初三下学期才算是正式学的话，其实整个 OI\r\n生涯满打满算是两年多。\r\n虽然看起来时间很长，但是其实是很快的，因为你不可能所有的时间都在 OI\r\n上。\r\n于是一个正确的学习思路很管用，尽管我并没有，这个我觉得 fys 和 zyc\r\n写的都很好了。\r\n一定会有比你学的好，比你学的时间长的，但是这些你其实没有什么办法。所以不要害怕垫底，要多去打模拟赛练手什么的。\r\n我把我号放出来垫分其实也是为了不让你们怕掉分就不打模拟赛。\r\n害怕掉分？下边总有一个菜鸡学长垫着呢。\r\n强手眼中的模拟赛是什么样子的，我不知道。\r\n但是我知道的是，对于弱手，其实只要不是非常烂的题，这个模拟赛总是有他的价值。因为作为弱手，不是四题都能快速秒的。于是模拟赛就有了他的用处，提升代码能力和适应考试时的状态。\r\n个人愚见，这两点是考场上最重要的，稳健的状态才能保持发挥。\r\n我本身线上交际可能多一点，所以认识的大佬很多，只不过我本身不太适合听课/听别人讲题，因为我总是跟不上……\r\n但是你们不一定和我一样，所以认识一些大佬，拓宽视野也是有用的。\r\n最后就是不要做压力选手，不要试图给别人施加压力，也不要给自己太大压力。希望你们能先做到后者，而前者我觉得则是基本的道德素养，没有也不强求。\r\n写的很乱，写的很烂，没有什么顺序，强手们看一乐呵就行。\r\n你要是闲的没事故意过来想来这里找乐子那我管不着你。\r\n同时欢迎现在的，过去的，和未来的强手讽刺。\r\n最后更新于：2022.11.28 00:04.\r\n","slug":"NOIP-2022","date":"2022-11-22T14:53:38.000Z","categories_index":"OI-TravelNotes","tags_index":"OI","author_index":"Heriko Deltana"},{"id":"000a8ad9fc6bb0e3bf2958a086089b5a","title":"Nothing : ForeverHome","content":"「现在想来，一切都过于匆忙，没有时间告别」\r\n\r\n\r\n0\r\n「8.32 - *Luna」\r\n\r\n雲のあいだ 君を隠したもやもやも\r\n如果能将云隙间隐盖你的那一片朦胧\r\n全部吹き飛ばせたらな\r\n全部吹跑的话\r\n空に咲いた 僕を隠したもやもやも\r\n如果能将绽放在空中 或者是掩盖在我心底的那一片朦胧\r\n全部忘れられたらな いいな\r\n全部忘却的话 那该有多好啊\r\n覗いたものは すべて輝いていつか\r\n所窥视到的一切 不知何时都在闪耀着光芒\r\n消えそうに ゆらゆら揺れて\r\n像是要消失一般摇摆不定\r\n触れたものは すべて透き通って繋ぎ\r\n所触碰到的一切 全部都变得清澈透明\r\n留めたくて くらくらしてた\r\n令想与它紧紧联系的我 头疼不已\r\nずっとそこにいたいよ 時を止めておくれよ\r\n好想呆在那里 时间啊请就此停滞吧\r\n何もかも上手くいかない そんな\r\n在什么都不如心意 那样的那样的\r\n退屈な日々だ そこに君が描いた\r\n无聊日子里我是不会\r\nこの色を手放せないんだ\r\n将你所描绘的色彩放开\r\n不確かものは いつだって\r\n虚无缥缈的东西 无论何时\r\nどうしようもなく僕を 惹きつけて離さない\r\n都能将我深深吸引 令我无法离去\r\n手を伸ばせばほら いつだって\r\n一旦伸出手 看吧 无论何时\r\n雲をつかむような そんな感覚だ\r\n都会有能将浮云握在手中的这种错觉\r\n溺れて\r\n使我沉溺其中\r\n溺れて\r\n使我沉溺其中\r\n手にしたものは すべて抜け落ちて今も\r\n将手中紧撮的东西 全部举起丢弃的感觉\r\n絶え間なく ちくちく痛んで\r\n至今仍不断一针一针地刺痛我\r\n思い出すのは すべて灰色な記憶\r\n能回想起来的 全都是灰色的记忆\r\n沈んでしまえ 深く深く\r\n沉溺吧 越深越好\r\nもういっそ 僕ごと全部\r\n干脆把我的一切\r\n連れて行ってくれ\r\n全部都带走吧\r\n不安定な君が いつだって\r\n不安定的你 无论何时\r\nどうしようもないくらいに 愛おしくて放せない\r\n都让我无可救药地深爱着\r\n目を閉じればほら いつだって\r\n一旦闭上眼 看吧 无论何时\r\nすぐ傍にいるような そんな錯覚だ\r\n就会有你陪伴在我身边这样的错觉\r\n溺れて\r\n使我沉溺其中\r\n今日が いつまでも\r\n“今天已经不再是今天”\r\n今日じゃないことくらい とっくに気づいていたよ\r\n这样的事早就已经察觉到了\r\n僕らだけの夏\r\n只属于我们的夏天\r\n誰だって 奪えやしないんだ\r\n无论是谁都无法夺走\r\n君が 攫って\r\n但只有你 可以随意拿去\r\n眩しい日差しを背に 君は笑っていた\r\n你背对着耀眼的太阳 嫣然一笑\r\n僕の影に凭れ 霞んでく\r\n逐渐靠近 令你的身影如雾般模糊不清\r\n揺れる白いワンピース\r\n向着身穿摇曳白色连衣裙\r\n光を通した君を抱きしめた\r\n被光线穿透的你 紧紧拥抱\r\n僕は君と共に行く\r\n我要与你一起同行\r\n終わらない夏の中\r\n在这无尽的盛夏之中\r\n終わらない夏の中\r\n在这无尽的盛夏之中\r\n\r\n\r\n1\r\n早上找照片的时候在 Onedrive\r\n上找到了这张图，也不知道是什么时候放上去的。\r\n于是意识到已经离开那里一年又半了，比是我来到高中部的时间短了一点。\r\n这张图制作的时间是 20.08.14，是初三前的暑假。\r\n初三暑假算是成绩好坏的分水岭吧，初三暑假之后在级部的排名的下限开始变低，包括高一，对于自己成绩的信心越来越少了，只剩下了英语上的一点微弱优势。\r\n其实我也不是很清楚到底是为什么。\r\n其实看见这张图只是发现那张图上的东西都是过往了，没有一个现在还在用的了，而它们的最大载体，那个家，我也再也回不去了。\r\n其实离开那里一年半的时间里一直都没太想起过，毕竟之前也是长时间在济南，只有过年的时候才会回去，但是直到今天才想起来这一切已经不一样了，之前它只是默不作声，仍然等待着我的回归，而现在它依旧默不作声，而我回不去了。\r\n说到底也是我住的时间最长的家，所以和之前在济南的几次搬家的感受不一样。\r\n其实因为搬家的时候家具是类似的，所以搬家之后对于之前的家的很多的记忆都是残缺的，大概就是能想起来框架而不知道到底在哪里发生的。\r\n然后同一天网易云随机到了 *Luna 的\r\n8.32，这是讲的夏日分别的曲子，而正好这张图是 20\r\n年的夏天，也是我最后一次在那里长住，所以就把 8.32 放到上面了。\r\n8.32，真的回到来吗，不会，因为 9.1 永远是 8.31 的下一天。\r\n但是 8.32\r\n会存在，因为我们都是意义不明的存在，这个世界的一切规章又为何不是如此呢。\r\n但是告别过去是一定要经历的部分，所以得到失去都没什么。\r\nEOF\r\n「群青讃歌 - Eve」\r\n是 PJSK 一周年的纪念曲，今天写的这一点东西就用它来结尾吧。\r\n\r\n作词 : Eve\r\n作曲 : Eve\r\n繋がっていたいって\r\n一句想要相连\r\n信じられる言葉\r\n让我不曾怀疑\r\nだってもう昨日の僕らにおさらば\r\n因为我们已经与昨日的自己挥手告别\r\n青い春を過ごした 遠い稲妻\r\n远方电闪雷鸣 青春已然流逝\r\nさっと泣いて 前だけを向けたら\r\n痛快哭过之后 一心向前的话\r\nきっとどんなに\r\n一定能过得\r\n楽になれていたろうな\r\n无比轻松的吧\r\nこの心を揺らした 一縷の望みは\r\n犹有一线希望 打动了内心\r\nないものねだりは辞めた\r\n已经不再强求什么的\r\n未完成人間\r\n还未成熟的人\r\n素晴らしき世界だけが\r\n唯有面前美好的世界\r\n答えを握ってる\r\n掌握着答案\r\n諦めてしまうほど この先沢山の\r\n虽然在这前方 将有无数的后悔等待着\r\n後悔が君を待ってるけど\r\n几乎会让人放弃\r\nもうない 迷いはしないよ\r\n但是没关系 已经不会再迷茫了\r\nこの傷も愛しく 思えてしまうほど\r\n积累起来就好 连这伤痕都能\r\n重ねてしまうよ\r\n让我想要珍惜\r\n不格好なまんまでいいから\r\n哪怕模样还是如此难看也没关系\r\n走れ その歩幅で\r\n奔跑吧 就用这样的步幅\r\n走れ 声 轟かせてくれ\r\n奔跑吧 让声音轰响吧\r\n期待と不安を同じくらい抱きしめて\r\n拥抱着相同分量的期待与不安\r\n君と今を紡ぐ未来照らして\r\n与你一同照亮用当下编织成的未来\r\n顔も名前も知らない僕たちが\r\n互不知晓面容和名字的我们\r\nたった1つの音をかき鳴らす\r\n奏响着同样的声音\r\nいたずらみたいな奇跡のような刹那\r\n就像恶作剧一样奇迹般的瞬间\r\nあっという間に流れる時が\r\n害怕转眼间流逝的时间\r\nありのままで在り続ける怖さが\r\n依然保持着原来的样子\r\n失った時間は取り戻せないけれど\r\n即使失去的时间无法追回\r\n過去を振り返ってばかりじゃ\r\n如果一味回顾过去\r\n泣いたっていいんだ\r\n那哭泣也就无妨了\r\n悔しさと痛みだけが\r\n因为唯有那些悔恨和伤痛\r\n君を肯定するから\r\n会承认你\r\n大人になったら 忘れてしまうの\r\n与你立下约定的地方\r\n君との約束をした場所は\r\n长大成人后可能就会忘记吧\r\nもうない 覚えていたいよ\r\n但是我不会 我想要铭记于心\r\n思い出も愛しく 思えてしまうほど\r\n积累起来就好 连回忆都能\r\n重ねてしまうよ\r\n让我想要珍惜\r\n不格好なまんまでいいから\r\n哪怕还是如此不成样子也没关系\r\nその声はどこまでも鳴り響いて\r\n这声音 响彻世界的每一个角落\r\n確かな理由を抱いて\r\n怀抱着确切的理由\r\nここまで来たんだ\r\n一路来到这里\r\nまだ終わらない旅路なんだ\r\n这是一段还未结束的旅程\r\nいつしか想いは形になる\r\n心愿终有一日成形\r\nこの真っ白に染まる朝\r\n这遍染纯白的早晨\r\n忘れられないまま だから\r\n让我永远难忘 所以\r\n諦めてしまうほど この先沢山の\r\n在这前方 将有无数会让人放弃的事\r\nもうない 迷いはしないよ\r\n但是没关系 已经不会再迷茫了\r\nかけがえのないもの\r\n在这世上充满着\r\n溢れてしまうよ\r\n无可替代的东西\r\n答えは君のその手の中に\r\n在你的手中就握着答案\r\n離さないで 物語は一歩前へ\r\n只要不放手 故事就将更进一步\r\n諦めてしまうほど この先沢山の\r\n虽然在这前方 将有无数的后悔等待着\r\n後悔が君を待ってるけど\r\n几乎会让人放弃\r\nもうない 迷いはしないよ\r\n但是没关系 已经不会再迷茫了\r\nこの傷も愛しく 思えてしまうほど\r\n积累起来就好 连这伤痕都能\r\n重ねてしまうよ\r\n让我想要珍惜\r\n不格好なまんまでいいから\r\n哪怕模样还是如此难看也没关系\r\n走れ その歩幅で\r\n奔跑吧 就用这样的步幅\r\n走れ 声 轟かせてくれ\r\n奔跑吧 让声音轰响吧\r\n期待と不安を同じくらい抱きしめて\r\n拥抱着相同分量的期待与不安\r\n君と今を紡ぐ未来照らして\r\n与你一同照亮用当下编织成的未来\r\n\r\n","slug":"ForeverHome","date":"2022-10-11T11:29:48.000Z","categories_index":"Nothing","tags_index":"Me","author_index":"Heriko Deltana"},{"id":"2e5e5be6a1a4d5a54dae70190be92674","title":"数位 DP RELOAD","content":"RELOAD 数位 DP.\r\n\r\n\r\n\r\n基于动态规划 | 数位\r\nDP。\r\n\r\n序言\r\n那么我准备 RELOAD\r\n一下，基本是小幅度修改，修正一些小的不清楚的地方。\r\n初见\r\n什么是数位 DP 呢（\r\n简介\r\n先放一下 OI-Wiki 上的数位介绍：\r\n\r\n数位：把一个数字按照个、十、百、千等等一位一位地拆开，关注它每一位上的数字。如果拆的是十进制数，那么每一位数字都是\r\n0~9，其他进制可类比十进制。[1]\r\n\r\n因为是小学知识所以就不多做解释。\r\n那么数位和 DP 是什么我们都知道了，那么数位 DP\r\n就是针对一些可以用数位的思想去解的题目，而这些题目通常会有非常明显的特征。\r\n题目特征\r\n一般来说数位 DP 的题目有如下特征：\r\n\r\n题目所求和数位相关或是转化后和数位相关，比如求一个数每一位的和；\r\n一般是一个计数问题；\r\n数据范围很大，所统计的答案已经与数据大小无关；\r\n一般输入时给出的是一个区间。\r\n\r\n简单来说就是，在区间  中统计符合条件  的数  的个数，一般  和  的大小无关，而与  的数位组成有关。\r\n既然和 \r\n的大小一般无关了，所以数位 DP 的复杂度就和  的大小关系不大了。\r\n模板\r\n众所周知数位 DP 的模板是非常好套的，于是先来讲一讲模板罢。\r\n当然好套只是其中一个原因，之所以先讲，是觉得先看完了模板框架和状态设计之后，更容易理解数位\r\nDP 的过程。\r\n设计状态\r\n我这里用记忆化搜索的形式来转移状态，这样的好处是我们的思维量更少，可以在\r\n 函数里维护更多的信息。\r\n当然模板也更好套，更好背\r\n下面的参数不懂可以先不用着急，下面节二会稍作分析。\r\nDFS 函数\r\n那么我们先来看一看 \r\n中都需要什么参数：\r\n\r\n：前导  的状态；\r\n：当前位置做多取值的有没有被限制；\r\n：当前的状态在原数中的位置；\r\n：当前状态的答案；\r\n：上一位数字。\r\n\r\n\r\n当然以上参数不一定每个题都需要，视题目而定即可。\r\n当然你记录的东西多了一般也不会错\r\nDP 数组\r\n下文中的 DP 数组我都用  来表示。\r\n一般来说我们要在 DP 数组中记录当前状态在原数中的位置  和当前状态的答案 ，也就是说，对于简单的数位\r\nDP，方程的样子一般都是 。\r\n当然根据题目的不同还有可能会往里面加一些其他的东西。\r\n参数分析\r\n前面所说的参数可能初见会不懂，于是下面来稍作分析。\r\n下文中若无特殊说明，\r\n均表示原数第  位的数。\r\nlead\r\n这个参数的存在是为了我们要从最高位开始搜时避免一些不必要的错误。\r\n下面来举个例子：\r\n\r\n求 \r\n中有任意相邻两位相同的数字。\r\n\r\n当  时，显然 \r\n都是符合题意的数字。\r\n但是我们搜索时记录出来的上列数字是这样的：，显然有了前导\r\n\r\n之后这些数字都不满足题意了，于是我们要把前导  的影响去掉。\r\n这个标记的意义如下：\r\n\r\n\r\n\r\n\r\n但是显然当我们所统计的东西和上一位是否为 \r\n无关的时候，这个参数也可以不用记录（比如问一个数的组成），当然记了肯定没错。\r\nlimit\r\n这个参数如果用相对严谨的形式去一句话定义的话会很绕，但是举个例子会非常有助于理解。\r\n\r\n从范围 \r\n中找符合条件某条件的数 。\r\n\r\n那么如果我们当前搜索到的数字的最高位为 ，那么显然我们次高位搜索的范围会被限制为\r\n。\r\n为了区分当前位置有没有被限制，我们加入了参数 。\r\n这个参数意义如下：\r\n我们设 \r\n为我们在当前位上搜索到了 ，那么显然 ，为了方便，下面统一将可搜的数的最大值设为 。\r\n在这里  函数第二个参数为\r\n。\r\n\r\n\r\n\r\n\r\n简单而言就是，如果当前位置是最高位，那么如果当前枚举的数达到了 ，那么下一位置只能从  中遍历；\r\n同理，当我们搜索到第 \r\n位的时候，若第 \r\n位达到了其限制，那么当前位置的搜索范围就由  被限制到了 。\r\n一般来说使用 (i==n) &amp;&amp; limit 可以直接更新。\r\n数组\r\n使用记忆化的原因很简单：数位 DP\r\n过程中存在大量的重复状态，采取记忆化就可以有效的降低复杂度。\r\n但是有时候一些状态并不能记录，也就是当前状态存在限制的时候不能取用之前的状态或将本次\r\nDFS 结果存储在 DP 数组中。\r\n一般来说即为 \r\n时显然不能取用和存储。\r\nCode\r\n前面对一些参数稍作分析之后，我们来上一份模板代码。\r\n123456789101112131415161718192021222324252627282930313233LL DFS(bool limit, int st, int pos, ...) {    if(!pos and ...)        Heriko st;    if(!limit and f[pos][st]...[...] != -1 and ...)        Heriko f[pos][st]...[...];    int res(0), up(limit ? a[pos] : 9);    for(R int i(0); i &lt;= up; ++ i)        res += DFS(...);    if(!limit and ...)        f[pos][st]...[...] = res;    Heriko res;}I LL DP(LL x) {    mst(f, -1);    int len(0);    while(x)        a[++ len] = x % 10, x /= 10;    Heriko DFS(1, 0, len);}S main() {    fr(l), fr(r);    fw((DP(r) - DP(l - 1) + MOD) % MOD, 1);    Heriko Deltana;}\r\n例题\r\n如果你能看懂模板，那么下面这道题你能很容易的切掉。\r\nLOJ | #10169.数字计数\r\n洛谷 | P2602\r\n数字计数 [ZJOI2007] \r\n给定两个正整数  和 ，求在 \r\n中的所有整数中，每个数码(digit)各出现了多少次。\r\n思路\r\n是一道数位 DP 的板子题，正好遇上洛谷日爆（\r\n采用模板化的 DFS 做法，定义  数组如下  表示是从高到低第  位， 则是数字出现次数。\r\nDFS 函数为 ，参数分别表示：从高到低第几位，要求哪个数出现的次数，当前出现次数，前导零的状态，当前位置上限的状态。\r\nCode\r\n12345678910111213141516171819202122232425262728293031323334353637383940CI MXX(15);LL l, r, f[MXX][MXX], a[MXX];LL DFS(LL pos, LL num, LL st, bool lead, bool limit) {    if(!pos)        Heriko st;    if(!limit and lead and f[pos][st] != -1)        Heriko f[pos][st];    LL n(limit ? a[pos] : 9), res(0);    for(R LL i(0); i &lt;= n; ++ i)        res += DFS(pos - 1, num, st + ((i or lead) and (i == num)), (lead or i), ((i == n) and limit));    if(!limit and lead)        f[pos][st] = res;    Heriko res;}I LL DP(LL x,LL y) {    mst(f, -1);    LL len(0);    while(x) {        a[++ len] = x % 10;        x /= 10;    }    Heriko DFS(len, y, 0, 0, 1);}S main() {    fr(l), fr(r);    for(R LL i(0); i &lt;= 9; ++ i)        fw(DP(r, i) - DP(l - 1, i), 0);    Heriko Deltana;}\r\n推荐题目\r\n在这里提供一些练习题目的推荐，以下推荐题目都可以在[总之就是 |\r\n一堆杂题]的 #174 到 #179 找到。\r\n较为板子类\r\n\r\n洛谷 | P6218\r\nRound Numbers S [USACO06NOV]\r\n\r\n洛谷 | P4317\r\n花神的数论题 \r\n洛谷 | P4999\r\n烦人的数学作业 \r\n\r\n稍灵活类\r\n\r\n洛谷 | P4127\r\n同类分布 [AHOI2009] \r\n洛谷 | P3413\r\nSAC#1 - 萌数 \r\n\r\n\r\n\r\n\r\n参考资料\r\n\r\n[1] 数位 DP ——\r\nOI-Wiki\r\n[2] 数字组成的奥妙——数位dp\r\n—— Mathison\r\n\r\n","slug":"RE-NumDP","date":"2022-10-09T02:59:16.000Z","categories_index":"OI-Algorithm","tags_index":"OI","author_index":"Heriko Deltana"},{"id":"0c3456e166b6942463510157bc43e6be","title":"CSP S1 2022","content":"「CSP22 初赛相关」\r\n\r\n\r\n\r\n因为先是知识点的一些总结，然后游记也会放进来，所以归类就是\r\nOI-TravelNotes 了。 最后游记会放在最上面，知识点在下面。\r\n\r\n游记\r\nDay -1\r\n因为第二天要考初赛了所以回家力，然而中午回家之后基本上啥都没干就是水水水。\r\n晚上最后感觉水多了就去郑哥开的疼逊悔意里面听了听各位哥哥的高超分析（\r\n其实主要是感觉不出来明天会考啥，考难了也就那样，简单了也就那样，差距大约不会很大（\r\nDay 1\r\n早上八点醒的，已经是今年最晚起床时间了，之前放假的时候也都是六点半左右起床。\r\n上午大约十一点半之前都在水，然后看了会知识点，突然觉得下午会考一些奇怪的东西（\r\n中午吃完饭就去考场，虽然是在一个城市但是距离我家有 40 km\r\n的车程，我直接进行一个睡觉，但是可能是长高了，在车上睡的很扭曲（指腿\r\n睡醒之后到了地方，从 QQ\r\n上问了问发现都还没来，于是在车里呆了一会，毕竟外面非常的晒。突然想起来要和\r\nHerself、lixx 和 1lgorithm\r\n面基，于是大约互相了解了一下位置，不过有点可惜 1lgorithm 没带手机（\r\n两点五分让进考场，于是一点四十多的时候下车准备进学校。\r\n一下车一看，哎呀这不 fys 吗，还是看看远处的 qzy 吧，看见\r\nfys 在分发他比利海灵顿的徽章，我不知道好像没要（？），ceh\r\n把这个勋章放到了校徽之上（\r\n然后就进去教学楼了，在上楼的时候看见了苗子，好久没见了好像，但是毕竟\r\n\r\n一起呆了大半年，希望他这次初赛能过吧……\r\n上楼之后看见了 ajh 等，发现了\r\n1lgorithm，但是显然他们没认出来我，于是我在 QQ\r\n上进行了提醒，于是今年第一次见\r\n1lgorithm，十个月不见，他已经是超级音游王了/oh/oh\r\n没过多久就进去考场了，今年还是和 hyl\r\n连号，只不过去年我俩在最后，今年在最前面。\r\n考试的时候做题就觉得非常的怪，不过最后做完整套题还是有一段时间，但是我觉得寄，主要是感觉出题人被外星射线轰了出的啥题。\r\n有意思的一些点是有些比较大争议的题我考场有些没看出来。\r\n\r\nfor(j=0;j&lt;n;j*=2)\r\n他在场上说更改之前我都没注意看，可能是直接过滤的，乐。\r\nT5 的外星射线轰炸我真的无语，你又没说轰炸什么，你轰炸个 CPU\r\n的指令集我选哪个？你轰炸个 \r\n我选哪个？真的不理解出这种随机刷人的题的意义何在。\r\nT10 到底怎么写的题面，怎么算都是\r\n105，赛后出来一听有人读出来，原来意思是只需要 ，即两个人，我希望出题人能去重修一下您的语文。\r\n 呢？ 呢？ 呢？ 呢？为什么又惦记你那  了？而且里面带常数是吧。\r\n还有就是出题人您会不会写二分啊哥……\r\n场后发现有人被现实生活中车牌没有 I 和 O\r\n而题目中有坑了，而我因为没有生活常识逃过一劫。\r\n\r\n感觉就是随机刷人了，做起来太**奇怪了。。\r\n推荐阅读一：好开，我闪跟了。\r\n推荐阅读二： 呢哥？\r\n如下是我的评价：\r\n你说的对，但是「CSP-S 2022 初赛」是由「省\r\nA·ℒℒ𝒟𝒟𝒟𝒟」推出的一款制作精良的「随机筛人」游戏。玩家将进入名为 「」的世界，扮演名为「小明」的角色，加入叫作「排序算法」的组织，在「基数排序」的帮助下寻找「计数排序」，探寻世界最终的秘密，而这一切都源于出题人早在\r\n2022 年就放弃利用正确的 \r\n以及捡起来精心设计的 \r\n让被「受宇宙射线的影响而异变」的大家眼前一亮。最终「time」和「秒表」在你的手中偷走了你的「Real\r\nTime」，最后携手「高超 RE 二分」一起将「桶排序」拯救到\r\nfor(j=0;j&lt;n;j*=2)，最后化身「出题人的同学」拯救了出题人，完成了他的「 大作业」。\r\n有用的链接\r\n主要是懒得写了，整点考前能看的链接在这里（\r\n\r\nCSP初赛知识点梳理-159号程序员-洛谷博客\r\nCSP-S 2020\r\n初赛解析-Rainy7-博客园\r\nCSP-S 2021\r\n初赛解析-Rainy7-博客园\r\nMaster\r\nTheorem EZ\r\n\r\n去年好像我就是看 Rainy7 的初赛解析过了一遍 20\r\n年题来着，写的确实挺好的有参考价值\r\n做题记录\r\n\r\n\r\n\r\n\r\nstrlen() 复杂度 \r\n\r\n","slug":"CSP-S1-2022","date":"2022-09-14T11:18:57.000Z","categories_index":"OI-TravelNotes","tags_index":"OI","author_index":"Heriko Deltana"},{"id":"54e196d163147151fde4219cd71e6702","title":"Master Theorem EZ","content":"「用来应对初赛的 Master Theorem」\r\n\r\n\r\n\r\n其实是搬运去年初赛前写的，因为只是为了初赛层面的，所以标了个 EZ.\r\n所以下面的“最近”之类的词都按照去年的时间就好了。 当然对比去年最后加了个例题，改了一下尾声。\r\n\r\n序\r\n最近做初赛题，发现这些小学数学题真是一个都不会（\r\n发现基本上每年都要考主定理，于是在这里简单记录一下。\r\nMaster Theorem\r\n主定理主要适用于求解形如下面这个递归式的时间复杂度：\r\n\r\n其中参数的含义如下：\r\n\r\n 是问题规模大小。\r\n 是原问题子问题的个数。\r\n\r\n是每个子问题的大小，当然这里的前提是设所有子问题的大小相等。\r\n\r\n是分拆子问题和合并子问题的（时间）复杂度函数。\r\n\r\n不过就我做的这几年的提高组初赛题来看，参数的意义实际上不太考，一般都是直接给出柿子让你分析时间复杂度。\r\n情况分类\r\n\r\n下面的大小比较都是渐进意义上的。\r\n\r\n上式的复杂度分析主要如下列三种情况：\r\n\r\n\r\nimage.png\r\n\r\n当然也有简化的版本（不与上面的三种一一对应）：\r\n\r\n若  且对于足够大的  和常数  有 ，那么 \r\n若 ，则 \r\n若 ，则 .\r\n\r\n初赛内就主要是  和  的大小关系（即  一般取 ）\r\n例题分析\r\nBinay Search\r\n\r\nStop learning\r\nuseless algorithms, go and solve some problems, learn how to use binary\r\nsearch.\r\n\r\n显然我们每次把一个问题分成两个子问题，所以 ，即：\r\n\r\n因为 ，所以复杂度为 \r\n归并排序\r\n和二分查找类似，不过原问题的子问题个数为两个，故 ，同时合并子问题的时间复杂度为 ，即：\r\n\r\n因为 ，所以复杂度为 \r\nNOIP 2016TG\r\n假设某算法的计算时间表示为递推关系式：\r\n\r\n则算法的时间复杂度为？\r\n因为 ，所以 \r\nNOIP 2017TG\r\n假设某算法的计算时间表示为递推关系式：\r\n\r\n则算法的时间复杂度为？\r\n因为  且  时 ，所以 \r\n浴谷 SCP21 初赛\r\n\r\n为了维护 CCF 的知识产权利益，本次比赛简称 SCP 第一轮。\r\n\r\n假设某算法的计算时间表示为递推关系式：\r\n\r\n则算法的时间复杂度为？\r\n因为 ，所以 \r\n浴谷 SCP22 初赛\r\n\r\n为了维护 CCF 的知识产权利益，本次比赛简称 SCP 第一轮。\r\n\r\n假设某算法的计算时间表示为递推关系式：\r\n\r\n则算法的时间复杂度为？\r\n因为 ，所以 \r\n尾声\r\n周天就是 CSP-S1 2022 了，希望各位都 RP++，AK 初赛（\r\n希望我能进复赛（\r\n","slug":"Master-Theorem-EZ","date":"2022-09-14T08:00:08.000Z","categories_index":"OI-Theorem","tags_index":"OI","author_index":"Heriko Deltana"},{"id":"a47e5509a68fd10a960cec6ed904b43a","title":"背包问题 RELOAD","content":"「回顾自己快全忘掉的背包……」\r\n\r\n\r\n算是第一个 RELOAD 吧，主要是这两天真的忘了各种 DP，所以决定从 RELOAD\r\n背包开始，之前在博客园写的就不搬过来了。\r\n看着当年的博客，感觉自己也是长大了吧。\r\n\r\n夢の続きを知りたいのかい?\r\n\r\n01 背包\r\n有  件物品，每件物品的价值为\r\n，费用为 ，背包容量为 ，求问能放入背包的物品最大总价值。\r\n分析\r\n\r\n因为是第一种背包，也是最为基础的一种，所以说的相对详细一点。\r\n\r\n01 背包的命名的含义在于：每一种物品都只有选和不选两个状态，即 01.\r\n用子问题来设计状态是一种常见的方式，在这里设  表示前 \r\n个物品恰好放入一个体积为  的背包可以获得的最大价值。\r\n然后考虑如何转移状态，首先，因为 01\r\n背包只有选和不选两个状态，所以考虑加入一个新的物品会对当前有什么影响：占据一部分背包容量，增加最大价值。\r\n那么显然如果要加入的物品费用小于剩余的背包容量，就可以向这个状态转移（当然，也可以不加入这个物品），即：\r\n\r\n最终我们要的答案并不是 ，而是 ，这是因为我们的状态设计时设置的为恰好，当然也可以通过在转移的时加入一项\r\n 来去掉这个恰好从而使得\r\n 是最终答案。\r\n优化\r\n首先来看时间复杂度能不能优化。不过很可惜的是，在常规方法的 DP\r\n下，一般是不能优化的。\r\n那么来看空间优化。这里第 \r\n项都是由 \r\n转移来的，所以我们考虑能否在循环的过程中直接传递而非单独在数组中记录。\r\n注意上面的式子中，我们每次转移的时候第二维都是从更小的数值来的，所以我们只要倒序枚举\r\n\r\n就可以保证转移的正确性，而根据我们的式子，枚举到当前物品的大小之后就没有意义了，所以我们可以优化成：\r\n123for(int i(1);i&lt;=n;++i)    for(int j(m);j&gt;=w[i];--j)        f[j]=max(f[j],f[j-w[i]]-v[i]);\r\n而这个一维数组的实现方式是接下来其他背包的基础。\r\n完全背包\r\n有 \r\n种物品，每件物品都有无限件，每件价值为 ，费用为 ，背包容量为 ，求问能放入背包的物品最大总价值。\r\n分析\r\n不同于 01 背包的只有一点：每个物品有无数件。\r\n朴素的想法是做成无数个 01 背包，但是这样复杂度显然太高。\r\n有一个特殊的性质，考虑对于两件物品 ，若  且 ，则可以把  替换为 ，但是这个性质并不能优化复杂度，还得寻求其他的方法。\r\n考虑和 01 背包的相关性，首先 01\r\n背包第二层循环逆序是为了保证转移的时候 \r\n已经被求过了，而在这里完全背包的特点是可以选无限多件，所以在考虑加入第\r\n\r\n件的时候，可能会需要一个已经选入第  种结果的子结果 ，所以我们把 01\r\n背包中的第二层循环改为正向循环就能用相同的复杂度来解决完全背包。\r\n123for(int i(1);i&lt;=n;++i)    for(int j(w[i]);j&lt;=m;--j)        f[j]=max(f[j],f[j-w[i]]-v[i]);\r\n当然，还有一种思路，即把每个物品二进制拆分，因为不管选择几件第  种，都你能被 \r\n表示出来，不过这样的话单个物品复杂度为 ，不如我们上面的\r\n 做法。\r\n多重背包\r\n有  种物品，每件物品有  件，每件价值为 ，费用为 ，背包容量为 ，求问能放入背包的物品最大总价值。\r\n分析\r\n最简单的想法是在 01\r\n背包的代码外层加入一个枚举数量的循环，不过这样复杂度同样比较高，仍然可以使用，不过需要单调队列。\r\n常见的写法是二进制拆分，就像上面完全背包的第二种方法。即：将第 \r\n种物品分成若干件物品，其中每件物品有一个系数，这件物品的费用和价值均是原来的费用和价值乘以这个系数，这些系数为\r\n，然后按照 01\r\n背包做即可。\r\n那么每种物品就被拆成了 \r\n级别，总体复杂度为 \r\n123456789101112131415161718for(int i=1;i&lt;=n;i++) {        int t=1,x,y,z;        cin&gt;&gt;y&gt;&gt;x&gt;&gt;z;        while(z&gt;=t) {            v[++n1]=x*t;            c[n1]=y*t;            z-=t;            t*=2;        }        v[++n1]=x*z;            c[n1]=y*z;    }for(int i=1;i&lt;=n1;i++)    for(int j=m;j&gt;=v[i];j--)        f[j]=max(f[j],f[j-v[i]]+c[i]);\r\n混合背包\r\n简单而言就是以上三种背包都有，有些物品只有一件，有些有有限件数，有些则为无限件。\r\n直接分类讨论即可，因为多重背包在二进制拆分之后和 01\r\n背包是相同的，所以一起算就行。\r\n123456789101112131415161718192021222324252627282930313233343536373839for(int i=1;i&lt;=n;i++){    ll x,y,z;    scanf(\"%lld %lld %lld\",&amp;x,&amp;y,&amp;z);    if(z==0) {        v[++n1]=x;        c[n1]=y;        p[n1]=0;    }    else if(z==1) {        v[++n1]=x;        c[n1]=y;        p[n1]=1;    }    else {        int t(1);        while(z&gt;=t) {            v[++n1]=x*t;            c[n1]=y*t;            p[n1]=1;            z-=t;            t*=2;        }        v[++n1]=x*z;        c[n1]=y*z;        p[n1]=1;    }}for(int i=1;i&lt;=n1;i++)    if(p[i]==1)        for(int j=m;j&gt;=v[i];j--)            f[j]=max(f[j],f[j-v[i]]+c[i]);    else if(p[i]==0)        for(int j=v[i];j&lt;=m;j++)            f[j]=max(f[j],f[j-v[i]]+c[i]);\r\nbitset 优化\r\n之所以单独说一下这个优化，主要是前段时间脑子比较欠抽一直写错。\r\n众所周知 bitset 是一个长一点的  串，而它相关的操作往往常数会除掉一个\r\n，在背包里主要的用处是用来优化复杂度，把一个\r\nbitset 作为一个状态，第  位为  则说明  可以被表示出来（即可以达到  的价值），而一般插入一个新值只需要\r\nf|=(f&lt;&lt;x) 就能实现，假设正常转移是  的，使用了 bitset\r\n的复杂度就应该是 （当然这样写应该不是很严谨）\r\n润\r\n写完了，润！\r\n其实泛化、分组、依赖背包没写，但是懒得写了\r\n","slug":"RE-Bag","date":"2022-09-08T02:55:11.000Z","categories_index":"OI-Algorithm","tags_index":"OI","author_index":"Heriko Deltana"},{"id":"c072324f844f5d28eda9971051c4943c","title":"逐月记","content":"「OI 2022，又一年。」\r\n\r\n\r\n时间顺序先新后旧，大体记录 NOIP2022 之前的一些练习。\r\n还记得刚入 OI\r\n时，很喜欢的一句诗：「愿我如星君如月，夜夜流光相皎洁。」\r\n而这是逐月的最后一次机会了，于是叫做逐月记。\r\n\r\n车遥遥篇 - 范成大\r\n车遥遥，马憧憧。\r\n君游东山东复东，安得奋飞逐西风。\r\n愿我如星君如月，夜夜流光相皎洁。\r\n月暂晦，星常明。\r\n留明待月复，三五共盈盈。\r\n\r\n11.26\r\n退役记。\r\n这篇记录不再继续置顶。\r\n11.10\r\nNOIP20-20\r\n20\r\n20 联测的最后一天，rk 22，rating 回到了 1596.\r\nA\r\n可以发现如果想要让结果不为 \r\n那么他一定是一直优先选择素数，而十四个素数相乘就已经超过了 ，所以在  的时候答案一定为 \r\n然后小于  的部分直接暴力\r\nDFS，注意要把空集合及时剪枝，否则复杂度为卡死的 \r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354CI MXX(2e5 + 5);LL n, m, a[MXX], c[MXX];vector&lt;LL&gt; v;LL DFS(int x, vector&lt;LL&gt; co) {    if(co.empty())          Heriko Deltana;    if(x == m + 1) {        LL res(0);        while(!co.empty())            res += co.back(), co.pop_back();        Heriko res;    }    vector&lt;LL&gt; a, b;    a.clear(), b.clear();    while(!co.empty())        if(co.back() % c[x] == 0)            a.push_back(co.back()), co.pop_back();        else            b.push_back(co.back()), co.pop_back();    LL v1(DFS(x + 1, a)), v2(DFS(x + 1, b));    Heriko (x &amp; 1) ? Hmin(v1, v2) : Hmax(v1, v2);}S main() {    Files();    fr(n), fr(m);    if(m &gt;= 100) {        puts(\"0\");        Heriko Deltana;    }      for(int i(1); i &lt;= n; ++ i)        fr(a[i]), v.emplace_back(a[i]);    for(int i(1); i &lt;= m; ++ i)        fr(c[i]);    fw(DFS(1, v), 1);    Heriko Deltana;}\r\nB\r\n如果是纯的 Dinic 能过  或者\r\n，考虑复杂度瓶颈在于访问结点次数过多，考虑这个图可以化作几个环相连的形式，而流量只取决于一两个结点，所以可以先拓扑序处理之后跑环，复杂度\r\n\r\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859CI MXX(1e6 + 5);int n, p[MXX];LL a[MXX], b[MXX], c[MXX], t, ans, into[MXX];queue&lt;int&gt; q;I void Flow(int x) {    t = Hmin(a[x], b[x]), a[x] -= t, b[x] -= t, ans += t;    t = Hmin(a[x], c[x]), a[x] -= t, c[x] -= t, a[p[x]] += t;}S main() {    Files();    fr(n);    for(int i(1); i &lt;= n; ++ i)        fr(p[i]), into[p[i]] ++;    for(int i(1); i &lt;= n; ++ i)        fr(a[i]);    for(int i(1); i &lt;= n; ++ i)        fr(b[i]);    for(int i(1); i &lt;= n; ++ i)        fr(c[i]);    for(int i(1); i &lt;= n; ++ i)        if(!into[i])            q.emplace(i);    while(q.size()) {        int x(q.front());        q.pop();        Flow(x), -- into[p[x]];        if(!into[p[x]])            q.emplace(p[x]);    }    for(int i(1); i &lt;= n; ++ i)        if(into[i]) {            vector&lt;int&gt; v;            for(int j(i); into[j]; j = p[j])                v.emplace_back(j), into[j] = 0;            for(int j(1); j &lt;= 2; ++ j)                for(int x : v)                    Flow(x);        }    fw(ans, 1);    Heriko Deltana;}\r\n11.9\r\nNOIP20-19\r\n19\r\n魔幻的，三场比赛下 201 分。\r\nA\r\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879CL MOD(1e9 + 7), MXX(305);int n, a[MXX], m, f[MXX][MXX][MXX][2], cnt, all, pre[MXX];bool vis[MXX];inline void Solve(int id,int o,int op){    for(int j(1); j &lt;= m; ++ j) {        for(int k(0); k &lt;= cnt; ++ k) {            int val(1);            if(op) {                if(o == 1)                    val = cnt - k+1;                else                    val = all - cnt - (pre[id - 1] - k);            }            if(val &lt;= 0)                continue;            (f[id][j][k][o] += 1ll * f[id - 1][j][k - (op &amp;&amp; o)][o] * val % MOD) %= MOD;            (f[id][j][k][o] += 1ll * f[id - 1][j - 1][k - (op &amp;&amp; o)][o ^ 1] * val % MOD) %= MOD;        }    }}S main(){    Files();    fr(n), fr(m);    for(int i(1); i &lt;= n; ++ i)        fr(a[i]), vis[a[i]] = 1;    if(m &gt; n) {        puts(\"0\");        Heriko Deltana;    }    for(int i(1); i &lt;= n; ++ i) {        pre[i] = pre[i - 1];        if(!a[i])            pre[i] ++;    }    for(int i(1); i &lt;= n; ++ i)        if(!vis[i]) {            if(i &amp; 1)                ++ cnt;                        ++ all;        }    if(!a[1]) {        if(cnt)            f[1][1][1][1] = cnt;        if(all - cnt)            f[1][1][0][0] = all - cnt;    }    else if(a[1] &amp; 1)        f[1][1][0][1] = 1;    else        f[1][1][0][0] = 1;    for(int i(2); i &lt;= n; ++ i) {        if(!a[i])            Solve(i, 0, 1), Solve(i, 1, 1);        else if(a[i] &amp; 1)            Solve(i, 1, 0);        else            Solve(i, 0, 0);    }    fw((f[n][m][cnt][0] + f[n][m][cnt][1]) % MOD, 1);    Heriko Deltana;}\r\nB\r\n场上想出来一个科幻贪心过了 （？\r\n但是发现那个贪心在处理最后一个符合条件的 \r\n的时候有几率出错，改了好长时间不知道怎么搞。\r\n还是正经 DP 吧，设 \r\n表示前  位钦定了  个 ，剩余不为零的值的和为 .\r\n一个类似于背包的转移，然后滚掉一维就好了）\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445CL MXX(205), INF(1e9);int f[2][MXX][MXX * MXX], n, m, a[MXX], b[MXX];S main() {    Files();    fr(n);    for(int i(1); i &lt;= n; ++ i)        fr(a[i]), m += a[i];    for(int i(1); i &lt;= n; ++ i)        fr(b[i]);    for(int i(0); i &lt;= n; ++ i)        for(int j(0); j &lt;= m; ++ j)            f[0][i][j] = INF;        f[0][0][0] = 0;    int nw(1);    for(int i(1); i &lt;= n; ++ i) {        for(int j(0); j &lt;= n; ++ j)            for(int k(0); k &lt;= m; ++ k)                f[nw][j][k] = INF;        for(int j(0); j &lt;= n; ++ j)            for(int k(0); k &lt;= m; ++ k)                if(f[nw ^ 1][j][k] &lt;= n * 200) {                    int km(Hmin(k + b[i], m));                    f[nw][j][km] = Hmin(f[nw][j][km], f[nw ^ 1][j][k] + Hmax(a[i] - b[i], 0));                    f[nw][j + 1][k] = Hmin(f[nw][j + 1][k], f[nw ^ 1][j][k] + a[i]);                }        nw ^= 1;    }    nw ^= 1;    for(int i(0); i &lt; n; ++ i)        fw(f[nw][i][m] &gt;= INF ? -1 : f[nw][i][m] * 2, 0);    Heriko Deltana;}\r\n11.8\r\nNOIP20-18\r\n18\r\n魔幻的。\r\nA\r\n考场怒写 7K 代码，科幻，然后写挂了，最后挣扎了一下最多拿 40\r\n分，于是直接重写。\r\n其实可以发现对于 \r\n这个区间内的都只能是三个数，其余的都能两个数解决。\r\n于是先特判，然后分别构造……具体思路就是考虑上一位的进位的影响。\r\n这个题真的好多小细节。\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110CI MXX(105);char s[MXX];int a[MXX], len;I bool Check() {    if(a[1] == 1) {        for(int i(2); i &lt;= len; ++ i)            if(a[i] != 9)                Heriko Deltana;        Yoisaki Kanade;    }    else if(a[1] == 2) {        for(int i(2); i &lt;= len; ++ i)            if(a[i] &gt; 2)                Heriko Deltana;            else if(a[i] &lt; 2)                Yoisaki Kanade;    }        Heriko Deltana;}I void Solve2() {    vector&lt;int&gt; ans[2];    int nw(1);    while(s[nw]=='2')        ans[0].emplace_back(2), ++ nw;    int lst(0);    if(s[nw] == '1')        ++ nw, lst = 1;    else        ans[0].emplace_back(a[nw] - 1), ++ nw, lst = 1;    for(int i(nw); i &lt;= len; ++ i) {        int val(a[i] + lst * 10);        lst = 0;        if(val == 19 || (i != len &amp;&amp; s[i + 1] &lt;= '7'))            lst = 1, -- val;        ans[0].emplace_back(val / 2);        ans[1].emplace_back(val - (val / 2));    }    fw(2, 1);    for(int i : ans[0])        fw(i, 0);    putchar(' ');    for(int i : ans[1])        fw(i, 0);    puts(\"\");}void Solve3(){    vector&lt;int&gt; ans[3];    int p(a[2] + a[1] * 10 - (len != 2));    ans[0].emplace_back(p / 3), ans[1].emplace_back(p / 3), ans[2].emplace_back(p - (p / 3) * 2);        for(int i(3); i &lt;= len; ++ i) {        int val(10 + a[i] - (len != i));        ans[0].emplace_back(val / 3), ans[1].emplace_back(val / 3), ans[2].emplace_back(val - (val / 3) * 2);    }    fw(3, 1);    for(int i : ans[0])        fw(i, 0);    putchar(' ');    for(int i : ans[1])        fw(i, 0);    putchar(' ');    for(int i : ans[2])        fw(i, 0);    puts(\"\");}S main() {    Files();    int T;    fr(T);    while(T --) {        scanf(\"%s\", s + 1), len = strlen(s + 1);        for(int i(1); i &lt;= len; ++ i)            a[i] = s[i] - '0';        if(Check())            Solve3();        else            Solve2();    }    Heriko Deltana;}\r\nB\r\n考虑对一个数的二进制表示，对于所有和它 \r\n的值等于其本身的数，可以看作它的子集。\r\n那么对于 \r\n来说，只会向它的子集连边，于是不妨把子集之间连长度为 \r\n的有向边，结点向自己对应集合连一条长度为  的无向边，BFS 跑一次即可。\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960CI MXX(2e5 + 5), SXX((1 &lt;&lt; 20) + 5), INF(1e9);int n, m, a[MXX], dis[MXX + SXX];vector&lt;int&gt; r[MXX], id[SXX];deque&lt;int&gt; q;S main() {    Files();    fr(n), fr(m);    for(int i(1); i &lt;= n; ++ i)        fr(a[i]), id[a[i]].emplace_back(i);    for(int i(1); i &lt;= m; ++ i) {        int x, y;        fr(x), fr(y);        r[x].emplace_back(y);    }    for(int i(1); i &lt;= n + (1 &lt;&lt; 20); ++ i)        dis[i] = INF;    q.emplace_back(1), dis[1] = 0;    while(q.size()) {        int x(q.front());        q.pop_front();        if(x &lt;= n) {            for(int y : r[x])                if(dis[y] &gt; dis[x] + 1)                    dis[y] = dis[x] + 1, q.emplace_back(y);            if(dis[a[x] + n + 1] &gt; dis[x] + 1)                dis[a[x] + n + 1] = dis[x] + 1, q.emplace_back(a[x] + n + 1);        }        else {            int val(x - n - 1);            for(int y : id[val])                if(dis[y] &gt; dis[x])                    dis[y] = dis[x], q.emplace_front(y);            for(int i(0); i &lt; 20; ++ i) {                int y((val ^ (1 &lt;&lt; i)) + n + 1);                if((val &gt;&gt; i &amp; 1) and dis[y] &gt; dis[x])                    dis[y] = dis[x], q.emplace_front(y);            }        }    }    for(int i(1); i &lt;= n; ++ i)        fw(dis[i] &gt;= INF ? -1 : dis[i], 1);    Heriko Deltana;}\r\n11.7\r\nNOIP20-17\r\n17\r\nA\r\n可以发现答案一定是一个 \r\n的前一小部分和剩下的都为 \r\n的数组成的。\r\n1234567891011121314151617181920212223242526272829303132CL MXX(20), LMT(1e18);LL lx, rx, ans;I LL F(LL x) {    LL res(1);    while(x) {        res *= (x % 10);        x /= 10;    }    Heriko res;}S main() {    Files();    fr(lx), fr(rx), ans = rx;    for(int LL i(LMT); i; i /= 10)        if(lx / i != rx / i) {            if(F(rx / i * i - 1) &gt; F(ans))                ans = rx / i * i - 1;            lx = rx / i * i;        }    fw(ans, 1);    Heriko Deltana;}\r\nB\r\n考虑到每次攻击总会死一个（通过不等式可以分析得出），所以可以直接暴力枚举，一共是\r\n 个状态。\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;#define N 15#define LL long long#define LD double#define INF 999999999using namespace std;int n,m;int vp1[N],vp2[N],sum1[N],sum2[N],f1[N],f2[N];LD ans1,ans2,ans3;void dfs(int Sum1,int Sum2,int op,LD p){    if((!Sum1)&amp;&amp;(!Sum2)) {ans3+=p;return ;}    if((!Sum1)||(!Sum2)) {!Sum1?ans2+=p:ans1+=p;return ;}    int tot=INF,t,ss=0;    if(op==1){        for(int i=1;i&lt;=n;i++) if(sum1[i]&lt;tot&amp;&amp;vp1[i]&gt;0) t=i,tot=sum1[i];        for(int i=1;i&lt;=m;i++) if(vp2[i]&gt;0) ss++;        for(int i=1;i&lt;=m;i++) {            if(vp2[i]&lt;=0) continue;            vp2[i]-=f1[t],vp1[t]-=f2[i],sum1[t]++;            dfs(Sum1-(vp1[t]&lt;=0),Sum2-(vp2[i]&lt;=0),2,p/ss);            vp2[i]+=f1[t],vp1[t]+=f2[i],sum1[t]--;        }    }     else if(op==2){        for(int i=1;i&lt;=m;i++) if(sum2[i]&lt;tot&amp;&amp;vp2[i]&gt;0) t=i,tot=sum2[i];        for(int i=1;i&lt;=n;i++) if(vp1[i]&gt;0) ss++;        for(int i=1;i&lt;=n;i++) {            if(vp1[i]&lt;=0) continue;            vp1[i]-=f2[t],vp2[t]-=f1[i],sum2[t]++;            dfs(Sum1-(vp1[i]&lt;=0),Sum2-(vp2[t]&lt;=0),1,p/ss);            vp1[i]+=f2[t],vp2[t]+=f1[i],sum2[t]--;        }    }}int main(){    scanf(\"%d%d\", &amp;n, &amp;m);    for(int i=1;i&lt;=n;i++) scanf(\"%d\", &amp;vp1[i]), f1[i]=vp1[i];    for(int i=1;i&lt;=m;i++) scanf(\"%d\", &amp;vp2[i]), f2[i]=vp2[i];    if(n&gt;m) dfs(n,m,1,1.0);    else if(n&lt;m) dfs(n,m,2,1.0);    else if(n==m){dfs(n,m,1,0.5);dfs(n,m,2,0.5);}    printf(\"%.10f\\n%.10f\\n%.10f\",ans1,ans2,ans3);    return 0;}\r\n11.3\r\nNOIP20-16\r\n16\r\nA\r\n首先，对于首尾的两端连续的  或\r\n，他们里面的任何数都不能被选择，下面不再讨论他们。\r\n考虑每一段连续的  或者 \r\n都只能选择一个数，所以我们把这一段连续的变为他们中的最大值，于是我们可以获得一个\r\n\r\n交叉出现的序列，在这个序列里面操作，显然每次取出一个数都要删除另一个相邻的数。\r\n于是对于这个序列中的数，我们无论如何都可以得到他，所以直接输出前\r\n\r\n大的数的和。\r\n1234567891011121314151617181920212223242526272829303132333435363738394041424344CI MXX(300000 + 10);LL n, a[MXX], w[MXX], ln, ans;char s[MXX];I bool CMP(LL x, LL y) {    Heriko x &gt; y;}S main() {    Files();    fr(n), scanf(\"%s\", s + 1), s[n + 1] = '?';    for(int i(1); i &lt;= n; ++ i)        fr(w[i]);    LL mx(w[1]), flg(0);    for(int i(2); i &lt;= n + 1; ++ i) {        if(s[i] == s[i - 1])            mx = Hmax(mx, w[i]);        else {            if(!flg)                flg = 1;            else                a[++ ln] = mx;            mx = w[i];        }    }    -- ln;    sort(a + 1, a + ln + 1, CMP);    for(int i(1); i &lt;= (ln + 1) / 2; ++ i)        ans += a[i];    fw(ans, 1);    Heriko Deltana;}\r\nB\r\n考虑一个二元组 ，如果在\r\n 中  出现的最前和最后位置构成的区间和  的有交叉，那么这个二元组一定不会出现在\r\n 中。\r\n记不会交叉的二元组为 \r\n考虑  为以  为结尾的最长合法  的长度，那么 ，可以使用树状数组优化。\r\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647CI MXX(5e5 + 5);#define lowbit(x) ((x) &amp; (-x))int t[MXX], l[MXX], r[MXX], s[MXX], a[MXX], n, m, ans;I void Modify(int x, int v) {    while(x)        t[x] = Hmax(t[x], v), x -= lowbit(x);}I int Query(int x) {    int res(0);    while(x &lt;= m)        res = Hmax(t[x], res), x += lowbit(x);    Heriko res;}S main() {    Files();    fr(n), fr(m);    for(int i(1); i &lt;= n; ++ i)        fr(s[i]);    for(int i(1); i &lt;= m; ++ i)        fr(a[i]);    for(int i(1); i &lt;= m; ++ i)        r[a[i]] = i;    for(int i(m); i; -- i)        l[a[i]] = i;    for(int i(1); i &lt;= n; ++ i)        if(l[s[i]])             Modify(l[s[i]], Query(r[s[i]]) + 1);        else            ++ ans;    fw(ans + Query(1), 1);    Heriko Deltana;}\r\nC\r\n考虑每座工厂是用谁生产的原材料做的，那么会形成一棵有根树。\r\n如果这棵有根树确定了，我们可以树形 DP，记  为以  为根的答案，那么 ，其中\r\n 为  的儿子，且  单调减，于是可以状压。\r\n12345678910111213141516171819202122232425262728293031323334353637383940CI MXX(20), NXX((1 &lt;&lt; 16) + 1);int n, a[MXX], b[MXX], f[NXX], g[MXX][NXX], h[MXX][NXX];S main() {    Files();    fr(n);    for(int i(1); i &lt;= n; ++ i)        fr(a[i]), fr(b[i]);    mst(h, 0x3f), mst(f, 0x3f), mst(g, 0x3f);    f[0] = g[0][0] = 0;    for(int i(1); i &lt;= n; ++ i)        h[i][0] = 0;    for(int s(1); s &lt; (1 &lt;&lt; n); ++ s) {        for(int i(1); i &lt;= n; ++ i)            if(s &amp; (1 &lt;&lt; (i - 1)))                f[s] = Hmin(f[s], h[i][s ^ (1 &lt;&lt; (i - 1))]);            for(int i(1); i &lt;= n; ++ i) {            g[i][s] = g[i - 1][s];            for(int j(s); j; j = (j - 1) &amp; s)                g[i][s] = Hmin(g[i][s], Hmax(g[i - 1][s ^ j], f[j]));        }        for(int i(1); i &lt;= n; ++ i)            if((s &amp; (1 &lt;&lt; (i - 1))) == 0)                for(int j(s); j; j = (j - 1) &amp; s)                    h[i][s] = Hmin(h[i][s], Hmax(g[b[i]][j], h[i][s ^ j]) + a[i]);    }    fw(f[(1 &lt;&lt; n) - 1], 1);    Heriko Deltana;}\r\n11.2\r\nNOIP20-15\r\n15\r\nA\r\n考虑对于人最多的那一组，可以把其他组和它穿插，发现剩余不足以穿插的时候开新的队列。\r\n那么我们用堆维护一下。\r\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465CI MXX(1e5 + 5);#define P pair&lt;int, int&gt;int a[MXX], n, res(1);priority_queue&lt;P&gt; q;vector&lt;int&gt; ans[MXX], co[MXX];S main() {    Files();    fr(n);    for(int i(1); i &lt;= n; ++ i)        fr(a[i]), co[a[i]].emplace_back(i);    for(int i(1); i &lt;= n; ++ i)        if(co[i].size())            q.emplace(mkp(co[i].size(), i));    while(q.size() &gt;= 2) {        P t1(q.top());        q.pop();        P t2(q.top());        q.pop();        if(ans[1].size() and ans[1][(int)ans[1].size() - 1] == t1.second)            swap(t1, t2);        ans[1].emplace_back(co[t1.second].back()), ans[1].emplace_back(co[t2.second].back());        co[t1.second].pop_back(), co[t2.second].pop_back();        -- t1.first, -- t2.first;        if(t1.first)            q.emplace(t1);        if(t2.first)            q.emplace(t2);    }    if(q.size()) {        P x(q.top());        q.pop();        ans[1].emplace_back(co[x.second].back());        co[x.second].pop_back();        for(int i(2); i &lt;= x.first; ++ i)            ans[++ res].emplace_back(co[x.second].back()), co[x.second].pop_back();    }    fw(res, 1);    for(int i(1); i &lt;= res; ++ i) {        fw(ans[i].size(), 0);        for(int j : ans[i])            fw(j, 0);        puts(\"\");    }    Heriko Deltana;}\r\nB\r\n设  表示赢了  次，输了  次，显然的是这个 DP\r\n有环，转移方程为：\r\n\r\n考虑二分胜率。\r\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647CI MXX(1005), INF(1e9);LD f[MXX][MXX], g[MXX][MXX], p, EPS(1e-8);int n, m, P, b[MXX][MXX];I bool Check(LD x) {    for(int i(0); i &lt; n; ++ i)        f[i][m] = x;    for(int i(n - 1); i &gt;= 0; -- i)        for(int j(m - 1); j &gt;= 0; -- j) {            f[i][j] = f[i + 1][j] * p + f[i][j + 1] * (1.0 - p) + 1;            if(f[i][j] &gt; x) {                if(!i and !j)                    Heriko Deltana;                f[i][j] = x;            }        }    Yoisaki Kanade;}S main() {    Files();    fr(n), fr(m), fr(P), p = (DB)P / 100.0;    LD l(0), r(INF - 1);    while(l + EPS &lt; r) {        LD mid((l + r) / 2.0);        if(Check(mid))            r = mid;        else            l = mid;    }    if(l &gt;= INF)        fw(INF, 1);    else        printf(\"%0.8Lf\", l);    Heriko Deltana;}\r\n11.1\r\nNOIP20-14\r\n14\r\nA 数组开小 ，寄。\r\nA\r\n考虑将棋盘旋转四十五度之后，每个象的限制就变成了行和列，然后考虑到奇偶行之间没有影响，所以拆开进行\r\nDP，而显然这些行的位置关系对于我们最终求出的答案没有影响，所以每次将两个相同长度的行转移。\r\n设  表示前  个奇数行选了  个的方案数， 则为前  个偶数行选了 \r\n个的方案数，那么最后答案就是两者合并。\r\n转移显然是将当前行选和不选的情况加起来，即 \r\n但是由于偶数在 \r\n奇偶不同的时候行数不同所以需要考虑这个小细节。\r\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253CL MXX(5005), MOD(998244353);int n, tot;LL f[MXX][MXX], g[MXX][MXX], ans;S main() {    Files();    fr(n);    for(int i(0); i &lt;= n; ++ i)        f[i][0] = g[i][0] = 1;    tot = 0;    for(int i(1); i &lt;= n; i += 2) {        ++ tot;        for(int j(1); j &lt;= tot; ++ j)            f[i][j] = (f[i - 1][j] + f[i - 1][j - 1] * (i - j + 1) % MOD) % MOD;        ++ tot;        for(int j(1); j &lt;= tot; ++ j)            f[i + 1][j] = (f[i][j] + f[i][j - 1] * (i - j + 1) % MOD) % MOD;    }    tot = 0;    for(int i(2); i &lt;= n; i += 2) {        ++ tot;        for(int j(1); j &lt;= tot; ++ j)            g[i - 1][j] = (g[i - 2][j] + g[i - 2][j - 1] * (i - j + 1) % MOD) % MOD;        ++ tot;        for(int j(1); j &lt;= tot; ++ j)            g[i][j] = (g[i - 1][j] + g[i - 1][j - 1] * (i - j + 1) % MOD) % MOD;    }    for(int i(1); i &lt;= n + n - 1; ++ i) {        ans = 0;        for(int j(0); j &lt;= i; ++ j)            ans = (ans + f[n][j] * g[n - 1][i - j] % MOD) % MOD;        fw((ans % MOD + MOD) % MOD, 0);    }    Heriko Deltana;}\r\nB\r\n考虑将区间按照左端点排序，然后显然对于所有左端点相同的区间我们可以贪心的选\r\n 个。\r\n但是可能会出现之前这个区间两个端点都被选择过的情况，所以建图来跑。\r\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970CI MXX(2e5 + 5);int n, m, ans[MXX], vis[MXX], flg, cnt;vector&lt;int&gt; v[MXX], r[MXX];I void DFS(int x, int v) {    ans[x] = v;    vis[x] = 1;    for(int y : r[x])        if(!vis[y])            DFS(y, v);}S main() {    Files();    fr(n), fr(m), cnt = n;    for(int i(1); i &lt;= m * 2; ++ i) {        int l, r;        fr(l), fr(r);        if(l != r)            flg ++;        else            continue;        v[l].emplace_back(r);    }    if(flg &lt; m) {        puts(\"-1\");        Heriko Deltana;    }    for(int i(1); i &lt;= n; ++ i)        sort(v[i].begin(), v[i].end(), [&amp;](int x, int y) {Heriko x &gt; y;});    flg = 1;    for(int i(1); i &lt;= n; ++ i) {        for(int j(0); j &lt; (int)v[i].size(); ++ j) {            -- m;            if(!m or j == (int)v[i].size() - 1) {                if(!m)                    flg = 0;                r[i].emplace_back(v[i][j]), r[v[i][j]].emplace_back(i);                break;            }        }        if(!flg)            break;    }    for(int i(1); i &lt;= n; ++ i)        if(!vis[i])            DFS(i, i);    for(int i(1); i &lt;= n; ++ i)        fw(ans[i] ? ans[i] : ++ cnt, 0);    Heriko Deltana;}\r\n10.31\r\nNOIP20-13\r\n13\r\nA 过了，但是没有做出人均成绩，rating -= 3.\r\nA\r\n就是扩展 KMP（Z 函数），但是我用的哈希。\r\n先对于每个后缀二分求出其 LCP，然后显然每个 LCP\r\n对于长度小于等于他的原串的前缀的出现次数都有为  的贡献，差分一下最后前缀和输出 LCP\r\n对应的前缀的出现次数即可。\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051CL MXX(2e6 + 5), B(233), MOD(998244353);int n, lcp[MXX], co[MXX];ULL hass[MXX], b[MXX];char s[MXX];I ULL GetSub(int l, int r) {    Heriko hass[r] - hass[l - 1] * b[r - l + 1];}S main() {    Files();    scanf(\"%s\", s + 1);    n = strlen(s + 1);    b[0] = 1;    for(int i(1); i &lt;= n; ++ i)        b[i] = b[i - 1] * B;    for(int i(1); i &lt;= n; ++ i)        hass[i] = (hass[i - 1] * B + (ULL)s[i]) + MOD;    for(int i(1); i &lt;= n; ++ i) {        int l(1), r(n - i + 1);        while(l &lt;= r) {            int mid((l + r) &gt;&gt; 1);            if(GetSub(1, mid) == GetSub(i, i + mid - 1))                l = mid + 1, lcp[i] = mid;            else                r = mid - 1;        }    }    for(int i(1); i &lt;= n; ++ i)        co[1] ++, co[lcp[i] + 1] --;    for(int i(1); i &lt;= n; ++ i)        co[i] += co[i - 1];    for(int i(1); i &lt;= n; ++ i)        fw(co[lcp[i]], 0);    puts(\"\");    Heriko Deltana;}\r\nC\r\n考虑科幻转移，根据奇偶性来每次决定是否累加选择，其实就是对 DP\r\n的一个简化。\r\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758CL MXX(1e4 + 5), MOD(1e9 + 7);LL fac[MXX], infac[MXX];I LL FstPow(LL x, LL y = MOD - 2ll) {    x %= MOD;    LL res(1);    while(y) {        if(y &amp; 1)            (res *= x) %= MOD;        (x *= x) %= MOD;        y &gt;&gt;= 1;    }    Heriko res;}I LL C(LL n, LL m) {    if(m &lt; 0 or n &lt; m)        Heriko Deltana;    Heriko fac[n] * infac[m] % MOD * infac[n - m] % MOD;}int n;S main() {    Files();    fr(n), fac[0] = 1;    for(LL i(1); i &lt;= n * n; ++ i)        fac[i] = fac[i - 1] * i % MOD;    infac[n * n] = FstPow(fac[n * n]);    for(LL i(n * n); i; -- i)        infac[i - 1] = infac[i] * i % MOD;    for(int i(0); i &lt;= n * (n - 1) / 2; ++ i) {        LL res(0);        for(int j(0); j &lt; n; ++ j) {            LL tmp(C((n - j) * (n - j + 1) / 2 - 1 - i, n - 1) * (C(2 * n, j) - C(2 * n, j - 1) + MOD) % MOD);            if(j &amp; 1)                res -= tmp;            else                res += tmp;        }        fw((res % MOD + MOD) % MOD, 0);    }    Heriko Deltana;}\r\n10.30\r\nNOIP10-7\r\n7\r\nA\r\n考虑找到中心之后把两端的字符依次匹配，那么移动的代价显然是一段前缀和，可以用树状数组维护。\r\n其实最一开始想的是从中间向外匹配，但是那样真的难写……\r\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556CI MXX(1e6 + 5);#define lowbit(x) ((x) &amp; (-x))int t[MXX], n, vis[MXX];LL ans;char s[MXX];vector&lt;int&gt; v[130];I void Modify(int x, int v) {    while(x &lt;= n)        t[x] += v, x += lowbit(x);}I int Query(int x) {    int res(0);    while(x)        res += t[x], x -= lowbit(x);    Heriko res;}S main() {    Files();    scanf(\"%s\", s + 1);    n = strlen(s + 1);    for(int i(1); i &lt;= n; ++ i)        v[s[i]].emplace_back(i);    for(int i(1); i &lt;= n + 1; ++ i)        Modify(i, 1);    for(int i(1); i &lt;= n; ++ i)        if(!vis[i]) {            int x(v[s[i]][v[s[i]].size() - 1]);            if(i == x)                ans += (Query(n) - Query(x)) / 2;            else                ans += Query(n) - Query(x);            Modify(i, -1), Modify(x, -1);            vis[i] = vis[x] = 1;            v[s[i]].erase(v[s[i]].end() - 1);        }    fw(ans, 1);    Heriko Deltana;}\r\nB\r\n观察发现可以用  和 \r\n来将排列分开成为两个段（如果是三个段的话，因为头尾循环，所以还是两个段）。\r\n考虑  表示前  个数的方案数，因为头尾循环所以答案为\r\n.\r\n显然的转移是枚举一个  且\r\n 和  不在同段中，但是这样是  的不能通过此题。\r\n发现根据题目，如果 \r\n是可以合法加入段的，那么  中至少有一个是 \r\n的倍数，所以直接枚举 \r\n的倍数转移即可，复杂度 .\r\n（前 \r\n那个是考场打的表，并不是特殊情况到 ，其实特殊情况只有  和 。）\r\n123456789101112131415161718192021222324252627282930313233CL MXX(1e6 + 5), MOD(998244353);LL n, f[MXX], ans, a[30] = {0, 1, 2, 6, 16, 40, 96, 196, 384, 684, 1200, 1936, 3120, 4732, 7112, 10260, 14784, 20536, 28512, 38380, 51680};S main() {    Files();    fr(n);    if(n &lt;= 20) {        fw(a[n], 1);        Heriko Deltana;    }    f[0] = 2;    for(int i(n - 1); i &gt;= 3; -- i) {        int sum(0);        for(int j(0); j &lt;= n; j += i)            sum = (sum + f[j] + f[j + 1] + f[j + 2]) % MOD;                f[i + 1] = (f[i + 1] + sum) % MOD;    }    for(int i(0); i &lt;= n; ++ i)        ans = (ans + f[i]) % MOD;    fw(ans * n % MOD, 1);    Heriko Deltana;}\r\n10.27\r\n关于山东\r\nCSP-S2，它没了，在经历了多天的举办地址的不确定和疫情的反复之后，取消了。\r\nNOIP20-12\r\n12\r\n上午这一搞没心情打了。\r\nB\r\n注意到我们要求对于所有点为出发点的答案。而  将会随着 Alice\r\n胜利的点集变小而越来越大。 所以我们从大到小枚举 ，同时增量式地维护胜利的点集合，这样就可以直接算出所有答案，使用\r\nBFS，复杂度 \r\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950CI MXX(2e5 + 5);vector&lt;int&gt; r[MXX];int n, m, f[MXX], into[MXX], vis[MXX];queue&lt;int&gt; q;S main() {    Files();    fr(n), fr(m);    for(int i(1); i &lt;= m; ++ i) {        int x, y;        fr(x), fr(y);        r[y].emplace_back(x + n), r[y + n].emplace_back(x);        ++ into[x + n];    }    for(int i(n); i; -- i) {        if(!vis[i])            f[i] = i, q.emplace(i), vis[i] = 1;        if(!vis[i + n])            q.emplace(i + n), vis[i + n] = 1;        while(q.size()) {            int x(q.front());            q.pop();            for(int y : r[x])                if(!vis[y]) {                    if(y &gt; n) {                        -- into[y];                        if(!into[y])                            q.emplace(y), vis[y] = 1;                    }                    else                        vis[y] = 1, f[y] = i, q.emplace(y);                }        }     }    for(int i(1); i &lt;= n; ++ i)        fw(f[i], 0);    Heriko Deltana;}\r\nC\r\n非常妙的一道题，考虑不断缩小答案所在的值域，因为我们只需要知道这些数据原来的相对顺序。\r\n考虑到这个伪随机的数据生成器只要重置了种子就会输出一样的数，于是可以直接将值域缩小到\r\n\r\n12345678910111213141516171819202122232425262728293031323334353637383940414243CI MXX(65536);// 65536 = 1 &lt;&lt; 16int n, k, co[MXX], ln;ULL seed, a[MXX], st, preseed;ULL GET() {    seed ^= seed &lt;&lt; 13;    seed ^= seed &gt;&gt; 7;    seed ^= seed &lt;&lt; 17;    Heriko seed;}S main() {    Files();    fr(n), fr(k), fr(seed), preseed = seed;    for(int i(1); i &lt;= n; ++ i)        co[GET() &gt;&gt; 48] ++;    for(int i(0); i &lt; MXX; ++ i) {        if(co[i] &lt; k)            k -= co[i];        else {            st = i;            break;        }    }    seed = preseed;    for(int i(1); i &lt;= n; ++ i)        if((GET() &gt;&gt; 48) == st)            a[++ ln] = seed;    sort(a + 1, a + 1 + ln);    fw(a[k], 1);    Heriko Deltana;}\r\n10.26\r\nNOIP20-11\r\n11\r\n我的评价是抽象，B 这种分论签到题挂了，\r\nA\r\n其实是一个 CDQ\r\n优化三维偏序最长链的板子（但是我完全没见过），赛事没调出来就扔了个暴力。\r\n有意思的是我把一个 unsigned long long\r\n类型的变量初值设置为 ，然后想了一下午为什么取  的时候他比  大。\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293CL MXX(1e5 + 5), INF(1e16);ULL k1, k2, by[MXX], bz[MXX];int n, lny, lnz, ans[MXX];ULL CoronavirusBeats() {    ULL k3 = k1, k4 = k2;    k1 = k4;    k3 ^= k3 &lt;&lt; 23;    k2 = k3 ^ k4 ^ (k3 &gt;&gt; 17) ^ (k4 &gt;&gt; 26);    return k2 + k4;}struct Cell {    ULL x, y, z, id;    I bool operator &lt; (const Cell &amp;co) const {        Heriko x &lt; co.x;    }}a[MXX];ULL t[MXX];#define lowbit(x) ((x) &amp; (-x))I void Modify(int x, ULL y) {    while(x &lt;= lny)        t[x] = Hmin(t[x], y), x += lowbit(x);}I ULL Query(int x) {    ULL res(INF);    while(x)        res = Hmin(res, t[x]), x -= lowbit(x);    Heriko res;}set&lt;ULL&gt; s;vector&lt;ULL&gt; v;S main() {    Files();    fr(n), fr(k1), fr(k2);    for (int i(1); i &lt;= n; ++ i) {        a[i].x = CoronavirusBeats(), a[i].y = CoronavirusBeats(), a[i].z = CoronavirusBeats(), a[i].id = i;        by[i] = a[i].y, bz[i] = a[i].z;        s.insert(i);        ans[i] = -1;    }    sort(by + 1, by + 1 + n);    sort(bz + 1, bz + 1 + n);    lny = unique(by + 1, by + 1 + n) - by - 1, lnz = unique(bz + 1, bz + 1 + n) - bz - 1;    for(int i(1); i &lt;= n; ++ i)        a[i].y = lower_bound(by + 1, by + 1 + lny, a[i].y) - by, a[i].z = lower_bound(bz + 1, bz + 1 + lnz, a[i].z) - bz;    sort(a + 1, a + 1 + n);    ULL cnt(0);    while(s.size()) {        fill(t + 1, t + 1 + n, INF), v.clear();        for(int i : s)            if(!(Query(a[i].y) &lt; a[i].z or Query(a[i].y - 1) &lt;= a[i].z))                ans[a[i].id] = cnt, v.emplace_back(i), Modify(a[i].y, a[i].z);        for(int i : v)            s.erase(i);        ++ cnt;     }    int len(0);    for(int i(1); i &lt;= n; ++ i)        len = Hmax(len, ans[i]);    fw(len + 1, 1);    for(int i(1); i &lt;= n; ++ i)        fw(ans[i], 0);    Heriko Deltana;}\r\nB\r\n首先，两个奇素数一定是不能满足的，然后就是可以发现对于  时，只有 \r\n这一种答案，于是可以发现对于每个三元组，一定是  的排列，否则不成立，于是  的时候没有解。\r\n对于  的时候不再讨论。\r\n对于 \r\n的时候，若两个空或者一个空一个二，那么填入  即可，否则如果一个 ，另外一个数和它加上二（孪生质数）都为质数，那么它合法，否则不合法。\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172CI MXX(1e5 + 5);int n, a[MXX];I bool P(int x) {    if(x == 1)        Heriko Deltana;    for(int i(2); i * i &lt;= x; ++ i)        if(x % i == 0)            Heriko Deltana;    Yoisaki Kanade;}S main() {    Files();        fr(n);    for(int i(1); i &lt;= n; ++ i)        fr(a[i]);    if(n &gt;= 4) {        puts(\"Impossible\");        Heriko Deltana;    }    if(n == 1) {        if(!a[1])            fw(3, 1);        else if(P(a[1]))            fw(a[1], 1);        else            puts(\"Impossible\");    }    else if(n == 2) {        if(!a[1] and !a[2])            fw(2, 0), fw(3, 1);        else if(a[1] and !a[2]) {            if(a[1] == 2)                fw(2, 0), fw(3, 1);            else if(P(a[1]) and P(a[1] + 2))                fw(a[1], 0), fw(2, 1);            else                puts(\"Impossible\");        }         else if(a[2] and !a[1]) {            if(a[2] == 2)                fw(3, 0), fw(2, 1);            else if(P(a[2]) and P(a[2] + 2))                fw(2, 0), fw(a[2], 1);            else                puts(\"Impossible\");        }        else if(a[1] == 2 and P(a[2]) and P(a[2] + 2))            fw(a[1], 0), fw(a[2], 1);        else if(a[2] == 2 and P(a[1]) and P(a[1] + 2))            fw(a[1], 0), fw(a[2], 1);        else            puts(\"Impossible\");    }    else if(n == 3) {        if((a[1] == 2 or !a[1]) and (a[2] == 3 or !a[2]) and (a[3] == 2 or !a[3]))            fw(2, 0), fw(3, 0), fw(2, 1);        else            puts(\"Impossible\");    }    Heriko Deltana;}\r\nC\r\n首先考虑 \r\n什么时候会成为最小生成树：显然对于每条非树边，它的权值必须大于它对应的树上路径上的每一条边（连上边以后构成的环上的树边）。\r\n这样的限制可以变成：如果边 \r\n的权值需要小于边  的权值，那么就从\r\n 向  连一条边。\r\n于是问题可以变成所有树边代表点的在拓扑序中的排名和。\r\n同时可以发现，我们得到的这个图类似于二分图，即所有的边都是从树边连向非树边的。\r\n所以如果我们每次删除一个树上的点作为当前图中拓扑序里最靠前的点，那么非树上的有一部分点的入度会变成\r\n，他们之后的顺序就可以任意了。我们可以考虑对这个过程\r\nDP，\r\n表示树上的边在/不在拓扑序中的方案数，\r\n表示所有方案的答案和。转移的时候，考虑选择的树上点，然后这个点之前可能会有一些非树上的点插入。\r\n考虑插入一条边的时候结果的变化，假设现在的树边的排名为 ，对于  显然有  种方案让他的排名 \r\n根据期望的线性性，插入一条边的时候答案的增量就是 ，即  记录的和。\r\n总的时间复杂度 \r\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485CI MXX(205), SXX((1 &lt;&lt; 19) + 5), MOD(1e9 + 7);vector&lt; pair&lt;int, int&gt; &gt; r[MXX];int n, m, k, dep[MXX], fa[MXX], id[MXX];void DFS(int x) {    for(auto i : r[x]) {        int y(i.first);        if(y == fa[x])            continue;        fa[y] = x, dep[y] = dep[x] + 1;        id[y] = i.second;        DFS(y);    }}int f[2][SXX], g[2][SXX], c[SXX];#define lowbit(x) ((x) &amp; (-x))#define count(x) __builtin_popcount(x)S main() {    Files();    fr(n), fr(m), k = 1 &lt;&lt; (n - 1);    for(int i(1); i &lt; n; ++ i) {        int x, y;        fr(x), fr(y);        r[x].emplace_back(mkp(y, i));        r[y].emplace_back(mkp(x, i));    }    DFS(1);    for(int i(n); i &lt;= m; ++ i) {        int x, y, s(0);        fr(x), fr(y);        while(x != y) {            if(dep[x] &lt; dep[y])                swap(x, y);            s |= 1 &lt;&lt; (id[x] - 1);            x = fa[x];        }        ++ c[s];    }    for(int i(0); i &lt; n - 1; ++ i)        for(int s(0); s &lt; k; ++ s)            if((s &gt;&gt; i) &amp; 1)                c[s] = (c[s] + (c[s ^ (1 &lt;&lt; i)])) % MOD;    f[1][0] = 1;    int nw(1), lst(0);    for(int i(0); i &lt; m; ++ i) {        swap(nw, lst);        for(int s(0); s &lt; k; ++ s)            f[nw][s] = g[nw][s] = 0;        for(int s(0); s &lt; k; ++ s)            if(f[lst][s]) {                for(int t(s ^(k - 1)), x; t; t -= lowbit(t)) {                    x = lowbit(t);                    f[nw][s | x] = (f[nw][s | x] + f[lst][s]) % MOD;                    g[nw][s | x] = (g[nw][s | x] + g[lst][s] + 1ll * (i + 1) * f[lst][s] % MOD) % MOD;                }                int v(c[s] - (i - count(s)));                f[nw][s] = (f[nw][s] + 1ll * f[lst][s] * v) % MOD;                g[nw][s] = (g[nw][s] + 1ll * g[lst][s] * v) % MOD;            }    }    fw(g[nw][k - 1], 1);    Heriko Deltana;}\r\n10.25\r\nNOIP20-10\r\n10\r\nA 我用的链式前向星，MLE 了，然后赛后用 vector\r\n试了试，过了，6.\r\nA\r\n可以发现这个题的答案主要限制在边上，那么考虑 Kruskal\r\n重构树的性质是两个点之间路径上的最小边权的是他们 LCA 的点权。\r\n那么用  表示在以 \r\n为根的子树中选取一个根的答案，显然在重构树中只有叶子结点才是原树中的结点，而重构树又是二叉树，所以可以直接\r\nDFS 的时候转移。\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172CI MXX(1e6 + 5);int fa[MXX &lt;&lt; 1], n, sz[MXX &lt;&lt; 1], v[MXX &lt;&lt; 1];LL f[MXX &lt;&lt; 1], ans;int Find(int x) {    if(x != fa[x])        fa[x] = Find(fa[x]);    Heriko fa[x];}struct Edge {    int x, y, v;    I bool operator &lt; (const Edge &amp;co) const {        Heriko v &gt; co.v;    }}e[MXX];int cnt;vector&lt;int&gt; r[MXX &lt;&lt; 1];void DFS(int x, int fa) {    for(int y : r[x])        if(y != fa)            DFS(y, x);    if(!r[x].size())        Heriko;        int s1(r[x][0]), s2(r[x][1]);    f[x] = Hmax(f[s1] + 1ll * sz[s2] * v[x], f[s2] + 1ll * sz[s1] * v[x]);}S main() {    Files();    fr(n), cnt = n;    for(int i(1); i &lt;= n * 2; ++ i)        fa[i] = i;    for(int i(1); i &lt;= n; ++ i)        sz[i] = 1;    for(int i(1); i &lt; n; ++ i)        fr(e[i].x), fr(e[i].y), fr(e[i].v);    sort(e + 1, e + 1 + n - 1);    for(int i(1); i &lt; n; ++ i) {        int fx(Find(e[i].x)), fy(Find(e[i].y));        if(fx != fy) {            fa[fx] = fa[fy] = ++ cnt;            v[cnt] = e[i].v;            r[cnt].emplace_back(fx), r[cnt].emplace_back(fy);            sz[cnt] += sz[fx] + sz[fy];        }    }    DFS(cnt, 0);    fw(f[cnt], 1);    Heriko Deltana;}\r\nB\r\n考虑建立一个类似哈夫曼树的编码树，于是题目问题转化为要求一个节点的儿子个数不超过\r\n，而代价为叶子结点权值乘上深度的和。\r\n考虑区间 DP，设  为将\r\n\r\n中的字符构成编码树的最小代价， 为将区间划分为 \r\n段能达到的最小的  的和，\r\n发现没必要求出所有的 ，于是复杂度为 \r\n然后代码里把这个  的第三维用\r\n 中转了一下。\r\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859CI MXX(505);int n, k, a[MXX], icnt, antid[15], ch[15][2], id[MXX];LL sum[MXX], f[MXX][MXX], g[MXX][MXX][15];int DFS(int x) {    if(x &lt;= 0)        Heriko Deltana;    if(id[x])        Heriko id[x];    if(x &gt; 1)        DFS(x / 2), DFS((x + 1) / 2);    id[x] = ++ icnt;    antid[icnt] = x;    if(x &gt; 1)        ch[id[x]][0] = id[x / 2], ch[id[x]][1] = id[(x + 1) / 2];    Heriko id[x];}S main() {    Files();    fr(n), fr(k), k = Hmin(n, k);    mst(f, 0x3f), mst(g, 0x3f);    DFS(k);    for(int i(1); i &lt;= n; ++ i)        f[i][i] = 0;    for(int i(1); i &lt;= n; ++ i)        fr(a[i]), sum[i] = sum[i - 1] + a[i], g[i][i][id[1]] = a[i];    for(int len(2); len &lt;= k; ++ len)        for(int l(1), r(l + len - 1); r &lt;= n; ++ l, ++ r)            f[l][r] = sum[r] - sum[l - 1];    for(int len(2); len &lt;= n; ++ len)        for(int l(1), r(l + len - 1); r &lt;= n; ++ l, ++ r) {            for(int x(1); x &lt;= icnt; ++ x)                if(antid[x] &gt; 1) {                    for(int i(l); i &lt;= r; ++ i)                        g[l][r][x] = Hmin(g[l][r][x], g[l][i][ch[x][0]] + g[i + 1][r][ch[x][1]]);                    f[l][r] = Hmin(f[l][r], g[l][r][x]);                }            g[l][r][id[1]] = f[l][r] + sum[r] - sum[l - 1];        }    fw(f[1][n], 1);    Heriko Deltana;}\r\nC\r\n场上以为是数学题，结果是构造题，要是上来就向着构造题想就好了）\r\n假设 ， 是两个质数，那么 \r\n而 \r\n是偶数，于是转化成将一个偶数表示成两个不同质数之和。\r\n根据哥德巴赫猜想，在题面中的数据范围内，判掉过于小的质数 \r\n之后，这很有可能是可行的，可以跑一个  的暴力证明这个是可行的。\r\n然后可以暴力枚举 ，判断  和  是否质数，如果都是，那么 \r\n12345678910111213141516171819202122232425262728293031323334LL n;I bool P(LL x) {    for(int i(2); i * i &lt;= x; ++ i)        if(x % i == 0)            Heriko Deltana;    Yoisaki Kanade;}S main() {    Files();    fr(n);    if(n == 1)        fw(2, 1);    else if(n == 3)        fw(9, 1);    else if(n == 5)        fw(25, 1);    else {        n ++;        for(int i(2); i &lt;= n; ++ i)            if(P(i) and P(n - i)) {                fw(i * (n - i), 1);                Heriko Deltana;            }    }    Heriko Deltana;}\r\n10.24\r\nNOIP20-9\r\n9\r\nACD 的暴力都打上了，B 的 100 挂到 80.\r\nA\r\n考场写了个 \r\n求逆序对， 求本题的 nt\r\n暴力。\r\n正解考虑把每个数和其位置转化为坐标 ，然后发现反转两个数造成的减少只存在于以它们两个连线为对角线的矩形中，具体来说就是对于逆序对个数的贡献从\r\n+2 变为 0.\r\n于是可以预处理两个序列，分别是左上和右下，然后线段树维护。\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990CI MXX(1e6 + 5);int n, a[MXX], k1[MXX], k2[MXX], ln1, ln2, vis[MXX], ans;struct Seq {    int x, lx, rx, v;    I bool operator &lt; (const Seq &amp;co) const {        Heriko x == co.x ? v &lt; co.v : x &lt; co.x;    }}s[MXX &lt;&lt; 1];int cnt;struct Node {    int v, tg;}t[MXX &lt;&lt; 2];#define lc(x) (x &lt;&lt; 1)#define rc(x) (x &lt;&lt; 1 | 1)void Modify(int x, int l, int r, int lx, int rx, int v) {    if(lx &lt;= l and r &lt;= rx) {        t[x].tg += v;        t[x].v += v;        Heriko;    }    int mid((l + r) &gt;&gt; 1);    if(lx &lt;= mid)        Modify(lc(x), l, mid, lx, rx, v);    if(rx &gt; mid)        Modify(rc(x), mid + 1, r, lx, rx, v);    t[x].v = Hmax(t[lc(x)].v, t[rc(x)].v) + t[x].tg;}I bool CMP(int x, int y) {    Heriko a[x] &lt; a[y];}S main() {    Files();    fr(n);    for(int i(1); i &lt;= n; ++ i)        fr(a[i]);    if(is_sorted(a + 1, a + 1 + n)) {        fw(0, 1);        Heriko Deltana;    }    for(int i(1); i &lt;= n; ++ i)        if(a[i] &gt; a[k1[ln1]])            vis[i] = 1, k1[++ ln1] = i;    for(int i(n); i; -- i)        if(!ln2 or a[i] &lt; a[k2[ln2]])            vis[i] = 1, k2[++ ln2] = i;    reverse(k2 + 1, k2 + 1 + ln2);    for(int i(1); i &lt;= n; ++ i)        if(!vis[i]) {            int l(k1[upper_bound(k1 + 1, k1 + 1 + ln1, i, CMP) - k1]);            int r(k2[lower_bound(k2 + 1, k2 + 1 + ln2, i, CMP) - k2 - 1]);            if(l &lt; i and i &lt; r)                s[++ cnt] = {l, i + 1, r, 1}, s[++ cnt] = {i, i + 1, r, -1};        }    sort(s + 1, s + 1 + cnt);    for(int i(1); i &lt;= cnt; ++ i)        Modify(1, 1, n, s[i].lx, s[i].rx, s[i].v), ans = Hmax(ans, t[1].v);    fw(ans * 2 + 1, 1);    Heriko Deltana;}\r\nB\r\n首先看数据范围，允许 。\r\n然后发现这个操作本质上相当于把一个三元组拆成两部分进行冒泡排序，所以可以直接按照升序把数一个一个拽到前面。\r\n但是发现因为每次只能操作一个三元组，所以我们最后会剩下三个数字，于是需要对这三个数进行一下判断。\r\n显然可以先判断是否能对着 \r\n操作两次来达到升序，然后不行的话，因为是排列，可以考虑重编号直到所有编号方式都不能构造。\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778CI MXX(1005), LMT(1005 * 1005);int n, a[MXX], p[MXX], ans[LMT], ln;I void Move(int i) {    ans[++ ln] = i;    int x(a[i]), y(a[i + 1]), z(a[i + 2]);    a[i] = y, a[i + 1] = z, a[i + 2] = x;}S main() {    Files();    fr(n);    for(int i(1); i &lt;= n; ++ i)        fr(a[i]), p[i] = a[i];        sort(p + 1, p + 1 + n);    for(int i(1); i &lt;= n - 2; ++ i) {        int pos(0);        for(int j(i + 1); j &lt;= n; ++ j)            if(a[j] == p[i]) {                pos = j;                break;            }        if(!pos)            continue;        while(pos != i)            if(pos == i + 1)                Move(pos - 1), -- pos;            else                Move(pos - 2), -- pos;    }    int cnt(0);    if(a[n - 1] &lt;= a[n] and a[n] &lt;= a[n - 2])        Move(n - 2);    else if(a[n] &lt;= a[n - 2] and a[n - 2] &lt;= a[n - 1])        Move(n - 2), Move(n - 2);    else if(a[n - 2] &lt; a[n - 1] and a[n - 1] &gt; a[n]) {        int tmp(-1);        for(int i(2); i &lt;= n - 2; ++ i)            if(a[i] == a[i - 1])                tmp = i;        if(tmp == -1) {            puts(\"-1\");            Heriko Deltana;        }        for(int i(tmp); i &lt;= n - 2; ++ i)            Move(i - 1);        while(!(a[n - 2] &lt;= a[n - 1] and a[n - 1] &lt;= a[n]) and cnt &lt; 3)            Move(n - 2), ++ cnt;    }    else if(!(a[n - 2] &lt;= a[n - 1] and a[n - 1] &lt;= a[n])){        puts(\"-1\");        Heriko Deltana;    }    fw(ln, 1);    for(int i(1); i &lt;= ln; ++ i)        fw(ans[i], 0);    Heriko Deltana;}\r\n10.23\r\nNOIP10-6\r\n6\r\n。\r\nA\r\n乐……一个 A 写了这么久。。\r\n显然对于走一步的情况最一开始可以处理出来。\r\n然后就是对于跳的情况，可以离散化之后通过冰茶姬来合并成连通块，然后就变成从某点出发找到最大的连通块。\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475CI MXX(1e6 + 5);int fa[MXX], n, sz[MXX], v[MXX];int Find(int x) {    if(x != fa[x])        fa[x] = Find(fa[x]);    Heriko fa[x];}I void UNI(int x, int y) {    int fx(Find(x)), fy(Find(y));    if(fx != fy)        fa[fx] = fy, sz[fy] += sz[fx];}pair&lt;int, int&gt; a[MXX];map&lt;pair&lt;int, int&gt;, int&gt; mp;int dx[6] = {1, 0, -1, -1, 0, 1}, dy[6] = {0, -1, -1, 0, 1, 1}, tot, ans[MXX][7], vis[MXX], tmp[MXX];S main() {    Files();    fr(n);    for(int i(1); i &lt;= n * 10; ++ i)        fa[i] = i, sz[i] = 1;    for(int i(1); i &lt;= n; ++ i)        fr(a[i].first), fr(a[i].second), mp[a[i]] = ++ tot, vis[tot] = 1, ans[i][6] = tot;    for(int i(1); i &lt;= n; ++ i)        for(int j(0); j &lt; 6; ++ j) {            int tx(a[i].first + dx[j]), ty(a[i].second + dy[j]);            if(!mp[{tx, ty}])                mp[{tx, ty}] = ++ tot;            ans[i][j] = mp[{tx, ty}];        }    for(int i(1); i &lt;= n; ++ i)        for(int j(0); j &lt; 3; ++ j)            if(!vis[ans[i][j]] and !vis[ans[i][j + 3]])                UNI(ans[i][j], ans[i][j + 3]);    for(int i(1); i &lt;= n; ++ i) {        int nw(0), res(0);        for(int j(0); j &lt; 6; ++ j)            if(vis[ans[i][j]] and !vis[ans[ans[i][j]][j]])                tmp[++ nw] = Find(ans[ans[i][j]][j]);        sort(tmp + 1, tmp + 1 + nw);        nw = unique(tmp + 1, tmp + 1 + nw) - tmp - 1;        for(int j(1); j &lt;= nw; ++ j)            res += sz[tmp[j]], v[tmp[j]] = 1;        for(int j(0); j &lt; 6; ++ j)            if(!vis[ans[i][j]])                res += !v[Find(ans[i][j])];        for(int j(1); j &lt;= nw; ++ j)            v[tmp[j]] = 0;        fw(res, 1);    }    Heriko Deltana;}\r\n10.22\r\nCSP7-7\r\n7\r\nFinal.\r\n但是出题人你怎么光发刀子不来个新章节的琪芽重逢）\r\nA\r\n幼儿园题 Again，但是考场写错一个东西挂了三十。\r\nB\r\n排序之后找第一个大于等于当前射击位置的 ，然后判断一下即可。\r\n最一开始忘了排序傻了半天。\r\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455CL MXX(1e5 + 5), INF(1e9 + 1);//Again Normal Failed Perfect#define int long longint n, k, l[MXX], r[MXX], x[MXX], y[MXX], m, co[MXX];S main() {    // Files();    fr(n), fr(m), fr(k);    for(int i(1); i &lt;= n; ++ i)        fr(l[i]), fr(x[i]), fr(y[i]), fr(r[i]);    l[n + 1] = r[n + 1] = INF;    sort(l + 1, l + 1 + n);    sort(r + 1, r + 1 + n);    sort(x + 1, x + 1 + n);    sort(y + 1, y + 1 + n);    for(int i(1); i &lt;= k; ++ i) {        int nw;        fr(nw);        int pos(lower_bound(r + 1, r + 1 + n, nw) - r);        // fw(pos, 1);        if(nw &lt; l[pos] or nw &gt; r[pos]) {            puts(\"Failed\");            continue;        }//801376028 801558022 801702927 802253774 792329141        if(co[pos]) {            puts(\"Again\");            continue;        }        if(x[pos] &lt;= nw and nw &lt;= y[pos]) {            puts(\"Perfect\"), co[pos] = 1;            continue;        }        if(l[pos] &lt;= nw and nw &lt;= r[pos]) {            puts(\"Normal\"), co[pos] = 1;            continue;        }    }    Heriko Deltana;}\r\n10.19\r\nNOIP20-8\r\n8\r\nA\r\n又是幼儿园题。\r\nB\r\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980CI MXX(5e6 + 5);int n, k, cnt, p[MXX], vis[MXX], f[MXX], g[MXX], co[MXX];I void Es() {    for(int i(2); i &lt;= n; ++ i) {        if(!vis[i])            p[++ cnt] = i;        for(int j(1); i * p[j] &lt;= n and j &lt;= cnt; ++ j) {            vis[i * p[j]] = 1;            if(i % p[j] == 0)                break;        }    }}deque&lt;int&gt; f1, f2, g1, g2;I void POP(deque&lt;int&gt; &amp;q, int x) {    while(q.size() and q.front() &lt; x - k)        q.pop_front();}S main() {    Files();    fr(n), fr(k), Es();    for(int i(2); i &lt;= n; ++ i) {        POP(f1, i), POP(f2, i), POP(g1, i), POP(g2, i);        if(g2.size()) {            co[i] = 1, f[i] = g[g2.front()] + 1;            if(vis[i]) {                while(f1.size() and f[i] &gt;= f[f1.back()])                    f1.pop_back();                f1.emplace_back(i);            }        }        else {            f[i] = g1.size() ? g[g1.front()] + 1 : 0;            if(vis[i]) {                while(f2.size() and f[i] &lt;= f[f2.back()])                    f2.pop_back();                f2.emplace_back(i);            }        }        if(f2.size()) {            g[i] = f[f2.front()] + 1;            if(!vis[i]) {                while(g1.size() and g[i] &gt;= g[g1.back()])                    g1.pop_back();                g1.emplace_back(i);            }        }        else {            g[i] = f1.size() ? f[f1.front()] + 1 : 0;            if(!vis[i]) {                while(g2.size() and g[i] &lt;= g[g2.back()])                    g2.pop_back();                g2.emplace_back(i);            }        }    }    fw(co[n] ? f[n] : -f[n], 1);    Heriko Deltana;}\r\nNOIP20-7\r\n7\r\n什么顶级难度梯度：T1 幼儿园题，T2 二分图/网络流，T3 闵可夫斯基和优化\r\nDP（我不到啊），T4 科幻做法我真的看不懂。\r\nA\r\n幼儿园题，跳过）\r\nB\r\n考虑求一个图的最大团相当于求它的补图的最大独立集，可以发现它的补图是一个二分图，于是这个\r\n题就转化为了二分图求最大独立集。\r\n然后求方案的话相当于求最小点覆盖。\r\n学了一个科幻的匈牙利写法（\r\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374CI MXX(505);int r[MXX][MXX], co[MXX], n, m, ans, vis[MXX], mat[MXX], flg[MXX];vector&lt;int&gt; v;void Pre(int x, int c) {    co[x] = c;    for(int i(1); i &lt;= n; ++ i)        if(r[x][i] and co[i] &lt; 0)            Pre(i, !c);}bool DFS(int x, int c) {    if(vis[x] == c)        Heriko Deltana;    vis[x] = c;    for(int i(1); i &lt;= n; ++ i)        if(r[x][i]) {            vis[i] = c;            if(!mat[i] or DFS(mat[i], c)) {                mat[i] = x, flg[x] = i;                Yoisaki Kanade;            }        }    Heriko Deltana;}S main() {    Files();    fr(n), fr(m), mst(co, -1);    for(int i(1); i &lt;= n; ++ i)        for(int j(1); j &lt;= n; ++ j)            if(i != j)                r[i][j] = 1;    for(int i(1); i &lt;= m; ++ i) {        int x, y;        fr(x), fr(y);        r[x][y] = r[y][x] = 0;    }        for(int i(1); i &lt;= n; ++ i)        if(co[i] &lt; 0)            Pre(i, 1);    for(int i(1); i &lt;= n; ++ i)        DFS(i ,i);    mst(vis, 0);    for(int i(1); i &lt;= n; ++ i)        if(co[i] and !flg[i])            DFS(i, i);    for(int i(1); i &lt;= n; ++ i)        if((co[i] and vis[i]) or (!co[i] and !vis[i]))            v.emplace_back(i), ++ ans;    fw(ans, 1);    for(int i : v)        fw(i, 0);    Heriko Deltana;}\r\n10.18\r\nNOIP20-6\r\n6\r\nA\r\n考虑对于每个位进行每种操作之后状态为  或  的方案的统计。\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445#define ULL unsigned long longCI MXX(1000005);int n, k;ULL a[MXX], ans, seed, f[2][5];I void Pre() {    std::mt19937_64 rng(seed);    ULL U(k == 64 ? -1ull : (1ull &lt;&lt; k) - 1);    for(int i(1); i &lt;= n; ++ i)        a[i] = rng() &amp; U;}S main() {    Files();    fr(n), fr(seed), fr(k), Pre();    for(int d(0); d &lt; 64; ++ d) {        for(int i(1); i &lt;= 4; ++ i)            f[0][i] = f[1][i] = 0;        for(int i(1); i &lt;= n; ++ i) {            int x((a[i] &gt;&gt; d) &amp; 1);            if(x)                ans += f[1][4] * (1ull &lt;&lt; d);            for(int j(4); j &gt;= 2; -- j)                if(j &amp; 1)                    f[x | 0][j] += f[0][j - 1], f[x | 1][j] += f[1][j - 1];                else                    f[x ^ 0][j] += f[0][j - 1], f[x ^ 1][j] += f[1][j - 1];                        ++ f[x][1];        }    }    fw(ans, 1);    Heriko Deltana;}\r\nB\r\n场上想的是所有的相邻的  和\r\n（包括 ）作为左右端，再和它们的和作为一个元素，形成一个集合。\r\n每次从这个集合中选取和最大的元素，然后选取  和  中更大的那个设为 ，将当前的元素和以  为右端的元素合并，也就是说我们要做\r\n 次操作就能达到要求。\r\n使用一个 multiset 或者 set\r\n和链表维护，这样复杂度为 \r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960CL MXX(5e5 + 5), INF(1e12);int n, k, a[MXX], L[MXX], R[MXX], ans;I void DEL(int x) {    R[L[x]] = R[x];    L[R[x]] = L[x];}struct Node {    int l, r, val;    I Node(int l, int r, int val) : l(l), r(r), val(val) {}    I bool operator &lt; (const Node &amp;b) const {        if(val != b.val)            Heriko val &gt; b.val;        else            Heriko mkp(l, r) &lt; mkp(b.l, b.r);    }};multiset&lt;Node&gt; s;S main() {    Files();    fr(n), fr(k);    for(int i(1); i &lt;= n; ++ i)        fr(a[i]), L[i] = i - 1, R[i] = i + 1;    R[n] = 1, L[1] = n;    for(int i(1); i &lt;= n; ++ i)        s.insert(Node(i, R[i], a[i] + a[R[i]]));    for(int i(1); i &lt;= n - k; ++ i) {        Node now(*s.begin());        int lx(L[now.l]), rx(R[now.r]);        if(a[now.l] &lt; a[now.r]) {            s.erase(now);            s.erase(Node(now.r, rx, a[now.r] + a[rx]));            DEL(now.r);            s.insert(Node(now.l, rx, a[now.l] + a[rx]));        }        else {            s.erase(now);            s.erase(Node(lx, now.l, a[lx] + a[now.l]));            DEL(now.l);            s.insert(Node(lx, now.r, a[lx] + a[now.r]));        }    }    ans = (*s.begin()).val;    fw(ans, 1);    Heriko Deltana;}\r\n但是 multiset 或者 set\r\n的常数巨大所以就算这个是一个 \r\n也只过了 .\r\n然后只能换方法了，考虑二分，也就不用链表了。\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384CI MXX(5e5 + 5);int n, k, a[MXX], b[MXX], stk[MXX], tp;I bool Checker(LL x) {    tp = 0;    for(int i(1); i &lt;= n; ++ i)        b[i] = a[i] * 2 - x;    for(int i(1); i &lt;= n; ++ i)        if(b[i] &lt;= 0)            stk[++ tp] = i;        else {            while(tp and b[stk[tp]] &gt; b[i])                -- tp;            if(!tp or b[stk[tp]] &lt;= 0)                stk[++ tp] = i;        }    if(tp &lt; k)        Heriko Deltana;    if(b[stk[1]] &gt; 0 and b[stk[tp]] &gt; 0) {        if(b[stk[1]] &gt; b[stk[tp]])            stk[1] = stk[tp];        -- tp;    }    if(tp &lt; k)        Heriko Deltana;    int tmp(tp);    for(int i(1); i &lt;= tp; ++ i) {        if(b[stk[i]] &lt;= 0)            continue;        int l(i - 1), r(i + 1);        if(l == 0)            l = tp;                if(r == tp + 1)            r = 1;        if(b[stk[i]] + b[stk[l]] &gt; 0 or b[stk[i]] + b[stk[r]] &gt; 0)            -- tmp;    }    Heriko tmp &gt;= k;}I bool CMP(int x, int y) {    Heriko a[x] &gt; a[y];}S main() {    Files();    fr(n), fr(k);    for(int i(1); i &lt;= n; ++ i)        fr(a[i]), b[i] = i;    sort(b + 1, b + 1 + n, CMP);    LL l(1), r(2e9);    while(l &lt; r) {        LL mid((l + r) &gt;&gt; 1);        if(Checker(mid))            r = mid;        else            l = mid + 1;    }    fw(l, 1);    Heriko Deltana;}\r\n10.17\r\nNOIP20-5\r\n5\r\nA\r\n需要支持查询前缀最小和最大，开树状数组。\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;bits/stdc++.h&gt;#define mset(a,b) memset((a),(b),sizeof((a)))#define rep(i,l,r) for(int i=(l);i&lt;=(r);i++)#define dec(i,l,r) for(int i=(r);i&gt;=(l);i--)#define cmax(a,b) (((a)&lt;(b))?(a=b):(a))#define cmin(a,b) (((a)&gt;(b))?(a=b):(a))#define Next(k) for(int x=head[k];x;x=li[x].next)#define vc vector#define ar array#define pi pair#define fi first#define se second#define mp make_pair#define pb emplace_back#define N 100010#define M 2000010using namespace std;typedef double dd;typedef long double ld;typedef long long ll;typedef unsigned int uint;typedef unsigned long long ull;#define int long longtypedef pair&lt;int,int&gt; P;typedef vector&lt;int&gt; vi;const int INF=1e18;const dd eps=1e-9;const int base=1000001;template&lt;typename T&gt; inline void read(T &amp;x) {    x=0; int f=1;    char c=getchar();    for(;!isdigit(c);c=getchar()) if(c == '-') f=-f;    for(;isdigit(c);c=getchar()) x=x*10+c-'0';    x*=f;}int n,a[N],t,f[N],g[N],an[N];struct BIT{    int p[M],len;    inline void init(int n,int x){fill(p,p+n+1,x);len=n;}    inline int lowbit(int x){return x&amp;(-x);}    inline void suf_add_max(int w,int x){        for(int i=w;i&lt;=len;i+=lowbit(i)) cmax(p[i],x);    }    inline int pre_ask_max(int w){        int res=-INF;        for(int i=w;i;i-=lowbit(i)) cmax(res,p[i]);        return res;    }    inline void suf_add_min(int w,int x){        for(int i=w;i&lt;=len;i+=lowbit(i)) cmin(p[i],x);    }    inline int pre_ask_min(int w){        int res=INF;        for(int i=w;i;i-=lowbit(i)) cmin(res,p[i]);        return res;    }}bmx,bmn;signed main(){    read(t);    while(t--){        read(n);rep(i,1,n) read(a[i]);        bmx.init(2*base,-INF);        bmn.init(2*base,INF);        rep(i,1,n) f[i]=a[i];        rep(i,1,n) g[i]=a[i];        rep(i,1,n){            int ans=bmn.pre_ask_min(a[i]-1+base);            if(ans==INF) f[i]=-INF;            else f[i]=f[i]*ans;            ans=bmx.pre_ask_max(a[i]-1+base);            if(ans==-INF) g[i]=-INF;            else g[i]=g[i]*ans;            bmx.suf_add_max(a[i]+base,a[i]);            bmn.suf_add_min(a[i]+base,a[i]);        }        bmx.init(2*base,-INF);        bmn.init(2*base,INF);        rep(i,1,n) an[i]=a[i];        int Ans=-INF;        rep(i,1,n){            int ans=-1;            if(a[i]&gt;0) ans=bmx.pre_ask_max(a[i]-1+base);            else ans=bmn.pre_ask_min(a[i]-1+base);            if(ans==INF||ans==-INF){                an[i]=-INF;            }            else an[i]=an[i]*ans;            if(f[i]!=-INF){                bmx.suf_add_max(a[i]+base,f[i]);                bmn.suf_add_min(a[i]+base,f[i]);            }            if(g[i]!=-INF){                bmx.suf_add_max(a[i]+base,g[i]);                bmn.suf_add_min(a[i]+base,g[i]);            }            cmax(Ans,an[i]);        }        if(Ans!=-INF) printf(\"%lld\\n\",Ans);        else puts(\"-1\");    }    return 0;}\r\nB\r\n先考虑分析这个总长度的下界，设  表示第  个字符的个数，一定有 ,\r\n（因为前两个字符和最后两个字符一定是最小的字符，且每个字符  之后都必须有一个字符 ）。\r\n这样就导出了一种构造方法：在前面和后面插入两个最小的字符,\r\n每个次小的字符后面插入一个最小的字符，可以通过归纳证明，这种构造方案，在长度固定为下界的情况下是字典序最小的。\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445CI MXX(2e5 + 5);int T, n, k, a[MXX], b[MXX], cox, coy;S main() {    Files();    fr(T);    while(T --) {        fr(n), fr(k), cox = 1;        a[1] = -- k;        while(k --) {            coy = cox;            for(int i(1); i &lt;= coy; ++ i)                b[i] = a[i];            cox = 2, a[1] = a[2] = k;            for(int i(1); i &lt;= coy; ++ i) {                a[++ cox] = b[i];                if(b[i] == k + 1)                    a[++ cox] = k;            }                        a[++ cox] = k;        }        if(cox &gt; n)            puts(\"-1\");        else{            while(n &gt; cox)                putchar('a'), -- n;            for(int i(1); i &lt;= cox; ++ i)                putchar(a[i] + 'a');            puts(\"\");        }    }    Heriko Deltana;}\r\nC\r\n不会。\r\nD\r\n考虑一个暴力的 DP， 表示当前已经填完  的数， 填到点 ， 填到点 ，当前填过的点集是 \r\n的方案数，那么转移直接枚举下一个填谁，需要保证  在填完 \r\n之后所有树上相邻的点都被填了，然后记忆化一下就过了，非常意外）\r\n首先根据题意可以发现这棵树最多是一颗三叉树，那么对于刚才那个状态，若把\r\n 和  删掉，那么剩下的点集一定是  的子集或补集。\r\n如果不满足这个条件，就会存在一个被染上不大于 \r\n编号的点与至少一个没染色的点相邻，但是之后染色的所有点编号都是大于  的，一定无解，而可以发现  的合法状态最多  种。\r\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455CI MXX(65), MOD(1e9 + 7);mt19937 knd(time(0));int n, ans;LL p1(knd()), p2(knd()), p3(knd()), r[MXX];map&lt;LL, int&gt; f;int DFS(LL s, int x, int y) {    if(s == (1ll &lt;&lt; n) - 1)        Yoisaki Kanade;    LL nw(s * p1 + x * p2 + y * p3);    if(f[nw])        Heriko f[nw];    int &amp;ans(f[nw]);    LL tmp(r[y] &amp; ~s), cnt(__builtin_popcountll(tmp));    if(cnt &gt; 1)        Heriko ans = 0;    else if(cnt == 1)        Heriko ans = DFS(s | tmp, __lg(tmp) + 1, x);    for(int i(1); i &lt;= n; ++ i)        if(!(s &gt;&gt; (i - 1) &amp; 1))            ans = (ans + DFS(s | (1ll &lt;&lt; (i - 1)), i, x)) % MOD;        Heriko ans;}S main() {    Files();    fr(n);    for(int i(1); i &lt; n; ++ i) {        int x, y;        fr(x), fr(y);        r[x] |= 1ll &lt;&lt; (y - 1);        r[y] |= 1ll &lt;&lt; (x - 1);    }    for(int i(1); i &lt;= n; ++ i)        for(int j(1); j &lt;= n; ++ j)            if(i != j)                ans = (ans + DFS((1ll &lt;&lt; (i - 1) | (1ll &lt;&lt; (j - 1))), i, j)) % MOD;    fw(ans, 1);    Heriko Deltana;}\r\n10.13\r\nNOIP20-4\r\n4\r\n因为中午要回去补觉就没报名，但是反正 A\r\n挺简单，剩下的好像我顶多暴力）\r\nA\r\n瓶颈显然是最慢的点，于是答案为 \r\nB\r\n考虑对于暴力的 DP：\r\n表示区间  最大值为 \r\n的时候的答案为多少，这个可以用前缀和优化。\r\n其实我们不用真正的限定这个最大值为 ，因为在这个位置上取不到最大值一定不优，所以状态可以简化为\r\n，区间 DP 的式子就是：\r\n\r\n其中对于最后这个 \r\n可以看作直线用李超线段树维护一下。\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293CL MXX(305), NXX(1e7 + 5), LMT(1e8), INF(1e18);struct Line {    LL k, b;        LL Clac(LL x) {        Heriko k * x + b;    }}t[NXX];int ls[NXX], rs[NXX], rt[NXX], icnt;#define lc(x) ls[x]#define rc(x) rs[x]void Insert(int &amp;x, int l, int r, Line v) {    if(!x)        x = ++ icnt, t[x] = {0, -INF};        int mid((l + r) &gt;&gt; 1);    if(v.Clac(mid) &gt; t[x].Clac(mid))        swap(v, t[x]);    if(l == r)        Heriko;    if(v.Clac(l) &gt; t[x].Clac(l))        Insert(lc(x), l, mid, v);    if(v.Clac(r) &gt; t[x].Clac(r))        Insert(rc(x), mid + 1, r, v);}LL Query(int x, int l, int r, LL pos) {    if(!x)        Heriko -INF;    if(l == r)        Heriko t[x].Clac(pos);    int mid((l + r) &gt;&gt; 1);    LL res(t[x].Clac(pos));    if(pos &lt;= mid)        res = Hmax(res, Query(lc(x), l, mid + 1, pos));    else        res = Hmax(res, Query(rc(x), mid + 1, r, pos));    Heriko res;}int n, v[MXX][MXX], k[MXX];LL f[MXX][MXX];I int SUM(int xa, int ya, int xb, int yb) {    Heriko v[xb][yb] - v[xa - 1][yb] - v[xb][ya - 1] + v[xa - 1][ya - 1];}S main() {    Files();    fr(n);    for(int i(1); i &lt;= n; ++ i)        for(int j(i); j &lt;= n; ++ j)            fr(v[i][j]), v[i][j] += v[i - 1][j] + v[i][j - 1] - v[i - 1][j - 1];    for(int i(1); i &lt;= n; ++ i) {        fr(k[i]);        for(int j(1); j &lt;= k[i]; ++ j) {            LL x, y;            fr(x), fr(y);            Insert(rt[i], 0, LMT, {x, -y});        }    }    for(int len(1); len &lt;= n; ++ len)        for(int l(1), r(len); r &lt;= n; ++ l, ++ r) {            f[l][r] = -INF;            for(int i(l); i &lt;= r; ++ i)                f[l][r] = Hmax(f[l][r], f[l][i - 1] + f[i + 1][r] + Query(rt[i], 0, LMT, SUM(l, i, i, r)));        }    fw(f[1][n], 1);    Heriko Deltana;}\r\nC\r\n先不补，我不会数数题。\r\nD\r\n考虑以 \r\n为根之后一层一层询问内层叶节点在不在外层叶节点到根的路径上来二分出每个点的父亲来找叶子，但是发现从下往上这样做是\r\n\r\n的，所以需要从上往下做。\r\n设当前未确定的点集为 ，然后通过二分找到  和  子树的交中的任意一个结点 ，然后循环查询 \r\n的子树结构，这样可以保证整个子树从上往下至少调用一次查询，然后就只剩下\r\n\r\n和其儿子之间的关系没有确定，这个通过接二分查看  在哪些点到根的路径上即可，时间复杂度\r\n\r\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374vector&lt;int&gt; s, t;vector&lt;pair&lt;int, int&gt; &gt; ans;I vector&lt;int&gt; Copy(vector&lt;int&gt; a, int l, int r) {    vector&lt;int&gt; res;    for(int i(l); i &lt;= r; ++ i)        res.emplace_back(a[i]);    Heriko res;}I bool Query(vector&lt;int&gt; a, int x) {    a.emplace_back(1);    Heriko ask(a, x);}void Solve(int x) {    while(s.size() and Query(s, x)) {        int l(0), r(s.size() - 1);        while(l &lt; r) {            int mid((l + r) &gt;&gt; 1);            vector&lt;int&gt; tmp(Copy(s, l, mid));            if(Query(tmp, x))                r = mid;            else                l = mid + 1;        }        int nex(s[l]);        s.erase(s.begin() + l);        Solve(nex);    }    if(!t.size() or !Query(t, x)) {        t.emplace_back(x);        Heriko;    }    while(t.size() and Query(t, x)) {        int l(0), r(t.size() - 1);        while(l &lt; r) {            int mid((l + r) &gt;&gt; 1);            vector&lt;int&gt; tmp(Copy(t, l, mid));            if(Query(tmp, x))                r = mid;            else                l = mid + 1;        }        int nex(t[l]);        t.erase(t.begin() + l);        ans.emplace_back(mkp(x, nex));    }    t.emplace_back(x);}std::vector&lt;std::pair&lt;int, int&gt; &gt; work(int n) {    s.clear(), t.clear();    for(int i(2); i &lt;= n; ++ i)        s.emplace_back(i);    Solve(1);    Heriko ans;}\r\n10.12\r\nNOIP20-3\r\n3\r\n如何评价呢，没大样例然后我也没对拍，再加上昨天晚上没睡好迷迷糊糊写挂一堆，，爽。\r\n总之以后要写对拍了，也算是个教训，之前一直没这个教训好像是因为太菜于是场上切题太少。\r\nA\r\n考虑暴力枚举区间的时候，使用前缀和  来获得区间的数值。\r\n而这个过程其实就是在 \r\n之后的位置找到一个前缀和的后缀最大值，减去在  之前的前缀和的前缀最小值。\r\n时间复杂度 ，但是后缀最大值的边界最大值设小了，挂了\r\n\r\n123456789101112131415161718192021222324252627282930CI MXX(2e5 + 5), NXX(1e9 + 5);#define int long longint n, a[MXX], sum[MXX], premin[MXX], sufmax[MXX];S main() {    Files();    fr(n);    for(int i(1); i &lt;= n; ++ i)        fr(a[i]);    for(int i(1); i &lt;= n; ++ i)        sum[i] += sum[i - 1] + a[i];    premin[0] = 0, sufmax[n + 1] = sum[n];    for(int i(1); i &lt;= n; ++ i)        premin[i] = Hmin(premin[i - 1], sum[i]);    for(int i(n); i; -- i)        sufmax[i] = Hmax(sufmax[i + 1], sum[i]);    for(int i(1); i &lt;= n; ++ i)        fw(sufmax[i] - premin[i - 1], 0);    Heriko Deltana;}\r\nB\r\n根据题意，没有入度的一定是起点，没有出度的一定是终点。\r\n我为了方便直接将二维坐标转化为一维坐标来做。\r\n然后我们可以根据题意建立一张 DAG，然后在上面做一下递推，设  表示到达点  的路径数量，那么初始就是所有起点 ，然后通过拓扑序来进行递推。\r\n但是还需要减去不合法的答案，这个直接从每个起点开始进行一个限制深度的\r\nDFS 即可。\r\n发现今天早上确实因为睡不好而迷糊，边全建反了，DFS\r\n还写挂了两个地方，直接挂 \r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109CL MXX(1005), NXX(1e6 + 5), MOD(1e9 + 7);int n, m, a[MXX][MXX], ln;LL f[NXX];struct Edge {    int nex, to;}r[NXX &lt;&lt; 2];int head[NXX], rcnt, into[NXX], outo[NXX];I void ADD(int x, int y) {    r[++ rcnt] = (Edge){head[x], y}, head[x] = rcnt;    ++ into[y];    ++ outo[x];}I int Trans(int x, int y) {    Heriko (x - 1) * m + y;}vector&lt;int&gt; st, ed;LL cnt;void DFS(int x, int step) {    if(step &gt;= 4)        Heriko;    if(!outo[x]) {        ++ cnt;        Heriko;    }    for(int i(head[x]); i; i = r[i].nex)        DFS(r[i].to, step + 1);}S main() {    Files();    fr(n), fr(m), ln = Trans(n, m);    for(int i(1); i &lt;= n; ++ i)        for(int j(1); j &lt;= m; ++ j)            fr(a[i][j]);    for(int i(1); i &lt;= n; ++ i)        for(int j(1); j &lt;= m; ++ j) {            if(i - 1 &gt;= 1)                if(a[i - 1][j] - a[i][j] == 2)                    ADD(Trans(i, j), Trans(i - 1, j));                            if(j - 1 &gt;= 1)                if(a[i][j - 1] - a[i][j] == 2)                    ADD(Trans(i, j), Trans(i, j - 1));            if(i + 1 &lt;= n)                if(a[i + 1][j] - a[i][j] == 2)                    ADD(Trans(i, j), Trans(i + 1, j));            if(j + 1 &lt;= m)                if(a[i][j + 1] - a[i][j] == 2)                    ADD(Trans(i, j), Trans(i, j + 1));        }    for(int i(1); i &lt;= ln; ++ i) {        if(!into[i] and outo[i])            st.emplace_back(i), f[i] = 1;                if(into[i] and !outo[i])            ed.emplace_back(i);    }    queue&lt;int&gt; q;    for(int i : st)        q.emplace(i);    while(!q.empty()) {        int x(q.front());        q.pop();        for(int i(head[x]); i; i = r[i].nex) {            int y(r[i].to);            (f[y] += f[x]) %= MOD;            -- into[y];            if(!into[y])                q.emplace(y);        }    }    LL ans(0);    for(int i : ed)        (ans += f[i]) %= MOD;    for(int i : st)         DFS(i, 1);    fw((ans - cnt + MOD) % MOD, 1);    Heriko Deltana;}\r\nC\r\n这题对于我来说真的很科幻，我真的不是很会构造，下面假定 \r\n首先手模了 \r\n的，可以发现对于  的时候，一定无法去填充，所以答案为 ，而排除掉上面的情况之后，只有一行或只有一列的时候，即\r\n 的时候，一定只有\r\n 种填充方法。\r\n考虑如何满足题意的情况下填充，中间需要画一堆图，我不想放图于是不放了，总之构造的思路类似于摆砖头。\r\n最后的结果就是可以证明对于  且 \r\n为奇数的情况，可以使用  和 \r\n两种矩形组成，而对于  且\r\n 为偶数的情况，加入一些  的矩形填补在中间，然后使用\r\n 和  的矩形构造。\r\n至于  时，因为只能使用\r\n 和  的矩形进行填充，所以可以通过\r\nDP 得出答案。\r\n最后使用 DP 得出答案，注意下面的代码中 ，和上面相反。主要是发现自己写反了也懒得改了\r\n1234567891011121314151617181920212223242526272829303132333435363738394041CL MOD(998244353), MXX(1e7 + 5);LL n, m, f[MXX];S main() {    Files();    fr(n), fr(m);    if((n * m) &amp; 1) {        puts(\"0\");        Heriko Deltana;    }    if(Hmin(n, m) == 1) {        puts(\"1\");        Heriko Deltana;    }    if(m &gt; n)        swap(n, m);    f[0] = 1;    for(int i(m - 1); i &lt;= n + 1; ++ i)        if(i &lt; m + 1)            f[i] = f[i - m + 1];        else            f[i] = (f[i - m + 1] + f[i - m - 1]) % MOD;    if(m == 2)        fw((f[n] + f[n - 2]) % MOD, 1);    else if(m &amp; 1)        fw(f[n] * 2ll % MOD, 1);    else        fw((f[n] * 2ll % MOD + f[n + 1] + f[n - 1]) % MOD, 1);    Heriko Deltana;}\r\nD\r\n首先看到题就发现 \r\n的范围没有给出，需要自己毛估估一下，设以  为公差的等差序列 ，那么答案上界大约为 ，下界大约为 ，得出大概的范围\r\n。\r\n不会分析 \r\n的范围怎么办：这题一眼看过去只要是一个  就能过的吧）\r\n考虑构造出来这样一个 \r\n和原序列的距离：表达成 ，那么要找到这个 \r\n就相当于是寻找带权中位数，它一定取在 \r\n的位置上。这个题就可以拆成两个等差序列，使用对顶堆来维护，两个堆分别表示前\r\n 和剩余的  个数。\r\n因为要考虑奇偶，所以第一个堆要维护奇偶的数的数量和它们的和，时间复杂度\r\n\r\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788CL MXX(1e5 + 5), INF(1e15);int n, a[MXX], b[MXX], c[MXX];LL f[2][MXX], cnt1, cnt2, cnt, sum1, sum2, sum, ans(INF);I LL GetVal(int v) {    LL res(sum - 1ll * v * cnt);    if(v &amp; 1)        res += (1ll * v * cnt1 - sum1) / 2 + (1ll * (v + 1) * cnt2 - sum2) / 2 + cnt2;    else        res += (1ll * v * cnt2 - sum2) / 2 + (1ll * (v + 1) * cnt1 - sum1) / 2 + cnt1;    Heriko res;}I void ADD1(int x, int v) {    if(x &amp; 1)        cnt1 += v, sum1 += x * v;    else        cnt2 += v, sum2 += x * v;}I void Solve(int opt, int d) {    if(opt)        for(int i(1); i &lt;= n; ++ i)            b[i] = c[i] - (i - 1) * d;    if(!opt)        for(int i(1); i &lt;= n; ++ i)            b[i] = a[i] - (i - 1) * d;    priority_queue&lt;int&gt; q1;    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q2;    cnt = cnt1 = cnt2 = sum = sum1 = sum2 = 0;    for(int i(1); i &lt;= n; ++i) {        if(q1.empty() or q1.top() &gt;= b[i])            q1.emplace(b[i]), ADD1(b[i], 1);        else            q2.emplace(b[i]), cnt ++, sum += b[i];        while((int)q1.size() &gt; i - (i + 2) / 3 + 1) {            int tp(q1.top());            q1.pop(), ADD1(tp, -1);            q2.emplace(tp), cnt ++, sum += tp;        }        while((int)q1.size() &lt; i - (i + 2) / 3 + 1) {            int tp(q2.top());            q2.pop(), -- cnt, sum -= tp;            q1.emplace(tp), ADD1(tp, 1);        }        int tp(q1.top());        f[opt][i] = Hmin(GetVal(tp), GetVal(tp - 1));    }}I LL KND(int x) {    Solve(0, x), Solve(1, -x);    LL res(INF);    for(int i(1); i &lt;= n; ++ i)        res = Hmin(res, f[0][i] + f[1][n - i]);    Heriko res;}S main() {    Files();     fr(n);    int mx(0);    for(int i(1); i &lt;= n; ++ i)        fr(a[i]), mx = Hmax(mx, a[i]), c[n - i + 1] = a[i];    mx = mx * 4 / n + 1;    for(int i(-mx); i &lt;= mx; ++ i)        ans = Hmin(ans, KND(i));    fw(ans, 1);    Heriko Deltana;}\r\n10.11\r\nNOIP20-2\r\n2\r\n今天 A 很简单，也没挂，B\r\n想了大约一个小时想不出来如何去排放这些质数，最后打了个  分的表。\r\n然后看 C\r\n发现应该是一个手模之后有一定的规律的结论，所以觉得暴力不好打，就去写 D\r\n的暴力。\r\n因为 D 是两个图，所以直接去先去暴力拿分，然后最后最大值设小了，就亏了\r\n 分。\r\n因为 C 我感觉比较科幻写不出来代码，而 D\r\n涉及到淀粉质我不会写所以这俩先只写思路。\r\nA\r\n手模 2 2 的样例转换出来这样的状态矩阵：\r\n1200 0110 11\r\n那么我们可以发现对于题目所问的\r\nh m，可以变成这样的一个状态矩阵：\r\n123400 01 02 ... 0(m - 1)10 11 12 ... 1(m - 1)...(h - 1)1 ... (h - 1)(m - 1) \r\n然后就可以发现在 00 到 (h - 1)(m - 1)\r\n这题对角线之上的都是合法的状态（包括这条对角线）\r\n那么可以发现，构成的这个倒三角里面状态个数为一个公差为  的等差序列。\r\n若 ，那么这个等差序列的首项为 ，否则则为 。\r\n题目要求约分，整个 \r\n就行。\r\n123456789101112131415161718192021222324252627282930#define int long longint GCD(int x, int y) {    Heriko !y ? x : GCD(y, x % y);}I int SUM(int x) {    Heriko (1ll + x) * x / 2ll;}S main() {    Files();    int h, m, res1, res2;    fr(h), fr(m), res2 = h * m;    if(m &lt;= h)        res1 = SUM(m);    else        res1 = SUM(m) - SUM(m - h);    if(res1 == res2)        puts(\"1\");    else {        int g(GCD(res1, res2));        fw(res1 / g, 0), fw(res2 / g, 1);    }    Heriko Deltana;}\r\nB\r\n场上手模到  发现  部分分为 \r\n于是就打了个表上去，虽然一直感觉很接近正解，但是就是没想出来。\r\n不难发现其实是让我们把 \r\n以内的质数使用他们的公因数连接起来。\r\n考虑使用质数的  倍数和质数的\r\n\r\n倍数来进行质数之间的连接，而显然对于  倍数和  倍数都  的质数不用考虑，它不会出现在这个序列中，而仅满足 \r\n的质数最多可以放置两个在序列的两端，在下面我们把它们称作  和 \r\n那么最后要构造出这样一个序列：\r\n代码其实不好写，感觉细节不好写（把打的表也放上了）\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155CI MXX(1e6 + 5);int n;I void MIN30() {    if(n == 4)        puts(\"2\"), puts(\"2 4\");    else if(n == 5)        puts(\"2\"), puts(\"2 4\");    else if(n == 6)        puts(\"4\"), puts(\"3 6 2 4\");    else if(n == 7)        puts(\"4\"), puts(\"3 6 2 4\");    else if(n == 8)        puts(\"5\"), puts(\"3 6 2 4 8\");    else if(n == 9)        puts(\"6\"), puts(\"3 9 6 2 4 8\");    else if(n == 10)        puts(\"8\"), puts(\"3 9 6 2 4 8 10 5\");    else if(n == 11)        puts(\"8\"), puts(\"3 9 6 2 4 8 10 5\");    else if(n == 12)        puts(\"9\"), puts(\"3 9 6 12 2 4 8 10 5\");    else if(n == 13)        puts(\"9\"), puts(\"3 9 6 12 2 4 8 10 5\");    else if(n == 14)        puts(\"11\"), puts(\"7 14 6 3 9 12 2 4 8 10 5\");    else if(n == 15)        puts(\"12\"), puts(\"7 14 6 3 9 12 2 4 8 10 5 15\");    else if(n == 16)        puts(\"13\"), puts(\"7 14 6 3 9 12 2 4 8 16 10 5 15\");    else if(n == 17)        puts(\"13\"), puts(\"7 14 6 3 9 12 2 4 8 16 10 5 15\");    else if(n == 18)        puts(\"14\"), puts(\"7 14 6 3 9 12 2 4 8 16 18 10 5 15\");    else if(n == 19)        puts(\"14\"), puts(\"7 14 6 3 9 12 2 4 8 16 18 10 5 15\");    else if(n == 20)        puts(\"15\"), puts(\"7 14 6 3 9 12 2 4 8 16 18 20 10 5 15\");    else if(n == 21)        puts(\"16\"), puts(\"7 14 21 3 6 9 12 2 4 8 16 18 20 10 5 15\");    else if(n == 22)        puts(\"18\"), puts(\"7 14 21 3 6 9 15 12 2 4 8 16 18 10 5 20 22 11\");    else if(n == 23)        puts(\"18\"), puts(\"7 14 21 3 6 9 15 12 2 4 8 16 18 10 5 20 22 11\");    else if(n == 24)        puts(\"19\"), puts(\"7 14 21 3 6 9 15 12 2 4 8 16 18 24 10 5 20 22 11\");    else if(n == 25)        puts(\"20\"), puts(\"7 14 21 3 6 9 15 12 2 4 8 16 18 24 10 5 25 20 22 11\");    else if(n == 26)        puts(\"22\"), puts(\"13 26 14 7 21 3 6 9 15 12 2 4 8 16 18 24 10 5 25 20 22 11\");    else if(n == 27)        puts(\"23\"), puts(\"13 26 14 7 21 3 6 9 15 27 12 2 4 8 16 18 24 10 5 25 20 22 11\");    else if(n == 28)        puts(\"24\"), puts(\"13 26 14 7 21 3 6 9 15 27 12 2 4 8 16 18 24 28 10 5 25 20 22 11\");    else if(n == 29)        puts(\"24\"), puts(\"13 26 14 7 21 3 6 9 15 27 12 2 4 8 16 18 24 28 10 5 25 20 22 11\");    else if(n == 30)        puts(\"25\"), puts(\"13 26 14 7 21 3 6 9 12 15 18 24 27 30 2 4 8 16 28 10 5 25 20 22 11\");}int prime[MXX], cnt, q;bool nopr[MXX];I void Es() {    nopr[1] = 1;    for(int i(2); i &lt;= n; ++ i) {        if(!nopr[i])            prime[++ cnt] = i;        for(int j(1); j &lt;= cnt and prime[j] * i &lt;= n; ++ j) {            nopr[i * prime[j]] = 1;            if(i % prime[j] == 0)                break;        }    }}vector&lt;int&gt; ans;int co[MXX];I void ADD(int x, int v) {    if(!co[x] or v)        co[x] = 1, ans.emplace_back(x);}S main() {    Files();    fr(n);        if(n &lt;= 30) {        MIN30();        Heriko Deltana;    }    Es();    while(prime[cnt] * 2 &gt; n)        -- cnt;        if(prime[cnt] * 3 &gt; n)        ADD(prime[cnt], 0), ADD(2 * prime[cnt], 0), -- cnt;    ADD(4, 0), co[12] = 1;    if(prime[cnt] * 3 &gt; n)        co[prime[cnt] * 2] = 1;    for(int i(1); i &lt;= cnt; ++ i)        if(prime[i] * 3 &lt;= n)            co[prime[i] * 2] = co[prime[i] * 3] = 1;    int lst(2);    for(int i(1); i &lt;= cnt; ++ i) {        if(prime[i] * 3 &lt;= n) {            if(lst == 2)                ADD(prime[i] * 2, i != 1);            else                ADD(prime[i] * 3, 1);            ADD(prime[i], 0);            for(int j(4); j * prime[i] &lt;= n; ++ j)                ADD(prime[i] * j, 0);                        if(lst == 2)                ADD(prime[i] * 3, 1);            else                ADD(prime[i] * 2, i != 2);            lst = i == 2 ? lst : 5 - lst;        }    }    ADD(12, 1);    if(prime[cnt] * 3 &gt; n)        ADD(prime[cnt] * 2, 1), ADD(prime[cnt], 0);    fw(ans.size(), 1);    for(int i : ans)        fw(i, 0);    puts(\"\");    Heriko Deltana;}\r\nC\r\n考虑有限和无限的团队如何区分：有限的团队一定在偶数位置上，而奇数位置上一定是无限团队，而\r\n\r\n的位置需要特判（场上好多人因为没判断这个从  被卡到 ）\r\n而有限的团队的每个人之间的间隔是相同的。\r\n于是有限团队就被无限团队分割，对于开头位置可以用前缀和加二分得到，而对于非开头的位置一直除以\r\n 就也能得到，因为  的值域是 ，所以最多做这个除法  次。\r\n中间那部分可以用维护加乘双 Tag\r\n的线段树，然后场上大多是都是写的这个。\r\n但是其实不需要，前缀和处理一下 \r\n次幂就能做，但是目前我还不会写。\r\nD\r\n需要对树进行质心分解，也就是点分治，然后通过 \r\n来转化树上两点之间的距离，而我不会淀粉质，所以这玩意先不写了。\r\n因为在质心树上每个结点最多有  个祖先，所以可以考虑枚举 ，那么会有  种组合，也就是目前已知的是一对\r\n 和 ，但是发现对于  这个限制，其实不是很好找 \r\n于是考虑到如果去暴力枚举所有的子树的顶点，那么求得的答案要不然符合要求，要不然他的\r\n\r\n这个子树中，这样就有了约束，最后复杂度为 \r\n但是我还是觉得最后这个操作非常玄幻所以我还是不会写。\r\n10.10\r\nNOIP20-1\r\n1\r\n大家好，呢首先我考场懒得写 70 分然后后来发现我写不了 70\r\n分了，然后就去写 C 了，我整了个哇，很科幻的线段树优化建图跑\r\nSPFA，哇，就是说什么呢，我写挂了，然后我就直接睡觉去了，最后回来发现 A\r\n贪假了，爽。\r\nA\r\n 贪心减去最小的  个 \r\n这题可以认为一半的人选 ，一半的人选 ，所以可以先假定所有人都选 ，然后就有了上面。\r\nB\r\n首先考虑枚举当前的种族，把他们的权值设置为 ，其他的设置为 ，那么原问题就变成了询问和大于  的连通块个数。\r\n显然我们只需要保留当前种族数量 \r\n的正负一倍之内的值即可，因为只有这些是有可能有贡献的答案。\r\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#define int long longCL MXX(3005), LMT(3000), MOD(998244353);int n, a[MXX], f[MXX][MXX &lt;&lt; 1], v[MXX], sz[MXX], m, g[MXX &lt;&lt; 1], ans;struct Edge {    int nex, to;}r[MXX &lt;&lt; 1];int head[MXX], rcnt;I void ADD(int x, int y) {    r[++ rcnt] = (Edge){head[x], y}, head[x] = rcnt;    r[++ rcnt] = (Edge){head[y], x}, head[y] = rcnt;}void DFS(int x, int fa) {    for(int i(-m); i &lt;= m; ++ i)        f[x][i + LMT] = 0;    f[x][LMT + v[x]] = 1;    sz[x] = 1;    for(int i(head[x]); i; i = r[i].nex)        if(r[i].to != fa)            DFS(r[i].to, x);            for(int i(head[x]); i; i = r[i].nex) {        int y(r[i].to);        if(y == fa)            continue;        for(int j(-m); j &lt;= m; ++ j)            g[j + LMT] = 0;        for(int j(Hmax(-m, -sz[x])); j &lt;= Hmin(m, sz[x]); ++ j)            for(int k(Hmax(-m, Hmax(-m - j, -sz[y]))); k &lt;= Hmin(m, Hmin(m - j, sz[y])); ++ k)                g[j + k + LMT] = (g[j + k + LMT] + f[x][j + LMT] * f[y][k + LMT] % MOD) % MOD;        sz[x] += sz[y];        for(int j(-m); j &lt;= m; ++ j)            (f[x][j + LMT] += g[j + LMT]) %= MOD;    }    for(int i(1); i &lt;= m; ++ i)        (ans += f[x][i + LMT]) %= MOD;}int co[MXX];S main() {    Files();    fr(n);    for(int i(1); i &lt;= n; ++ i)        fr(a[i]), co[a[i]] ++;    for(int i(1); i &lt; n; ++ i) {        int x, y;        fr(x), fr(y);        ADD(x, y);    }    for(int i(1); i &lt;= n; ++ i) {        for(int j(1); j &lt;= n; ++ j)            if(a[j] == i)                v[j] = 1;            else                v[j] = -1;        m = co[i];        DFS(1, 0);    }    fw(ans, 1);    Heriko Deltana;}\r\nC\r\n最初场上的想法是线段树优化建图，然后跑单源最短路，但是因为有负权所以只能用\r\nSPFA.\r\n而今天晚上发现转化点权那里写错了，应该拆点新建边，我觉得非常抽象而且难写而且估计过不了于是就没写。\r\n正解是把  拆成 \r\n然后按照  去建  棵树状数组维护 ，每次转移的时候枚举 ，时间复杂度 。\r\n还有 \r\n的做法，但是常数比较大，没有常数小的两个 \r\n快，而且我不会，就不写了。\r\n这个读入是题面给的，就直接用了。\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#define T (1&lt;&lt;15)char buf[T], *p1 = buf, *p2 = buf;#define nc() (p1 == p2 &amp;&amp; (p2 = buf + fread(p1 = buf, 1, T, stdin), p1 == p2) ? -1 : *p1 ++)LL rd(){    LL x = 0;    char c;    bool s = 0;    do        c = nc();    while(c!=45&amp;&amp;(c&lt;48||c&gt;57));    if(c == 45)        c = nc(), s = 1;        do        x = 10 * x + (c &amp; 15), c=nc();    while(c &gt;= 48 &amp;&amp; c &lt;= 57);    return s ? -x : x;}#undef TCL MXX(2e6 + 26), INF(1e15);#define int long longint n, K, D, H[MXX], T[MXX], f[MXX], ftr[MXX], dlt[MXX], mx[MXX], ans;vector&lt;int&gt; t[MXX];#define lowbit(x) ((x) &amp; (-x))I void ADDP(int x, int v) {    while(x &lt;= n) {        t[n + 2][x] = Hmax(t[n + 2][x], v);        x += lowbit(x);    }}I void ADDS(int x, int y, int v) {    ++ x, ++ y;    while(y &lt;= ftr[n] + 1) {        t[x][y] = Hmax(t[x][y], v);        y += lowbit(y);    }}int QueryP(int x) {    int res(-INF);    while(x)        res = Hmax(res, t[n + 2][x]), x -= lowbit(x);    Heriko res;}int QueryS(int x, int y) {    int res(-INF);    ++ x, ++ y;    while(y)        res = Hmax(res, t[x][y]), y -= lowbit(y);    Heriko res;}S main() {    Files();    n = rd(), K = rd(), D = rd();    for(int i(1); i &lt;= n; ++ i)        ftr[i] = i / K, dlt[i] = i % K;    for(int i(1); i &lt;= n; ++ i)        H[i] = rd();    for(int i(1); i &lt; n; ++ i)        T[i] = rd();    for(int i(0); i &lt;= K; ++ i)        t[i].assign(n / K + 5, -INF);    t[n + 2].assign(n + 2, -INF);    for(int i(n); i; -- i) {        if(i == n)            f[i] = 0;        else {            f[i] = QueryP(i + T[i]) + D * ftr[i];            f[i] = Hmax(f[i], QueryS(Hmin(dlt[i] - 1, dlt[i + T[i]]), ftr[i + T[i]]) + D * (ftr[i] + 1));            f[i] = Hmax(f[i], QueryS(dlt[i] - 1, ftr[i + T[i]] - 1) + D * (ftr[i] + 1));        }        f[i] += H[i];        ADDP(i, f[i] - D * ftr[i]);        if(!dlt[i]) {            mx[i] = f[i] - D * ftr[i];            ADDS(dlt[i], ftr[i], mx[i]);            for(int j(i + 1); j - K &lt; i and j &lt;= n; ++ j) {                mx[j] = Hmax(mx[j - 1], f[j] - D * ftr[j]);                ADDS(dlt[j], ftr[j], mx[j]);            }        }    }    for(int i(1); i &lt;= n; ++ i)        ans ^= (f[i] + i);    fw(ans, 1);    Heriko Deltana;}\r\nD\r\nD 是个结论题，明天搞。\r\n第二天早上起来发现看了一早上也没看懂，不补了，不会。\r\n10.9\r\n昨天整了三道题加老师的一道作为模拟赛，成为了 SteamOJ 上第一场没人 AK\r\n的模拟赛）\r\n这两天其实一直没有干什么，不过明天就要开 20 连测了。\r\n\r\n因为 #115.\r\n菠萝披萨的 std 被 zyc Hack 了，所以我简单排一下今天任务。\r\n\r\n\r\nRELOAD 数位\r\nDP 至本博客。\r\n\r\n修复 #115. 的 std.\r\n\r\n9.28\r\n简单说一下 SteamOJ\r\n#76..\r\n首先考虑覆盖关系，我们让最小面积的矩形当作树根，然后就能构造出来一个森林。\r\n然后我们考虑类似扫描线的处理方式，把询问离线拆分为开始和结束的两端，再排序，然后来一个动态开点的线段树作区间覆盖。\r\n最后启发式合并统计答案，复杂度为 ，瓶颈在于启发式合并。\r\n比较奇怪，反正我在本地 SEGMENT FAULT，但是在 SteamOJ\r\n和洛谷上都能过。\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#define int long longCI MXX(160005), INF(1e9 + 5);struct Question {    int X, Y, Z, T, ID;    I bool operator &lt; (const Question &amp;co) const {        Heriko X == co.X ? T &lt; co.T : X &lt; co.X;    }}q[MXX &lt;&lt; 1];int fa[MXX], ans[MXX], ln;set&lt;int&gt; s[MXX];vector&lt;int&gt; r[MXX];void DFS(int x) {    if(!fa[x])        fa[x] = x;    int mxson(x);    for(int y : r[x]) {        DFS(y);        if(s[fa[y]].size() &gt; s[fa[mxson]].size())            mxson = y;    }    swap(fa[x], fa[mxson]);    for(auto y : r[x])        for(auto z : s[fa[y]])            s[fa[x]].insert(z);    ans[x] = s[fa[x]].size();}int lc[MXX &lt;&lt; 4], rc[MXX &lt;&lt; 4], v[MXX &lt;&lt; 4], tg[MXX &lt;&lt; 4];int rt, tcnt;#define lc(x) lc[x]#define rc(x) rc[x]I void Pushdown(int x) {    if(tg[x] != -1) {        v[lc(x)] = v[rc(x)] = tg[lc(x)] = tg[rc(x)] = tg[x];        tg[x] = -1;    }}void Modify(int &amp;x, int lx, int rx, int l, int r, int val) {    if(!x)        x = ++ tcnt;    if(lx &lt;= l and r &lt;= rx) {        v[x] = tg[x] = val;        Heriko;    }    Pushdown(x);    int mid((l + r) &gt;&gt; 1);    if(lx &lt;= mid)        Modify(lc(x), lx, rx, l, mid, val);    if(rx &gt; mid)        Modify(rc(x), lx, rx, mid + 1, r, val);}int Query(int x, int l, int r, int pos) {    if(!x)        Heriko -1;    if(l == r)        Heriko v[x];    Pushdown(x);    int mid((l + r) &gt;&gt; 1), res(0);    if(pos &lt;= mid)        res = Query(lc(x), l, mid, pos);    else        res = Query(rc(x), mid + 1, r, pos);    if(res == -1)        Heriko v[x];    else        Heriko res;}int n, m, lmt, fath[MXX];S main() {    Files();    fr(n), fr(m), lmt = n * 2 + m;    for(int i(1); i &lt;= n; ++ i) {        int x,y,z,w;        fr(x), fr(y), fr(z), fr(w);        q[++ ln] = (Question){x, y, w, -1, i};        q[++ ln] = (Question){z, y, w, 1, i};         }    for(int i(1); i &lt;= m; ++ i) {        int x, y, z;        fr(x), fr(y), fr(z);        q[++ ln] = (Question){x, y, y, 0, z};    }        sort(q + 1, q + 1 + ln), mst(v, -1), mst(tg, -1);    for(int i(1); i &lt;= ln; ++ i) {        if(q[i].T == 1)            Modify(rt, q[i].Y, q[i].Z, 1, INF, fath[q[i].ID]);        else if(q[i].T == -1) {            int f(Query(rt, 1, INF, q[i].Y));            if(f == -1)                f = 0;                        fath[q[i].ID] = f;            r[f].emplace_back(q[i].ID);            Modify(rt, q[i].Y, q[i].Z, 1, INF, q[i].ID);        }        else {            int res(Query(rt, 1, INF, q[i].Y));            if(res != -1)                s[res].insert(q[i].ID);        }    }    DFS(0);    for(int i(1); i &lt;= n; ++i)        fw(ans[i], 1);    Heriko Deltana;}\r\n9.24 ~ 9.26\r\nCSP7-5\r\n就是说什么呢，科幻的普及组题，hyl 直接 AK.\r\n我怒挂 80 变成 220.\r\n5\r\nA\r\n签到题不说。\r\nB\r\n场上看似是 DP，其实是规律，但是 DP 是对的，但是我挂分了（\r\n首先可以发现正数可以全都选完，所以答案里一定是有全部的正数。\r\n然后设  来表示选完前\r\n 个，第  Alice 选或没选的最大值。\r\n首先对于 ，上一个 Alice\r\n选不选都可以，所以从 \r\n中挑选最大值然后加上当前位置的数即可。\r\n然后对于 ，上一个必须是\r\nAlice 选的，所以直接继承 \r\n的值。\r\n还有一个特殊情况：当没有负数的时候第一个数 Alice 必须选，所以需要在\r\nDP 转移之前特判一下。\r\n因为是简单 DP 所以代码不放了。\r\nC\r\n朴素的暴力是前缀和处理一下在 \r\n有多少个奇数，然后枚举区间，如果当前区间的奇数个数为偶数个，那么这个区间就是可行的，复杂度为\r\n\r\n然后经过一顿思考发现并不能在这条路上降低复杂度，我最多能根据这个想法再除掉一些常数，但是显然没有什么用。\r\n然后发现 ，而平均数并不会超过序列中的任何数，所以可以枚举这个平均数，前缀和一下之后加上所有多次出现的差值，复杂度为\r\n\r\n1234567891011121314151617181920212223242526272829303132333435CI MXX(2e7+5),LMT(1e7);#define int long longint n,a[MXX],co[MXX],mx,ans,ro[MXX];S main() {    Files();    fr(n);    for(int i(1);i&lt;=n;++i)        fr(a[i]),mx=max(mx,a[i]);    for(int i(1);i&lt;=n;++i)        co[i]+=co[i-1]+a[i];    for(int i(1);i&lt;=mx;++i) {        for(int j(1);j&lt;=n;++j)            co[j]-=i*j;        for(int j(0);j&lt;=n;++j)            ++ro[co[j]+LMT];        for(int j(0);j&lt;=n;++j)            --ro[co[j]+LMT],ans+=ro[co[j]+LMT];        for(int j(1);j&lt;=n;++j)            co[j]+=i*j;    }    fw(ans,1);    Heriko Deltana;}\r\nD\r\n首先解决：连通块？冰茶姬！\r\n当然如果当前连通块的个数不足 ，那么肯定没有解。\r\n否则把这些连通块按照大小升序排列，然后处理出来边数的上下界，如果\r\n\r\n不在这个区域内则无解，否则直接枚举输出解即可。\r\n其实不太好说，但是代码结构还是清晰的，尝试了一下行上更加宽松的码风。\r\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697CI MXX(5e5 + 5);int n, m, X, q, fa[MXX];int Find(int x) {    if(x != fa[x])        fa[x] = Find(fa[x]);    Heriko fa[x];}vector&lt; vector&lt;int&gt; &gt; s(MXX);vector&lt;int&gt; l;S main() {    Files();    fr(n), fr(m), fr(X), fr(q);    for(int i(1); i &lt;= n; ++ i)        fa[i] = i;    for(int i(1); i &lt;= q; ++ i) {        int x, y;        fr(x), fr(y), -- x, -- y;        int fx(Find(x)), fy(Find(y));        if(fx != fy)            fa[fx] = fy;    }    for(int i(0); i &lt; n; ++ i)        s[Find(i)].emplace_back(i);    s.erase(remove_if(s.begin(), s.end(), [&amp;](auto &amp;v){Heriko v.empty();}), s.end());    sort(s.begin(), s.end(), [&amp;](auto &amp;c, auto &amp;d){Heriko c.size() &lt; d.size();});    if(int(s.size()) &lt; X)        fw(-1, 1), exit(0);    while(int(s.size()) &gt; X) {        auto &amp;x(s[s.size() - 2]), &amp;y(s[s.size() - 1]);        swap(x,y);        x.insert(x.end(), y.begin(), y.end());        s.pop_back();    }    LL x(0), y(0), z(0);    for(auto &amp;i : s) {        x += (i.size() == 1 ? 0 : i.size());        y += 1ll * i.size() * (i.size() - 1 + z);        z += i.size();    }    if(m &lt; x or y &lt; m)        fw(-1, 1), exit(0);    for(auto &amp;x : s)        if(x.size() != 1) {            int sz(x.size());            for(int i(0); i &lt; sz; ++ i)                fw(x[i] + 1, 0), fw(x[(i + 1) % sz] + 1, 1);        }    m -= x;    for(auto &amp;x : s) {        int sz(x.size());        for(int i(0); i &lt; sz; ++ i) {            for(int j(0); j &lt; sz; ++ j)                if(i != j and (i + 1) % sz != j) {                    -- m;                    if(m &lt; 0)                        exit(0);                    fw(x[i]+1, 0), fw(x[j]+1, 1);                }            for(auto j : l) {                -- m;                if(m &lt; 0)                    exit(0);                fw(x[i] + 1, 0), fw(j + 1, 1);            }        }        l.insert(l.end(), x.begin(), x.end());    }    Heriko Deltana;}\r\nNOIP10-4\r\n4\r\nA\r\n考虑贪心，发现对于相邻的三个数 ，只有两种情况即 \r\n或 ，所以根据  和  的大小关系判断，但是只有  的时候才会使得 ，所以我们找到第一个出现的 ，后面的都当作 \r\n的幂数不用考虑，前面以此做幂运算即可。\r\nB\r\n首先求出原本的最小生成树，将每两个点之间的路径上的最大值放到一个序列里，同时把没在图上的边放到另外一个序列里，然后这个两个序列分别升序排列之后去做匹配即可，这样做是\r\n 的。\r\n考虑对这个优化，考虑到那些最大值可能会出现多次，那么可以直接通过枚举边然后求出其连接的两个连通块大小，那么经过它的重复次数就是这两个连通块大小再减一，这个可以通过冰茶姬实现，最终复杂度\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include&lt;bits/stdc++.h&gt;#define mset(a,b) memset((a),(b),sizeof((a)))#define rep(i,l,r) for(int i=(l);i&lt;=(r);i++)#define dec(i,l,r) for(int i=(r);i&gt;=(l);i--)#define cmax(a,b) (((a)&lt;(b))?(a=b):(a))#define cmin(a,b) (((a)&gt;(b))?(a=b):(a))#define Next(k) for(int x=head[k];x;x=li[x].next)#define vc vector#define ar array#define pi pair#define fi first#define se second#define mp make_pair#define pb push_back#define N 500010#define M numberusing namespace std;typedef double dd;typedef long double ld;typedef long long ll;typedef unsigned int uint;typedef unsigned long long ull;#define int long longtypedef pair&lt;int,int&gt; P;typedef vector&lt;int&gt; vi;const int INF=0x3f3f3f3f;const dd eps=1e-9;template&lt;typename T&gt; inline void read(T &amp;x) {    x=0; int f=1;    char c=getchar();    for(;!isdigit(c);c=getchar()) if(c == '-') f=-f;    for(;isdigit(c);c=getchar()) x=x*10+c-'0';    x*=f;}vi e[N&lt;&lt;1];namespace LCA{    int fa[N][21],dep[N];    inline void dfs(int k,int fat){        fa[k][0]=fat;        rep(i,1,20) fa[k][i]=fa[fa[k][i-1]][i-1];        dep[k]=dep[fat]+1;        for(int to:e[k]){            dfs(to,k);        }    }    inline int ge(int a,int b){        if(dep[a]&lt;dep[b]) swap(a,b);        dec(i,0,20) if(dep[fa[a][i]]&gt;=dep[b]) a=fa[a][i];        if(a==b) return a;        dec(i,0,20) if(fa[a][i]!=fa[b][i]) a=fa[a][i],b=fa[b][i];        return fa[a][0];    }}using LCA::ge;using LCA::dfs;int n,m;struct edge{    int u,v,w;    inline bool operator &lt; (const edge &amp;b)const{return w&lt;b.w;}}li[N&lt;&lt;1];int tail,fa[N],siz[N],tot,a[N],sum[N];map&lt;ll,ll&gt; cnt;vi v,pas,nowval;bool vis[N];inline int Find(int x){return x==fa[x]?x:fa[x]=Find(fa[x]);}inline int Cnt(int val){    int num=upper_bound(nowval.begin(),nowval.end(),val)-nowval.begin();    return num;}inline int GetVal(int rk){    int l=1,r=n*(n-1)/2;    while(l&lt;r){        int mid=(l+r)&gt;&gt;1;        int cntmid=Cnt(mid);        if(mid-cntmid&gt;=rk) r=mid;        else l=mid+1;    }    return l;}signed main(){    read(n);read(m);    rep(i,1,m){        int u,v,w;read(u);read(v);read(w);        li[i]={u,v,w};        nowval.pb(w);    }    sort(nowval.begin(),nowval.end());    rep(i,1,n) fa[i]=i,siz[i]=1;    rep(i,n+1,2*n) fa[i]=i;    sort(li+1,li+m+1);    tot=n;    v.clear();v.pb(-1);    rep(i,1,m){        int fau=Find(li[i].u),fav=Find(li[i].v);        if(fau==fav){            pas.pb(i);            continue;        }        tot++;        vis[i]=1;        e[tot].pb(fau);        e[tot].pb(fav);siz[tot]=siz[fau]+siz[fav];        a[tot]=li[i].w;        fa[fau]=tot;fa[fav]=tot;        cnt[li[i].w]=siz[fau]*siz[fav];        v.pb(li[i].w);    }    for(int i=1;i&lt;v.size();i++){        assert(cnt[v[i]]);        cnt[v[i]]--;    }    dfs(tot,0);    for(int id:pas){        int l=ge(li[id].u,li[id].v);        assert(a[l]);        cnt[a[l]]--;    }    for(int i=1;i&lt;v.size();i++){        sum[i]=sum[i-1]+cnt[v[i]];    }    for(int i=1;i&lt;v.size();i++){        int nv=GetVal(sum[i-1]+1);        int val=GetVal(sum[i-1]+1);        assert(val!=v[i]);        if(val&lt;v[i]){            puts(\"No\");return 0;        }    }    puts(\"Yes\");    return (0-0);}\r\nC\r\n首先考虑  是排列的情况，若\r\n，因为  被从堆里拿出来之后一定是空的，那么说明\r\n 序列中的前  个元素恰好是  中的前  个元素，所以这个问题被  的位置分为了两部分，\r\n那么考虑分治，考虑子问题的形式，我们始终是考虑当前序列的最大值，枚举其在\r\n\r\n中的位置，然后分治成两边，其中左边要把最大值删去。因此子问题中的序列\r\n 一定是原序列  的某个区间 \r\n中删掉了一些比较大的值后组成的子序列。\r\n设  表示  中不超过  的数构成的子序列的答案，若  不在这个区间中那么继承  的值，否则枚举  的位置 ，即：\r\n\r\n如果不是排列的话考虑到如果一个数字出现了多次就可以按照下标把他们看成不同的即可。\r\n12345678910111213141516171819202122232425262728293031323334353637383940414243CI MXX(105), MOD(998244353);int n, a[MXX], b[MXX], x[MXX], c[MXX], f[MXX][MXX][MXX], ln; S main() {    Files();    fr(n);    for(int i(1); i &lt;= n; ++ i)        fr(a[i]), b[i] = i, c[i] = a[i];    sort(c + 1, c + 1 + n);    for(int i(1); i &lt;= n; ++ i) {        a[i] = b[lower_bound(c + 1, c + 1 + n, a[i]) - c] ++;        x[a[i]] = i;    }    f[0][0][0] = 1;    for(int i(1); i &lt;= n + 1; ++ i)        for(int j(0); j &lt;= n + 1; ++ j)            f[i][i-1][j] = 1, f[i][j][0] = 1;    for(int i(n); i ; -- i)        for(int j(i); j &lt;= n; ++ j)            for(int k(1); k &lt;= n; ++ k)                if(x[k] &lt; i or x[k] &gt; j)                    f[i][j][k] = f[i][j][k - 1];                else if(a[i] &gt; k)                    f[i][j][k] = f[i + 1][j][k];                else if(a[j] &gt; k)                    f[i][j][k] = f[i][j - 1][k];                else                    for(int w(x[k]); w &lt;= j; ++ w)                        if(a[w] &lt;= k)                            f[i][j][k] = (f[i][j][k] + 1ll * f[i][w][k - 1] * f[w + 1][j][k] % MOD) % MOD;    fw(f[1][n][n], 1);    Heriko Deltana;}\r\n9.21\r\nSteamOJ\r\n\r\n#37~#40 Done.\r\n#16 Done.\r\n\r\n9.19 ~ 9.20\r\nCSP7-4\r\n4\r\n这出题人习惯是不是不太好，题面不放样例。\r\nA\r\n做这个题引起我对初赛的不好回忆，但是显然这比那随机数初赛杨戬多了。\r\n首先可以发现 qsort() 会被以及升序排列好的数列卡到 ，五十分解决。\r\nqsort2() 加入了一个\r\nrandint()，但是并不是随机的 randint()\r\n就显得有点弱（\r\n于是我们就可以根据这个 randint()\r\n把我们的序列变成它过一遍 randint()\r\n之后会变成升序的序列，然后我 DFS\r\n里的第七、八行位置调了半天，原因是我没看见 static 会让每次 RandInt\r\n的值不一样。\r\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849CL MXX(505),INF(2147483647);int t,n,d;int RandInt() {    static unsigned s(0x80000001);    unsigned long t(s);    t^=t&gt;&gt;10,t^=t&lt;&lt;9,t^=t&gt;&gt;25;    s=t;    Heriko (t&amp;INF);}int a[MXX];void DFS(int x) {    if(x&lt;=1) {        a[x-1]=x;        Heriko;    }    int t(RandInt()%x);    DFS(x-1);    a[x-1]=a[0],a[0]=a[t],a[t]=x;}S main() {    Files();    fr(t),fr(n),fr(d),fw(n,1);    if(t==0) {        for(int i(1);i&lt;=n;++i)            fw(i,0);        puts(\"\");    }    else {        DFS(n);        for(int i(1);i&lt;=n;++i)            fw(a[i-1],0);        puts(\"\");    }    Heriko Deltana;}\r\nB\r\n非常好题目。但是大家都踩了 std 想法。\r\n一个单纯的想法是钦定当前的 \r\n为最小值，那么在他之前的 \r\n都应为后缀最小值，在他之后的都应为前缀最小值，当然，如果有不合适的情况就需要具体改变。\r\n那么我们可以处理出来当前 \r\n能不能做前缀最小值/后缀最小值，最后枚举 \r\n作为最小值看看能不能拼出来合法的序列。\r\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667template&lt;typename J&gt;I J Hmin(const J &amp;x,const J &amp;y) {    Heriko x&lt;y?x:y;}CI MXX(1e6+5),INF(0x7fffffff),LMT(1e5);int n,a[MXX],b[MXX],mi(INF),f[MXX],g[MXX];S main() {    Files();    fr(n);    for(int i(1);i&lt;=n;++i)        fr(b[i]),mi=Hmin(mi,b[i]);    int lst(INF);    for(int i(1);i&lt;=n;++i)        if(b[i]!=mi) {            if(b[i]&gt;lst)                break;            else                f[i]=1,lst=b[i];        }        else f[i]=1;    lst=INF;    for(int i(n);i;--i)        if(b[i]!=mi) {            if(b[i]&gt;lst)                break;            else                g[i]=1,lst=b[i];        }        else g[i]=1;    for(int ln(1);ln&lt;=n;++ln) {        if(b[ln]!=mi or !f[ln] or !g[ln])            continue;        a[ln]=mi;        for(int i(1);i&lt;=n;++i) {            if(i==ln)                continue;            if(b[i]==mi)                a[i]=LMT;            else                a[i]=b[i];        }        for(int i(1);i&lt;=n;++i)            fw(a[i],0);                    puts(\"\");        Heriko Deltana;    }    puts(\"cut_the_watermelon_with_a_hand\");    Heriko Deltana;}\r\nC\r\n其实题还不算难想但是为什么我写了个奇怪的 UB 卡了一下午。\r\n设  表示在  的子树中有一条不含匹配的从  开始的长度为  的链。\r\n如果强制将链两端的点匹配，那么中间其实是个卡斯兰数，而两条链  的答案合并需要加上 ，这个  是 \r\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y) {    Heriko x&gt;y?x:y;}CL MXX(2015),MOD(998244353);#define int long longvector&lt;int&gt; r[MXX];int n,h[MXX];I void Pre() {    h[0]=h[2]=1;    for(int i(4);i&lt;=n;i+=2)        for(int j(2);j&lt;=n;j+=2)            h[i]=(h[i]+h[i-j]*h[j-2])%MOD;}int f[MXX][MXX],g[MXX],ln[MXX];void DFS(int x,int fa) {    f[x][1]=ln[x]=1;    for(int y:r[x])        if(y!=fa)            DFS(y,x);    for(int y:r[x]) {        if(y==fa)            continue;        for(int i(0);i&lt;=ln[x];++i)            g[i]=f[x][i],f[x][i]=f[x][i]*f[y][0]%MOD;        for(int i(2);i&lt;=ln[x];++i)            for(int j(1);j&lt;=ln[y];++j)                f[x][0]=(f[x][0]+g[i]*f[y][j]%MOD*h[i+j-2]%MOD)%MOD;        for(int i(1);i&lt;=ln[y];++i)            f[x][i+1]=(f[x][i+1]+g[1]*f[y][i]%MOD)%MOD;        ln[x]=Hmax(ln[x],ln[y]+1);    }    for(int i(1);i&lt;=ln[x];++i)        f[x][0]=(f[x][0]+f[x][i]*h[i-2]%MOD)%MOD;}S main() {    Files();    fr(n),Pre();    for(int i(1);i&lt;n;++i) {        int x,y;        fr(x),fr(y);        r[x].emplace_back(y),r[y].emplace_back(x);    }    DFS(1,0);    fw(f[1][0]%MOD,1);    Heriko Deltana;}\r\n9.17 ~ 9.18\r\n初赛，详见CSP S1\r\n2022。\r\n9.14 ~ 9.16\r\n复习初赛，给 SteamOJ 搬题（\r\n9.12 ~ 9.13\r\nCSP7-3\r\n3\r\nA\r\n场上 naive 了，忘了进一步看看，扔了个欧拉筛就跑后面去了。\r\n因为除了 \r\n以外所有的质数都是奇数，所有对于  的时候，对应的的区间  最多有  个质数。\r\n若 ，则可以发现， 的情况下都有超过  个质数， 就没有了，所以直接人工智能即可，代码狗都会写不放了。\r\nB\r\n就是说什么呢，我甚至无法成为一个人工智能，因为我人工智能都写错了。\r\n手摸样例题，首先根据题意知道了数据中都为  之类的矩形，根据样例手模可以发现  时，若  答案为 ，否则为 ，剩下的也都可以转化，设解决\r\n 的方案为 ，则有：\r\n\r\n，\r\n，\r\n，\r\n\r\n代码人工智能不放。\r\nC\r\n根据题意模拟即可，但是场上并没有看这道题，所以就放了。\r\n题解说有个复数类更好操作，其实直接模拟也不难。\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#define int long longCI MXX(2e7+5);char c;int a,b,ln;bool ans[MXX];template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y) {    Heriko x&gt;y?x:y;}template&lt;typename J&gt;I void fr(J &amp;x) {    short f(1);    x=0;    c=getchar();    if(c=='-')        f=-1,c=getchar();    while(c&gt;='0' and c&lt;='9') {        x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48);        c=getchar();    }    if(c=='i')        x=Hmax(x,1ll);    x*=f;}template&lt;typename J&gt;I void fw(J x,bool k) {    if(x&lt;0)        x=-x,putchar('-');    static short stak[35];    short top(0);    do {        stak[top++]=x%10;        x/=10;    }    while(x);    while(top)        putchar(stak[--top]+'0');    k?puts(\"\"):114514;}I void Into() {    int x;    fr(x);    if(c=='\\n')        a=x;    else if(c=='i')        b=x;    else if(c=='+')        a=x,fr(b);    else if(c=='-')        a=x,fr(b),b*=-1;}S main() {    Files();    Into();    if(!a and !b) {        puts(\"0\");        Heriko Deltana;    }    while(a|b) {        bool co((a&amp;1)!=(b&amp;1));        ans[++ln]=co;        a-=co;        int ta(a),tb(b);        a=(tb-ta)&gt;&gt;1,b=(-tb-ta)&gt;&gt;1;    }    for(int i(ln);i;--i)        fw(ans[i],0);    Heriko Deltana;}\r\nD\r\n首先呢我不是很理解为什么当时我写 Subtask2\r\n的时候把判断距离写着写着就写成了判断深度了，然后场上就爆零了（\r\n容易发现的是在 Sub2 的时候两者之间的路径长度若为偶数则 CQ 赢，否则 LF\r\n赢。而在整道题来看，可以根据这个来判断谁追谁跑（因为不是所有边两个人都可以用的），然后跑的最优策略是去到一个两端追方都无法到达的边达成平局（因为显然追方可以减少或维持追击距离，所以逃方没法赢，最多是平局），那么方案就是优先去比追方到达距离更短的点，所以两个\r\nDFS 分别来解决，先算距离，再求是否能平局。\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118I void fw(int x) {    if(x==0)        puts(\"Cuber QQ\");    else if(x==1)        puts(\"Little Fang\");    else        puts(\"Draw\");}CI MXX(1e5+5);struct Edge {    int nex,to,val;}r[MXX&lt;&lt;1];int rcnt,head[MXX];I void ADD(int x,int y,int z) {    r[++rcnt]=(Edge){head[x],y,z},head[x]=rcnt;    r[++rcnt]=(Edge){head[y],x,z},head[y]=rcnt;}int n,ln,st[2],dis[MXX][2];void DFS(int x,int fa,int nw) {    for(int i(head[x]);i;i=r[i].nex) {        int y(r[i].to),v(r[i].val);        if(y==fa)            continue;        if(y==st[nw^1])            ln=dis[x][nw]+1;        if(v!=(nw^1)) {            dis[y][nw]=dis[x][nw]+1;            DFS(y,x,nw);        }    }}int runner;bool RUN(int x,int fa) {    bool flg(0);    for(int i(head[x]);i;i=r[i].nex) {        int y(r[i].to),v(r[i].val);        if(y==fa or v==(runner^1) or (dis[y][runner^1]!=-1 and dis[y][runner]&gt;=dis[y][runner^1]))            continue;        if(dis[x][runner^1]==-1 and dis[y][runner^1]==-1)            Yoisaki Kanade;        flg|=RUN(y,x);    }    Heriko flg;}S main() {    Files();    fr(n),fr(st[0]),fr(st[1]);    int flg1(0),flg2(0);    mst(dis,-1);    for(int i(1);i&lt;n;++i) {        int x,y,z;        char s[10];        fr(x),fr(y),scanf(\"%s\",s+1);        if(s[3]=='u')            z=0;        else if(s[1]=='r')            z=1;        else            z=2;        ADD(x,y,z);        if(z!=1 and ((x==st[0] and y!=st[1]) or (y==st[0] and x!=st[1])))            flg1=1;                if(z!=0 and (x==st[1] or y==st[1]))            flg2=1;    }    if(!flg1) {        fw(1);        Heriko Deltana;    }        if(!flg2) {        fw(0);        Heriko Deltana;    }    for(int i(0);i&lt;=1;++i)        dis[st[i]][i]=0,DFS(st[i],0,i);    runner=(ln+1)&amp;1;    if(RUN(st[runner],0)) {        fw(2);        Heriko Deltana;    }    fw(runner^1);    Heriko Deltana;}\r\nNOIP10-3\r\n3\r\nA\r\n开一个桶，记一下有多少不重复能选即可。\r\n1234567891011121314151617181920212223242526272829vector&lt;string&gt; a,b;unordered_map&lt;string,bool&gt; vis;LL ans(1),cnt[30],co[30];S main() {    Files();    ON;    string s1,s2;    cin&gt;&gt;s1&gt;&gt;s2;    int n1(s1.size()),n2(s2.size());    for(int i(0);i&lt;n1;++i)        ++cnt[s1[i]-'a'];    for(int i(0);i&lt;=26;++i)        for(int j(0);j&lt;=26;++j)            if(i!=j)                co[i]+=cnt[j];    for(int i(0);i&lt;n2;++i)        ans+=co[s2[i]-'a'];    cout&lt;&lt;ans+n1+n2&lt;&lt;endl;    Heriko Deltana;}\r\nB\r\n设  为以  为根的子树， 的父边是否能选大于 \r\n的答案，考虑题目给出的东西的性质意思就是大于  的边的个数不超过 \r\n个。转移的时候分别算出当前这条边在大于和小于等于  情况下的最大答案  和 （按照两端的权值大小关系人工智能一下），默认\r\n 和  都是选的 ，然后排序  贪心选取即可。\r\n不过  只在当前  的时候才行。\r\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y) {    Heriko x&gt;y?x:y;}template&lt;typename J&gt;I J Hmin(const J &amp;x,const J &amp;y) {    Heriko x&lt;y?x:y;}CI MXX(5e5+5),INF(0x7fffffff);struct Edge {    int nex,to;}r[MXX&lt;&lt;1];int rcnt,head[MXX],outo[MXX];I void ADD(int x,int y) {    ++outo[x],++outo[y];    r[++rcnt]=(Edge){head[x],y},head[x]=rcnt;    r[++rcnt]=(Edge){head[y],x},head[y]=rcnt;}LL f[MXX][2],a[MXX];int n,m;void DFS(int x,int fa) {    LL sum(0),w1(0),w2(0);    vector&lt;LL&gt; v;    for(int i(head[x]);i;i=r[i].nex) {        int y(r[i].to);        if(y==fa)            continue;        DFS(y,x);        if(a[x]&lt;=a[y])            w1=a[x]+f[y][0],w2=Hmax(a[y]+f[y][0],m+f[y][1]);        else            w1=Hmax(a[y]+f[y][0],a[x]+f[y][1]),w2=m+f[y][1];        sum+=w1;        v.emplace_back(Hmax(0ll,w2-w1));    }    sort(v.begin(),v.end(),[](LL x,LL y){Heriko x&gt;y;});    f[x][0]=sum;    for(int i(0);i&lt;Hmin((int)v.size(),(outo[x]-1)&gt;&gt;1);++i)        f[x][0]+=v[i];    if(outo[x]&lt;=2) {        f[x][1]=-INF;        Heriko;    }    f[x][1]=sum;    for(int i(0);i&lt;Hmin((int)v.size(),(outo[x]-3)&gt;&gt;1);++i)        f[x][1]+=v[i];}S main() {    Files();    fr(n),fr(m);    for(int i(1);i&lt;=n;++i)        fr(a[i]);    for(int i(1);i&lt;n;++i) {        int x,y;        fr(x),fr(y);        ADD(x,y);    }    DFS(1,0);    fw(f[1][0],1);    Heriko Deltana;}\r\nC\r\n题意即要找出一个  满足 ，那么可以枚举 ，然后钦定这个  在答案中被选择，枚举  的因数  求出 ，这样的复杂度为 ，直接枚举还是会寄，但是发现随机选取一个\r\n 在最优解中的概率至少为 ，所以可以随机化一下  然后对着一个选择的 ，对  进行上述操作  次即可，这样就能做到正确率至少是 \r\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y) {    Heriko x&gt;y?x:y;}CI MXX(1e6+5);#define int long longint n,a[MXX],b[MXX],ans(1),co[MXX],tot[MXX];mt19937 knd(3316116355);int GCD(int x,int y) {    Heriko !y?x:GCD(y,x%y);}S main() {    Files();    fr(n);    for(int i(1);i&lt;=n;++i)        fr(a[i]);    int T(10);    while(T--) {        LL nw(a[knd()%n+1]),cnt(0);        for(int i(1);i*i&lt;=nw;++i)            if(nw%i==0) {                co[++cnt]=i;                if(i*i!=nw)                    co[++cnt]=nw/i;            }        sort(co+1,co+1+cnt);        mst(tot,0);        for(int i(1);i&lt;=n;++i)            ++tot[lower_bound(co+1,co+1+cnt,GCD(nw,a[i]))-co];        for(int i(1);i&lt;=cnt;++i)            for(int j(i+1);j&lt;=cnt;++j)                if(co[j]%co[i]==0)                    tot[i]+=tot[j];        for(int i(cnt);i;--i)            if((tot[i]&lt;&lt;1)&gt;=n) {                ans=Hmax(ans,co[i]);                break;            }    }    fw(ans,1);    Heriko Deltana;}\r\n\r\n12 号晚上一些人对着这个题 Hack\r\n上瘾了，本来就是一个随机化的题，你叉一两个也就算了，你对着固定模数叉，还对着\r\nstd 的 time(0) 叉，真的无语，纯粹就是找乐子。\r\n\r\n9.10 ~ 9.11\r\nCSP7-3 只有 30，下大分。\r\nNOIP7-3 只有 T1 A 了，寄。\r\n9.7\r\nHerikoDeltana 于 2022 年 9 月 7 日下午 5:00 挂了 160\r\n分，警钟长鸣。\r\nT1 100 -&gt; 40（写挂了哈哈）\r\nT3 100 -&gt; 0（忘开 long long）\r\n乐。\r\n9.4 ~ 9.6\r\n我不理解，一个脑瘫 NOIP10-2 T1 调了一下午一晚上（9.4）。\r\nCF R#819 (Div 1 + Div 2)\r\n上次我打 Div 2 还是在生日那天（虽然那天晚上挂没了（\r\n然后这次又挂没了，不过最后 F 重题了所以就 UnRated 了，但是我是真的\r\nRetard.\r\n因为 A 和 B WA on PreTest 3\r\n的经历过于痛苦，所以我只想简单说一下\r\nD：思路很简单，考虑到最优的方案是红边构成一棵树，那么会至多剩下三条蓝边，它们最差情况下会形成一个三元环，把其中一条和一条于环相连的路径上的一条红边替换一下即可。\r\nCSP7-EX1\r\n去年送过一次了，然而我正好做过前两题，乐。\r\n但是第一题挂掉了 90，第三题挂了两个点变成 80.\r\n没啥好说的就不仔细说了。\r\n\r\nA\r\n观察可以发现能分讨，据说还有一些冰茶姬做法，反正我是没想到，直接分讨的。\r\nB 类似于 CSP 2021\r\nT1，分别预处理行和列的最优方案，最后再合并，合并的时候要去掉交叉点个数之积乘上\r\n\r\nC OI 顶针，一眼题面，鉴定为纯纯模拟，把六个面用 54\r\n个数来组成（每个数代表一个面上的一块）然后按照题意模拟。\r\n\r\nNOIP10-2\r\n2\r\nA\r\n因为一共就十种砝码，所以可以按照把完全背包所有集合的状态先预处理，然后线段树里面区间十种数的存在状态。\r\n最后把 tag 从编号变成数才过。\r\n\r\n早读的时候突然想起来我 Pushdown 是判 0 的，但是编号里有\r\n0。乐，这一个东西调了昨天一天。\r\n\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142CI MXX(1e6+5),NXX(1e5+5);bitset&lt;NXX&gt; co[1050],knd;vector&lt;int&gt; s;int n,m,q,a[MXX],id[NXX],vis[NXX];struct Question {    int opt,l,r,x;}b[MXX];struct Node {    int l,r,tg,f;}t[MXX&lt;&lt;2];#define lc(x) (x&lt;&lt;1)#define rc(x) (x&lt;&lt;1|1)I void Pushup(int x) {    t[x].f=t[lc(x)].f|t[rc(x)].f;}I void Pushdown(int x) {    if(t[x].tg) {        t[lc(x)].f=t[rc(x)].f=(1&lt;&lt;id[t[x].tg]);        t[lc(x)].tg=t[rc(x)].tg=t[x].tg;        t[x].tg=0;    }}void Build(int x,int l,int r) {    t[x].l=l,t[x].r=r;    t[x].tg=t[x].f=0;    if(l==r) {        t[x].f=(1&lt;&lt;id[a[l]]);        Heriko;    }    int mid((l+r)&gt;&gt;1);    Build(lc(x),l,mid);    Build(rc(x),mid+1,r);    Pushup(x);}void Modify(int x,int lx,int rx,int v) {    if(lx&lt;=t[x].l and t[x].r&lt;=rx) {        t[x].f=(1&lt;&lt;id[v]);        t[x].tg=v;        Heriko;    }    Pushdown(x);    int mid((t[x].l+t[x].r)&gt;&gt;1);    if(lx&lt;=mid)        Modify(lc(x),lx,rx,v);    if(rx&gt;mid)        Modify(rc(x),lx,rx,v);    Pushup(x);}int Query(int x,int lx,int rx) {    if(lx&lt;=t[x].l and t[x].r&lt;=rx)        Heriko t[x].f;    Pushdown(x);    int mid((t[x].l+t[x].r)&gt;&gt;1),res(0);    if(lx&lt;=mid)        res|=Query(lc(x),lx,rx);    if(rx&gt;mid)        res|=Query(rc(x),lx,rx);    Heriko res;}S main() {    Files();    fr(n),fr(m),fr(q);    for(int i(1);i&lt;=n;++i) {        fr(a[i]);        if(!vis[a[i]])            vis[a[i]]=1,s.emplace_back(a[i]);    }    for(int i(1);i&lt;=q;++i) {        fr(b[i].opt),fr(b[i].l),fr(b[i].r),fr(b[i].x);        if(b[i].opt==1 and !vis[b[i].x])            vis[b[i].x]=1,s.emplace_back(b[i].x);    }    int nl(s.size());    for(int i(0);i&lt;nl;++i)        id[s[i]]=i;    for(int i(1);i&lt;(1&lt;&lt;nl);++i) {        vector&lt;int&gt; tmp;        knd.reset();        knd[0]=1;        for(int j(0);j&lt;nl;++j)            if((i&gt;&gt;j)&amp;1)                tmp.emplace_back(s[j]);        for(int j:tmp)            for(int k(1);1ll*j*k&lt;=NXX-5;k+=k)                knd|=(knd&lt;&lt;(j*k));        co[i]=knd;    }    Build(1,1,n);    for(int i(1);i&lt;=q;++i)        if(b[i].opt==1)            Modify(1,b[i].l,b[i].r,b[i].x);        else {            int res(Query(1,b[i].l,b[i].r));            if(co[res][b[i].x])                puts(\"Yes\");            else                puts(\"No\");        }    Heriko Deltana;}\r\nB&amp;D\r\n因为 B 涉及我不会的拉格朗日插值，而 D\r\n我知道他是个分段凸函数但是我也不会怎么做，所以就先把这两个题放了。\r\nC\r\n\r\n不会写，真的不会写，所以不写了，虽然会了怎么做了，但是不会写。\r\n\r\n比较好想到的是因为题目说了删掉重边是树，所以重边可以看作是一条边的不同颜色。考虑到对于一条路径上的一条边，于它相连的只有两条边，所以它只要有大于等于三种颜色就能保证和相连的两边的颜色不同。那么把这种边的颜色重置为一个大于\r\n\r\n的颜色，整棵树上就只有两种颜色的边。\r\n于是设  为从  往上跳 \r\n步，最前面和最后面的边选择哪种颜色。\r\n因为我不会写这个所以就没写。\r\nCSP7-2\r\n2\r\n这场题目名字都是阳炎曲（夕景昨日，透明答案，界外科学，回忆补时），绝赞绝赞中！\r\nA\r\n因为如果出现重复的数字那么肯定有两种，所以场上发现只要  肯定有解，所以小于  暴力即可，用 bitset\r\n优化的背包， 表示第  位是否能被表示出来。\r\n因为上次用 bitset 还是去年的 10\r\n连测，所以完全忘了怎么用。。导致浪费巨大时间。\r\n123456789101112131415161718192021222324252627282930313233343536CI MXX(1e6+25),N(5e5);bitset&lt;MXX&gt; f;int n,a[MXX];S main() {    Files();    fr(n);    if(n&gt;1000) {        puts(\"Yes\");        Heriko Deltana;    }    for(int i(1);i&lt;=n;++i)        fr(a[i]);    f[a[1]+N]=1;    for(int i(2);i&lt;=n;++i) {        f|=(f&lt;&lt;a[i]),f|=(f&gt;&gt;a[i]);        if(f[N]) {            puts(\"Yes\");            Heriko Deltana;        }    }            puts(\"No\");    Heriko Deltana;}\r\nB\r\n场上写的记忆化搜索写挂了，然后题解说是爆搜找规律， 则 Bob 赢，否则\r\nAyano，没什么代码就不放了。\r\nC\r\n这题给我整乐了，题解做法是折半搜索异或和满意值的结果后上 01 Trie\r\nDFS.\r\n但是呢你贪心把到当前位置的最大值先预处理出来然后直接爆搜就能过（\r\n1234567891011121314151617181920212223242526272829303132333435363738394041template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y) {    Heriko x&gt;y?x:y;}CI MXX(40);int a[MXX],b[MXX],n,m;LL ans,co[MXX];void DFS(int step,int x,LL y) {    if(x&lt;=m)        ans=Hmax(ans,y);    if(step==n+1 or y+co[step]&lt;=ans)        Heriko;    DFS(step+1,x,y);    DFS(step+1,x^a[step],y+b[step]);}S main() {    Files();    fr(n),fr(m);    for(int i(1);i&lt;=n;++i)        fr(a[i]);    for(int i(1);i&lt;=n;++i)        fr(b[i]);    for(int i(n);i;--i)        co[i]=Hmax(co[i+1],co[i+1]+b[i]);    DFS(1,0,0);    fw(ans,1);    Heriko Deltana;}\r\nD\r\n场上就想到是李超线段树了，但是因为在写\r\nT1（生气，连着两场都是被遗忘的背包和 bitset 炸了 T1\r\n导致悲剧），所以没时间了。\r\n考虑把式子内部看作一个整体，即：\r\n那么显然若 ， 取  时最优；反之， 时， 取  最优。\r\n那么我们可以先把 \r\n的最大值和最小值求出来，但是又因为 ，所以我们还需要记录一个次大值和次小值。\r\n但是我不会记录，所以用了 maoyiting 的方法。\r\n代码中 Losstime Memory 即回忆补时，和题名相同。\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y) {    Heriko x&gt;y?x:y;}template&lt;typename J&gt;I J Hmin(const J &amp;x,const J &amp;y) {    Heriko x&lt;y?x:y;}CI MXX(1e5+5);CL INF(1e12),LMT(1e18);struct Line {    LL k,b,id;    LL Calc(LL x) {        Heriko k*x+b;    }}a[MXX],mx1,mx2,mi1,mi2;Line IA(Line a,Line b,LL x) {    Heriko a.Calc(x)&gt;b.Calc(x)?a:b;}struct LCTree {    int tot,pre[MXX&lt;&lt;5],suf[MXX&lt;&lt;5],lc[MXX&lt;&lt;5],rc[MXX&lt;&lt;5];    Line t[MXX&lt;&lt;5];    int Modify(int lst,LL l,LL r,Line v) {        LL x(++tot),mid((l+r)&gt;&gt;1);        lc[x]=lc[lst],rc[x]=rc[lst],t[x]=t[lst];        if(!lst or v.Calc(mid)&gt;t[x].Calc(mid))            swap(t[x],v);        if(l==r)            Heriko x;        if(v.Calc(l)&gt;t[x].Calc(l))            lc[x]=Modify(lc[lst],l,mid,v);        if(v.Calc(r)&gt;t[x].Calc(r))            rc[x]=Modify(rc[lst],mid+1,r,v);        Heriko x;    }    Line Query(int x,LL l,LL r,LL pos) {        if(!x)            Heriko (Line){0,-LMT,0};        if(l==r)            Heriko t[x];        LL mid((l+r)&gt;&gt;1);        Line res(t[x]);                if(pos&lt;=mid)            res=IA(res,Query(lc[x],l,mid,pos),pos);        else            res=IA(res,Query(rc[x],mid+1,r,pos),pos);        Heriko res;    }}T1,T2;int n,q;LL ans;I void Losstime_Memory(LL x,LL v) {    if(!x)        Heriko;        LL res(a[x].Calc(v));    ans=Hmax(Hmax(ans,a[T1.Query(T1.pre[x-1],-INF,INF,res).id].Calc(res)),a[T1.Query(T1.suf[x+1],-INF,INF,res).id].Calc(res));}S main() {    Files();    fr(n);    for(int i(1);i&lt;=n;++i) {        fr(a[i].k),fr(a[i].b),a[i].id=i;        T1.pre[i]=T1.Modify(T1.pre[i-1],-INF,INF,a[i]);        T2.pre[i]=T2.Modify(T2.pre[i-1],-INF,INF,(Line){-a[i].k,-a[i].b,i});    }    for(int i(n);i;--i) {        T1.suf[i]=T1.Modify(T1.suf[i+1],-INF,INF,a[i]);        T2.suf[i]=T2.Modify(T2.suf[i+1],-INF,INF,(Line){-a[i].k,-a[i].b,i});    }        fr(q);    while(q--) {        LL x;        fr(x),ans=-LMT;        mx1=T1.Query(T1.pre[n],-INF,INF,x);        mx2=IA(T1.Query(T1.suf[mx1.id+1],-INF,INF,x),T1.Query(T1.pre[mx1.id-1],-INF,INF,x),x);        mi1=T2.Query(T2.pre[n],-INF,INF,x);        mi2=IA(T2.Query(T2.suf[mi1.id+1],-INF,INF,x),T2.Query(T2.pre[mi1.id-1],-INF,INF,x),x);        Losstime_Memory(mx1.id,x);        Losstime_Memory(mx2.id,x);        Losstime_Memory(mi1.id,x);        Losstime_Memory(mi2.id,x);        fw(ans,1);    }    Heriko Deltana;}\r\n9.3\r\n和家里人讨论决定从现在停到联赛，因为是最后一次了。\r\n[省选联考 2021 A/B 卷]\r\n卡牌游戏\r\n因为想不出来什么是正确的操作，感觉这个同一张牌的限制有点麻烦，于是就想着把这些全都放在一起排列贪心选，但是问题就是双指针如何去实现。\r\n想不出来，然后看了 VinstaG173\r\n的题解，才明白合法区间的左端点右移时，右端点不可能左移，于是就可以解决了。\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657template&lt;typename J&gt;I J Hmin(const J &amp;x,const J &amp;y) {    Heriko x&lt;y?x:y;}CI MXX(2e6+5),INF(0x7fffffff);struct Card {    int v,id,co;    I bool operator &lt; (const Card &amp;x) const {        Heriko v&lt;x.v;    }}a[MXX];int n,m,cnt[MXX];S main() {    Files();    fr(n),fr(m);    for(int i(1);i&lt;=n;++i)        fr(a[i].v),a[i].id=a[i+n].id=i,a[i].co=1;    for(int i(n+1);i&lt;=n+n;++i)        fr(a[i].v),a[i].co=0;    n&lt;&lt;=1;    int l(1),r(n),nw(0),ans(INF);    sort(a+1,a+1+n);    for(;r;--r) {        if(cnt[a[r].id] or (nw==m and a[r].co))            break;        ++cnt[a[r].id],nw+=a[r].co;        }    for(;l&lt;=n;++l) {        ans=Hmin(ans,a[r].v-a[l].v);        ++cnt[a[l].id],nw+=a[l].co;        while(r&lt;n and (cnt[a[l].id]&gt;1 or nw&gt;m))            --cnt[a[++r].id],nw-=a[r].co;        if(r==n)            break;    }    fw(ans,1);    Heriko Deltana;}\r\n「SWTR-07」My rating is\r\n-32（Eazy Version）\r\n因为昨天做了两道 SWTR 的题，所以今天就继续看了看，那么还是惯例先看\r\nEZ，但是这题我是真的没读懂……当然是我语文有问题，那个简化题意里的 \r\n理解错了半天还思索了半天这样例为啥不对……\r\n思路很简单，因为要每个账号第一个是最大的，所以前两个肯定要让前两个账号发，然后剩下的调前\r\n\r\n大的就行，剩余的随便放都可以，反正都比选过的小。所以就不放代码了，直接放个提交记录。\r\n「SWTR-07」My rating is\r\n1064（Hard Version）\r\n那么来看 HD.\r\n相对于 EZ，放宽了一点发帖子的性质。首先， 的时候，还是和 EZ 一样的交替进行，而\r\n 时就留给后面的 \r\n大的即可，前面的还是放到第一个和第二个账号。\r\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y) {    Heriko x&gt;y?x:y;}template&lt;typename J&gt;I J Hmin(const J &amp;x,const J &amp;y) {    Heriko x&lt;y?x:y;}CI MXX(1e5+5);priority_queue&lt; int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q;int a[MXX],n,k;S main() {    Files();    int t,T;    fr(t),fr(T);    while(T--) {        fr(n),fr(k);        LL ans(0),sum(0);        for(int i(1);i&lt;=n;++i)            fr(a[i]);        while(!q.empty())            q.pop();        for(int i(n-k+2);i&lt;=n;++i)            sum+=a[i],q.emplace(a[i]);        for(int i(2);i&lt;=n-k+1;++i)            sum-=Hmin(a[i-1],a[i]);        ans=sum;        for(int i(n-k+1);i&gt;=2;--i) {            sum+=Hmin(a[i-1],a[i]);            sum-=q.top(),q.pop();            sum+=a[i],q.emplace(a[i]);            ans=Hmax(ans,sum);        }        fw(ans+a[1],1);    }    Heriko Deltana;}\r\n9.2\r\n延命治疗了，所以今天继续。\r\n[HNOI2004] 宠物收养场\r\nLuogu\r\n破题面写的啥玩意，根本就不是让人读的东西吧？\r\n大体意思就是当人比宠物多的时候宠物选人，否则人选宠物。统一按照需求差值最小的选，若有需求差值相同的，选需求值更小的。\r\n因为我不是那种喜欢写平衡树的人，所以 set 跑了。\r\n123456789101112131415161718192021222324252627282930313233343536373839404142CL MXX(80005),MOD(1000000),INF(1e18);LL ans;set&lt;LL&gt; s;I void Query(LL x) {    auto t(s.lower_bound(x)),r(t),l(--t);        if(x-*l&lt;=*r-x and *l!=-INF)        (ans+=(x-*l))%=MOD,s.erase(l);    else if(x-*l&gt;=*r-x and *r!=INF)        (ans+=(*r-x))%=MOD,s.erase(r);}int n;S main() {    Files();    fr(n),s.insert(-INF),s.insert(INF);    int lst(0);    for(int i(1);i&lt;=n;++i) {        LL x,y;        fr(x),fr(y);        if(s.size()==2) {            lst=x;            s.insert(y);        }        else if(x==lst)            s.insert(y);        else            Query(y);    }    fw(ans%MOD,1);    Heriko Deltana;}\r\n[CSP-S 2021] 廊桥分配\r\n完全没脑子了一样，整毛，去年自己写的 CSP T1 都看不懂了。\r\n看懂了顺便 RELOAD\r\n了一遍。\r\n「SWTR-07」Scores（easy\r\nversion）\r\n偶然看见，就写了，一会去看看\r\nHard Ver.\r\n这个 Eazy Ver. 做法很简单：相邻两列一个升序一个降序就行。\r\n「SWTR-07」Scores（hard\r\nversion）\r\n做了 EZ 肯定要看看 HD，感觉这个题还能 EX，HD 和 EZ\r\n不同的是多了一层限制。\r\n首先感觉这个东西就很想让人连边，于是连边看看，那么可以发现最后如果有解，一定是一张\r\nDAG，所以就可以把无解情况排除了（当然 EZ\r\n里难搞只有一个学科的时候而有多个人的仍然是无解）。\r\n然后考虑如何借助 DAG\r\n进行操作……然后发现其实每条关系都可以拆成一条链（如果出现分支，根据题目中的性质，可以在分支出去的两个结点之间任意建立一条有向边，然后删除原本的一条分支边，汇合同理）。\r\n然后通过两个学科来进行合法生成即可，生成方式和 EZ\r\n相同，升降序即可，剩下的学科可以直接复制这两个学科。\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115CI MXX(105);int fa[MXX];int Find(int x) {    if(x!=fa[x])        fa[x]=Find(fa[x]);    Heriko fa[x];}I void UNI(int x,int y) {    int fx(Find(x)),fy(Find(y));    if(fx!=fy)        fa[fx]=fy;}int a[MXX][MXX],rk[MXX],vis[MXX],rt[MXX],ans[MXX][MXX],tot;vector&lt;int&gt; s[MXX];int n,m;S main() {    Files();    int t,T;    fr(t),fr(T);    while(T--) {        mst(rk,0),tot=0;        int flg(1),nw(0);        fr(n),fr(m);        for(int i(1);i&lt;=n;++i)            s[i].clear();        for(int i(1);i&lt;=n;++i)            for(int j(1);j&lt;=n;++j)                fr(a[i][j]);        for(int i(1);i&lt;=n;++i)            fa[i]=i;        for(int i(1);i&lt;=n;++i)            for(int j(1);j&lt;=n;++j)                for(int k(1);k&lt;=n;++k)                    if(i!=j and j!=k and i!=k and !a[i][j] and !a[j][k] and a[i][k]) {                        flg=0;                        break;                    }        for(int i(1);i&lt;=n;++i)            for(int j(1);j&lt;=n;++j)                if(i!=j and !a[i][j])                    UNI(i,j);        for(int i(1);i&lt;=n;++i)            s[Find(i)].emplace_back(i);        for(int i(1);i&lt;=n;++i) {            if(!s[i].empty()) {                mst(vis,0),++tot;                for(auto j:s[i])                    for(auto k:s[i])                        if(j!=k and !a[j][k])                            ++rk[j];                for(int j:s[i]) {                    if(vis[rk[j]])                        flg=0;                                        vis[rk[j]]=1;                    if(!rk[j])                        rt[i]=j;                }            }        }        if(!flg or (m==1 and tot&gt;1)) {            puts(\"NO\");                        continue;        }        for(int i(1);i&lt;=n;++i)            if(!s[i].empty()) {                ans[rt[i]][1]=nw+s[i].size();                ans[rt[i]][2]=100-nw;                for(int j(3);j&lt;=m;++j)                    ans[rt[i]][j]=100;                for(int j:s[i])                    for(int k(1);k&lt;=m;++k)                        ans[j][k]=ans[rt[i]][k]-rk[j];                nw+=s[i].size();            }        puts(\"YES\");        for(int i(1);i&lt;=n;puts(\"\"),++i)            for(int j(1);j&lt;=m;++j)                fw(ans[i][j],0);                }    Heriko Deltana;}\r\n8.31 ~ 9.1\r\nNOIP10-1\r\n1\r\nA\r\n当我们选取 K\r\n的时候，要考虑对平均数变化的影响，为了让我们选取的集合中大于平均数的数尽量的多，所以我们在选取小于平均数的数时，要尽量选取小的数让平均数位置前移，同理，选取大于平均数的数时也要尽量小。\r\n所以我们选取的就是一个前缀，我的实现方式是先排序，然后每次试图去除后缀，时间复杂度\r\n.\r\n123456789101112131415161718192021222324252627282930313233343536373839template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y) {    Heriko x&gt;y?x:y;}#define int long longCI MXX(1e6+5);int n,a[MXX],sum,ans;DB per;S main() {    Files();    fr(n);    for(int i(1);i&lt;=n;++i)        fr(a[i]),sum+=a[i];    per=(DB)sum/(DB)n;    sort(a+1,a+1+n);        for(int i(1);i&lt;=n;++i)        if(per&lt;(DB)a[i])            ++ans;    for(int i(n);i&gt;=2;--i) {        sum-=a[i];        per=(DB)sum/(DB)(i-1);        int tmp(upper_bound(a+1,a+i,per)-a);        ans=Hmax(ans,i-tmp);    }    fw(ans,1);    Heriko Deltana;}\r\nB\r\n考虑到一个性质：最小生成树上的边权都比其他非树边更小，否则它可以被替换。\r\n因为本题要求序列字典序最小，既然我们知道了这些边权的相对关系，就可以考虑贪心的对这些边进行赋值。考虑类似拓扑排序的方式依次处理边，但是这题空间卡到\r\n128MB，所以考虑在处理之后将点用冰茶姬缩起来，总体复杂度 ，瓶颈在排序。\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118CI MXX(1e6+5);struct RedEdge {    int nex,to,val;}r[MXX&lt;&lt;1];int rcnt,head[MXX];I void ADD(int x,int y,int z) {    r[++rcnt]=(RedEdge){head[x],y,z},head[x]=rcnt;    r[++rcnt]=(RedEdge){head[y],x,z},head[y]=rcnt;}struct Edge {    int x,y,z;}q[MXX];int qcnt;int fa[MXX];int Find(int x) {    if(x!=fa[x])        fa[x]=Find(fa[x]);    Heriko fa[x];}int f[MXX],dep[MXX],co[MXX];I void UNI(int x,int y) {    int fx(Find(x)),fy(Find(y));    if(dep[x]&lt;dep[y])        fa[fy]=fx;    else        fa[fx]=fy;}void DFS(int x,int fath) {    f[x]=fath,dep[x]=dep[fath]+1;    for(int i(head[x]);i;i=r[i].nex) {        int y(r[i].to);        if(y==fath)            continue;        co[y]=r[i].val;        DFS(y,x);    }}int a[MXX],ln,n,m,ans[MXX],cnt;S main() {    Files();    fr(n),fr(m);    for(int i(1);i&lt;=m;++i) {        int x,y,z;        fr(x),fr(y),fr(z);        if(z)            ADD(x,y,i);        q[++qcnt]=(Edge){x,y,z};    }    DFS(1,0);    for(int i(1);i&lt;=n;++i)        fa[i]=i;    for(int i(1);i&lt;=m;++i) {        if(ans[i])            continue;        int x(q[i].x),y(q[i].y),z(q[i].z);        if(z) {            ans[i]=++cnt;            UNI(x,y);        }        else {            int fx(Find(x)),fy(Find(y));            ln=0;            while(fx!=fy) {                if(dep[fx]&lt;dep[fy])                    swap(x,y),swap(fx,fy);                a[++ln]=co[fx];                fa[fx]=Find(f[fx]),x=f[fx];                fx=Find(x);            }            sort(a+1,a+1+ln);            for(int j(1);j&lt;=ln;++j)                ans[a[j]]=++cnt;            ans[i]=++cnt;        }    }    for(int i(1);i&lt;=m;++i)        fw(ans[i],0);    puts(\"\");    Heriko Deltana;}\r\nC\r\n考虑到要留下不大于的 k\r\n个连通块，所以我们要删去的结点是一些特定的位置，那么假设我们找到了这些位置，包含这些位置的区间都需要删除。\r\n设  为到  时，枚举在  位置再切一次时，考虑只保留  价值最大的  个，复杂度 ，若把从后往前枚举\r\n 的时候，把前  大用堆维护能做到 ，大概是吃不满，所以跑的还不慢。\r\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y) {    Heriko x&gt;y?x:y;}CI MXX(2525);#define int long longstruct Node {    int l,r,v;    I bool operator &lt; (const Node &amp;co) const {        Heriko (r==co.r)?(l&lt;co.l):(r&lt;co.r);    }}a[MXX];int b[MXX&lt;&lt;1],n,k,sum,f[MXX&lt;&lt;1],ln;vector&lt;int&gt; nw[MXX&lt;&lt;1];S main() {    Files();    fr(n),fr(k);    for(int i(1);i&lt;=n;++i)        fr(a[i].l),fr(a[i].r),fr(a[i].v),sum+=a[i].v,b[++ln]=a[i].l,b[++ln]=a[i].r;    sort(b+1,b+1+ln);    for(int i(1);i&lt;=n;++i)        a[i].l=lower_bound(b+1,b+1+ln,a[i].l)-b,a[i].r=lower_bound(b+1,b+1+ln,a[i].r)-b;    sort(a+1,a+1+n);    int t(1);    for(int i(1);i&lt;=ln;++i) {        for(;t&lt;=n and a[t].r&lt;=i;++t)            nw[a[t].l].emplace_back(a[t].v);        priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q;        int tmpsum(0),tmppos(0);        for(int j(i-1);j&gt;=0;--j) {            for(int x:nw[j+1]) {                if(tmppos&lt;k)                    ++tmppos,q.push(x),tmpsum+=x;                else {                    int v(q.top());                                        if(x&gt;v)                        q.pop(),q.push(x),tmpsum+=x-v;                }            }            f[i]=Hmax(f[i],f[j]+tmpsum);        }    }    fw(sum-f[ln],1);    Heriko Deltana;}\r\nD\r\n开 D 了，也想好怎么写了，但是人均 9k\r\n代码真的让我提不起写的兴趣，考虑到明天还得回班，要不然还是先看看 CSP7-1\r\n吧。\r\nCSP7-1\r\n1\r\nA\r\n考虑若  是 \r\n的倍数，说明两者质因数分解之后，对于每个质因数的指数，都有 ，那么若是  为  的倍数， 就需要满足 ，那么对  质因数分解即可。\r\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647I LL FstPow(LL x,LL y) {    LL res(1);    while(y) {        if(y&amp;1)            res*=x;        x*=x;        y&gt;&gt;=1;    }    Heriko res;}LL x,ans(1),n;S main() {    Files();    fr(x),n=x;    for(LL i(2);i*i&lt;=n;++i) {        LL cnt(0);        while(n%i==0)            n/=i,++cnt;        if(!cnt)            continue;        if(cnt&amp;1)            cnt&gt;&gt;=1,++cnt;        else            cnt&gt;&gt;=1;        ans*=FstPow(i,cnt);    }    ans*=n;    if(ans&gt;=x)        puts(\"-1\");    else        fw(ans,1);    Heriko Deltana;}\r\nB\r\n因为一共九个数字，所以这题一定不是数论题，那么对 GCD=1\r\n这个条件进行一下分类讨论。\r\n显然对于 6 来说，它和每个数字 GCD 都不为 1，所以我们可以用 6\r\n来把数列分段，然后对其中的部分考虑。\r\n那么 238(x 组) 和 39(y 组)\r\n的相似点在于，两组组内都不能交换，但是不同类型的组和组之间可以交换，所以这些在每一段里面的贡献即为\r\n.\r\n剩下的 157 可以任意插入到任何空间里，最后加入贡献即可。\r\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071CI MXX(5e5+5),MOD(998244353);I LL FstPow(LL x,LL y) {    x%=MOD;    LL res(1);     while(y) {        if(y&amp;1)            (res*=x)%=MOD;        (x*=x)%=MOD;        y&gt;&gt;=1;    }    Heriko res%MOD;}LL fac[MXX],infac[MXX];I LL C(LL x,LL y) {    if(x&lt;0 or y&lt;0 or x&lt;y)        Heriko Deltana;    Heriko fac[x]*infac[x-y]%MOD*infac[y]%MOD;}LL a[MXX],n,ans(1),cnt[15],subx,suby,subz;S main() {    Files();    fr(n);    for(int i(1);i&lt;=n;++i)        fr(a[i]),++cnt[a[i]];    fac[0]=1;    for(int i(1);i&lt;=n;++i)        fac[i]=fac[i-1]*i%MOD;    infac[n]=FstPow(fac[n],MOD-2);    for(int i(n-1);i&gt;=0;--i)        infac[i]=infac[i+1]*(i+1)%MOD;    for(int i(1);i&lt;=n;++i)        if(a[i]==6)            (ans*=C(subx+suby,subx))%=MOD,subx=suby=0;        else if(a[i]%2==0)            ++subx;        else if(a[i]%3==0)            ++suby;    (ans*=C(subx+suby,subx))%=MOD;    for(int i(1);i&lt;=9;++i) {        if(i%2==0 or i%3==0)            continue;        subz+=cnt[i];        (ans*=infac[cnt[i]])%=MOD;    }    (ans*=C(n,subz))%=MOD;    (ans*=fac[subz])%=MOD;    fw(ans,1);    Heriko Deltana;}\r\nC\r\n\r\n本来以为 B\r\n是最后一题了，但是一想他们下午讲不完题，就没回去（甚至可能明天都讲不完），然后一个下午就用来干\r\nC 了。\r\n\r\n考虑枚举作为划归基准的能力值，然后考虑如何削减复杂度。如果能把暴力中每次的答案继承，就能优化很多，所以考虑每次移动什么会影响答案。\r\n显然每次移动，只会和左右有多少有关系，所以把和上次结果的差值扔到一个对顶堆里， 搞定。\r\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768CL MXX(1e5+5),INF(1e20);#define int long longpriority_queue&lt;int&gt; q2;priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q1;int a,b,n,co[MXX],ans[MXX];S main() {    Files();    fr(n),fr(a),fr(b);    for(int i(1);i&lt;=n;++i)        fr(co[i]);    int lst(co[1]),cnt(1),res(0);    for(int i(2);i&lt;=n;++i) {        if(co[i]==lst)            ++cnt;        else if(co[i]&lt;lst)            res+=(lst-co[i])*a,q2.emplace(co[i]);        else if(co[i]&gt;lst)            res+=(co[i]-lst)*b,q1.emplace(co[i]);        int d1(INF),d2(INF);        if(!q1.empty())            d1=res+a*(q1.top()-lst)*(i-q1.size())-b*(q1.top()-lst)*q1.size();        if(!q2.empty())            d2=res+b*(lst-q2.top())*(i-q2.size())-a*(lst-q2.top())*q2.size();        if(d1&lt;d2 and d1&lt;res) {            res=d1;            for(int i(1);i&lt;=cnt;++i)                q2.emplace(lst);                        cnt=0;            lst=q1.top();            while(!q1.empty() and q1.top()==lst)                q1.pop(),++cnt;        }        else if(d1&gt;=d2 and d2&lt;res) {            res=d2;            for(int i(1);i&lt;=cnt;++i)                q1.emplace(lst);                        cnt=0;            lst=q2.top();            while(!q2.empty() and q2.top()==lst)                q2.pop(),++cnt;        }        ans[i]=res;    }    for(int i(1);i&lt;=n;++i)        fw(ans[i],1);    Heriko Deltana;}\r\nD\r\n\r\n早知道，还是先开 D.jpg\r\n\r\n这玩意感觉是比较经典的套路，把贡献用 LCA\r\n或询问节点的子树包含关系划分，因为不想写 Tarjan 所以用的树剖。\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131CI MXX(1e6+5),MOD(998244353);#define int long longstruct Edge {    int nex,to;}r[MXX&lt;&lt;1];int rcnt,head[MXX];I void ADD(int x,int y) {    r[++rcnt]=(Edge){head[x],y},head[x]=rcnt;    r[++rcnt]=(Edge){head[y],x},head[y]=rcnt;}int dep[MXX],sz[MXX],fa[MXX],son[MXX],sub[MXX];void DFS1(int x,int fath) {    fa[x]=fath,dep[x]=dep[fath]+1,sz[x]=sub[x]=1;    for(int i(head[x]);i;i=r[i].nex) {        int y(r[i].to);        if(y==fath)            continue;        DFS1(y,x);        sz[x]+=sz[y];        (sub[x]+=sub[y]*2)%=MOD;        if(sz[y]&gt;sz[son[x]])            son[x]=y;    }}int id[MXX],top[MXX],antid[MXX],icnt,co[MXX];void DFS2(int x,int tp) {    top[x]=tp,id[x]=++icnt,antid[icnt]=x;    for(int i(head[x]);i;i=r[i].nex) {        int y(r[i].to);        if(y==fa[x])            continue;        co[y]=(co[x]*2+(sub[x]-(sub[y]*2)+MOD)*2%MOD)%MOD;    }    if(son[x])        DFS2(son[x],tp);    for(int i(head[x]);i;i=r[i].nex) {        int y(r[i].to);        if(y==fa[x] or y==son[x])            continue;        DFS2(y,y);    }}I int QRoot(int x,int to) {    while(top[x]!=top[to] and fa[top[x]]!=to)        x=fa[top[x]];    if(fa[x]==to)        Heriko x;    else if(fa[top[x]]==to)        Heriko top[x];    else        Heriko antid[id[to]+1];}I int LCA(int x,int y) {    while(top[x]!=top[y]) {        if(dep[top[x]]&lt;dep[top[y]])            swap(x,y);        x=fa[top[x]];    }    if(dep[x]&gt;dep[y])        swap(x,y);    Heriko x;}int n,m,fac[MXX];S main() {    Files();    fr(n);    for(int i(1);i&lt;n;++i) {        int x,y;        fr(x),fr(y);        ADD(x,y);    }    DFS1(1,0);    DFS2(1,1);    fac[0]=1;    for(int i(1);i&lt;=n;++i)        fac[i]=(fac[i-1]*2)%MOD;    fr(m);    while(m--) {        int x,y;        fr(x),fr(y);        if(id[x]&gt;id[y])            swap(x,y);        if(id[y]&lt;id[x]+sz[x]) {            int dlt(dep[y]-dep[x]);             fw(co[QRoot(y,x)]*sub[y]%MOD*fac[dlt-1]%MOD,1);        }        else {            int lca(LCA(x,y)),len(dep[x]+dep[y]-2*dep[lca]);            fw(sub[x]*sub[y]%MOD*fac[len]%MOD,1);        }    }    Heriko Deltana;}\r\n那么 CSP7-1 就补完了，总体来说比去年的 7-1\r\n略难，可惜错过没打错失上分机会（\r\n至于 NOIP10-1 的 D，现在不太想写，感觉写了我估计也调不出来（\r\n","slug":"OI22","date":"2022-08-31T03:08:46.000Z","categories_index":"OI-Solutions","tags_index":"OI","author_index":"Heriko Deltana"},{"id":"7186b391e864b958d5ec0bc8dcbfed1a","title":"锐评 F1 2022 上半赛季","content":"「锐评 F1 2022 上半赛季」\r\n\r\n\r\n\r\nTifosi 的失望.jpg\r\n\r\n之前我的有过预测，让我自己来看看预测的对不对罢（\r\n那么就按照 2021 年车队积分榜的顺序来逐个看看罢。\r\n梅奔\r\n对于梅奔，我在冬测之前的猜测是仍然保持在火星组，甚至非常自信的写出了“就研发实力来说的话，梅奔应该是比较确定的独一档”。巴林冬测期间我一直觉得\r\nW13B 也就是最后比赛的 W13 要不然是真的寄了要不然就是马桶狼在藏。\r\n后来事实证明是真的寄了。\r\n从某种意义上梅奔今年的单圈节奏一直在火星组和地球组之间，确实是独一档（\r\n可以看出梅奔在夏休期前的最后几站进步很大，拉塞尔甚至在乐扣和塞恩斯的手里抢走了匈牙利的杆位。现在，因为法拉利的拉跨操作，现在法拉利和梅奔在车队积分榜上的差距已经越来越小，所以下半年我们或能看到梅奔和法拉利的车队第二之战。\r\n而在比利时站的采访中，拉塞尔说到目标是车队车手双第二，我觉得还是有可能的。\r\n红牛\r\n红牛的巴林站可以说是惨目忍睹，四辆\r\nRBPT，退赛了三个，虽然不全是引擎的直接问题，但是也给了当时的 tifosi\r\n看到乐扣 WDC 的希望，毕竟在梅奔在 Q3 宣告退出争冠行列之后，今年的 WDC\r\n的竞争者就只有乐扣和维斯塔潘了。\r\n然而第一站佩雷斯和维斯塔潘的退赛并没有影响到动力单元的继续使用，这一点为红牛在赛季后期减少罚退有很大的作用，反观法拉利每次恩静寄了基本都是不可修复的，也只能是说法拉利点背了。\r\n今年 RB18\r\n和更加成熟的维斯塔潘的组合基本无懈可击，再加上红牛团队中的人至少已经经历过了一次争冠，所以也就出现了现在的赛季过半领先\r\n80 分的情况。\r\n我先在这里奶一口，维斯塔潘提前锁定双冠王（\r\n法拉利\r\n法拉利，赛季之初优势比较大，截止到澳大利亚。\r\n从伊莫拉开始，就开始寄了，我真的已经气的心态平和了，说不出来了，那么分别来看看法拉利在上半赛季遇到的各种问题。\r\n\r\n巴林：「车辆问题」乐扣电池故障，要不是修复了再加上维斯塔潘最后一次超越的时候锁死了，可能冠军就拱手相让了。\r\n澳大利亚：「车手问题」赛恩斯起步太着急冲进沙石地退赛。\r\n伊莫拉：「车手问题」乐扣追击佩雷斯时上路肩太多打滑上墙，掉到\r\nP6。「运气问题」赛恩斯第一圈被里卡多顶出赛道退赛。\r\n西班牙：「车辆问题」乐扣引擎故障，领跑退赛。「？？问题」赛恩斯受到侧切风影响进入沙石地跌出领奖台。\r\n摩纳哥：「策略问题」不能理解的策略失误，让乐扣\r\nP1 变 P4.\r\n阿塞拜疆：「车辆问题」双车故障退赛。\r\n加拿大（其实因为乐扣要接受罚退，所以这个问题没太被显现出来）「换胎问题」乐扣换胎慢了导致掉进慢车堆，失去冲击领奖台机会。\r\n英国：「策略问题」搞不清楚谁在争 WDC.\r\n奥地利：「车辆问题」赛恩斯引擎起火退赛，乐扣油门踏板故障，还好保住冠军\r\n法国：「车手问题」乐扣领跑上墙。\r\n匈牙利：「策略问题」给乐扣换上了明明整个周末都证明了不能用的白胎。\r\n\r\n服了，我写这个真是如数家珍。\r\n迈凯伦\r\n赛季初直接变成垫底的拖拉机，令人惊讶迈凯伦是咋设计的车，阻力高，还没下压力（？\r\n从澳大利亚开始逐步恢复到去年的竞争力，但是速度上估计还是和 Alpine\r\n差一些，今年的车队第四估计已经不保了，除非 Alpine 整活（\r\n夏休期一直和 Alpine 抢人（\r\nAlpine\r\n雷诺/Alpine\r\n已经当了好几年的第五了，今年的目标是第四，不过整个目标就目前来看应该比较明朗，但是现在\r\nAlpine 最大的问题并不是今年，而是明年的车手席位。\r\n在夏休期的第一个周，随着维特尔宣布退役，Alpine\r\n先是丢掉了阿隆索，然后（大概是）没了皮亚斯特里，现在可能的席位是里卡多和米克（或者……周冠宇？可能性比较小）。\r\n不过不管如何，明年的车手市场都会很好看了。\r\n小红牛\r\n今年的小红牛，简单来说就是寄，只能说是中下游的水准，有点像是往年的阿罗，加斯利今年可能是因为车慢了，有些时候有点急（角田：你先别急.jpg），不过今年这两位还不用担心自己的席位问题，毕竟红牛那边没有合适的\r\nF2 人选。\r\n阿斯顿马丁\r\n马丁赛季初真的是拖拉机，完完全全的拖拉机，和威廉姆斯一起在地心组，但是能看出来马丁还是在逐渐的升级，而且不像是阿罗的反向升级，马丁是结结实实的一路升级到了积分区边缘的位置，尤其是匈牙利带来的特色尾翼非常有意思。\r\n随着老 stroll\r\n计划中的工厂、风洞等即将完成，再加上榨汁机阿隆索将在下个赛季加入，马丁明年可能回到中游的位置。\r\n威廉姆斯\r\n去年依靠拉塞尔的神勇表现和多次捡皮夹，威廉姆斯在去年达到了车队第八，但是今年的车真的太慢了……长距离真的不行，估计是垫底了。\r\n明年威廉姆斯的第二个席位也一直在争论，随着 Alpine\r\n和迈凯伦争夺皮亚斯特里已经开始，威廉姆斯现在明年可能的第二个席位会在萨金特和拉提非中决定出，两者的优势都很明显：拉提非有威廉姆斯非常需要的赞助，今年也展现出了一些能力（比如银石进入\r\nQ3，匈牙利 FP3 最后时刻拿下 P1，Q1\r\n第一段刷紫），而萨金特在速度优势上更胜一筹。\r\nF2 的比赛还有三场，看波谢尔和萨金特的表现了。\r\n阿尔法罗密欧\r\n阿罗今年开始的时候着实是惊艳，大约是第四快的车，博塔斯也趁机拿了很多分，而周冠宇首战拿分之后确实运气一直不好。\r\n随着赛季中不断地逆升级，阿罗根据赛道不同，现在估计是第六~第八快的车，无语。\r\n和威廉姆斯一样，阿罗的第二个席位也没有确定，目前来看是周冠宇和波谢尔之间出一个了，那么还是看\r\nF2 最后的成绩了。\r\n个人还是希望周能在围场里多来几年的。\r\n哈斯\r\n英语老师很高兴.jpg\r\n哈斯 All in 2022\r\n的策略很成功，今年目标第六我感觉努力一下（阿罗整个活）是有可能的。米克拿分之后，终于能够放开开车了，挺欣慰的，虽然还是经常在周后面（周：吃饭睡觉超米克\r\n其他\r\n关于 F1 22，真的做的很差，不准备买了。\r\n等赛季完了再来一次锐评罢（\r\n","slug":"RP-F12022-1","date":"2022-08-11T07:35:44.000Z","categories_index":"Other","tags_index":"F1","author_index":"Heriko Deltana"},{"id":"7fcaeeecedb674640a10d625a72c0ec1","title":"Balanced Tree","content":"「平衡树……们」\r\n\r\n\r\n引\r\n偶然想起自己虽然在去年 6 月就把第一份 Treap\r\n写出来了，但是现在也没做几道平衡树的题（一直在用\r\nset），而且也没写博客，所以寻思着把之前的东西 Reload\r\n一下写一写。\r\n所以本文的模板代码都是在看了去年六月的代码之后重写了一遍，毕竟码风变了。\r\n本文所用到的缺省源：V5.3.1\r\n二叉查找树\r\n一切的起始，以下简称 BST.\r\n定义和基本操作\r\n\r\n空树是 BST.\r\nBST\r\n的左子树若不为空，则其上所有点的附加权值均小于其根节点的权值。\r\nBST\r\n的右子树若不为空，则其上所有点的附加权值均大于其根节点的权值。\r\nBST 的左右子树均为 BST.\r\n\r\n随机构造一颗 BST 的期望高度为 ，在普通的 BST 中的基础操作最好时间复杂度为 ，最坏为 \r\n可以支持的操作有：\r\n\r\n设  为结点个数， 为 BST 高度。\r\n\r\n\r\n遍历 BST，\r\n查询最大值/最小值，\r\n\r\n最小值为 BST 左链的末端，最大值为 BST 右链的末端。\r\n\r\n插入/删除元素，\r\n查询元素的排名/查询排名为 \r\n的元素，\r\n\r\nTreap\r\n一种弱平衡的 BST.\r\n简介\r\nTreap = Tree + Heap，即树与堆的结合，Treap 同时满足 BST\r\n和堆的性质。然而我们知道堆的性质是子节点的权值比父节点都要大/小（取决于是大/小根堆），在使用同一权值的时候，这和\r\nBST\r\n的性质显然矛盾。所以我们若要满足堆的性质，就需要在来个权值，于是我们给每个点随机生成一个权值。\r\n\r\n而这个堆性质的作用是干什么的呢？\r\n\r\n显然，在朴素的 BST\r\n中插入一个有序的序列的时候，这个新插入的序列在树上会变成一棵树，所以如果我们用堆的性质来打乱这个插入顺序，就会使得插入获得的树层数更少，从而降低各种与层数相关操作的复杂度。\r\n而这就涉及到我们在插入和删除的过程中可能要去改变一些节点之间的相对位置，而这一般有两种解决方案：旋转和分裂、合并。\r\n使用这两种方式的 Treap 也就分别是有旋 Treap 和无旋 Treap.\r\n有旋 Treap\r\n旋转 Treap 维护平衡的方式为旋转，和 AVL\r\n树的旋转操作类似，分为左旋和右旋。即在满足二叉搜索树的条件下根据堆的优先级对\r\nTreap 进行平衡操作。\r\n\r\n因为我不写指针所以下面当然是数组实现（\r\n\r\n结点\r\n俗话说得好，千里之行始于足下，所以先来看树上最为基础的结点的结构。\r\n好吧我承认这和俗话没有什么关系。\r\n123456789101112struct Node {    int sz,cnt; //当前子树大小和相同权值节点个数；    int val,rad; //节点权值和随机（堆—）权值    int l,r; //左右儿子编号}t[MXX];#define lc(x) t[x].l#define rc(x) t[x].rint tot,rt; //Treap 上的总结点数和根编号\r\n更新\r\n类似于线段树，我们对结点进行了修改类操作后，会影响其所在子树的数值，所以要有更新操作。\r\n123I void Pushup(int x) {    t[x].sz=t[lc(x)].sz+t[rc(x)].sz+t[x].cnt; //注意要加上当前结点的重复次数}\r\n旋转\r\n旋转操作分为左旋和右旋，左旋是将右子树变成根结点，而右旋则是将左子树变为根结点。\r\n嘛，其实就是将与旋转方向相反的子树作为根节点，毕竟你向左旋一定是右面上位啊（\r\n如图，这两个操作互为逆操作。\r\n\r\n123456789101112131415I void RotateL(int &amp;x) { //左旋    int y(rc(x)); //先把右儿子摘出来    rc(x)=lc(y); //把右儿子的左儿子变为右儿子    lc(y)=x; //把本来的根结点变为右儿子的左儿子    Pushup(x),Pushup(y); //分别更新    x=y; //编号也换位}I void RotateR(int &amp;x) { //右旋，和上面同理    int y(lc(x));    lc(x)=rc(y);    rc(y)=x;    Pushup(x),Pushup(y);    x=y;}\r\n插入和删除\r\n其实就是正常的插入操作，只不过这里要涉及到根据堆的性质进行旋转。\r\n至于删除操作主要的就是分类讨论，不同的情况处理方法不同。\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657I int Create(int val) {    t[++tot].val=val;    t[tot].sz=t[tot].cnt=1;    t[tot].rad=rand();    Heriko tot;}void Insert(int &amp;x,int val) {    if(!tot)        x=0;    if(!x)        x=Create(val);    else if(val==t[x].val)        ++t[x].cnt;    else if(val&lt;t[x].val) {        Insert(lc(x),val);        if(t[lc(x)].rad&gt;t[x].rad)            RotateR(x);    }    else {        Insert(rc(x),val);        if(t[rc(x)].rad&gt;t[x].rad)            RotateL(x);    }    Pushup(x);}void Remove(int &amp;x,int val) {    if(!x)        Heriko;    if(val==t[x].val) {        if(t[x].cnt&gt;1) //如果有多个那么就先减重复次数            --t[x].cnt;        else if(!lc(x) and !rc(x)) //如果是叶子结点直接删除            x=0;        else {            if(!rc(x) or t[lc(x)].rad&gt;t[rc(x)].rad) {                RotateR(x);                Remove(rc(x),val);            }            else {                RotateL(x);                Remove(lc(x),val);            }        }    }    else        val&lt;t[x].val?Remove(lc(x),val):Remove(rc(x),val);    Pushup(x);}\r\n查询元素排名\r\n一个元素在可重有序序列中的排名，显然是比他小的数的个数加一。\r\n123456789101112int QRank(int x,int val) {    if(!x)        Heriko -INF;            if(t[x].val==val)        Heriko t[lc(x)].sz+1;    if(val&lt;t[x].val)        Heriko QRank(lc(x),val);    Heriko QRank(rc(x),val)+t[lc(x)].sz+t[x].cnt;}\r\n查询指定排名的元素\r\n有如下分类：\r\n\r\n如果这个元素他的排名小于左子树的大小，那么在左子树。\r\n如果这个元素的排名大于左子树大小，但是小于左子树加根节点的重复次数，那么她在根结点。\r\n否则，则在右子树。\r\n\r\n123456789101112int QVal(int x,int rk) {    if(!x)        Heriko -INF;    if(t[lc(x)].sz&gt;=rk)        Heriko QVal(lc(x),rk);    if(t[lc(x)].sz+t[x].cnt&gt;=rk)        Heriko t[x].val;    Heriko QVal(rc(x),rk-t[lc(x)].sz-t[x].cnt);}\r\n查询某值的前驱/后继\r\n根据 BST 性质逐步找即可。\r\n12345678910111213141516171819int QPre(int x,int val) {    if(!x)        Heriko -INF;    if(t[x].val&gt;=val)        Heriko QPre(lc(x),val);    else        Heriko Hmax(t[x].val,QPre(rc(x),val));}int QSuf(int x,int val) {    if(!x)        Heriko INF;    if(t[x].val&lt;=val)        Heriko QSuf(rc(x),val);    else        Heriko Hmin(t[x].val,QSuf(lc(x),val));}\r\n全部代码\r\n封装到结构体里了。\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142CI MXX(1e6+5),INF(0x3f3f3f3f);struct Treap {    struct Node {        int sz,cnt;        int val,rad;        int l,r;    }    t[MXX];    #define lc(x) t[x].l    #define rc(x) t[x].r    int tot,rt;    I void Pushup(int x) {        t[x].sz=t[lc(x)].sz+t[rc(x)].sz+t[x].cnt;    }    I void RotateL(int &amp;x) {        int y(rc(x));        rc(x)=lc(y);        lc(y)=x;        Pushup(x),Pushup(y);        x=y;    }    I void RotateR(int &amp;x) {        int y(lc(x));        lc(x)=rc(y);        rc(y)=x;        Pushup(x),Pushup(y);        x=y;    }    I int Create(int val) {        t[++tot].val=val;        t[tot].sz=t[tot].cnt=1;        t[tot].rad=rand();        Heriko tot;    }    void Insert(int &amp;x,int val) {        if(!tot)            x=0;        if(!x)            x=Create(val);        else if(val==t[x].val)            ++t[x].cnt;        else if(val&lt;t[x].val) {            Insert(lc(x),val);            if(t[lc(x)].rad&gt;t[x].rad)                RotateR(x);        }        else {            Insert(rc(x),val);            if(t[rc(x)].rad&gt;t[x].rad)                RotateL(x);        }        Pushup(x);    }    void Remove(int &amp;x,int val) {        if(!x)            Heriko;        if(val==t[x].val) {            if(t[x].cnt&gt;1)                --t[x].cnt;            else if(!lc(x) and !rc(x))                x=0;            else {                if(!rc(x) or t[lc(x)].rad&gt;t[rc(x)].rad) {                    RotateR(x);                    Remove(rc(x),val);                }                else {                    RotateL(x);                    Remove(lc(x),val);                }            }        }        else            val&lt;t[x].val?Remove(lc(x),val):Remove(rc(x),val);        Pushup(x);    }    int QRank(int x,int val) {        if(!x)            Heriko -INF;                if(t[x].val==val)            Heriko t[lc(x)].sz+1;        if(val&lt;t[x].val)            Heriko QRank(lc(x),val);        Heriko QRank(rc(x),val)+t[lc(x)].sz+t[x].cnt;    }    int QVal(int x,int rk) {        if(!x)            Heriko -INF;        if(t[lc(x)].sz&gt;=rk)            Heriko QVal(lc(x),rk);        if(t[lc(x)].sz+t[x].cnt&gt;=rk)            Heriko t[x].val;        Heriko QVal(rc(x),rk-t[lc(x)].sz-t[x].cnt);    }    int QPre(int x,int val) {        if(!x)            Heriko -INF;        if(t[x].val&gt;=val)            Heriko QPre(lc(x),val);        else            Heriko Hmax(t[x].val,QPre(rc(x),val));    }    int QSuf(int x,int val) {        if(!x)            Heriko INF;        if(t[x].val&lt;=val)            Heriko QSuf(rc(x),val);        else            Heriko Hmin(t[x].val,QSuf(lc(x),val));    }}Tree;\r\n无旋 Treap\r\n正如其名，无旋 Treap\r\n不用旋转的方法来维护平衡，而是通过分裂和合并。在很多情况下可以比旋转\r\nTreap 更方便的实现别的操作。\r\n分裂\r\n分裂分为按值分裂和按排名分裂，我只写了前者的代码（\r\n按值分裂\r\n分裂就如正常想的那样，将一颗树强力断开从而生成两颗新树，按值分裂就是给出一个权值，因为本身\r\nBST 的权值是有特点的，所以可以按照权值将树分为两个部分，如图。\r\n\r\n123456789101112131415161718void Split(int x,int val,int &amp;lx,int &amp;rx) { //lx 和 rx 分别是最后分离开的两棵树的根    if(!x) {        lx=rx=0;        Heriko;    }    if(t[x].val&lt;=val) { //按照权值递归分裂        lx=x;        Split(rc(x),val,rc(x),rx);    }    else {        rx=x;        Split(lc(x),val,lx,lc(x));    }    Pushup(x);}\r\n按排名分裂\r\n按照排名分裂的操作类似于根据排名查询结点编号，核心仍然是将按照三种分类来逐层递归。\r\n合并\r\n在经过了多次的分裂之后，显然我们需要把这些树合并到一棵树上来应对询问。因为两个\r\nTreap\r\n都是有序的，所以我们只需要考虑两棵树哪棵在上面，而这里我们根据堆的性质直接讨论即可。\r\n1234567891011121314151617int Merge(int x,int y) { //默认 x 里面的所有结点值是小于 y 的    if(!x or !y)        Heriko x+y;    if(t[x].rad&gt;t[y].rad) {        rc(x)=Merge(rc(x),y);        Pushup(x);        Heriko x;    }    else {        lc(y)=Merge(x,lc(y));        Pushup(y);        Heriko y;    }}\r\n插入\r\n实现方法非常的简单，我们把这个树在这个新结点的权值处分裂，然后生成新结点将三者合并即可。这里是写的可以有相同结点存在的版本，当然也可以写成上面的旋转\r\nTreap 一样的使用一个变量记录结点重复次数的版本。\r\n12345I void Insert(int val) {    int x,y;    Split(rt,val-1,x,y);    rt=Merge(Merge(x,Create(val)),y);}\r\n删除\r\n和插入同理，通过分裂找到和 \r\n权值相同的结点，然后合并的时候不要他们即可。\r\n12345678910I void Remove(int val) {    int x,y,z;    Split(rt,val,x,z);    Split(x,val-1,x,y);    if(y)        y=Merge(lc(y),rc(y));    rt=Merge(Merge(x,y),z);}\r\n根据权值查询排名\r\n还是找出 \r\n的位置，然后分裂出来的左树的大小加一即为排名，不过不要忘了这种查询操作要再把树合并回去（\r\n12345678I int QRank(int val) {    int x,y,res;    Split(rt,val-1,x,y);    res=t[x].sz+1;    rt=Merge(x,y);    Heriko res;}\r\n根据排名查询权值\r\n和旋转 Treap 类似有三种分类，这里就不再重新写一次了。\r\n12345678910111213I int QVal(int rk) {    int x(rt);    while(x) {        if(t[lc(x)].sz+1==rk)            break;        else if(t[lc(x)].sz&gt;=rk)            x=lc(x);        else rk-=t[lc(x)].sz+1,x=rc(x);    }    Heriko !x?INF:t[x].val;}\r\n查询 val 的前驱后继\r\n都是和根据权值查询排名的类似操作，先找出来  的位置，然后一直根据 BST\r\n的性质跳即可。\r\n123456789101112131415161718192021222324252627I int QPre(int val) {    int x,y,nw,res;    Split(rt,val-1,x,y);    nw=x;    while(rc(nw))        nw=rc(nw);    res=t[nw].val;    rt=Merge(x,y);    Heriko res;}I int QSuf(int val) {    int x,y,nw,res;    Split(rt,val,x,y);    nw=y;    while(lc(nw))        nw=lc(nw);    res=t[nw].val;    rt=Merge(x,y);    Heriko res;}\r\n全部代码\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136CI MXX(5e5+5),INF(0x3f3f3f3f);struct FHQ_Treap {    struct Node {        int val,rad;        int sz;        int l,r;    }    t[MXX];    #define lc(x) t[x].l    #define rc(x) t[x].r    int tot,rt;    I void Pushup(int x) {        t[x].sz=t[lc(x)].sz+t[rc(x)].sz+1;    }    I int Create(int val) {        t[++tot].val=val;        t[tot].rad=rand();        t[tot].l=t[tot].r=0;        t[tot].sz=1;        Heriko tot;    }    void Split(int x,int val,int &amp;lx,int &amp;rx) {        if(!x) {            lx=rx=0;            Heriko;        }        if(t[x].val&lt;=val) {            lx=x;            Split(rc(x),val,rc(x),rx);        }        else {            rx=x;            Split(lc(x),val,lx,lc(x));        }        Pushup(x);    }    int Merge(int x,int y) {        if(!x or !y)            Heriko x+y;        if(t[x].rad&gt;t[y].rad) {            rc(x)=Merge(rc(x),y);            Pushup(x);            Heriko x;        }        else {            lc(y)=Merge(x,lc(y));            Pushup(y);            Heriko y;        }    }    I void Insert(int val) {        int x,y;        Split(rt,val-1,x,y);        rt=Merge(Merge(x,Create(val)),y);    }    I void Remove(int val) {        int x,y,z;        Split(rt,val,x,z);        Split(x,val-1,x,y);        if(y)            y=Merge(lc(y),rc(y));        rt=Merge(Merge(x,y),z);    }    I int QRank(int val) {        int x,y,res;        Split(rt,val-1,x,y);        res=t[x].sz+1;        rt=Merge(x,y);        Heriko res;    }    I int QVal(int rk) {        int x(rt);        while(x) {            if(t[lc(x)].sz+1==rk)                break;            else if(t[lc(x)].sz&gt;=rk)                x=lc(x);            else rk-=t[lc(x)].sz+1,x=rc(x);        }        Heriko !x?INF:t[x].val;    }    I int QPre(int val) {        int x,y,nw,res;        Split(rt,val-1,x,y);        nw=x;        while(rc(nw))            nw=rc(nw);        res=t[nw].val;        rt=Merge(x,y);        Heriko res;    }    I int QSuf(int val) {        int x,y,nw,res;        Split(rt,val,x,y);        nw=y;        while(lc(nw))            nw=lc(nw);        res=t[nw].val;        rt=Merge(x,y);        Heriko res;    }}Tree;\r\n如何过掉文艺平衡树\r\n众所周知文艺平衡树涉及到的区间翻转操作是\r\nSplay 独享的 moment 板子，但是无旋 Treap\r\n也是可以实现这个操作的。\r\n因为这道题并不关心树上的权值，所以我们只需要关注结点之间的顺序，即关注题目所要的中序遍历。\r\n所以我们需要使用按排名分裂，也就是保证结点相对顺序。\r\n那么我们把 \r\n分裂出来，然后在  上分出来\r\n\r\n的一段，就是题目所要求的翻转序列，我们对它进行操作即可。\r\n朴素的想法是把所有结点的左右儿子依次调转，但是显然这样复杂度为  级别，和暴力一样。\r\n然而我们并不需要树的形态真正改变，只需要中序遍历的时候序列输出反向即可，所以我们可以考虑使用类似线段树的\r\nLazyTag 方式，将需要翻转的区间的代表结点打上\r\nTag，然后在需要的时候在 Pushdown 即可。\r\nCode\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125CI MXX(1e5+1);struct FHQ_Treap {    struct Node {        int val,rad;        int tg,sz;        int l,r;    }    t[MXX];    #define lc(x) t[x].l    #define rc(x) t[x].r    int tot,rt;    I void Pushup(int x) {        t[x].sz=t[lc(x)].sz+t[rc(x)].sz+1;    }    I void Pushdown(int x) {        if(!t[x].tg)            Heriko;        swap(lc(x),rc(x));        t[lc(x)].tg^=1;        t[rc(x)].tg^=1;        t[x].tg=0;    }    I int Create(int val) {        t[++tot].val=val;        t[tot].rad=rand();        t[tot].l=t[tot].r=0;        t[tot].sz=1;        t[tot].tg=0;        Heriko tot;    }    void Split(int x,int rk,int &amp;l,int &amp;r) {        if(!x) {            l=r=0;            Heriko;        }        Pushdown(x);        if(t[lc(x)].sz&lt;rk)            l=x,Split(rc(x),rk-t[lc(x)].sz-1,rc(x),r);        else            r=x,Split(lc(x),rk,l,lc(x));        Pushup(x);    }    int Merge(int x,int y) {        if(!x or !y)            Heriko x+y;        if(t[x].rad&lt;t[y].rad) {            Pushdown(x);            rc(x)=Merge(rc(x),y);            Pushup(x);            Heriko x;        }        else {            Pushdown(y);            lc(y)=Merge(x,lc(y));            Pushup(y);                        Heriko y;        }    }    I void Insert(int val) {        int x,y;        Split(rt,val,x,y);        rt=Merge(Merge(x,Create(val)),y);    }    I void Reverse(int l,int r) {        int x,y,z;        Split(rt,l-1,x,y);        Split(y,r-l+1,y,z);        t[y].tg^=1;        rt=Merge(x,Merge(y,z));    }    void Print(int x) {        if(!x)            Heriko;        Pushdown(x);        Print(lc(x));        fw(t[x].val,0);        Print(rc(x));    }}Tree;int n,m;S main() {    Files();    srand(time(0));    fr(n),fr(m);    for(int i(1);i&lt;=n;++i)        Tree.Insert(i);    while(m--) {        int l,r;        fr(l),fr(r);        Tree.Reverse(l,r);    }    Tree.Print(Tree.rt);    Heriko Deltana;}\r\nSplay\r\nSplay 是另外一种\r\nBST，保持平衡的方法是不断地将结点旋转至根节点。\r\n说实话我真的不喜欢 Splay，长，常数不小，但是作为 LCT\r\n的辅助树好像不得不学，虽然我还没去学 LCT.\r\n结点结构\r\n和之前的两位 Treap 类似，只不过多记录了父亲结点来完成 Splay\r\n操作。\r\n1234567891011121314struct Node {    int cnt,val;    int sz;    int f,c[2];}    t[MXX];#define lc(x) t[x].c[0] //左儿子#define rc(x) t[x].c[1] //右儿子#define c(x,y) t[x].c[y] //c(x,0) 左儿子，c(x,1) 右儿子#define fa(x) t[x].f    int tot,rt; \r\n当然这里多 #define 了几个方便下面的使用。\r\n基本操作\r\n把一些不好分类的基本操作都放在这里了。\r\n1234567891011I void Pushup(int x) { //更新结点    t[x].sz=t[lc(x)].sz+t[rc(x)].sz+t[x].cnt;}I bool Status(int x) { //查询是什么儿子，左返回 0，右返回 1    Heriko x==rc(fa(x));}I void Clear(int x) { //清空结点    lc(x)=rc(x)=fa(x)=t[x].val=t[x].cnt=t[x].sz=0;}\r\n旋转\r\n和旋转 Treap\r\n的旋转基本一致，只不过需要多改一个父亲，所以还是把之前那图搬过来（\r\n\r\n123456789101112131415I void Rotate(int x) {    int y(fa(x)),z(fa(y)),st(Status(x));    c(y,st)=c(x,st^1);    if(c(x,st^1))        fa(c(x,st^1))=y; //相比旋转 Treap 多出来的    c(x,st^1)=y;    fa(y)=x,fa(x)=z; //这个也是    if(z)        c(z,y==c(z,1))=x; //这也是    Pushup(y),Pushup(x);}\r\nSplay 操作\r\n这是 Splay\r\n的核心所在，每访问一个节点后都要强制将其旋转到根节点，此时的旋转分为如下几种情况：\r\n（设要旋转的结点为 ，其父结点为\r\n， 的父结点为 ）\r\n\r\n如果 \r\n是根结点，直接一次旋转 \r\n即可。（绿图）\r\n如果  和  为相同类型的儿子，先旋转  再以相反的方向旋转 .（蓝图）\r\n如果  和 \r\n为不同类型的儿子，那么朝着分别两个方向旋转一次 .（紫图）\r\n\r\n\r\n然后把这些东西揉起来就是代码了（\r\n1234567I void Splay(int x) {    for(int i(fa(x));i=fa(x),i;Rotate(x))        if(fa(i))            Rotate(Status(x)==Status(i)?i:x);    rt=x;}\r\n插入\r\n插入比较麻烦，但是整体上思路还是清晰的。\r\n\r\n如果树空了那么直接插入根。\r\n如果找到和插入权值一样的结点，那么增加结点的重复次数，然后对其进行\r\nSplay 操作。\r\n如果没有相同权值的结点，那么在 BST 上找到空点位就插入即可（顺着\r\nBST 性质找即可）。\r\n\r\n123456789101112131415161718192021222324252627282930313233343536I void Insert(int val) {    if(!rt) {        t[++tot].val=val;        t[tot].cnt=t[tot].sz=1;        lc(tot)=rc(tot)=0;        rt=tot;        Pushup(rt);        Heriko;    }    int nw(rt),y(0);    while(1) {        if(t[nw].val==val) {            ++t[nw].cnt;            Pushup(nw),Pushup(y);            Splay(nw);            break;        }        y=nw,nw=c(nw,t[nw].val&lt;val);        if(!nw) {            t[++tot].val=val;            t[tot].cnt=t[tot].sz=1;            fa(tot)=y;            c(y,t[y].val&lt;val)=tot;            Pushup(tot),Pushup(y);            Splay(tot);            break;        }    }}\r\n查询排名/权值\r\n这个和之前的 Treap 的查询基本一致，只不过最后要进行 Splay 操作。\r\n12345678910111213141516171819202122232425262728293031323334353637383940I int QRank(int val) {    int ans(0),nw(rt);    while(1) {        if(val&lt;t[nw].val)            nw=lc(nw);        else {            ans+=t[lc(nw)].sz;            if(val==t[nw].val) {                Splay(nw);                Heriko ans+1;            }            ans+=t[nw].cnt;            nw=rc(nw);        }    }}I int QVal(int rk) {    int nw(rt);    while(1) {        if(lc(nw) and rk&lt;=t[lc(nw)].sz)            nw=lc(nw);        else {            rk-=t[nw].cnt+t[lc(nw)].sz;            if(rk&lt;=0) {                Splay(nw);                Heriko t[nw].val;            }            nw=rc(nw);        }    }}\r\n查询前驱/后继\r\n还是从 BST 性质出发。\r\n因为我们在 Splay 中插入一个元素是在根上，所以前驱就是 \r\n左子树最右面的结点，后继同理，然后查询完再把这个元素删掉即可。\r\n123456789101112131415161718192021222324252627I int QPre() {    int nw(lc(rt));    if(!nw)        Heriko nw;    while(rc(nw))        nw=rc(nw);    Splay(nw);    Heriko nw;}I int QSuf() {    int nw(rc(rt));    if(!nw)        Heriko nw;    while(lc(nw))        nw=lc(nw);    Splay(nw);    Heriko nw;}\r\n删除\r\n和插入一样，都比较麻烦（指代码），但是思路清晰。\r\n插入和删除代码麻烦是我不喜欢 Splay 的原因之一\r\n先要把 \r\n旋转到根结点，然后如果有重复次数就减一，否则合并其左右子树。\r\n合并的时候我们把左子树旋转到根，然后把右子树变为右儿子即可。\r\n别忘了操作完成后要 Splay.\r\n1234567891011121314151617181920212223242526272829303132333435363738394041I void Remove(int x) {    QRank(x);    if(t[rt].cnt&gt;1) {        --t[rt].cnt;        Pushup(rt);        Heriko;    }    if(!lc(rt) and !rc(rt)) {        Clear(rt);        rt=0;        Heriko;    }    if(!lc(rt)) {        int nw(rt);        rt=rc(rt);        fa(rt)=0;        Clear(nw);        Heriko;    }    if(!rc(rt)) {        int nw(rt);        rt=lc(rt);        fa(rt)=0;        Clear(nw);        Heriko;    }    int nw(rt),y(QPre());    fa(rc(nw))=y;    rc(y)=rc(nw);    Clear(nw);    Pushup(rt);}\r\n完整代码\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204CI MXX(1e5+5);struct SPlay {    struct Node {        int cnt,val;        int sz;        int f,c[2];    }        t[MXX];    #define lc(x) t[x].c[0]    #define rc(x) t[x].c[1]    #define c(x,y) t[x].c[y]    #define fa(x) t[x].f        int tot,rt;    I void Pushup(int x) {        t[x].sz=t[lc(x)].sz+t[rc(x)].sz+t[x].cnt;    }    I bool Status(int x) {        Heriko x==rc(fa(x));    }    I void Clear(int x) {        lc(x)=rc(x)=fa(x)=t[x].val=t[x].cnt=t[x].sz=0;    }    I void Rotate(int x) {        int y(fa(x)),z(fa(y)),st(Status(x));        c(y,st)=c(x,st^1);        if(c(x,st^1))            fa(c(x,st^1))=y;        c(x,st^1)=y;        fa(y)=x,fa(x)=z;        if(z)            c(z,y==c(z,1))=x;        Pushup(y),Pushup(x);    }    I void Splay(int x) {        for(int i(fa(x));i=fa(x),i;Rotate(x))            if(fa(i))                Rotate(Status(x)==Status(i)?i:x);        rt=x;    }    I void Insert(int val) {        if(!rt) {            t[++tot].val=val;            t[tot].cnt=t[tot].sz=1;            lc(tot)=rc(tot)=0;            rt=tot;            Pushup(rt);            Heriko;        }        int nw(rt),y(0);        while(1) {            if(t[nw].val==val) {                ++t[nw].cnt;                Pushup(nw),Pushup(y);                Splay(nw);                break;            }            y=nw,nw=c(nw,t[nw].val&lt;val);            if(!nw) {                t[++tot].val=val;                t[tot].cnt=t[tot].sz=1;                fa(tot)=y;                c(y,t[y].val&lt;val)=tot;                Pushup(tot),Pushup(y);                Splay(tot);                break;            }        }    }    I int QRank(int val) {        int ans(0),nw(rt);        while(1) {            if(val&lt;t[nw].val)                nw=lc(nw);            else {                ans+=t[lc(nw)].sz;                if(val==t[nw].val) {                    Splay(nw);                    Heriko ans+1;                }                ans+=t[nw].cnt;                nw=rc(nw);            }        }    }    I int QVal(int rk) {        int nw(rt);        while(1) {            if(lc(nw) and rk&lt;=t[lc(nw)].sz)                nw=lc(nw);            else {                rk-=t[nw].cnt+t[lc(nw)].sz;                if(rk&lt;=0) {                    Splay(nw);                    Heriko t[nw].val;                }                nw=rc(nw);            }        }    }    I int QPre() {        int nw(lc(rt));        if(!nw)            Heriko nw;        while(rc(nw))            nw=rc(nw);        Splay(nw);        Heriko nw;    }    I int QSuf() {        int nw(rc(rt));        if(!nw)            Heriko nw;        while(lc(nw))            nw=lc(nw);        Splay(nw);        Heriko nw;    }    I void Remove(int x) {        QRank(x);        if(t[rt].cnt&gt;1) {            --t[rt].cnt;            Pushup(rt);            Heriko;        }        if(!lc(rt) and !rc(rt)) {            Clear(rt);            rt=0;            Heriko;        }        if(!lc(rt)) {            int nw(rt);            rt=rc(rt);            fa(rt)=0;            Clear(nw);            Heriko;        }        if(!rc(rt)) {            int nw(rt);            rt=lc(rt);            fa(rt)=0;            Clear(nw);            Heriko;        }        int nw(rt),y(QPre());        fa(rc(nw))=y;        rc(y)=rc(nw);        Clear(nw);        Pushup(rt);    }}Tree;\r\n终\r\n因为目前就学了这几种平衡树，所以就先写这些，以后学了别的再补（\r\n","slug":"Balanced-Tree","date":"2022-07-24T06:49:45.000Z","categories_index":"OI-Algorithm","tags_index":"OI","author_index":"Heriko Deltana"},{"id":"1437984c9793a07a05ea1fb578f2c7d4","title":"FWT","content":"「初学 FWT.」\r\n\r\n\r\n\r\n主要从 xht37\r\n的洛谷模板题解学习。\r\n\r\n启\r\n摘自 APIO2022\r\n游记\r\n\r\n下午讲的 FWT 前半段好歹跟着听懂了一部分，所以晚上就开始搞 FWT，hyl\r\n因为之前会 FWT 于是就研究今天老师课件上很妙的定义方式，而我把 xht\r\n的题解整会了好歹是过了板子。\r\n\r\n前置知识\r\n\r\n记对序列 \r\n进行快速沃尔什变换为 \r\n显然对于已知的序列  和\r\n，直接计算  复杂度为 \r\n若对序列进行快速沃尔什变换都为  的，而  是\r\n 的，那么我们就可以  的求解出 \r\n在 OI 中，FWT\r\n是用于解决对下标进行位运算卷积问题的方法，即如下的形式：\r\n\r\n\r\n其中 \r\n是一种二元位运算，下面就来分别分析 or、and 和\r\nxor 三种运算如何利用 FWT 解决这类问题。\r\n或 or\r\n即：\r\n\r\n若有 ，，则有 ，于是可以构造 \r\n故有\r\n\r\n\r\n即：\r\n\r\n考虑将这个分治解决，方法是按照二进制下最高位分类，设  为最高位为  的那一段序列， 反之，于是就有：\r\n\r\nMerge 即拼接两端序列，序列之前的加法即对应位置相加。\r\n故有代码：\r\n123456I void FWTOr(LL f[]) {    for(int nw(2),k(1);nw&lt;=n;nw&lt;&lt;=1,k&lt;&lt;=1)        for(int i(0);i&lt;n;i+=nw)            for(int j(0);j&lt;k;++j)                (f[i+j+k]+=f[i+j])%=MOD;}\r\n同理  时，\r\n\r\n即：\r\n123456I void FWTOr(LL f[]) {    for(int nw(2),k(1);nw&lt;=n;nw&lt;&lt;=1,k&lt;&lt;=1)        for(int i(0);i&lt;n;i+=nw)            for(int j(0);j&lt;k;++j)                (f[i+j+k]-=f[i+j]+MOD)%=MOD;}\r\n所以可以综合为：\r\n123456I void FWTOr(LL f[],LL x) {    for(int nw(2),k(1);nw&lt;=n;nw&lt;&lt;=1,k&lt;&lt;=1)        for(int i(0);i&lt;n;i+=nw)            for(int j(0);j&lt;k;++j)                (f[i+j+k]+=f[i+j]*x%MOD)%=MOD;}\r\n与 and\r\n和 or 同理：\r\n123456I void FWTAnd(LL f[],LL x) {    for(int nw(2),k(1);nw&lt;=n;nw&lt;&lt;=1,k&lt;&lt;=1)        for(int i(0);i&lt;n;i+=nw)            for(int j(0);j&lt;k;++j)                (f[i+j]+=f[i+j+k]*x%MOD)%=MOD;}\r\n异或 xor\r\n我们考虑用类似的方式来拆解和式下标计算过程来构造 FWT.\r\n定义  于是可以发现满足 \r\n于是可以构造 \r\n则有：\r\n\r\n因此有：\r\n\r\n代码实现即为：\r\n123456789I void FWTXor(LL f[],LL x) {    for(int nw(2),k(1);nw&lt;=n;nw&lt;&lt;=1,k&lt;&lt;=1)        for(int i(0);i&lt;n;i+=nw)            for(int j(0);j&lt;k;++j) {                (f[i+j]+=f[i+j+k]+MOD)%=MOD;                f[i+j+k]=(f[i+j]-f[i+j+k]+MOD-f[i+j+k]+MOD)%MOD;                (f[i+j]*=x)%=MOD,(f[i+j+k]*=x)%=MOD;            }}\r\nCode\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687CI MXX((1&lt;&lt;17)+5),MOD(998244353);LL n,a[MXX],b[MXX],c[MXX],A[MXX],B[MXX];I void Into() {    for(int i(0);i&lt;n;++i)        a[i]=A[i],b[i]=B[i];}I void GetVal() {    for(int i(0);i&lt;n;++i)        c[i]=a[i]*b[i]%MOD;}I void FWTOr(LL f[],LL x) {    for(int nw(2),k(1);nw&lt;=n;nw&lt;&lt;=1,k&lt;&lt;=1)        for(int i(0);i&lt;n;i+=nw)            for(int j(0);j&lt;k;++j)                (f[i+j+k]+=f[i+j]*x%MOD)%=MOD;}I void FWTAnd(LL f[],LL x) {    for(int nw(2),k(1);nw&lt;=n;nw&lt;&lt;=1,k&lt;&lt;=1)        for(int i(0);i&lt;n;i+=nw)            for(int j(0);j&lt;k;++j)                (f[i+j]+=f[i+j+k]*x%MOD)%=MOD;}I void FWTXor(LL f[],LL x) {    for(int nw(2),k(1);nw&lt;=n;nw&lt;&lt;=1,k&lt;&lt;=1)        for(int i(0);i&lt;n;i+=nw)            for(int j(0);j&lt;k;++j) {                (f[i+j]+=f[i+j+k]+MOD)%=MOD;                f[i+j+k]=(f[i+j]-f[i+j+k]+MOD-f[i+j+k]+MOD)%MOD;                (f[i+j]*=x)%=MOD,(f[i+j+k]*=x)%=MOD;            }}I LL Inv(LL x,LL y=MOD-2) {    LL res(1);    while(y) {        if(y&amp;1)            (res*=x)%=MOD;        (x*=x)%=MOD;        y&gt;&gt;=1;    }    Heriko res%MOD;}S main() {    Files();    fr(n);    n=(1&lt;&lt;n);    for(int i(0);i&lt;n;++i)        fr(A[i]);    for(int i(0);i&lt;n;++i)        fr(B[i]);    Into(),FWTOr(a,1),FWTOr(b,1),GetVal(),FWTOr(c,MOD-1);    for(int i(0);i&lt;n;++i)        fw(c[i],0);    puts(\"\");    Into(),FWTAnd(a,1),FWTAnd(b,1),GetVal(),FWTAnd(c,MOD-1);    for(int i(0);i&lt;n;++i)        fw(c[i],0);    puts(\"\");    Into(),FWTXor(a,1),FWTXor(b,1),GetVal(),FWTXor(c,Inv(2));    for(int i(0);i&lt;n;++i)        fw(c[i],0);    puts(\"\");    Heriko Deltana;}\r\n另一种定义\r\n等我学会了就填坑（\r\n","slug":"FWT","date":"2022-05-27T13:08:58.000Z","categories_index":"OI-Algorithm","tags_index":"OI","author_index":"Heriko Deltana"},{"id":"c143396bc6a5425e72cbc5a10446c8d4","title":"Nothing : Asymmetry","content":"「≠」\r\n\r\n\r\n\r\n主要是觉得「不对等、不对称」很有意思所以就想把想的写一下。\r\n但是显然没空写所以就先放一个坑在这里。（2022.5.27）\r\n\r\n有没有一种可能，我本来是想要高考假期写来着，但是我忘了✌(2022.6.11)\r\n\r\n0\r\n不对等/不对称来自于一个信息经济学名词：信息不对称。\r\n引用百度百科解释：\r\n\r\n信息不对称（asymmetric\r\ninformation）指交易中的各人拥有的信息不同。在社会政治、经济等活动中，一些成员拥有其他成员无法拥有的信息，由此造成信息的不对称。在市场经济活动中，各类人员对有关信息的了解是有差异的；掌握信息比较充分的人员，往往处于比较有利的地位，而信息贫乏的人员，则处于比较不利的地位。不对称信息可能导致逆向选择（Adverse\r\nSelection）。一般而言，卖家比买家拥有更多关于交易物品的信息，但反例也可能存在。前者例子可见于二手车的买卖，卖主对该卖出的车辆比买方了解。后者例子如医疗保险，买方通常拥有更多信息。\r\n\r\n不过嘛，因为和经济层面离得很远，所以平常我多见的是社会生活中的信息不对等，即在社会生活、人际交往中，双方在交流时所拥有的信息量不相等，可能导致出现其中一方占据信息交流的优势地位，从而导致这一方引导了交流结果的走向。\r\n嗯……感觉说的有点抽象，其实主要也不是来写这个哒，主要是受到这个词的启发写一些相关或者不相关的感受（\r\n最一开始一开始的起因是网课时期的一些令人血压飞升的事情，比如上课使用疼逊双煞啥的……从而体现出来某些人喜欢用信息不对称来忽悠人……\r\n不过底下的东西基本都是超级发散了，和这个词有什么关系我也不知道，可能就是我觉得有吧，毕竟我写的东西，我的博客，我觉得有就是有！（（（\r\n¼\r\n因为大家都是不同的所以才会有这个世界，而个体间的差异才使得人和人之间有了交流和互助的必要（\r\n虽然有时候感觉”如果……和……一样就好了“的愿望，但是差异是无法抹除的呀，所以这种愿望大多是无法达成的（\r\n嘛，有时候想着能碰到一个能明白自己和自己一样的人，但是想了想这种人好像也没什么必要，毕竟我也不是很喜欢接下来的每一步都会让别人知道（\r\n然而总是有类似的人啦，可能是性格里看见这样的人就莫名想要靠近，可能是寻求什么奇怪的认同感吧……（我不到啊\r\n½\r\n有时候在思索为什么自己会想这么多的时候，会想会不会有别人也想这么多（反而又叠了一层思索空间我真的服了天天的给自己叠迷宫。。\r\n显然答案是……大概不会，感觉自己在想各种奇奇怪怪的东西上还是挺特立独行的（哈……哈……nima.\r\n（不知道为什么我看完辉夜心情会变的这么奇怪，可能就是被**赤坂气的，wdnmd\r\n赤坂你能不能动动脑子看看你到底画的什么东西，写的什么玩意！别打你那 APEX\r\n了，打个啥啊打）\r\n有时候在试探着……像看看会不会真的有这样的人（\r\n可惜，可惜我并不是很会说话完全探不出来=\r\n所以啊真的很羡慕那些坦率的人啊，不给自己加重思维复杂度。\r\n¾\r\n看番也好，看游戏剧情也好，有时候就会在想编剧是怎么写出来的，如果我去写……会写出来什么样的人物呢……\r\n所以前段时间，就有想着写一个人物出来会是什么样子的呢……\r\n于是发现自己所想的形象和自己会很像啊，只不过是，他所处的是一个我设计的世界啊，她可以去完成我完成不了的事情（\r\n所以也不算是我的对等体罢，所以有时候我虽然本身很容易带入番的剧情，有时候能找到和自己类似经历的人，但是最终还是为不可逾越的鸿沟而叹息。\r\n毕竟这个世界不是番中的世界，也不是我构造的世界，我只能姑且为自己的思虑开拓一个小的架空世界（\r\n1\r\n其实是否对等是一个前置条件不充分的命题。\r\n只有在前置条件足够充分的情况下，才能说是两者对等，否则……如果你想的话，总能找到差别的，毕竟这个世界可是千变万化的啊……\r\n我可以在学校隔壁的楼上望着，思索，那是因为我想。\r\n而不会有对应的思绪相系，因为没有人想，我。\r\n那么，终于算是填完坑了（呜呼↓不能给自己瞎挖坑啊（（\r\n","slug":"Asymmetry","date":"2022-05-27T06:28:31.000Z","categories_index":"Nothing","tags_index":"Me","author_index":"Heriko Deltana"},{"id":"95010b821825f0f88482008996bb4af7","title":"APIO2022 线上游记","content":"「如题。」\r\n\r\n\r\n笑死了 APIO 周五到周天，周一周二 whk 联考。\r\nDay1\r\n上午是 OI 中的计数，感觉高级而我不会，寄。\r\n好吧没想到 hyl 比我摆的还快（\r\n\r\nhyl 太厉害了！\r\n昨天的时候他说发现自己邮箱把 icloud 填成了\r\niicloud 于是就没有收到 APIO 的账号和密码。\r\n于是今天上午去给人家发邮件申请办理，然后中午起床来了之后发现人家说他提供的身份证号不能被确认身份。\r\n我就很震惊啊，他总不能把身份证号和邮箱地址都填错了吧。\r\n然后一看，嘿嘿，还真是（\r\n\r\n因为感觉上午的课件不可补所以就直接放弃了（\r\n下午讲的 FWT 前半段好歹跟着听懂了一部分，所以晚上就开始搞 FWT，hyl\r\n因为之前会 FWT 于是就研究今天老师课件上很妙的定义方式，而我把 xht\r\n的题解整会了好歹是过了板子。\r\n算是没白学吧（安慰自己\r\nhyl 的账号在下午终于回来了（\r\nDay2\r\n早上买了一个面包和一瓶咖啡。\r\n虽然我一直觉得学校里卖的雀巢瓶装的咖啡和喝奶一样，所以我几倍呢都是把他当奶喝（\r\n五个小时三道题，参考去年的话是三黑难度，尽量把暴力打满吧（\r\n把昨天晚上没写完的 FWT\r\n的初学博客写完了，但是为啥我的浏览器还是摆烂不给我加载 LATEX 啊。\r\n\r\n九点准时开题，但是这部分明天再补上，因为微信群里说是不让讨论题目，所以就先不写了。\r\n\r\n下午被自己博客的 \r\n整血压炸了（\r\n晚上因为吃饭时间和 OI 活动时间重合所以就没看，晚上本来想打\r\nABC，但是没打。\r\nDay3\r\nlxl：没问题吧，打开 UOJ 群.jpg\r\n","slug":"APIO2022","date":"2022-05-27T01:35:31.000Z","categories_index":"OI-TravelNotes","tags_index":"OI","author_index":"Heriko Deltana"},{"id":"f9dd77a8d9c603197c025568474433b3","title":"SDOI2022 线上游记","content":"「如题。」\r\n\r\n\r\n请注意我是线上省选和所有内容和现场省选不相关\r\nDay -INF\r\n因为今年 SD 疫情，所以 SD\r\n省选一推再推，从最一开始的参与联合省选，再到推迟到 5.1 再到推迟到\r\n5.15，然后甚至 9H6T 创造人类耐力省选奇迹。\r\n因为 JN\r\n的疫情还没有太好，于是济南就单独出来考了，省选这天正好也是非毕业年级的返校日，这次疫情导致在家上网课了\r\n40 多天。\r\n同样是因为疫情及场地原因，原本是二等线之上都能参加省选改成了 112\r\n分以上参加线下正式省选，其余参加线上同步省选，不计入成绩。\r\n于是我就线上了。\r\n其实本来不太像参加了，但是一直没找到人退钱。。（先交钱才改成的线上。。）\r\n所以就线上游记了。\r\nDay 1\r\n早上没去教室直接来机房了。\r\n上午\r\n先是过了一遍 3 题，初步判断是：T1 感觉可做，T2 大概 DP，T3\r\n大概计数但是不懂。\r\nT1 观察到每次询问  和 \r\n都是固定的，所以可以预处理出前缀和方便做，这样的话 \r\n的暴力显然。于是最一开始的想法是莫队找区间，但是每次询问都要生成一次 C\r\n成了瓶颈，就不知道咋搞。\r\n最后解决方案是在分块去找  和\r\n 累积答案，不知道对不对。\r\nT2 暴力能拿几分不知道。\r\n下午\r\nT1 感觉不可做，T2 卡空间不会做，T3 不会做。\r\n说到 T2，昨天才说了今天省选可能考树剖，然后 T2\r\n整一个……树剖，但是卡空间 64M……\r\n好吧！是一条链的情况我上一个树状数组。\r\n但是我写挂了，麻了不写了，因为这几天一直心情不好，然后就交了，管你几分吧。\r\nEND\r\n省选无关，我现在是想写想说的东西太多了但是并找不到人去诉说，或者绝对一点的讲……根本就没有。\r\n","slug":"SDOI2022","date":"2022-05-15T04:46:30.000Z","categories_index":"OI-TravelNotes","tags_index":"OI","author_index":"Heriko Deltana"},{"id":"3912367636d89ff1f1d4bcbe3c2f0587","title":"CF 1671","content":"「随便做点题。」\r\n\r\n\r\n不想写前言的最好方法，就是不写（\r\n因为这些题很简单所以简单一提。\r\nA String Building\r\n找出最小的串长，如果小于 \r\n就不能拼出来。\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566template&lt;typename J&gt;I J Hmin(const J &amp;x,const J &amp;y) {    Heriko x&lt;y?x:y;}CI MXX(55);char s[MXX];S main() {    Files();    int T;    fr(T);    while(T--) {        scanf(\"%s\",s+1);        int n(strlen(s+1)),mina(MXX),nw(0),minb(MXX);        for(int i(1);i&lt;=n;++i)            if(s[i]=='a')                ++nw;            else {                if(nw)                    mina=Hmin(mina,nw);                nw=0;            }        if(nw)            mina=Hmin(mina,nw);        nw=0;        if(mina==1) {            puts(\"NO\");            continue;        }        for(int i(1);i&lt;=n;++i)            if(s[i]=='b')                ++nw;            else {                if(nw)                    minb=Hmin(minb,nw);                nw=0;            }        if(nw)            minb=Hmin(minb,nw);        nw=0;        if(minb==1) {            puts(\"NO\");            continue;        }        puts(\"YES\");    }    Heriko Deltana;}\r\nB Consecutive Points Segment\r\n序列中只有一个数的时候显然怎么改都能保证连续；当序列中有多个数的时候，因为一个序列若满足连续，那么这个序列的首项和末项之差为\r\n，而且给我们能填入的数字都他相近的两个数，也就是说在这里我们只能让这个差值更小，所以我们只能在原序列差值小于等于\r\n\r\n的时候才能修改得到一个满足连续的序列。\r\n1234567891011121314151617181920212223242526CI MXX(2e5+5);int n,a[MXX];S main() {    Files();    int T;    fr(T);    while(T--) {        fr(n);        for(int i(1);i&lt;=n;++i)            fr(a[i]);        if(n==1)            puts(\"YES\");        else if(a[n]-a[1]&gt;n+1)            puts(\"NO\");        else            puts(\"YES\");    }    Heriko Deltana;}\r\nC Dolce Vita\r\n首先肯定会有一天是临界状态，即我们能在这一天买最多的，从这一天往后买的越来越少，所以我们可以直接去找这一天，因为要贪心排序所以时间复杂度\r\n\r\n1234567891011121314151617181920212223242526272829303132333435CI MXX(2e5+5);LL n,x,a[MXX];S main() {    Files();    int T;    fr(T);    while(T--) {        fr(n),fr(x);        LL sum(0),lst(-1),ans(0);        for(int i(1);i&lt;=n;++i)            fr(a[i]),sum+=a[i];        sort(a+1,a+1+n);        for(int i(n);i;--i) {            LL now(-1);            if(x-sum&gt;=0)                now=(x-sum)/i;            ans+=i*(now-lst);            lst=now;            sum-=a[i];        }        fw(ans,1);    }    Heriko Deltana;}\r\nD Insert a Progression\r\n先拿出来一个样例进行观察，可以发现如果在两个数之间填入一个数，那么这个序列的分数会不变或增大，那么我们就要尽可能的让这个序列的分数不变，即填入的数的大小在这两个数之间。\r\n这样的话只有  和  有可能会对分数造成影响，即最小值大于\r\n 和 最大值小于 \r\n的时候，所以我们枚举找到最小值即可。\r\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y) {    Heriko x&gt;y?x:y;}template&lt;typename J&gt;I J Hmin(const J &amp;x,const J &amp;y) {    Heriko x&lt;y?x:y;}CI MXX(2e5+5),INF(INT32_MAX);LL n,x,a[MXX];S main() {    Files();    int T;    fr(T);    while(T--) {        fr(n),fr(x);        LL mi(INF),mx(-INF),ans(0);        for(int i(1);i&lt;=n;++i)            fr(a[i]),mi=Hmin(mi,a[i]),mx=Hmax(mx,a[i]);        for(int i(2);i&lt;=n;++i)            ans+=abs(a[i]-a[i-1]);        if(mi&gt;1) {            LL tmpans(Hmin(a[1]-1,a[n]-1));            for(int i(2);i&lt;=n;++i)                tmpans=Hmin(tmpans,a[i]-2-abs(a[i]-a[i-1])+a[i-1]);            ans+=tmpans;        }        if(mx&lt;x) {            LL tmpans(Hmin(x-a[1],x-a[n]));            for(int i(2);i&lt;=n;++i)                tmpans=Hmin(tmpans,2*x-abs(a[i]-a[i-1])-a[i]-a[i-1]);            ans+=tmpans;        }        fw(ans,1);    }    Heriko Deltana;}\r\n嗯，就四道简单题，终。\r\n","slug":"CF-1671","date":"2022-05-03T01:47:30.000Z","categories_index":"OI-Solutions","tags_index":"OI","author_index":"Heriko Deltana"},{"id":"c2f162b0d9d8609f8fe8146717a605e4","title":"Nothing : Reverie","content":"「我常常思索，可我思索不出来。」\r\n\r\n\r\n前言\r\n可能是喜欢瞎想，而瞎想的程度又很深，所以有些东西想的确实很多，其实很多时候都是懒得开电脑或是在学校无法用电脑的时间段想到的，所以有些就埋藏起来了。\r\n然而有机会还是写一点吧，先把标题写出来，剩下的慢慢补吧。\r\n自由、爱、生活、生命\r\n这是仿佛是一个最近的东西，让人来排序，和 MBTI 有关好像。\r\n从标题也能看出来我的排序了。\r\n为什么这样排序呢？其实没有想太多东西，单纯就是看见哪个排哪个。\r\n首先是自由，个人觉得自由是很重要的东西，没有自由，剩下的三者没有了太大的意义。\r\n没有自由的爱，那是套着枷锁的舞蹈。\r\n没有自由的生活，那是树上枯末的灰叶。\r\n没有自由的生命，是麻木的存在。\r\n其次是爱和生活，实际上我觉得这俩其实是一个东西，所以并不好排序，然而我感觉被人爱了才有生活的价值，所以我把爱放在前面。\r\n最后是生命，很简单，没了上面，生命只是机体正常工作这种状态。\r\n我个人的感觉是，如果生命真的最重要，也不会有用生命换别的东西的人。\r\n没看过对于排序后的进一步人格分析，但我是 ENFP-T.\r\n占有\r\n锐评（信）：占有欲是人类最恐怖的欲望。当然，如果我不是人类这玩意再说（\r\n其实对不是很重要的东西并没有什么占有欲，所以一般来说找我借一般的东西还是挺容易的。\r\n不过想想平时，因为我占有的东西好像只有我（存疑）、我的电脑、手机而已。\r\n然而总是想得到一些自己可能这辈子都不会有的……\r\n网络\r\n之前在 16\r\n岁的回顾里说过我的线上线下逐渐分裂了，现在疫情停课在家可能更严重了。\r\n因为家里大部分时间都没人，所以感觉自己的语言能力快要消失了。\r\n不过最近这两天和🐏、🍑、🐟，以及 ysa 和 ysc\r\n打过几次电话，感觉好多了。\r\n于是网络成为了我的发声平台，也成为了我在家唯一的外界通道。\r\n意识到，网络是信息交互的载体，但是信息量好大，大到会影响我的很多方面，所以开始间断性的退网。\r\n但其实，即便是网络，也只是那几个支柱牵动神经，和在学校一样，只不过在网上更敢说一些东西了。\r\n我\r\n我感觉自己的样子，在自己脑海中越来越模糊了。\r\n大约是因为做出每个决定的我，好像都不太一样，而我在感知自己这一方面做的还是不太好的样子。我并不能感受到我做出某些选择的时候的原因，或者说，我并不太能明确的感知到自己。\r\n这个问题仿佛不是在家的问题，在学校也一样。在学校的时候因为天天有更多的学习压力，对自己的感知就更不清楚了，当然也没那个时间像在家一样内耗。\r\n所以我现在只是一个混合物的样子，不过也没人在意我是什么罢了，在我认识的绝大多数人来看，我是人是别的都无所谓罢。\r\n梦境和真实\r\n本来这两个是分开列出的，但是我想了想应该放在一起。\r\n我有时候就非常佩服自己做梦的本领，我真的好会做梦，梦见的东西相当真实，以至于让我常常分不清我到底是在梦中还是在醒着。当然，不排除我现在还在做一个长梦……\r\n做梦真的很有意思，尤其是在我分不清梦和真实的情况下。我的梦中总是能出现现实中不太可能发生但是发生了也不是很离谱的事情。\r\n梦里的我似乎更加完整，更能做到我想做的事情，真的好羡慕（\r\n不过有时候做梦太真实也不是什么好事，比如上课的时候假如有点困，脑子里就开始做梦，梦到的东西还是老师在讲课，讲的东西也和之前能对接上，班里上课的气氛也和现实一样，但是是在做梦。\r\n然后 SKP\r\n把我碰起来或是我自己压到自己的时候，才会发现，老师其实讲的不是那些东西，我睡着了。\r\n虽然已经很久没有上课睡着了。\r\n未来\r\n对于未来，我一直是抱着一种不确定的忐忑心理。太多的不确定性让我无法下决定，目标也随着经历逐渐淡化。\r\n但是一味的失落迷茫也是没有用的，所以我试图尽力去找到我的未来。\r\n即使有些愿两年之后的愿望实现的希望还很是渺茫，但是我努力去做吧。因为，这很重要。\r\n世界与重度依赖\r\n「世界」是我去年网易云的年度词汇，主要是来自于 IA 的一些歌。\r\n而我在元旦发烧的时候也写过，现实世界让我真的很绝望，这大概是去年试图自杀的主要原因之一。\r\n从某种意义上来讲，发烧的时候写出来的东西或许是最真切的体验，但全写出来还是于心不忍。\r\n现在来说世界于我而言就是那几个人，他们是我全部的支柱，于是也就有了精神状态会随着他们而波动的风险。然而我不知道他们中的每个人是不是都能接受我，所以我有时只能默默的想着，或者写点东西记录一下，窥探着，确定自己的世界不会突然坍塌。\r\n可我真的害怕没有人能注意到我，理解哪怕一部分的我。\r\n但是我真的好怕过度打扰他们了……可能他们之中可能有人开始烦我了吧。\r\n对于自己在家的时候，网络成为了和世界连接的唯一通道，所以只要我退网，我就可以给这个世界说再见了吧。\r\n空\r\n在很多时候会感到空寂，并不是没有事情去做，而是没有自己想做的事情。\r\n我可能真的需要有人理我，但是也可能不需要，因为我并不重要hh\r\n锁\r\n这个博客有些文章锁上了，密码并不是一样的，所以可访问的人的范围也会不同。\r\n为什么要锁呢，可能是个性所然，我一直喜欢把自己很多东西锁起来。\r\n或许锁起来的东西成为我情绪不稳定而不能向别人诉说的诱因。但是我选择仍然锁着，可能我决定好了和世界告别，就会把一切揭开吧。\r\n玩\r\n我喜欢玩，原因很简单，我不想面对。我在玩的时候，会忘掉很多，算是我最好的忘掉东西的方法了。\r\n负罪感\r\n小时候性格就是容易担心很多东西，按照妈妈的话就是多愁善感，所以小时候真的很容易哭。\r\n现在或许能忍住或是掩饰眼泪了，但是或许性格的底层未改，很容易担心人，或者事情。\r\n我真的很讨厌我这一点，这是我目前明确最讨厌的自己的一点，为什么总是担心这么多东西啊，担心了又有什么用吗，你活了十五年又不是不知道，你担心了这么多东西最后有几个有用的？不都是最后只能白白给自己增加难受吗……\r\n可是我懂了又能怎样啊，我没能改变，十五年了。\r\n如果这种东西也会传递的话，我还是早一点和这个世界告别的好，就看我啥时候决定了。\r\n真是矛盾，想要不影响别人，但是还去找别人，我有病。\r\n所以会一直一直一直一直一直一直一直一直一直一直一直一直一直一直一直一直一直一直一直一直一直为自己负罪，我永远有罪。\r\n光\r\n我喜欢光明，向往光，可是就算阳光正好，能否有一丝的光透进我呢。\r\n尾声\r\n那么这一些东西经过一个多周，大约就写完了吧。\r\n写下 Nothing 这一类的文章，大约是向这个世界告别之前留下一些东西。\r\n","slug":"Reverie","date":"2022-04-06T23:41:31.000Z","categories_index":"Nothing","tags_index":"Me","author_index":"Heriko Deltana"},{"id":"080f5a245d713ca2e2d4f3a9890cad1a","title":"谜语集","content":"「记录一些谜语。」\r\n\r\n\r\n启\r\n这些谜语，或没有谜底，或不是谜语。\r\n大多是在学校写的，所以在家的时间段会显著的少。\r\n2022.04.03\r\n颤抖的心情，等待的凉意。\r\n2022.03.31\r\n好，虽相比有差，然我觉得这更好，人格差恰适应此。\r\n2022.03.30\r\n\r\n为什么，为什么，为什么，为什么，为什么，为什么，为什么，为什么，为什么，为什么，为什么，为什么，为什么，为什么，为什么，为什么，为什么，为什么，为什么\r\n#某人潜伏生物宿舍一个半学期最终带领信息并入生物#\r\n\r\n2022.03.29\r\n\r\n昨天真有意思\r\n\r\n2022.03.28\r\n\r\n甚至不看我一眼\r\n阿罗车队就是晕蛋\r\n我的评价是：没必要\r\n我的评价是：为什么\r\n我的评价是：：：：：：：：\r\n我的评价是：所以。\r\n我的评价是：我真抽象。。\r\n\r\n2022.03.27\r\n\r\nNothing - Kimi\r\n优美，左手冰凉右手热，左半边脸热右半边凉，为啥会有这样的分差！祝我早日一分为二（）\r\n一只人类尚未能探知到自我\r\n占有欲是人类最恐怖的东西\r\n毒电波毒电波毒电波毒电波毒电波毒电波\r\n\r\n2022.03.26\r\n\r\nWhat's Happened? We need to know!\r\nWhat's Happened? We need to know!\r\nWhat's Happened? We need to know!\r\nWhat's Happened? We need to know!\r\n假面骑士 STROLL\r\n无知者无罪（信）\r\n\r\n2022.03.25\r\n\r\n有被笑到我过生日成为纸王，宽哥过生日成为水果（木瓜）摊（\r\n\r\n2022.03.24\r\n\r\n恢复跑操\r\n我就是那种除了学术问题都能问我的 B.\r\n\r\n2022.03.22\r\n\r\n这周从家里回来之后，总觉得手脚冰凉，即使上周三到周六气温比这几天低。\r\n好不容易把手捂热，一节课过去温度又下来了……\r\n\r\n2022.03.21\r\n\r\n窝法一二，冠宇夺分，彳亍\r\n什么是报告之王啊（后仰）真就近水楼台先得月\r\n恰当的用例总是能引发人的感情\r\n\r\n2022.03.20\r\n\r\n注意力偏移（信）\r\n\r\n2022.03.18\r\n\r\n腹有诗书气善华\r\n清早：谢谢有被吓到（再放送x）\r\n《假如我成为大导体》\r\n↓深海烧酒↑\r\n有些人好会（指又看了一下贺卡）\r\n人类，自相矛盾\r\n\r\n2022.03.17\r\n\r\n当我昨天第一个什么都没写（）\r\n浮想行止\r\n里表情人（x）、电火花（\r\n已经好久没数猎杀清单里多少人了，可能多了两三个\r\n\r\n2022.03.16\r\n\r\n可惜我执的笔写不出我真切的愿，而另一张纸上早已写满华章\r\n引用 SAI 的一句话：So close but so far.\r\n引用 LEC 的一句话：I am stupid；引用 VER 的一句话：Stupid\r\nidiot.\r\n\r\n","slug":"Set-of-Riddles","date":"2022-04-03T12:56:08.000Z","categories_index":"Nothing","tags_index":"Me","author_index":"Heriko Deltana"},{"id":"9d3ea1b7bb5f47fd56a5e9fe586cc10c","title":"Nothing : 20220401","content":"「四月一日。」\r\n\r\n\r\n启\r\n记所想而已。\r\n没有及时写下来，属实是语文太差，而自感过多（\r\n没有什么逻辑性，单纯想到什么写什么。\r\n春\r\n源\r\n\r\n岚 2022/4/1 0:25:46 四月快乐\r\n岚 2022/4/1 0:25:51 寝之前\r\n岚 2022/4/1 0:25:58 感觉还是得说\r\n岚 2022/4/1 0:26:22 当我们姑且把一个月的第一天当做新的开始的时候\r\n岚 2022/4/1 0:26:33 就必须要好好生活下去了\r\n白葱 2022/4/1 0:27:17 是呢（）\r\n岚 2022/4/1 0:27:17 这是一个清澈温暖的季节\r\n岚 2022/4/1 0:27:26 不管外面怎么样\r\n岚 2022/4/1 0:27:34 我们\r\n白葱 2022/4/1 0:28:35 我们（）\r\n岚 2022/4/1 0:28:58 每一天都要明媚喔\r\n岚 2022/4/1 0:29:03 （sign）\r\n白葱 2022/4/1 0:29:06 呜呜\r\n\r\n四季印象\r\n四月……\r\n我的记忆里，四月好像一直没有什么特殊的事情。\r\n可能是因为对于季节的概念随着在济南上学的时间增长而淡化了。\r\n去年一整年对于季节的更替好像只有冷暖之分，因为绝大多数时间都在机房和教室，就没有去关注周遭的环境。\r\n\r\n顺着想一下对于季节的记忆罢……\r\n春天，我印象里的春天，就是春的……花？现在去想小时在聊城，对于春天，脑袋里只有花了……\r\n花，于我而言，是什么呢……好像说不清楚，因为我不是那种专门去了解某种植物的人，所以我也只能分辨出来这些色彩的植株是花。\r\n我不是很喜欢看起来比较富贵或者说华丽的花，可能跟我不喜欢华丽闪亮的东西有关。\r\n喜欢比较纯净颜色的花，让我心情愉快（）\r\n总之春花于我的感觉比夏花更单纯啥的，所以春的记忆是花。\r\n今年无意中开始观察校园里的花，从冬末春初到现在渐入繁春，从等着它们开放到风过花现满眼，这就是我这里的春罢。\r\n月份的话，聊城和济南的春天时间差不多，基本都是二月中旬盼花开，五月初暮春初夏。\r\n\r\n我的夏，总是快乐，当然可能主要是有暑假（\r\n但是整个夏天的心态都会很好，干什么事情也都会很顺心，作为 IA\r\n推人，Orangestar 和 *Luna\r\n的夏曲是不能少的，当然，正式入术坑也是从夏天开始的。\r\n于是夏天在印象中是亮的，明亮，阳光与夏日的微风恰逢，融合出我心中的夏气。\r\n夏天的代表事物好多的样子，好像不太能是描述的样子。\r\n聊城记不清了，因为主要在济南嘛，所以只有假期才会回去，基本都是冬和夏，分不清时间了。\r\n济南好像从五月到十月初都是夏的样子（\r\n\r\n因为我想这些季节印象的时候首先会参考去年，所以其实不太想想秋天来着……\r\n但是又不是秋天的错，毕竟济南入冬还挺早的，十一月那个时候都下雪了，所以去年十一月算在冬天罢（\r\n都扯到哪去了（意识流也不能瞎扯啊ww\r\n但是秋天给我的总体印象是枫叶万叶的枫红和叶黄，这两个在我心中真的是非常温暖的颜色。\r\n所以秋天是温暖的，大概是续了盛夏后的余温，不至于热烈，但是平和而温暖。\r\n秋天最喜欢干的事情是看秋风过枫叶飘飞和沉浸在秋日的暖阳下，喜欢的颜色是蓝色，偏冷的蓝，但是秋的红橙黄总能带给我暖意，从目染，慢慢的，扩散至全身。\r\n所以我说过秋日的暖阳下是最舒服的（\r\n想起来去年停课的时候宽哥在一天阳光非常好的中午说，今天就应该在阳台上晒太阳（\r\n晒太阳好啊，晒太阳好（\r\n但是济南的秋天太短暂了，十月初夏还未散去，十一月初就开始下雪了（指去年\r\n\r\n冬。\r\n小时候问我最喜欢哪个季节的时候，我说的都是冬天，原因很简单，冬天下雪，雪纯净洁白，而我喜欢这种纯色的天然；冬天冷，水会成冰，冰质透，而我喜欢无色的原晶。\r\n可是去年冬天是真的冷啊w\r\n冬天好像没有什么花呐……不过也不是很重要啦，冬天我都是呆在屋子里罢（\r\n下雪会非常高兴，每次下雪跟没见过雪一样（（\r\n济南的冬天也很长，十一月就开始冷、下雪，然后一直到二月（\r\n那么，差不多就写完了欸。\r\n雨\r\n源\r\n出门买奶，下雨了。\r\n春雨\r\n想起来之前课文里的：“光头浇更舒服”了hh\r\n本来想在楼下多转几圈的，结果突然点雨点了（\r\n但是，我真的好喜欢这种小雨。雨落下的沙沙声，让这个世界不再是寂静或是小小的嘈杂，它掩盖了熵增，将天地连接成一体，仿佛，全世界都在雨中静默的思索着自己。\r\n喜欢在小雨中漫步，打不打伞并无所谓，反正我是喜欢小雨点在身上的清凉。\r\n雨中漫步，周围的景观仿佛更加清晰，而远方因为雨的笼罩而渐渐模糊。\r\n我常常在雨中忘了这个世界的外围，这种自己归属自己的感觉真好。于是有时候就在想，是不是在意别人太多了。当然，想了也改不掉了，我社交的习惯已经养成如此了。\r\n于是雨中就把自己留给自己罢。\r\n末\r\n本来可能写更多来着，但是 4.1 的东西已经拖到 4.3\r\n了，真的写不出来了（）\r\n还是没有勇气找到自己到底是谁。\r\n","slug":"Nothing-4-1","date":"2022-04-02T04:21:47.000Z","categories_index":"Nothing","tags_index":"Me","author_index":"Heriko Deltana"},{"id":"6b36ee370d1db44c985e315c41cb1521","title":"Hash 回顾","content":"对于 Hash 的一些回顾\r\n\r\n\r\n前言\r\n可能要给学弟学妹普及一下这个东西，所以顺便重新回顾一下吧。\r\nHash 的内容还是比较宽泛的，这里主要是 OI 中常用的字符串 Hash.\r\n本文缺省源使用：V5.3。\r\nHash 思想\r\n我们总会遇到非常大不便于存储或使用的数据，换一种方式来表示往往是一种比较好的解决方案。\r\n这里说的方式常是将数据映射到值域较小，可以比较的范围，一般来说这个范围在\r\n 或者 long long\r\n之内。\r\n下面以字符串 \r\n整数为例具体说一下。定义一个将字符串映射到整数的 Hash 函数 ，这个函数的作用就是能让我们快速的比较原来的字符串。\r\n具体一点来说，\r\n函数就需要有以下两个性质：\r\n\r\n，若 ，则 \r\n，若 ，则 \r\n\r\n然而第二条性质往往会有偏差，也就是说，会有 Hash\r\n值相同但是对应字符串不同的情况，我们称这种情况为哈希碰撞。\r\n所以在实现的时候除了时空复杂度，还需要考虑准确率。\r\nHash 实现\r\n通常，我们选用一个类似 \r\n进制数的方式来定义 Hash 函数，即多项式式。\r\n也就是说，对于一个长度为 \r\n的字符串 ，有：\r\n\r\n一般来说，这里的  和  都是质数。\r\n举个例子，对于字符串 ，有：\r\n\r\n可以看到就是一个 \r\n进制数的表示形式。\r\n一般 \r\n是一个比最大字符要大的质数，而 \r\n则是从  中选取一个。\r\nCode\r\n1234567891011121314CI MOD(1e9+7),X(233);I int Hash(char s[]) {    int res(0),len(strlen(s));    for(int i(0);i&lt;len;++i)        res=(res*X+s[i])%MOD;    Heriko res;}I bool CMP(char s1[],char s2[]) {    Heriko Hash(s1)==Hash(s2);}\r\n这样实现的话，每次查询 Hash 值是  的。进行  次比较，每次比较错误率为 ，总错误率就是  ， 的时候，大约是 ，其实不低。\r\n所以我们可以通过分别对两个模数取模来得到两个 Hash 值以扩充值域。\r\n12345678910111213141516171819202122232425262728293031323334353637383940414243CI MXX(1501),NXX(10005),MOD1(19260817),MOD2(998244353);int n;char s[MXX];namespace Hash {    #define ULL unsigned long long    struct Node {        ULL h1,h2;        I bool operator &lt; (const Node &amp;co) const {            Heriko (h1==co.h1)?(h2&lt;co.h2):(h1&lt;co.h1);        }        I bool operator != (const Node &amp;co) const {            Heriko !((h1==co.h1)&amp;(h2==co.h2));        }    }    a[NXX];    I void GetHash1(int pos,char s[]) {        int len(strlen(s));        ULL tmp(0);        for(int i(0);i&lt;len;++i)            tmp=(tmp*255+s[i])%MOD1;        a[pos].h1=tmp;    }    I void GetHash2(int pos,char s[]) {        int len(strlen(s));        ULL tmp(0);        for(int i(0);i&lt;len;++i)            tmp=(tmp*255+s[i])%MOD2;        a[pos].h2=tmp;    }}\r\n当然，这样常数也会大上不少，不过，准很多。\r\n但是显然多次询问的时候可以用更优的实现方式来优化查询的时间复杂度。\r\n首先， 子串  的 Hash 值为：\r\n\r\n（这个简单推一下就能出来）\r\n然后我们就可以  预处理  的幂和求 ，于是就可以做到查询 \r\nHash 应用\r\n字符串匹配\r\n这个将匹配串和文本串相比对即可。\r\n最长回文子串\r\n分别求出正反的 Hash 值，判断两侧是否相等，复杂度 \r\n最长公共子字符串\r\n若存在长度为 \r\n的公共串，那么长度为 \r\n的公共串也一定存在，所以可以二分长度，每次把每个原串中当前长度的字符串的\r\nHash 求交集，总体时间复杂度 \r\n骗分\r\n其实还有很多，而且例题也不少，所以我放一个不是哈希的题在这（\r\nNOIP 2021 T3 方差\r\n题目链接（洛谷）\r\n这题有一个 \r\n的部分分，于是我当时在考场就寻思打一个暴力。\r\n然后发现 DFS 的时候需要记录当前序列有没有被查过……\r\n所以我就每次把当前序列整一个 Hash 值，开个 map\r\n存一下有没有出现过即可。\r\n因为本身不是字符串题，也肯定不会有人卡模数，所以就用了\r\nunsigned long long 的自然溢出。\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384template &lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y){\tHeriko x&gt;y?x:y;}template&lt;typename J&gt;I J Hmin(const J &amp;x,const J &amp;y){\tHeriko x&lt;y?x:y;}CI MXX(10001),MOD(998244353),INF(0x7f7f7f7f);LL n,a[MXX],sm,ans,b[MXX];I LL Hash(LL tmp[]){\tLL res(0);\tfor(LL i(1);i&lt;=n;++i)\t\tres=(res*211+tmp[i])%MOD;\tHeriko res;}map&lt;LL,bool&gt; ump;void DFS(LL tmp[]){\tLL v(Hash(tmp)),res(0),sum(0);\tif(ump[v])\t\tHeriko;\tump[v]=1;\tfor(LL i(1);i&lt;=n;++i)\t\tsum+=tmp[i];\tfor(LL i(1);i&lt;=n;++i)\t\tres+=(tmp[i]*n-sum)*(tmp[i]*n-sum);\tres/=n;\tans=Hmin(ans,res);\tfor(LL i(2);i&lt;n;++i)\t{\t\tLL t(tmp[i]);\t\ttmp[i]=tmp[i+1]+tmp[i-1]-tmp[i];\t\tDFS(tmp);\t\ttmp[i]=t;\t}}S main(){\t// freopen(\"variance.in\",\"r\",stdin);\t// freopen(\"variance.out\",\"w\",stdout);\tfr(n);\tfor(LL i(1);i&lt;=n;++i)\t\tfr(a[i]),sm+=a[i];\tump[Hash(a)]=1;\t\tfor(LL i(1);i&lt;=n;++i)\t\tans+=(a[i]*n-sm)*(a[i]*n-sm);\tans/=n;\tfor(LL i(2);i&lt;n;++i)\t{\t\tLL t(a[i]);\t\ta[i]=a[i-1]+a[i+1]-a[i];\t\tDFS(a);\t\ta[i]=t;\t}\tfw(ans,1);\tHeriko Deltana;}\r\n然后可能数据比较水，过了 24 分。\r\n","slug":"Hash-review","date":"2022-03-25T09:26:31.000Z","categories_index":"OI-Algorithm","tags_index":"OI","author_index":"Heriko Deltana"},{"id":"2ba917cbd1aa0fcb43bb6612c2425e54","title":"SEKAI R1 赛后认锅","content":"「我是锅王。」\r\n\r\n\r\n前言\r\n首先呢，我是傻逼，昨天因为加字幕去了忘了二次验题。\r\n得分情况总体正常，不再说，下面来一一说我的锅。\r\nA 憧憬の翼\r\n\r\n题目链接\r\n题目背景歌曲链接\r\n\r\n贪心即可，答案即为 \r\nSTD 就不放了，反正签到题。\r\nB HelloWorld2022\r\n\r\n视频链接\r\n\r\n这题本身是一个树上每次将结点修改为其子树中最大值，每次询问子树中最大值的题，但是我寻思学弟学妹应该还不是都会树链剖分，所以就削了一刀到序列上了。\r\n但是我今天上课的时候突然想起来这玩意好像不太能 \r\n的做，但是不能及时过来说，所以真的很对不起。\r\nC Identity\r\n\r\n题目链接\r\n歌曲链接\r\n\r\n这个题本身是周末闲的没事想起来的一个东西，因为看起来问题好像也挺经典，所以拿来出应该也不会太难。\r\n然后最后 STD 有个地方溢出了于是数据锅了，真的很对不起。\r\n60 分做法\r\n设  表示考虑将  个区域用  种颜色分。\r\n首先考虑边界，显然 \r\n然后，我们先把这个圆拆为一条链，即不考虑首尾互斥的情况，那么答案显然是\r\n，然后我们考虑首尾冲突，可得多出来的方案数正好是\r\n 块用  种颜色填的情况，那么就有转移方程 \r\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*60pts Solution By Dfkuaid*/#define LOCAL#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int N = 100010;const int INF = 0x3f3f3f3f;const ll MOD = 1e9 + 7;template &lt;typename T&gt; inline void read(T &amp;x) {    x = 0; int f = 1; char c = getchar();    for (; !isdigit(c); c = getchar()) if (c == '-') f = -f;    for (; isdigit(c); c = getchar()) x = x * 10 + c - '0';    x *= f;}ll n, m, ans, t;inline ll fpow(ll a, int b) {    ll res = 1;    while (b) {        if (b &amp; 1) (res *= a) %= MOD;        b &gt;&gt;= 1, a = a * a % MOD;    }    return res;}inline void MAIN() {    read(n), read(m);    if (n == 1) ans = m;    else if (n == 2) ans = m * (m - 1) % MOD;    else ans = m * (m - 1) % MOD * (m - 2) % MOD;    for (int i = 4; i &lt;= n; ++ i)      ans = (m * fpow(m - 1, i - 1) % MOD - ans + MOD) % MOD;    printf(\"%lld\\n\", ans);}int main() {#ifdef LOCAL    freopen(\"in.txt\", \"r\", stdin);    freopen(\"out.txt\", \"w\", stdout);#endif    read(t); while (t --) MAIN(); return 0;}\r\n100 分做法\r\n首先，上面不考虑首尾矛盾的情况的柿子可以表示成这样：\r\n\r\n没错，这玩意最后能变成一个可以求通项的东西，下面写一下：\r\n\r\n1234567891011121314151617181920212223242526272829303132333435363738CI MOD(1e9+7);I LL FstPow(LL x,LL y) {    x%=MOD;    LL res(1);    while(y) {        if(y&amp;1)            (res*=x)%=MOD;        (x*=x)%=MOD;        y&gt;&gt;=1;    }    Heriko res;}LL T,n,m,ans;S main() {    Files();    fr(T);    while(T--) {        fr(n),fr(m);        ans=FstPow(m-1,n)%MOD;        if(n&amp;1)            ans-=(m-1);        else            ans+=(m-1);        fw(ans%MOD,1);    }    Heriko Deltana;}\r\nD 世界寿命と最後の一日\r\n\r\n题目链接\r\n歌曲链接\r\n\r\n题解\r\n","slug":"SEKAI-R1","date":"2022-03-16T08:56:18.000Z","categories_index":"OI-Solutions","tags_index":"OI","author_index":"Heriko Deltana"},{"id":"1e4043ea90d6485cff54f5c57877fe82","title":"16 次回环之日","content":"「十六岁生日巨献（bushi」\r\n\r\n\r\n\r\n提前几天开这个罢，想要等到回环的当天能够准时发出，毕竟周五当天写肯定是写不完罢。\r\n2022.02.27\r\n\r\n\r\n感觉快写成年度总结了（不就是吗\r\n2022.02.28\r\n\r\n\r\n好像大约能写完，好\r\n但是感觉内容没什么逻辑的样子，无所谓了（\r\n2022.03.01\r\n\r\n\r\n咋越写越慢了，感觉甚至写不完了（\r\n2022.03.02\r\n\r\n\r\n今天一定要写完（\r\n写完啦，完结撒花（并不\r\n2022.03.03\r\n\r\n\r\n今天在展望里加了一点东西，改掉了一些奇怪的语句（\r\n2022.03.11\r\n\r\n回顾\r\n去年，怎么说呢……\r\n好复杂的一年，经历的事情也很多，自己的变化也很多……\r\n那就从上次回环之日前一点开始回忆罢。\r\n2020.12 ~ 2020.1\r\n想起来也是一年前的事情了（废话）\r\n升入初三之后的状态是真的不好，学习成绩总是不向上走，大有一滑到底之势。于是，12\r\n月月考，就真的一滑到底了（\r\n当时大概是十二月中旬罢，当时的我在某种意义上算是日记本的地方上写下了：\r\n\r\n在那一天之前，却知道那一天不会到来。\r\n\r\n当时应该是对自己快绝望了，明明平常不比别人差，为什么实验班要参考的考试就炸成这样（\r\n所以这里写的“那一天”，就是实验班录取的那一天。不过那个时候的我心态还是调整得比较快的，毕竟去不了实验班那就考推荐生嘛，再不济中考也是可以的……罢。不过那个时候单调下降的成绩让我觉得中考希望也寄了的感觉（\r\n然后就换了一个比较离谱的位置（我咋想也想不到为啥我会和 jp\r\n同桌去，班主任换位的时候是忘了初一的事情了么w），然后度过了一个比较快乐的圣诞节（指帮迪哥打掩护以便于迪哥可以给\r\njp\r\n送礼物（草），以及第一次收到别人礼物（大约是，反正初中之前我也不记得了））。\r\n当然这个时期还是在好好学习的，期末考试虽然还是低于预期（主要是语文拉跨），但是也算是回升了，大约是没有压力的原因。\r\n一月的时候去参加了实验班选拔考试，放轻松考的，发挥啥样不知道，但是大约是除了信息炸了都算正常。（我的水平来说，毕竟本身不太适合其他科奥赛之类的，但是就信息写炸是我真的没想到的）想起来英语的作文格超级长，于是自己写了\r\n500 词的作文进去（草）\r\n考完期末考试和济南市抽测之后的一个周六的下午，因为是考完试了就放松了一点，去教室相对晚了一点，然后到了教室听见体育实心球可以补测，我其实非常想去，因为满分\r\n9.6 米，我 9.5x（\r\n但是级部主任在广播里说先等等，然后宣布了实验班的名单，一个一个的念名字。因为这个时候期末考试肯定没批完，所以我才发现参考期末考试好像只是为了稳心，所以我突然觉得我还是有希望的，于是就很紧张，万一有我呐（\r\njp 也很紧张，于是我俩就互相紧张的拽着对方袖子（草）\r\n很多熟悉的名字从广播里传来，班里也不断有被念到的同学，大家都为被念到的同学鼓掌（\r\n一百个了，应该没我了罢，应该……\r\n然后倒数第二个念到了我，我也就成了我们班最后一个进入实验班的同学（\r\n再往后就是比较常规的实验班生活了（\r\n2021.1 ~ 2021.6\r\n比较常规的实验班生活罢，也没啥而特别的好像，情绪波动趋向于月初沉月末高循环。\r\n2021.6 推荐生考试过了，顺利正式进入高中（\r\n6.16 初中那边毕业典礼，参与了部分毕业 PPT\r\n的制作啥的，挥手告别初中三年（\r\n然后就是全天奥赛，这也是我 OI\r\n水平提升最快的一个时期，也整好了暑假的培训计划（\r\n2021.7 ~ 2021.8\r\n和🐏、🍑度过了一个欢快的暑假（\r\n虽然日照的 SDSC 宿舍非常\r\n**，隔壁的小学生非常**，但是和🐏🍑过的挺快乐的（\r\n因为大约报班报低了，再加上那段时间的竞赛状态很好，所以每天下午模拟赛都挺顺畅的，Day\r\n6 的时候甚至 AK（也是我唯一一次 AK 比赛，大嘘\r\n在 SDSC 期间正式入坑了 Phigros 和\r\nArcaea，音游自此逐渐成为我手机上唯一玩的东西（\r\n因为 Arcaea 里有一首 IA 的 One Last Drive，于是第一次关注到\r\nIA（伏笔x）\r\n然后两次课都是在济南，除了 QBXT\r\n第一天考试因为电脑电源被后面孩子碰掉心态炸裂而爆零之外，感觉都在一个 21\r\n年我相对高的竞技状态上，最好成绩是 BCT 最后一天捡皮夹拿了 RK2（\r\n考完试之后一看睿站发现无意中转发的抽奖中奖了……草。\r\n话说我都不知道那条是抽奖来着，单纯的评论并转发（\r\n于是大约那天就把今年所有 RP 全用完了，一天之内一个皮夹一个中奖（\r\n感谢大哈鱼的 648，给我\r\n美好的日子总是短暂的，上完课就直接返校了。\r\n2021.9 ~ 2021.11\r\n大约从十月的下半段开始就停课了，停课之前的班内生活好像没有啥记住的了。\r\n好像影响比较大的是小明带着我入了术坑（\r\n九月中旬生物去湖南集训，因为宿舍里其他人都是生物的，于是有天中午就睡过了，那天因为教室里缺的人太多，甚至没人发现我没来（\r\n国庆假期前夕才想起来 9.29 是翔 B\r\n和小明的生日（其实是他们在群里都开始发他们在湖南生日的照片了我才想起来，我对不起\r\n国庆完了生物从湖南回来之后，我们就开始停课了，完美衔接生物，班里人总是不齐，不过班里少上六七个人也不是很影响（\r\n由于暑假的缘故，我和学长交际比较多。停课的日常就是上午做正睿的模拟赛，下午晚上补题。\r\n额但是不知道为啥吧，竞赛状态比暑假下降很多，放张正睿 rating\r\n在这里吧（\r\n\r\n其实 CSP 二轮之前的状态还是可以的，除了担心自己 T1\r\n挂掉之外（毒奶实锤(╯▔皿▔)╯\r\n然后就去了日照，懒得再复述了，看游记吧（\r\n从日照回来的那天晚上，没睡着，真的睡不着，谁能想到自己的第一次正式比赛以这样的形式结束。\r\n那天晚上真的是不知道该咋办了，虽然不断给自己说着 CSP 就是一个晋级\r\nNOIP 的跳板，但是心里还是意难平。\r\n放在四个多月后的今天，我感觉那可能是十一月的……一个预兆罢。\r\n因为自己铁不是一等，心里有点虚，所以再返校之后还是先去班里上了几天晚自习装作自己没有完全停课（\r\n但是等 NOIP 名单出来之后就还是全天停课了，心态恢复的还挺好的。\r\n然后就是被正睿的模拟赛连番血虐，低于百分成常态，不过本身我也不太有高分的预期，所以也觉得无所谓，于是就正常的补题\r\n2021.11.04……这天不太好[1]\r\n但是不好的事情还是不提了好，活着多好（\r\n于是就有了那天提前回家，然后就不想去学校了，直接去 BCT NOIP\r\n的班了。\r\n然后就是在自己学校的\r\nNOIP，考场想出来正解但是因为打挂以为是想假了，又炸了了一次\r\nT1，但是精神状态的原因就有了博客园和 Github 博客都没有写的\r\nNOIP 游记。\r\n我只能是对自己无语，也无助，于是第一年就以两个二等收尾了。\r\n当时还感觉 11 月有 20 天停课很长，现在好多事情都可能都忘了就觉得 11\r\n月消逝的非常快（\r\n2021.11 ~ 2022.2\r\n这段时间就是回归班学 whk 的日子了，中间夹了一个寒假（\r\n最一开始是觉得真的拉下好多课，但是由于级部里的进度我都学过了所以后期月考之前做了做期中的题感觉挺顺利的（\r\n但是期中和月考完全不是一个难度啊草，期中随随便便切掉，月考给我整不会了。不过作为高中第一次考试主要攒经验去了（\r\n然后就是一个快乐的元旦，Sociobiology Note\r\n里有说，懒得再写一遍了（\r\n因为没拿省一，也没有任何 whk\r\n优势，于是在这段期间思考明年的事情。已知的是上一级信息不受待见停课之后全都被扔到普通班，然而我经历过\r\n11\r\n月的低沉之后和其它一些原因是真的不想再去适应新的环境了，也不想离开这个环境（\r\n然而也不是没有解决方案，第一种是考回前\r\n200；第二种是上一级有学长选择不停课，成为了上一级唯一留在实验班的信息人（\r\n于是我决定效法，拿省一就润的话，今年暑假如果我觉得应该可以稳有那个水平了，就不长时间停课了，保持留在实验班吧。\r\n至于这段时间的心理状态的话，除了元旦的时候发烧、考完期末和寒假最后的时候，也没太有回到\r\n11 月的迹象了（\r\n新年的目标是活着就行（\r\n期末考试完全低于预期，不符合自己的练习量啥的。一般来说放在往前就依然按照之前的方式学就是了，但是十一月之后因为没有过往的负担了还是啥，准备故意开学考砸一次，看看会不会有老师找我。[2]\r\n然后寒假就没怎么学文化课，基本都在看奥赛或者不知道在干啥（感觉是在挣扎？），开学也故意考差，目标是班里倒数第一，试图摸班底。[Ex]\r\n但是结果就是并不是班里倒数第一，甚至也没有老师找我（[3]\r\n可能是因为现在内心世界即使重构，也是完全变形，和之前不一样了罢（[4]\r\n感觉十一月之后心理受到的影响还是挺大的，所以尽量避免这种事情罢（\r\n开学之后给自己心理暗示还是比较积极的，趁着这段乐观的重构期好好做一些事罢（\r\n展望\r\n前面说到了，对自己未来一年的预期不再像是上次回环之时了。\r\n这一岁目标就一个了，活着，活到 17.\r\n十一月以及之后我想了很多，很多。对自己的否定、肯定；对内心世界的肯定、否定；对未来的希望、失望；对前途的坚定、迷茫；对生命的滥想……\r\n还是顺其自然罢，活着就好，就算有极端的想法……\r\n那我不存在了，上面的都没用。\r\n所以活着罢，活到未来，这是我唯一的期许。[5]\r\n\r\n以下内容更新于 2022.03.11\r\n\r\n介于这几天发生的一些事情以及一些思考，对最后一段做一些简单的添加罢。\r\n前面说的活过这一年还是有点重了，某种意义上（\r\n因为我胆小啊（笑），只要没人要把我干掉就没啥问题的罢。\r\n之前写那些的时候主要是回想起太多不好的事情，所以就写的 down\r\n了一点。\r\n虽然还是比较难逃出来自己给自己压出来的阴影，但是不至于对自己干一些极端的事情罢（大概）[6]\r\n\r\n[1]\r\n我不会忘记那一天了。\r\n痛的，苦的，闷的，烦的，所有 downside\r\n的东西，一起冲向脑海了，我真的承载不住了，出生十五年来所有积压的东西，把我死死的压在地上。\r\n甚至快四个月过去了，那些东西到底从我身上离开了多少，我无法确定。那时的我那到底是谁呢，我吗？不知道，我真的不知道，不会描述，但是难受，不知道，真的不知道……\r\n世界崩塌的那一刻我不会描述。\r\n于是十一月之后就在一点点的重构世界（\r\n十一月之后感觉在各种方面还是变化挺大的，某种意义上之前我线上线下还是比较统一的，但是从那之后就开始，线上线下逐渐“分裂”了。\r\n我不知道哪个是真正的我，因为这好像都是我，但是好像有点偏向人格分裂了，不过和人格分裂的定义好像不太一样，人格分裂是完全的每个人格之前分裂开来不互通，而线下的我和线上的我之前好像还有一个独处的我连接着。\r\n其他方面的话，好像极端的想法多了一些，之前不敢的事情敢去做了。（当然还是有很多不敢的）\r\n情绪化更严重了，网络依赖更严重了（不如说是对“线上人格”的倾向更严重了）\r\n不愿意说话的时候变多了，自己一个人沉默的不知道要干什么的时候变多了。\r\n[2]\r\n寒假最后不知道自己想干啥，真的，而且很虚弱，不知道为什么。\r\n[Ex]\r\n寒假最后玩了主播女孩重度依赖，感觉对我还是挺有影响的，主要是认识到好像自己还有救，假如积极一点。\r\n说到重度依赖呢，今年在回归文化课之后逐渐发现了自己的一些精神支柱是别人的事实，而且这个支柱对我影响还挺大的。\r\n[3]\r\n看来已经学校没人在意我考成啥样了罢。\r\n[4]\r\n第一次有了想毁掉别人的想法，反正自己已经没有什么用了，无所谓了罢。\r\n[5]\r\n毕竟这个也失去真实世界的我的存在之后，一切都无法后悔了罢。\r\n[6]\r\n谁能想到一个周了我又想补充一些东西呐……\r\n首先是去掉了之前对于 11.04\r\n的前缀描述，感觉有点多余了，虽然没有人看。\r\n然后把这些字调成了真正的透明。\r\n想改一部分描述的主要原因是有点写的 down 了。\r\n其余原因就是生日之后每天都还过的挺好的（\r\n但是昨天开始微微感到架空世界的感觉了\r\n换句话来说就是把世界架空到一个或者一两个人或事之上了\r\n虽然这段时间挺好的，但是未来会怎么样呐？\r\n不是，我瞎想什么呢。。\r\n\r\n","slug":"16th","date":"2022-03-03T16:00:00.000Z","categories_index":"About Me","tags_index":"Me","author_index":"Heriko Deltana"},{"id":"e5c71879a251033d7463f1c63679489f","title":"回滚莫队浅记","content":"「浅谈回滚莫队。」\r\n\r\n\r\n前置知识\r\n之前写的普通莫队笔记，在这里当个前置知识，其实大约知道莫队大概就是把询问离线下来，分块并排序之后用两个指针\r\n 来更新信息统计答案即可。\r\n有时在区间转移的时候，有些删除或添加的操作无法实现，那么当只有一种操作不能实现的时候，就可以用莫队来解决这个问题，然而普通莫队是很难解决（或者说是不能解决）这个问题的，所以我们要对普通莫队进行改造，也就是回滚莫队。\r\n本文出现所有代码缺省源使用V5.3.\r\n「例题一」洛谷模板\r\n原题链接：P5906\r\n【模板】回滚莫队&amp;不删除莫队。\r\n「例题一」题目简述\r\n给定一个序列，多次询问一段区间 ，求区间中相同的数的最远间隔距离。\r\n序列中两个元素的间隔距离指的是两个元素下标差的绝对值。\r\n「例题一」思路简述\r\n首先来说这个题有什么操作不能实现。显然增加是好实现的，只需要每次在增加时更新距离信息（记录第一次出现和最后一次出现）即可。但是删除操作不能这样实现，因为在删除的时候若要更新答案，需要知道次大值……肯定是不能这样维护的，所以我们要让\r\n 和 \r\n在移动的过程中尽量避免删除操作，也就是尽量让  向左端移动， 向右端移动。\r\n那么我们每次枚举块，把块内的询问解决的时候，每次把  拉回当前块的右端，然后保证  只向右端移动，\r\n不断根据询问反复横跳，对于在一个块内的询问暴力更新（复杂度 ，不过可能实际略大），否则跳两个指针更新答案。因为块的是\r\n\r\n的，所以对于每个询问， 的移动是\r\n\r\n的，所以这样做的复杂度就是 \r\n「例题一」Code\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y) {    Heriko x&gt;y?x:y;}template&lt;typename J&gt;I J Hmin(const J &amp;x,const J &amp;y) {    Heriko x&lt;y?x:y;}CI MXX(2e5+1);int ans[MXX],a[MXX],b[MXX],n,blo[MXX],len,blocnt,qn,appeared[MXX],fstpos[MXX],lstpos[MXX],apn;struct Query {    int l,r,id;    I bool operator &lt; (const Query &amp;co) const {        Heriko (blo[l]==blo[co.l])?(r&lt;co.r):(blo[l]&lt;blo[co.l]);    }}q[MXX];int lst[MXX];I int Clac_Faster_Than_SF1000(int l,int r) {    int res(0);    for(int i(l);i&lt;=r;++i)        lst[a[i]]=0;    for(int i(l);i&lt;=r;++i)        if(!lst[a[i]])            lst[a[i]]=i;        else            res=Hmax(res,i-lst[a[i]]);      Heriko res;}S main() {    Files();    fr(n),len=sqrt(n);    for(int i(1);i&lt;=n;++i)        fr(a[i]),b[i]=a[i];    sort(b+1,b+1+n);    int nl(unique(b+1,b+1+n)-b-1);    for(int i(1);i&lt;=n;++i)        a[i]=lower_bound(b+1,b+1+nl,a[i])-b;    for(int i(1);i&lt;=n;++i)        blo[i]=(i-1)/len+1;    blocnt=blo[n];    fr(qn);    for(int i(1);i&lt;=qn;++i)        fr(q[i].l),fr(q[i].r),q[i].id=i;    sort(q+1,q+1+qn);    int l(0),r(0),nw(1),tmpans(0);    for(int i(1);i&lt;=blocnt;++i) {        int rx(Hmin(n,i*len));        l=rx+1,r=rx,tmpans=0,apn=0;        for(;blo[q[nw].l]==i;++nw) {            if(blo[q[nw].r]==i)                ans[q[nw].id]=Clac_Faster_Than_SF1000(q[nw].l,q[nw].r);            else {                while(r&lt;q[nw].r) {                    ++r;                    lstpos[a[r]]=r;                    if(!fstpos[a[r]])                        fstpos[a[r]]=r,appeared[++apn]=a[r];                    tmpans=Hmax(tmpans,r-fstpos[a[r]]);                }                int lsttmp(tmpans);                while(l&gt;q[nw].l) {                    --l;                    if(lstpos[a[l]])                        tmpans=Hmax(tmpans,lstpos[a[l]]-l);                    else                        lstpos[a[l]]=l;                }                ans[q[nw].id]=tmpans;                while(l&lt;=rx) {                    if(lstpos[a[l]]==l)                        lstpos[a[l]]=0;                    ++l;                }                tmpans=lsttmp;            }        }        for(int i(1);i&lt;=apn;++i)            fstpos[appeared[i]]=lstpos[appeared[i]]=0;    }    for(int i(1);i&lt;=qn;++i)        fw(ans[i],1);    Heriko Deltana;}\r\n「例题二」AT1219 歴史の研究\r\n原题链接：AtCoder-JOI2014\r\n歴史の研究；\r\n洛谷链接：AT1219\r\n歴史の研究。\r\n「例题二」题目简述\r\n给出长度为  的序列， 次询问，每次询问区间  中最大的重要度。\r\n重要度的定义为当前事件的权值 \r\n乘上事件在区间中出现次数 \r\n「例题二」思路简述\r\n和上个题一样，这个题添加操作也是很好实现的，维护一个桶即可，删除操作一样的不能实现，所以我们用同样的策略。\r\n「例题二」Code\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y) {    Heriko x&gt;y?x:y;}template&lt;typename J&gt;I J Hmin(const J &amp;x,const J &amp;y) {    Heriko x&lt;y?x:y;}CI MXX(2e5+1);int a[MXX],b[MXX],lx[MXX],rx[MXX],blo[MXX],n,qn,len,blocnt,cnt[MXX],co[MXX];LL ans[MXX],tmpans;struct Query {    int l,r,id;    I bool operator &lt; (const Query &amp;co) const {        Heriko blo[l]==blo[co.l]?r&lt;co.r:l&lt;co.l;    }}q[MXX];I void Add(int x) {    ++cnt[a[x]];    tmpans=Hmax(tmpans,(LL)cnt[a[x]]*b[a[x]]);}S main() {    Files();    fr(n),fr(qn),len=sqrt(n),blocnt=n/len;    for(int i(1);i&lt;=n;++i)        fr(a[i]),b[i]=a[i];    for(int i(1);i&lt;=qn;++i)        fr(q[i].l),fr(q[i].r),q[i].id=i;    sort(b+1,b+1+n);    int nl(unique(b+1,b+1+n)-b-1);    for(int i(1);i&lt;=n;++i)        a[i]=lower_bound(b+1,b+1+nl,a[i])-b;    for(int i(1);i&lt;=n;++i)        blo[i]=(i-1)/len+1;    for(int i(1);i&lt;=blocnt;++i)        lx[i]=rx[i-1]+1,rx[i]=lx[i]+len-1;    if(rx[blocnt]&lt;n)        ++blocnt,lx[blocnt]=rx[blocnt-1]+1,rx[blocnt]=n;//这里用了一种和前面不同的处理每个块端点的方法，都不难写    int l(0),r(0),nw(1);    sort(q+1,q+1+qn);    for(int i(1);i&lt;=blocnt;++i) {        mst(cnt,0);        r=rx[i],tmpans=0;        while(blo[q[nw].l]==i) {            l=rx[i]+1;            if(q[nw].r-q[nw].l&lt;=len) {                                mst(co,0);                LL anothertmpans(0);                for(int i(q[nw].l);i&lt;=q[nw].r;++i)                    ++co[a[i]];                for(int i(q[nw].l);i&lt;=q[nw].r;++i)                    anothertmpans=Hmax(anothertmpans,(LL)co[a[i]]*b[a[i]]);                for(int i(q[nw].l);i&lt;=q[nw].r;++i)                    --co[a[i]];                ans[q[nw].id]=anothertmpans;            }            else {                while(q[nw].r&gt;r)                    Add(++r);                LL lsttmp(tmpans);                while(q[nw].l&lt;l)                    Add(--l);                ans[q[nw].id]=tmpans;                tmpans=lsttmp;                while(l&lt;=rx[i])                    --cnt[a[l++]];            }            ++nw;        }    }    for(int i(1);i&lt;=qn;++i)        fw(ans[i],1);    Heriko Deltana;}\r\n终了\r\n终了。\r\n","slug":"Rollback-Mo-s-Algorithm","date":"2022-02-22T09:25:46.000Z","categories_index":"OI-Algorithm","tags_index":"OI","author_index":"Heriko Deltana"},{"id":"2b340e1849a1812b9cc593367ac19ea3","title":"Predict of F1 2022","content":"「关于 F1 2022 赛季的预测」\r\n\r\n\r\n同步于知乎：2022年新规大改后，哪些F1车队变数会特别大？\r\n冬测时的瞎想\r\n首先窝法冬测表现仍然不错，希望正赛能好一点，起码给 LEC 和 SAI\r\n争冠的机会吧（\r\n麦队整个冬测的表现也没有太多的问题，而且好像大家关注点都不太在麦队上（\r\n梅奔在巴塞罗那和巴林拿出了两版车，巴塞罗那的测试很稳定，但是巴林测试的这个表现……\r\n反正我是看着 W13B\r\n的直道表现真的令人无语……有点不像是藏东西（当然马桶狼老奸巨猾也不是没有可能\r\n红牛 RB18\r\n设计思路很多地方都很有意思，测试也基本上很稳定，小红牛除了巴塞罗那 GAS\r\n撞了好像也比较平淡。不过感觉小红牛在巴林的表现不是很好的样子（\r\n马丁这车……从巴林的表现来看……估计要寄。VET\r\n那几圈真是可以说惨目忍睹，一条赛道所有的可能锁死的地方都锁死了，甚至转向过度转向不足兼而有之……\r\n威廉姆斯整个冬测都很稳定，没有太大的亮点也没有什么槽点，感觉是除了速度比哈斯和阿尔法罗密欧强得多。\r\n然后就是难兄难弟，哈斯和阿尔法罗密欧。\r\n先是巴塞罗那的时候，两家车都一直因为各种原因寄掉，总里程数完全不够。巴塞罗那最后一天俄对乌特别行动，导致哈斯和乌拉尔钾肥的赞助关系取消，马泽平的席位后来也就没了（虽然换来了马格努森\r\n冬测之前的瞎想\r\n争冠行列\r\n前面有位老哥已经大体说过了，我的感觉也差不多（\r\n首先就研发实力来说的话，梅奔应该是比较确定的独一档。\r\n红牛因为今年的研发投入，明年车搞成啥样目前还没太有定数，不过就算崩了也不会太逊。\r\n上游\r\n然后就是法拉利和迈凯伦，感觉就上赛季来看，今年这两家还是会争一段时间。\r\n从研发角度来说，法家实力强一点，从今年仅有两个研发 token 的 SF21\r\n的改进，以及赛季末期引擎升级来看，我更看好法家，当然迈凯伦适应梅奔动力单元之后带来的提升也是个未知数。\r\n从车手角度来说 LEC 和 NOR 都是天赋异禀，但是就目前来看 SAI\r\n的稳定发挥拿分是要比 RIC 强不少的。（说实话 RIC\r\n适应了一个赛季的车是我没想到的，虽然迈队的车适合带速度入弯，不符合 RIC\r\n开红牛和雷诺时期早刹车入弯的习惯，，但是一个赛季都没配合好还是觉得有点……）\r\n（UPD 2022.2.5 ：感谢知乎上米兰米兰​的补充：RIC\r\n的习惯并不是晚刹车，是迈凯轮的车低速晚需要晚刹慢抬带比较重的 Trail Brake\r\n导致的 RIC 不适应）\r\n我个人还是希望这两家都能有个好的表现的（\r\n中游\r\n雷诺在 2021 失去了所有的客户车队之后，就剩下自己家的 Alpine 了（\r\n就今年的表现来说，奥康的皮夹和头哥的领奖台算是非常惊喜了，剩下的表现也都符合中游厂队的表现，至于研发方面，希望明年新引擎和新底盘能有好的表现吧（\r\n小红牛今年表现算是出色了，研发方面我感觉可能要寄（莫名），但是拿分还是非常稳的，角田明年应该能体现出来实力了，加斯利现在状态在顶峰，冲击领奖台还是有可能的。\r\n当然这个策略组我是真的看不懂了……今年小红牛策略真的无语……\r\n马丁今年拉还是比较能感觉出来的，去年的地球组第一（当然粉红梅奔也不是吹的）变成今年的……绿色拖拉机，心疼一波歪头……太会选队了，大有头哥之势（\r\n明年的研发估计不会太有起色，毕竟研发方式就比较被动，说好听了叫做逆向开发，说不好听了就是比着梅奔改……今年削底板、改后悬挂带来的后果也是非常明显了，据说本赛季还是保持之前的研发策略不变……我估计要寄。\r\n中下游\r\n都说哈斯放弃 2021 备战 2022 所以 2022\r\n的成绩可能会有大的提升。确实，但是提升估计大不了，而且两位公子爷的表现无法预测，2022\r\n将是哈斯生死攸关一年了，如果还是今年这个寄样，吉恩估计要卖队了。\r\n至于因为小周而备受关注的阿尔法，明年的主要提升，估计在窝法引擎上，其它估计没啥看头（\r\n威廉姆斯今年稍有起色，但是我个人觉得 RUS\r\n是火星人占据小半部分，明年估计威队或许能和马丁一战（？\r\nALB 的水平还是不错的，LAT 水平也一直有小的进步，威队 2022\r\n表现还是值得期待的。\r\n补充\r\n以上纯属个人根据最近两三个赛季的车队表现得出，因为是新规，所以不确定性还是很大的（\r\n万一窝法起来了呢（\r\n","slug":"PredictOfF12022","date":"2022-01-30T12:45:18.000Z","categories_index":"Other","tags_index":"F1","author_index":"Heriko Deltana"},{"id":"303723059d9d21ef04f23fae35acfd9c","title":"WC 2022 线上游记","content":"「WC 2022 线上游记。」\r\n\r\n\r\nDay -?\r\nWC 又一次因为疫情改到了线上，于是我也有了机会进行一个报名（\r\nDay 0\r\n下午开幕式，体验很莫名，但是居然有人跳舞是我没想到的。\r\nDay 1\r\n早上直接来机房，好事（虽然不如放假，但是也比上 whk\r\n好得多了），进行一个语文课文的背（\r\n上午\r\n上午是刘汝佳老师和曹钦翔讲的信息学竞赛中的直觉与证明。\r\n首先是一个证明一些贪心和 DP\r\n决策正确性的常见证明思路，就是要证明在任何时刻换一个决策都不会有更好的结果，因为我们会有很多的直觉（我没有），所以证明这些直觉是否正确是一个很重要的东西（\r\n讲了一种方法：\r\n\r\nExchange\r\nArgument：假设存在一个更优的算法和我们的决策相接近，然后通过交换两个算法里的一个步骤（或元素），得到一个新的更优的算法，同时这个算法比前一个最优算法更接近于我们的贪心算法，从而得到矛盾，原命题成立。过程就是交换元素后比较，不算难理解。\r\n\r\n决策规范化是个好东西，有时可以同时简化思路、证明和代码。\r\n找反例也是一个好习惯，可以精准的知道一个错误算法的缺陷到底在哪，当然若找不到，也是一种证明的过程，在时间有限的情况下，如果找了很多看起来能推倒当前结论的“反例”，那么也算是一种相对可信的证明过程（当然前提是你的“反例”有足够的强度）。\r\n当然把东西抽象出来也是好事，便于我们分析东西。\r\n还有一个\r\nrewrite，即改写，常用来证明等价性，常见的例子就是多项式展开、微积分（我不会）、手玩过程展开等\r\n\r\n第一段的时候讨论区无人发言，课间就变得活跃了起来，然后上课就一直很活跃了（\r\n草，第二节突然开始提速，SPEEEEEED UP.\r\n第三节持续 SPEEEEEED UP（坏\r\n两分钟一道题，害怕，害怕。\r\n下午\r\n下午的第一课堂是：网站可靠性工程中的算法，老师是钟诚。\r\n第二课堂是链表相关，但是我看了一遍课件只有跳跃表我不会，但是前段时间\r\ntyy 画的不用学的东西里就有这个（\r\n所以就去第一课堂听，然后顺便整理一下上午的内容。\r\n中间老师为了铺垫放了一段某电影的预告片，结果班主任进入机房问我为什么看电影。。\r\n然后中间因为打错个字被管理员踢出去了（？\r\n不能理解哦。\r\n然后因为疫情我不能通校了，但是……为什么学弟学妹今天就直接放假了（？\r\n不懂哦（\r\n前面那个事情，是因为管理员说要把说*脏话*的人踢出去，起因是老师一不小心说了个：wc，非常符合主题（bushi\r\n然后截止到五点，已经出现了 3*wc了（\r\n但是我寻思我也没发脏字啊（？\r\n \r\n不理解哦（\r\n晚上\r\n晚上是集训队大佬们的交流分享，先是”浅谈一类哈希表的复杂度分析“。\r\n说是和 OI 里学的关系不算很大，当作科普（\r\n那么就听吧，顺便把刚才选的树剖 + 李超线段树写一写（\r\n飞速讲完，居然是多人讲么，我还以为是就一个人（\r\n然后是“双射在划分计数上的应用”，有例题（\r\n然后是“模拟费用流”，这个时候正好我那题写完了，但是……略离谱，样例都不对。\r\n然后是……额这位大佬比较特别，ppt 名字就叫营员交流（\r\n然后晚上就一直在调 [SDOI2016]游戏……死活找不到错……日。\r\nDay2\r\n上午\r\n第一课堂看起来像是给集训队爷颓废指点前方道路的课，于是来第二课堂听网络瘤（\r\n讲课老师是李健欸（\r\n这些边我不加，这些边我不加，暴力怎么做？\r\n加边加边加边，冰茶姬查询（\r\n然鹅他今天讲的网络瘤（\r\n下午\r\n钱易佬讲 DS 杂题，这不得听之。\r\n但是发现越来越写不出来笔记了（呆\r\n前面能跟上，后面直接掉线（呆\r\n下课之后有位同学放出来了自己的灵梦fumo（好\r\n\r\n\r\nimage.png\r\n\r\nDay3\r\n上午\r\ndmy 讲杂题ww\r\n\r\n“我不会啊我就是个憨憨”\r\n”不要急优势在我“\r\n“有一个憨憨故事……啊三国演义，就锦囊”\r\n“怎么这么多评论区，哦说我现写，没有关系我和大家同场竞技”\r\n《我是椰树牌椰汁的粉丝，我很会排版》\r\n神峰：金 句 频 出\r\n神虎：我宣布，这里就是金句广场\r\n“有些同学说没听懂，没听懂还加个问号，那就是听懂了”（确信\r\n“初三开始给北京队讲，讲到现在”\r\n《没问题》\r\n《大家都很有智慧，谢谢大家》\r\n“恍然大雾我也不知道是恍然还是大雾，这可能是个偏义复词”\r\n《连 根 拔 起》\r\n《掀起波兰》\r\n神虎：《dmy 掀起波兰》\r\n“大家都是成熟的 OI 人了都会很熟练的使用 \r\n拉泰科了大家自己渲染一下”\r\n“给大家表演一下找代码，给大家表现一下我的技术（计数？）实力，我是纯憨憨，一个野蛮人”\r\n“哇我粘一下”\r\n“我给大家放大，很大很大“（指超出屏幕\r\n“return (0-0);//&lt;3”\r\n“这个题目很好，好就好在它什么是地方都很好，就都很好”\r\n“我认为这个题很好，你们都应该看看，因为这个题很好，就大家多看看非常好”\r\n“不是说这个题怎么，他就是非常好”\r\n“这个题很好，真的很好，非常有教育意义，就是对于刚学 DP”\r\n“有人会 ，有人会 ，有人会 ，有人会 ，这个题就是好在这个地方“\r\n”有的人读不懂题，确实”\r\n“啊对对对对，苹果输入法她很憨”\r\n“哎呀不想共享桌面，这样的话其他同学给我编做法就会被看见了”\r\n“优势在我，在不在，好像不太在”\r\n“我跟几个老哥交流做法，然后他们过来我没过就有点难过”（看起来是物理难过（\r\n“腾讯会议设计的人是个鬼才，大家以后设计东西一定不要设计成这样，我登录一下输验证码\r\n10 几次”\r\n“这题当时只有三个人过”\r\n“这个题（指上面那个三个人过的题）还是挺简单的”\r\n“很奇怪的就是做出来的好像都赢过 IOI”\r\n“后面还有好多道题，没有关系，优势（逐渐小声）……优势在谁（声音渐无）”\r\n《benq写了一年，dmy写了十分钟》\r\n《benq怎么做到的 很难理解》\r\n《很难理解》\r\n《benq的不会的题 我会 都是好题》\r\n“不要慌，优势在我，给大家表演一下光速讲课，我超会讲的啦，给大家共享一下，做大共享家”\r\n“这题我 20 分钟就过了，下个题我用了 114514 分钟”\r\n“这和我最近写的论文差不多，但是我写的论文的方法吊打他，这个不需要我论文的做法”\r\n“剩下还有六道题，四十分钟够了，不要急，优势在我”\r\n《luogu上能有加强版？》\r\n《luogu这么有实力的吗》\r\n“我题解进步很大，自从我用了太婆rua”\r\n“现在快晚上一点了，明天还有考试，上个大学怎么这么多事嘛”\r\n《构造主要就是图一乐》\r\n《T姓选手》\r\n“我电脑怎么卡了”\r\n《冷静一下，不要寄》\r\n《人工智能觉醒》\r\n《裹上鸡蛋面包糠》\r\n《苹果就这？》\r\n《有人在用他挖矿》\r\n《苹 果 就 是 垃 圾》\r\n《卡老师，不卡》\r\n神虎：#【】老师 SSH 侵入 MIT 网络并给 dmy 电脑下病毒#\r\n《是因为苹果太好了，所以永不重启》\r\n一上午的金句（\r\n发现同样的记录人：邓老师2022冬令营讲课简介\r\n下午\r\n鱼大讲构造，不过莫名 rap（\r\n我构造不能，冬眠营（\r\n\r\n草，完全掉线，写题去了（\r\nDay4\r\n上午\r\n大约只有第一课堂能听了吧（\r\n那就听彭老师讲 IOI2022 题目预测吧（\r\n虽然我这辈子估计都看不到IOI、NOI（\r\n说到动态电阻是 CTSC 标准题目（\r\n#物理被四大学科夺舍\r\n¯\\_(ツ)_/¯ 这表情好好笑（\r\nIOI: Host didn't want a 600\r\ndmy: 优势在我\r\n冬令营梗蜂以及梗鼠：\r\n\r\n\r\n椰树：dmy：《我是椰树牌椰汁的粉丝，我很会排版》\r\nfumo：上面说到了。\r\n土拨鼠：今天老师喜欢使用土拨鼠来表示惊讶（\r\n仓鼠：……\r\n\r\n离谱题：\r\n下午\r\nDCX 讲杂题（\r\n之前在 zr 听他讲题就觉得他声音特别像张京华，现在越听越像（\r\n就是声音像张京华，说话方式像 Tim（影视飓风）\r\n观看了评论区的 dmy 名言之后，发出感叹：《邓老师好有水平》\r\n草，综合版 \r\n晚上\r\n测试平台，额……和 NOI ONLINE/NOI 同步赛是一样的平台，给的测试题是 NOIO\r\n2020 #3 入门组题目\r\n幸好不是那个 T2 紫题的 NOIO 入门。\r\nT1 读错题了（\r\n然后做的还挺快的，没多久就全交上了，洛谷测了应该都对。\r\n今天晚上回家，希望明天考试 RP++.\r\nDay5\r\n\r\n因为今天考试而我又非常菜啥都不会，所以没有什么东西可以记的\r\n\r\n上午\r\n昨天晚上定了早上六点半的铃，铃响，我醒了，非常冷静的关掉了铃，然后接着睡（\r\n最后是七点起的床（\r\n八点二十多的时候把东西大约都准备好了（指本地的文件夹\r\n然后就开始做。\r\n上来看\r\nT1，怎么又是括号序列，我谢谢你，大约分析了十分钟左右发现可以将题目中给的操作转化为括号树上的旋转操作，然后能转化成一个链……\r\n然后我就不知道怎么搞了于是去看 T2.\r\nT2 的十分暴力非常显然，于是开始思考正解。\r\n因为是个排列所以思考如何利用排列性质……想了快一个小时没分析出来（\r\n然后因为一看就是 DS 题，所以考虑我曾经学过的 DS，经过了筛选之后 \r\n我都觉得不太行，于是最后剩下了分块和莫队。\r\n但是这题需要回滚莫队，我不会，爬了。\r\nT3 简而言之就是《我读不懂题但是写了纯随机但是觉得没用就没交》\r\n然后就寄了，10 分，可能就？\r\n那么这个 WC，就这样画上句号吧，哦对了下午还有讲评。\r\n下午\r\nT1：《小清新构造题》\r\nT2：《lxl DS 题》，说实话我看到成员列表出现 lxl 就觉得事情不妙（\r\nT3：《游戏改编但是随机化好多分 std 甚至写了 20k》\r\n那么这个\r\nWC，就这样画上句号吧，哦对了明天还有闭幕式，不过我个打铁的有啥好期待的。\r\nDay6\r\n啊哈哈哈，出分啦，差五分 Cu，菜，那么这个 WC，就这样画上句号吧。\r\n","slug":"WC2022Notes","date":"2022-01-23T00:35:28.000Z","categories_index":"OI-TravelNotes","tags_index":"OI","author_index":"Heriko Deltana"},{"id":"d02391e4e5b05700cce339d30dcd4af4","title":"李超线段树","content":"「李超线段树浅学浅记。」\r\n\r\n\r\n前言\r\n单纯的学了一下而已（\r\n因为尚未深入进行研究所以曰之浅学浅记。\r\n本次浅记就主要根据洛谷 P4097\r\n[HEOI2013]Segment 这道模板题来浅曰之，题目描述略。\r\n思路\r\n从一个相对好切入的点开始，实际上李超线段树某种程度上可以自己发明（？\r\n首先看到这个题，会发现我们需要一个 DS\r\n来维护这样一个线段的“容器”，它需要完成如题的各项操作。\r\n比较显然的是我们在每个区间内维护一个在本区间每个值都取值最大的线段的编号，那么我们就需要线段树来维护这个东西。\r\n那么考虑如何在每次插入线段的时候都能让每个区间保持最优，有两个步骤：\r\n\r\n这个区间是线段的定义域的子集，即 \r\n将此线段和当前区间内最优线段进行比较以让该区间保持最优。\r\n\r\n第一个步骤很好实现，那么考虑第二个，如何去比较呢？\r\n我们考虑让一个线段加入的影响通过不断二分区间来分化下传，下面来分类讨论之：\r\n假设我们新加入的直线/线段为 ，原有最大值为 ，区间中点为 \r\n\r\n 斜率大于 \r\n\r\n如果 ，那么\r\n\r\n在右子区间一定最优，而 \r\n仍有可能在左子区间更优。 \r\n反之，\r\n在左子区间一定最优，而 \r\n仍有可能在右子区间更优。 \r\n\r\n 斜率大于 \r\n\r\n如果 ，那么\r\n\r\n在左子区间一定最优，而 \r\n仍有可能在右子区间更优。 \r\n反之，\r\n在右区间一定最优，而 \r\n仍有可能在左子区间更优。 \r\n\r\n\r\n还有一些特殊情况，比如说形如 （\r\n为常数）的直线/线段，我们将其缩到每次的比较点来方便对比（\r\n当然，在比较的时候还需要考虑编号的大小，所以我们在比较的时候，将编号小的稍微加一点点（EPS）来保证我们每次得到的是编号更小的最优选择。\r\n然后就可以上代码了，复杂度的话，瓶颈在于 Pushdown 为\r\n，于是查询和修改的操作都为\r\n，总体复杂度就是 \r\nCode\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define Heriko return#define Deltana 0#define Romanno 1#define S signed#define LL long long#define DB double#define R register#define I inline#define CI const int#define CL const long long#define mkp(a,b) make_pair(a,b)#define mst(a,b) memset(a,b,sizeof(a))#define ON std::ios::sync_with_stdio(false);cin.tie(0)#define Files() freopen(\"RNMTQ.in\",\"r\",stdin);freopen(\"RNMTQ.out\",\"w\",stdout)using namespace std;template&lt;typename J&gt;I void fr(J &amp;x) {    short f(1);    x=0;    char c(getchar());    while(c&lt;'0' or c&gt;'9') {        if(c=='-')            f=-1;                c=getchar();    }    while(c&gt;='0' and c&lt;='9') {        x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^=48);        c=getchar();    }       x*=f;}template&lt;typename J&gt;I void fw(J x,bool k) {    if(x&lt;0)        x=-x,putchar('-');    static short stak[35];    short top(0);    do {        stak[top++]=x%10;        x/=10;    }    while(x);    while(top)        putchar(stak[--top]+'0');    k?puts(\"\"):putchar(' ');}template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y) {    Heriko x&gt;y?x:y;}template&lt;typename J&gt;I J Hmin(const J &amp;x,const J &amp;y) {    Heriko x&lt;y?x:y;}CI MXX(1e5+1),MOD1(39989),MOD2(1e9);const DB EPS(1e-12);I void Hmod(int &amp;x,int y,int mod) {    x=(x+y-1&gt;=mod)?x+y-mod:x+y;}#define lc(x) (x&lt;&lt;1)#define rc(x) (x&lt;&lt;1|1)struct Line {    DB k,b;    int id;    Line(const DB &amp;k=0,const int &amp;x=0,const int &amp;y=0,const int &amp;id=0) : k(k),b(y-x*k),id(id){}    I DB Calc(int x) {        Heriko k*x+b;    }    I bool Empty() {        Heriko !id;    }}t[MXX&lt;&lt;2];I void Hswap(Line &amp;x,Line &amp;y) {    Line z;    z=x,x=y,y=z;}I Line Lmx(Line x,Line y,int v) {    Heriko x.Calc(v)&gt;(y.Calc(v)+((x.id&gt;y.id)?EPS:-EPS))?x:y;}void Pushdown(int x,int l,int r,Line v) {    int mid((l+r)&gt;&gt;1);    if(t[x].Empty())        t[x]=v;    else {        if(v.Calc(mid)&gt;t[x].Calc(mid)+(v.id&gt;t[x].id?EPS:-EPS))            Hswap(v,t[x]);        if(v.Calc(l)&gt;t[x].Calc(l))            Pushdown(lc(x),l,mid,v);        else if(v.Calc(r)&gt;t[x].Calc(r))            Pushdown(rc(x),mid+1,r,v);    }}void Modify(int x,int lx,int rx,Line v,int l=1,int r=MXX) {    if(lx&lt;=l and r&lt;=rx)        Heriko Pushdown(x,l,r,v);    int mid((l+r)&gt;&gt;1);    if(lx&lt;=mid)        Modify(lc(x),lx,rx,v,l,mid);        if(rx&gt;mid)        Modify(rc(x),lx,rx,v,mid+1,r);}Line Query(int x,int pos,int l=1,int r=MXX) {    if(l==r)        Heriko t[x];    int mid((l+r)&gt;&gt;1);    if(pos&lt;=mid)        Heriko Lmx(t[x],Query(lc(x),pos,l,mid),pos);    else        Heriko Lmx(t[x],Query(rc(x),pos,mid+1,r),pos);}int n,lmd,lstans,cnt;S main() {    Files();    fr(n);    while(n--) {        int opt;        fr(opt);        if(!opt) {            int x1;            fr(x1),Hmod(x1,lmd,MOD1);            fw((lstans=Query(1,x1).id),1);            lmd=lstans%MOD1;        }        else {            int x1,x2,y1,y2;            Line v;            fr(x1),fr(y1),fr(x2),fr(y2);            Hmod(x1,lmd,MOD1),Hmod(x2,lmd,MOD1);            Hmod(y1,lstans,MOD2),Hmod(y2,lstans,MOD2);            if(x1&gt;x2)                x1^=x2^=x1^=x2,y1^=y2^=y1^=y2;            if(x1==x2)                v.b=Hmax(y1,y2),v.id=++cnt;            else                v=Line(1.0*(y2-y1)/(x2-x1),x1,y1,++cnt);                        Modify(1,x1,x2,v);        }    }    Heriko Deltana;}\r\n","slug":"Li-Chao-Tree","date":"2022-01-23T00:23:57.000Z","categories_index":"OI-Algorithm","tags_index":"OI","author_index":"Heriko Deltana"},{"id":"f5e27344f2b5924049019b3fd3c25797","title":"树链剖分中的边权变点权","content":"「浅谈树链剖分中的边权变点权」\r\n\r\n\r\n前言\r\n因为我只会轻重链剖分，所以下面都是说的轻重链剖分。\r\n发现自己会写这个也有很长时间了，所以来水丶东西。\r\n最近写了好两个，稍微借题来搞一搞，估计篇幅会很短，因为主要是简单说一说思路啥的。\r\n思路\r\n首先，都知道树链剖分是用来维护一棵树上的结点信息的一种思想，而对于一些题，我们需要维护树上的边权，于是我们就需要将边权等效替换到点权上。\r\n貌似这样的题在洛谷上的评级都是紫，但是其实没那么难（话说你谷评级啥时候准过。。）\r\n首先简单画棵树：\r\n\r\n显然如果我们要把边权变为点权，需要把权值化到边的两端。\r\n而因为一个结点会出现对应多条边的情况，所以我们将权值放到深度浅的结点是不合适的，于是我们把他放在深度深的那个点：\r\n\r\n于是我们就可以进行快乐的操作了。\r\n实现\r\n线段树部分显然是不用动了，因为我们不需要对线段树做出特定的要求，换句话说，如果写树状数组或者珂朵莉树的话也是可以用的。\r\n于是就来看前置的两个 DFS\r\n和后面的树链部分需要作何修改。\r\nDFS\r\n首先，因为我们要重新划归权值到点上，所以我们需要建立一个映射到点上的权值数组，这个直接在遍历的时候建立即可。\r\n1234567891011121314151617181920void DFS1(int x,int fath){    sz[x]=1,fa[x]=fath;    for(int i(head[x]);i;i=r[i].nex)    {        int y(r[i].to),v(r[i].val);        if(y==fath)            continue;        dep[y]=dep[x]+1;        tmp[y]=v;//这里 tmp 就是。        DFS1(y,x);        sz[x]+=sz[y];        if(sz[y]&gt;sz[son[x]])            son[x]=y;    }}\r\n然后，因为我们还需要建立原树结点到线段树上的结点的映射，所以方便起见把权值也映射过去（\r\n1234567891011121314151617void DFS2(int x,int tp){    top[x]=tp,id[x]=++cnt,antid[cnt]=x,a[cnt]=tmp[x];//这里的 a 就是。    if(son[x])        DFS2(son[x],tp);    for(int i(head[x]);i;i=r[i].nex)    {        int y(r[i].to);        if(y==fa[x] or y==son[x])            continue;        DFS2(y,y);    }}\r\n树链部分\r\n需要注意到的是我们询问一段路径上的边权最大值的时候，由于我们把权值全部下方到深度深的结点，所以路径上最浅结点的权值是不能计算在内的：\r\n\r\n于是我们把原本修改和查询中最后在一条链上的情况稍作修改，即从\r\nModify(1,id[x],id[y],v); 和\r\nQuery(1,id[x],id[y]); 变为\r\nModify(1,id[x]+1,id[y],v); 和\r\nQuery(1,id[x]+1,id[y]);.\r\n全部代码即为：\r\n12345678910111213141516171819202122232425262728293031323334353637I void MTree(int x,int y,int val){    while(top[x]!=top[y])    {        if(dep[top[x]]&lt;dep[top[y]])            swap(x,y);        Modify(1,id[top[x]],id[x],val);        x=fa[top[x]];    }    if(dep[x]&gt;dep[y])        swap(x,y);    Modify(1,id[x]+1,id[y],val);}I int QTree(int x,int y){    int res(0);    while(top[x]!=top[y])    {        if(dep[top[x]]&lt;dep[top[y]])            swap(x,y);        res+=Query(1,id[top[x]],id[x]);        x=fa[top[x]];    }    if(dep[x]&gt;dep[y])        swap(x,y);    res+=Query(1,id[x]+1,id[y]);    Heriko res;}\r\n例题\r\n洛谷 | P1505 旅游\r\n[国家集训队]\r\n\r\nTime: 1s | Memory: 256Mb\r\n\r\n这道题就需要用到上面的操作把边权下放到点权。\r\n当然，因为这个题的特殊性（需要维护最大值、最小值、区间和），所以代码会很长（（\r\n不过还是不难的，线段树多复制几个函数分别维护即可。\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define Heriko return#define Deltana 0#define Romanno 1#define S signed#define LL long long#define R register#define I inline#define CI const int#define mkp(a,b) make_pair(a,b)#define mst(a,b) memset(a,b,sizeof(a))#define ON std::ios::sync_with_stdio(false);cin.tie(0)#define Files() freopen(\"RNMTQ.in\",\"r\",stdin);freopen(\"RNMTQ.out\",\"w\",stdout)using namespace std;template&lt;typename J&gt;I void fr(J &amp;x){    short f(1);    x=0;    char c(getchar());    while(c&lt;'0' or c&gt;'9')    {        if(c=='-')            f=-1;                c=getchar();    }    while(c&gt;='0' and c&lt;='9')     {        x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^=48);        c=getchar();    }       x*=f;}template&lt;typename J&gt;I void fw(J x,bool k){    if(x&lt;0)        x=-x,putchar('-');    static short stak[35];    short top(0);    do    {        stak[top++]=x%10;        x/=10;    }    while(x);    while(top)        putchar(stak[--top]+'0');    k?puts(\"\"):putchar(' ');}template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y){    Heriko x&gt;y?x:y;}template&lt;typename J&gt;I J Hmin(const J &amp;x,const J &amp;y){    Heriko x&lt;y?x:y;}CI MXX(2e5+1),INF(0x7fffffff);struct Edge{    int nex,to,val;}r[MXX&lt;&lt;1];int rcnt,head[MXX];I void Add(int x,int y,int z){    r[++rcnt]=(Edge){head[x],y,z},head[x]=rcnt;    r[++rcnt]=(Edge){head[y],x,z},head[y]=rcnt;}int tmp[MXX],cnt,a[MXX],sz[MXX],fa[MXX],dep[MXX],son[MXX],top[MXX],id[MXX],antid[MXX];void DFS1(int x,int fath){    sz[x]=1,fa[x]=fath;    for(int i(head[x]);i;i=r[i].nex)    {        int y(r[i].to),v(r[i].val);        if(y==fath)            continue;        dep[y]=dep[x]+1;        tmp[y]=v;        DFS1(y,x);        sz[x]+=sz[y];        if(sz[y]&gt;sz[son[x]])            son[x]=y;    }}void DFS2(int x,int tp){    top[x]=tp,id[x]=++cnt,antid[cnt]=x,a[cnt]=tmp[x];    if(son[x])        DFS2(son[x],tp);    for(int i(head[x]);i;i=r[i].nex)    {        int y(r[i].to);        if(y==fa[x] or y==son[x])            continue;        DFS2(y,y);    }}#define lc(x) (x&lt;&lt;1)#define rc(x) (x&lt;&lt;1|1)struct Node{    int l,r,tg,mx,mi,v;}t[MXX&lt;&lt;2];I void Pushup(int x){    t[x].mi=Hmin(t[lc(x)].mi,t[rc(x)].mi);    t[x].mx=Hmax(t[lc(x)].mx,t[rc(x)].mx);    t[x].v=t[lc(x)].v+t[rc(x)].v;}I void Cover(int x){    t[x].tg^=1;    t[x].v=-t[x].v;    t[x].mi=-t[x].mi;    t[x].mx=-t[x].mx;    swap(t[x].mi,t[x].mx);}I void Pushdown(int x){    if(!t[x].tg)        Heriko;    Cover(lc(x));    Cover(rc(x));    t[x].tg=0;}void Build(int x,int l,int r){    t[x].l=l,t[x].r=r,t[x].tg=0;    if(l==r)    {        t[x].v=t[x].mi=t[x].mx=a[l];        Heriko;    }    int mid((l+r)&gt;&gt;1);    Build(lc(x),l,mid);    Build(rc(x),mid+1,r);    Pushup(x);}void ModifyOne(int x,int pos,int val){    if(t[x].l==t[x].r)    {        t[x].mx=t[x].mi=t[x].v=val;        Heriko;    }    Pushdown(x);    int mid((t[x].l+t[x].r)&gt;&gt;1);    if(pos&lt;=mid)        ModifyOne(lc(x),pos,val);    if(pos&gt;mid)        ModifyOne(rc(x),pos,val);    Pushup(x);}void ModifyAll(int x,int lx,int rx){    if(lx&lt;=t[x].l and t[x].r&lt;=rx)    {        Cover(x);        Heriko;    }    Pushdown(x);    int mid((t[x].l+t[x].r)&gt;&gt;1);        if(lx&lt;=mid)        ModifyAll(lc(x),lx,rx);    if(rx&gt;mid)        ModifyAll(rc(x),lx,rx);    Pushup(x);}int QueryMax(int x,int lx,int rx){    if(lx&lt;=t[x].l and t[x].r&lt;=rx)        Heriko t[x].mx;    Pushdown(x);    int res(-INF),mid((t[x].l+t[x].r)&gt;&gt;1);    if(lx&lt;=mid)        res=Hmax(res,QueryMax(lc(x),lx,rx));    if(rx&gt;mid)        res=Hmax(res,QueryMax(rc(x),lx,rx));    Heriko res;}int QueryMin(int x,int lx,int rx){    if(lx&lt;=t[x].l and t[x].r&lt;=rx)        Heriko t[x].mi;    Pushdown(x);    int res(INF),mid((t[x].l+t[x].r)&gt;&gt;1);    if(lx&lt;=mid)        res=Hmin(res,QueryMin(lc(x),lx,rx));    if(rx&gt;mid)        res=Hmin(res,QueryMin(rc(x),lx,rx));    Heriko res;}int QuerySum(int x,int lx,int rx){    if(lx&lt;=t[x].l and t[x].r&lt;=rx)        Heriko t[x].v;    Pushdown(x);    int res(0),mid((t[x].l+t[x].r)&gt;&gt;1);    if(lx&lt;=mid)        res+=QuerySum(lc(x),lx,rx);    if(rx&gt;mid)        res+=QuerySum(rc(x),lx,rx);    Heriko res;}I void MTree(int x,int y){    while(top[x]!=top[y])    {        if(dep[top[x]]&lt;dep[top[y]])            swap(x,y);        ModifyAll(1,id[top[x]],id[x]);        x=fa[top[x]];    }    if(dep[x]&gt;dep[y])        swap(x,y);    if(x!=y)        ModifyAll(1,id[x]+1,id[y]);}I int QTreeMax(int x,int y){    int res(-INF);    while(top[x]!=top[y])    {        if(dep[top[x]]&lt;dep[top[y]])            swap(x,y);        res=Hmax(res,QueryMax(1,id[top[x]],id[x]));        x=fa[top[x]];    }    if(dep[x]&gt;dep[y])        swap(x,y);    if(x!=y)        res=Hmax(res,QueryMax(1,id[x]+1,id[y]));    Heriko res;}I int QTreeMin(int x,int y){    int res(INF);    while(top[x]!=top[y])    {        if(dep[top[x]]&lt;dep[top[y]])            swap(x,y);        res=Hmin(res,QueryMin(1,id[top[x]],id[x]));        x=fa[top[x]];    }    if(dep[x]&gt;dep[y])        swap(x,y);    if(x!=y)        res=Hmin(res,QueryMin(1,id[x]+1,id[y]));    Heriko res;}I int QTreeSum(int x,int y){    int res(0);    while(top[x]!=top[y])    {        if(dep[top[x]]&lt;dep[top[y]])            swap(x,y);        res+=QuerySum(1,id[top[x]],id[x]);        x=fa[top[x]];    }    if(dep[x]&gt;dep[y])        swap(x,y);    if(x!=y)        res+=QuerySum(1,id[x]+1,id[y]);    Heriko res;}int n,m;pair&lt;int,int&gt; E[MXX];S main(){    Files();    fr(n);    for(int i(1);i&lt;n;++i)    {        int x,y,z;        fr(x),fr(y),fr(z);        Add(x+1,y+1,z);        E[i].first=x+1,E[i].second=y+1;    }    fr(m);    DFS1(1,0);    DFS2(1,1);    Build(1,1,n);    while(m--)    {        char opt[10];        int x,y;        scanf(\"%s\",opt+1),fr(x),fr(y);        if(opt[1]=='C')        {            if(dep[E[x].first]&gt;dep[E[x].second])                ModifyOne(1,id[E[x].first],y);            else                ModifyOne(1,id[E[x].second],y);        }        else if(opt[1]=='N')            MTree(x+1,y+1);        else if(opt[1]=='S')            fw(QTreeSum(x+1,y+1),1);        else if(opt[1]=='M' and opt[2]=='A')            fw(QTreeMax(x+1,y+1),1);        else if(opt[1]=='M' and opt[2]=='I')            fw(QTreeMin(x+1,y+1),1);    }    Heriko Deltana;}\r\n关于这道题做完之后在杂题记录里的感想：\r\n\r\n我在上个题的时候曾经说过：\r\n\r\n不得不说虽然长是长了点，树剖还是好玩的，对于我这种没有脑子的人来说，不用想就能打的东西太好了。\r\n\r\n确实，于是这个题的代码长度就成为了我目前为止通过代码中最长的，415\r\n行，7Kb。（当然，和我码风有空行有关系）\r\n\r\n\r\n\r\n树剖部分基本是一遍写对的，最后错了半天是因为题目说的边的编号要是\r\n，但是我读入的时候忘了\r\n+1，害的我把前面的重新看了一遍。。\r\n但是还好这是 7Kb 的树剖而不是其它别的什么鬼东西。\r\n\r\n终声\r\n水完力（\r\n","slug":"Tree-chain-splitting","date":"2022-01-08T09:08:01.000Z","categories_index":"OI-Algorithm","tags_index":"OI","author_index":"Heriko Deltana"},{"id":"059d3957398e3d8d567699f700b617cb","title":"平面最近点对","content":"「平面最近点对」\r\n\r\n\r\n闲来无事，学个新东西。\r\n问题概述\r\n求有 \r\n个点的平面上欧几里得距离最近的两个点。\r\n算法\r\n考虑分治，将当前的点集经过按照 \r\n坐标为关键字排序之后，不断的分为两段分别求解再合并。\r\n分治是好想的，问题是如何合并。\r\n假设我们要合并的两个区间的最近距离分别是 ，取较小值之后记作 ，区间中点为 。然后将所有满足 \r\n的点放到一个新的集合中。\r\n然后再将这个集合按照 \r\n为关键字排序，然后每次枚举两个点，只用满足  的点更新答案。\r\n而最后这个满足条件的点集的大小最大为 ，OI-wiki\r\n上有其证明。\r\nCode\r\n这个是洛谷模板题\r\nP1429的代码，复杂度为 ，使用缺省源「V5.2」。\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566template&lt;typename J&gt;I J Hmin(const J &amp;x,const J &amp;y){    Heriko x&lt;y?x:y;}CI MXX(2e5+1);const double INF(1e12);I bool CMP(const pair&lt;double,double&gt; &amp;a,const pair&lt;double,double&gt; &amp;b){    Heriko a.second&lt;b.second;}I double Dist(const pair&lt;double,double&gt; &amp;a,const pair&lt;double,double&gt; &amp;b){    Heriko sqrt((long double)(a.first-b.first)*(a.first-b.first)+(long double)(a.second-b.second)*(a.second-b.second));}int n;pair&lt;double,double&gt; a[MXX],tmp[MXX];double Merge(int l,int r){    if(l==r)        Heriko INF;    int mid((l+r)&gt;&gt;1),top(0);    double dis(INF);    dis=Hmin(Merge(l,mid),Merge(mid+1,r));    for(int i(l);i&lt;=r;++i)        if(fabs(a[mid].first-a[i].first)&lt;dis)            tmp[++top]=a[i];    std::sort(tmp+1,tmp+1+top,CMP);    for(int i(1);i&lt;=top;++i)        for(int j(i+1);j&lt;=top;++j)        {            if(tmp[j].second-tmp[i].second&gt;=dis)                break;                        dis=Hmin(dis,Dist(tmp[i],tmp[j]));        }                Heriko dis;}S main(){    Files();    fr(n);    for(int i(1);i&lt;=n;++i)        scanf(\"%lf%lf\",&amp;a[i].first,&amp;a[i].second);    std::sort(a+1,a+1+n);    double ans(Merge(1,n));    printf(\"%.4lf\",ans);    Heriko Deltana;}\r\n","slug":"Narest-points","date":"2022-01-04T09:16:17.000Z","categories_index":"OI-Algorithm","tags_index":"OI","author_index":"Heriko Deltana"},{"id":"e8e3e30a5367f7c7c99eccbd4faa059e","title":"硫球星观测枢","content":"「如星奏明天空」\r\n\r\n\r\n记录硫球星观测画中画的观测枢。\r\n\r\n关于之前的 HDSBN 简介，放在 2022.7.10 了\r\n如果在家/来不了机房，那必然更新的少，因为在家总是没啥特别的事情。\r\n2023.2.6\r\n开始不再学奥赛，于是去不了机房，所以要不然是在学校的时候写在纸上的，要不然就是在大休回忆的。\r\n2024.6.10\r\n高考结束，于是就是想起来就写一些吧，大概一周一次的样子？）\r\n我笨拙的手，写不出优美的语段，所以一切的一切都是普通的白话，并且，都是想到什么写什么，没有，任何，逻辑，所以，不要，带脑子，看，对不起。\r\n当然，不会有，太多人，看，吧。\r\n这里大概是会员邀请制（？？怪怪的\r\n\r\n2024\r\n2024.10.27\r\n居然一个周都没写什么吗。？\r\n周末回家两天晚上（？凌晨）补完了 MyGO\r\n首先感觉现在 B\r\n站补档的弹幕环境有点差啊，动不动就神人神人，，，到底谁是神人啊。。\r\n然后就是现在后来补档的翻录翻译问题好多（）\r\n然后就是关于 MyGO 本身，我认为我它真的很符合 MyGO\r\n这个名字，一群迷子，所谓乐队，只是一个表型。\r\n乐队是必须存在的吗？不是，但是归属是。\r\n灯在寻求着归属，在寻求着“变成人类”，祥子，和乐队的大家，让她第一次感受到了归属感。\r\n所以 CHYCHIC 的结束，让她感觉那个归属，结束了，她以为是自己的错。\r\n但从始至终灯都没有错啊，但从始至终谁都没有错啊。\r\n大家的决定都没有错啊，谁都没错啊，因为大家都只是迷茫的孩子罢了。\r\n即使是大小姐、前大小姐，又能做出什么样正确的决定呢，不能啊。\r\n最初在一起演奏的目的各不相同，但是最后依旧是一起演奏了呢，这个过程中的种种，或许就是这个乐队的意义，MyGO\r\n不是一个成熟的乐队，每个人都并不成熟，但是这就是 MyGO 啊。\r\n正如，詩超絆的歌词\r\n\r\n僕にはわからないんだ　いつも\r\n我一直都不明白\r\nみつけられない　正解も普通も\r\n找不到正解和普通的定义\r\n世界はずっと　ずっとずっと遠く\r\n世界离我好遥远好遥远\r\n僕には届かない場所にあるんだ\r\n在我触之不及的地方\r\nひだまりを抱きしめていた春も\r\n紧紧拥抱阳光的春季\r\n夏が照らしすぎて　消えてしまいそうで\r\n也因为夏季的艳阳而快要消失\r\nアスファルトで干からびてしまうなら僕は\r\n如果会因为柏油路而干枯的话\r\nずっと　石の下に隠れていたかった\r\n我宁可永远躲在石头底下\r\nふたたび　僕が壊してしまったんだ\r\n我又再一次毁坏了它\r\n失いたくなくて　忘れたくなくて\r\n我不希望失去，不希望忘记\r\nなのに　力なく手を離してしまった\r\n但无力的手却放开了它\r\nたいせつと　僕は知っていたのに\r\n我明明知道它有多重要\r\nああ　ぐちゃぐちゃになってしまったけど\r\n虽然脑中变得一团混乱\r\nすべて消えてしまったのでないのなら\r\n但如果它没有真的彻底消失\r\n戻りたい　(戻りたい)\r\n我想找回（我想找回）\r\n伝えたい　(伝えたい)\r\n我想传达（我想传达）\r\nゆるされるなら僕は\r\n如果能被容许的话\r\nあきらめたくない\r\n我不想就这么放弃\r\n誰にも見つけてほしくなかった　(ほしくない)\r\n虽然我不希望有任何人发现我（并不期望）\r\nなのに　きみといることが　(いることが)\r\n但是，和你在一起的时光（在我身边）\r\nどんなに嬉しかったかも\r\n让我感到多么开心\r\nまだちゃんと言えてないから　(ああ)　だから\r\n我都还没好好告诉过你\r\n傷つけたくなんかなかった\r\n所以说，我真的不想伤害你\r\nこんなふうに離れたくなかった\r\n真的不想像这样和你分开\r\n僕は一体どうすればいい？\r\n我到底该怎么做才好？\r\n上手く言えなかった言葉\r\n那些无法好好诉说的话语\r\nそれでも届けたい言葉\r\n即使如此仍想传达的话语\r\nうたううた　うたういま　ああ届いて\r\n我正唱着诗，在此刻唱着，传达出去吧\r\n君の胸に　まだ間に合うかい\r\n现在还来得及传到你心中吗？\r\nこころを叫ぶ\r\n呼喊出我的心声\r\n言葉を超えるため　(僕には)\r\n为了超越千言万语（对我来说）\r\nたったひとつのやりかただから　ああ\r\n因为我就只有这个方法了\r\n僕はうたう　うたううた　きみに届くまでうたう\r\n我歌唱着 歌唱着诗篇 唱到传达给你的那一刻\r\nきみに届くまでうたう\r\n唱到传达给你的那一刻\r\n僕はうたう　うたううた　きみに届くまでうたう\r\n我歌唱着 歌唱着诗篇 唱到传达给你的那一刻\r\n一緒に泣きたいよ　(きみと)\r\n好想和你一同哭泣（和你一起）\r\n一緒に笑いたいよ　(きみと)\r\n好想和你一同欢笑（和你一起）\r\n僕らの道が平行線だとしても\r\n哪怕我们的道路是两条平行线\r\n昨日を握ったまま　(きみの)\r\n紧紧地握住昨天（你的）\r\nズキズキ震えてる　(こころ)\r\n心脏剧烈跳动着（内心）\r\n痛いほど伝わるから　きみを離れない\r\n全都痛切地传达给我了 所以我绝对不会离开你\r\nうたう　手と手をつなぐうた\r\n我唱着，唱着连系起你我的手的诗\r\nほどきたくないんだ　ずっと一緒にいよう\r\n不希望将手松开，我们要永远在一起\r\nうたう　僕らになれるうた　うたう\r\n我唱着，唱着让我们成为我们的诗\r\nここではじめよう　もう一度\r\n让我们在这里重新再出发吧\r\n\r\n\r\n昨天意识到，大概以后每次看番之前都得提醒一下自己别代入了。\r\n在国庆之前做了个 MyGO 中出场人物匹配调查，测出来是睦头人。\r\n然后补的时候好像觉得灯的性格更加贴合？\r\n但是仔细一想的话，还是睦头人更符合一点吧，不如说，灯的勇气是我所向往的。\r\n认定的事情就一定去做了\r\n当灯神决定要做的时候，一切都好起来了啊\r\n相比之下我大概会一直把大部分想法憋在心里吧，所以大概，我还真是睦头人近似。\r\n但是或者又不是，吗，至少我很多时候会用比较容易被猜出来的谜语来告诉我想表达的事\r\n比如这个网站上，很多都是很明显的明示，吧。\r\n设定的时候就是让这些事情容易明白，也算是用其他的方式表达出来了吧。\r\n我，很矛盾的产物，就比如说这里，或许想让人看见，但是或许又不想让人完全看见。\r\n我，大概是这样的吧，除掉自己想接触的人之外，完全不想距离别人很近啊。\r\n所以，最近，总是觉得精力会很快花光吧，所以每天状态都不太好。\r\n果然还是有些时候自己的边界大一点比较好，吗\r\n但是自己已经掌握不了自己的边界了啊\r\n会想着说什么，但是说不出来啊\r\n会担心别人的看法啊，我依旧是这样啊，无论多少年没变啊\r\n想起有人评价 soyo 了，缺乏自我，安全感来自于他人。\r\n是啊，我是谁呢？\r\n真的很矛盾啊，我的大部分安全感和支撑来自于其他人，但是又抗拒着和别人过多接触，自己一个人大概也挺好的。\r\n但是自己一个人真的大概挺好吗，不好吧。\r\n打心底我还是一个依存于社会的孩子吧，但是这个世界的人并不是都能依存的吧。\r\n\r\n想要加入世界，\r\n但是又把自己用围栏围起来，\r\n但是又想给部分人开个小门，\r\n但是又在围栏里强行表演着，不让自己被世界抛弃。\r\n\r\n不愿意接触很多人，恐惧很多热情，但是想接触的人，害怕自己会被看作太烦，虽然大概已经被这样看了吧，。。\r\n很难想象这会是一个人，这大概也是为什么一直觉得自己和自己之间还存在一些距离吧。\r\n什么时候我能理解自己了，或许世界心理学会是某种大飞跃吧。\r\n如果有人能看见这些，大概率会有被我烦到吧，感谢包容，非常感谢。\r\n\r\n为什么最近精力很差呢，好像也不是压力吧。\r\n大概是没有方向感，也没有安全感，也没有归属感，补充精力的效果很差，大概这样。\r\n之前担心的问题果然出现了啊，，初三之后，我就缺乏把自己真正融入一个新集体的能力了吧。\r\n就像是那天给导员问到我现在有没有很好的朋友的时候说的一样，我大概对别人要求很高？\r\n但是我又说不清有什么要求，可能，真的，要求很高吧，以至于这个要求，我不知道。\r\n但是我又要求别人什么呢，我还没做好自己啊。\r\n但或许是这所谓的要求很高吧，遇到符合要求的人很少，第一是我绝大部分时间下不会去主动接触陌生人，第二是大概我想接触的人不存在一个明显的表型特征，只能进一步观察，但是不接触又如何知道呢，所以大概停滞了。\r\n所以大概，不知道，还，能不能，融入，新集体。\r\n最近打字真的很喜欢加意义不明的逗号啊，是为什么呢，大概，我的精力不足以让我输出一句完整的话吧，所以，随着思绪的或有或无就会停顿。\r\n最近感觉各种感官都弱化的好严重，会饿，但是吃东西吃不出来好不好吃，吃完之后也感觉不出来吃没吃，感觉就像是没吃一样？乱七八糟的，感觉。\r\n每次去吃饭会有一种奇怪的难受感，但是和我空的肚子又没啥关系，感觉好像在高三中段的时候体会过这种感觉，但是那个时候是压力大，现在也没什么东西压力我啊。\r\n我甚至害怕自己闲下来会瞎想还尽量让自己参加一些事情，。\r\n空虚吗，空虚吗，是空虚吗。\r\n大家人都很好，但是我总觉得自己接触起来会有些距离，不是别人设定的距离，是我自己设定的距离。\r\n但是，为什么，为什么，为什么呢，我疑问着，向着屋外走去，今天的月亮（或者说，已经是\r\n28 号的月亮了？）被雾环绕着。\r\n月，能否告诉我，为什么。\r\n\r\n果然还是写了一堆乱七八糟的东西了吗，对不起，我到底在凌晨干着什么。\r\n既然如此，再写一点东西吧。\r\nTracya 选择在深夜逃离自己的房间，逃离自己的家。\r\n跑向天台。\r\n从未在星月都默不作声的深夜登上天台。\r\n前往天台需要穿过的树林，在阴冷的夜里，令人畏惧。\r\n这也是之前从未偷偷跑出来过的原因。\r\n但是这次还是半闭着眼睛穿越了这片大人来看小小的树林。\r\n登上天台的脚步声很轻盈，听不出来任何深夜未眠的疲倦。\r\n“你知道吗 Synya”\r\n“我没有睡不着哦”\r\n“你知道吗 Synya”\r\n“我现在很好哦”\r\n穿越树林，将自己甩在身后，\r\n天台上留下了几滴不知是谁留下的泪水。\r\n今天，流星不会到来。\r\n2024.10.21\r\n于是乎第一次当这种团队组长的第一场线下会议结束了。\r\n因为是组长，所以说的话很多，感觉把这周的话都说完了，可以 disable\r\n自己的嘴了（\r\n最后投票选了我的方向，其实不太像这样，因为本身作为组长，这样结果多少有点，不太好。\r\n但是既然这样了，就得多负责人去干了（\r\n但是好累啊，存在在别人视野中好累啊。。可能这就是我要经历的痛吧。（\r\n2024.10.20\r\n很好，新耳机到了，希望他不会绝食（）\r\n\r\n前情提要：Flypods3 因为耳机绝食废了；MyGO Aigo TJ170\r\n间歇性绝食。\r\n\r\n为什么我喜欢春卷饭的歌。\r\n因为他所写的，我是我想写，而又写不出来的。\r\n或许这辈子终究是差很多话没说出来，差很多字写不出来。\r\n2024.10.18\r\n\r\n2024.10.16\r\n今天测出来变成 INFJ 了，为什么呢。\r\n虽然在定义上来说我好像越来越贴近 INFJ 了。\r\n\r\n但是荣格测出来之后 Fi 很高，大概还是 INFP？\r\n\r\n其实我不是很懂这些评判标准。\r\n至今觉得自己在线上和线下的性格是分割开的。\r\n线上水群水的不像 I，线下又是正儿八经的说不出来话。\r\n我简单猜测，可能是，因为，我变 I 是因为一些不可抗力\r\n（？好吧但是显然这东西不是不可抗力T_T我只是不会描述了就随便偷了个词）\r\n总之之前确实是 ENFP，可能我线上还保留着一些 E 的元素吧。\r\n但是为什么线上和线下会有差距呢，我们不得而知。\r\n反正明显能感觉出来现在不太愿意在被人看见，无论是线上还是线下。\r\n其实好像这样说也不算对，因为毕竟我一直在被人看见着，虽然注意中心大部分情况并不在我身上。\r\n所以，大概只是不想被很注意到。\r\n\r\n自以为是地觉得自己能够察觉到别人的一些小的情绪信息和心理活动，所以大部分时间能够读出来一些人。？\r\n这样的感觉习惯了之后，就会害怕自己不理解别人的想法。\r\n于是就会想得太多。\r\n然后在想对着一些人说话的时候会说不出来，因为总是害怕。\r\n虽然大概大部分时间还是挺乐观的，但是我从心底大概是悲观的。\r\n总是害怕一切事情的最差结果发生。\r\n所以说不出来话是因为这个吗，不知道。\r\n再回想为什么线上能够说出来话，大概是因为感觉没有在被注视着吧。\r\n说起来很有意思，我一直在尝试理解捕捉到的别人的信息，但是确找不到落点让我来探求自己。\r\n好像写远了。\r\n基本所有人我都能读个大概，偏差大概不会太大。\r\n所以有时候遇到我从最一开始就读不懂一点的人就很难得了，很有意思的是，现在这个名单增加了。\r\n但是有些时候这也不完全是难得的问题了，可能是我想进一步知道罢了。\r\n是为什么呢。\r\n我要是知道就不会写在这公开了（）\r\n\r\n\r\n\r\n总感觉自己有些时候活着是在表演，好累。\r\n在能展示出来的 10% 之上被推上台表演出剩下的 90% 构成一个人群中的我。\r\n\r\n2024.10.17\r\n如果雨森老登说的对的话，现在不会就是第三个……？\r\n但是这并没有依据，我只是紧闭着的大门里走出来的一个孩子而已。\r\n时间还真的会冲淡一切啊，但是冲淡一切之后，原本深刻的印记依然是留到最后的。\r\n2024.10.16\r\n今天是周三，周三之后，将是课最多的两天 :(\r\n今天，好奇妙啊————\r\n嗯，很好的一天。\r\n2024.10.13\r\n发现这些年一直在干一些很傻的事情：我想找到一个贴合程度高的人。\r\n或者抽象一点说，我想找到一个没有我的缺点的另一个我。\r\n我很早就知道这个事情基本没有可能。\r\n但是为什么不承认呢。\r\n但是为什么还在因为找到一个些许近似而高兴呢。\r\n但是为什么因为发现那个人的行为反复让我惊讶而些许难过呢。\r\n希腊奶。\r\n2024.10.8\r\n创造纪录的 12h 超长续航（（\r\n2024.10.6\r\n终于是把三年飞渡做了个结尾，不管是不是好结尾吧，至少结尾了。\r\n这是一个很好的结尾，至少我觉得是。\r\n深夜的日新楼亮着灯，我在那里故事早已结束，今天我们则将它画上句号。\r\n那么下一站将会是，我的四年远旅。\r\n敬，不完美的昨天、今天和明天。\r\n2024.10.1\r\n国庆节快乐 :D\r\n2024.9.29\r\n又是一年929，929 啊 929，这 929 真是太 929 了。\r\n祝 wxm 和 xb 生日快乐 :D\r\n2024.9.28\r\n新型美丽煤矿工业发展基地🤔\r\n但是第一次尝试干活就出了一堆锅，天生锅圣体🤔\r\n\r\n历史上的今天：202.9.28，原神，启动。\r\n2024.9.23\r\n现在是下午四点二十二，第一天的三节课已经全部上完了（近现代史纲要、高数、C语言）\r\n体感来说只有高数对我来说不是水课？\r\n关于军训，前期真的很累，主要问题来自于这个鞋真的很难受，你的脚底下会有两个近似于驼峰的东西顶着你的脚。\r\n但是好歹是结束了，而且后期进入擒敌拳方阵之后训练量小多了，再加上买了软一点的鞋垫，最后倒可以接受了。\r\n缺点是晒得很黑，呜呜。\r\n\r\n发现一个小小的问题，IN2THESTARLIGHT\r\n一直没往下写，要不有空的时候接上写写吧，虽然想写它的一些原因\r\n2024.9.8\r\n累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了累死了\r\n2024.9.4\r\n开学的第二天，大学生活果然是略显松弛。\r\n悦园饭不错，欣园也可以，主要是我们宿舍距离欣园近一点，也是里教学楼近，所以会方便一点，但是悦园总体会更好吃。\r\n主要麻烦的事是校园卡、宿舍电费、宿舍接水、宿舍洗澡、宿舍洗衣服……居然需要五个app……\r\n剩下就挺好的，除了这个床的梯子略显抽象，89°倾角，还不平）\r\n于是乎就挺好的 :D\r\n2024.8.10\r\n练车不累，但是去练车的路上真的好热，好热，好热，阿紫一！\r\n然后就因为好热所以好累 :(\r\n2024.7.29\r\n2024.7.26 ~ 2024.7.29\r\n核心：天津 烤only，但是不太核心（（\r\n\r\n7.26\r\n到了就进行了步行前往南开，途经五大道，还见识到了天津各种奇奇怪怪的多岔路口（\r\n狠狠的吃饭，唉，还狠狠的吃狗粮（\r\n步数反应里程：lyy 2.7w，妈沫 2.4w，我和 wxm 2.2w.\r\n\r\n7.27 核心内容：尾随小偶像参与烤o\r\n嘿嘿小偶像小偶像小偶像小偶像小偶像小偶像小偶像小偶像小偶像小偶像小偶像小偶像\r\n非常少 knd，使我奏推轻轻的碎了，但是还是有的，集邮成功（\r\n或许是因为头发太重了吗\r\n（不过好像 ick 和 mnr 更少（（\r\n有舞跳的很好的老师！真的好强！\r\n然后中午休整之后下午决定去海河边上转，还好这次我们就住在海河附近。\r\n因为充电线快断了，想去买一根，但是这个华为店里居然没有，6.\r\n吃完饭骑车很远去了有名的刨冰，人很多，但是也算是在十一点之前买到了回宾馆吃掉，好，冰，啊（可惜忘了拍照\r\n\r\n7.28 核心内容：去海博\r\n之前因为台风影响，预报的一直是有雨，而且是大雨，本来以为没法去了，但是，但是，没下雨！\r\n而且贼热！贼热！贼热！贼热！贼热！贼热！贼热！贼热！贼热！贼热！贼热！贼热！贼热！贼热！贼热！贼热！\r\n阿紫一\r\n/*实实在在的发现了自己具有深海和多肢动物恐惧症状\r\n然后去了海边，大海，真好啊……\r\n然后就去了北京了，\r\n\r\n7.29 核心内容：骑车去 pku 朝拜\r\n之所以骑车近似成了核心行动，是因为。。。坐公交车方向坐反了，然后骑车导航地方又错了，于是在北京骑了\r\n10km，但是只用了半个多小时。。。\r\n\r\n也算是圆梦了吧，一半。\r\n另一半，是当时说的去霓虹。\r\n2024.7.19\r\n发现自己根本没钱了啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊\r\n2024.7.17\r\n和 sxy 住的近就是好，随时出去吃饭开转（\r\n2024.7.14\r\n这周经历了什么？\r\n首先是正式开始学习考驾照了，但是依然在科一的模拟中挣扎 :(\r\n希望下周能去考科一 :)\r\n然后就没有什么大的事情，噢，有的，被山大提前批录了 :)\r\n看起来是出不去济南了 :)\r\n然后今天和 mxk 和 wyf 久违的吃了顿饭，并且去开了卡丁车 :)\r\n不得不说融创茂里面这个赛道真的很不错，双层赛道带来的高低落差让这个赛道的弯角很有意思。如果小时候那个也算的话，也算是十三年没开过卡丁车了（当然这个是电车，小时候那个油车）\r\n第一节成功拿下最快圈 56.769，起码是进了一分钟，mxk 第二，和我差\r\n2.512s，wyf 一分零三，看起来我适应能力强一点（）\r\n第二节 mxk 拿下最快圈 52.336，我 52.547，wyf\r\n53.394，我们包揽前三，而且大家都逐渐更会找极限了，但是工作人员多少有点业余啊，我和\r\nmxk\r\n在一个慢车后面待了两圈一直不出蓝旗，还是我俩找机会超过去的，要不然我俩还能再提升。\r\n第三节人太多了，基本上一直在套圈和被慢车挡，mxk\r\n第一顺位出去，情况还好一点，我和 wyf\r\n倒数三四出去的，就被慢车挡的很惨了，七圈超了八次车，没有一圈不被挡（还有一个哥们看后面是我吓一跳直接一脚刹停在弯中，于是就撞上去了，但是幸好是慢速弯我基本刹住了），但是我们还是都刷新了最好成绩：mxk\r\n进入 50s 大关来到 49.652，我 50.543，wyf 51.219，包揽前三。\r\n并且 mxk 成为了月圈速榜第三，年圈速榜第十四，我和 wyf\r\n也分别来到月榜的 P9 和\r\nP12，对于我们三个今天才开这个赛道的来说，已经不错的成绩了（这个赛道最快居然\r\n43.082，吓人）我们应该都还能提成绩，至少是 1s 级别的，因为实在是\r\ntraffic, traffic, traffic.\r\n这种一直在找极限的感觉真的太爽了，希望以后能再有机会 :)\r\n2024.7.8\r\n真就一周写一次，其实中间有想过写，但是也没啥好写的。\r\n这周主要就是报常规批志愿，然后对着 Excel\r\n改了好长时间，最一开始是选，然后是排序，排序排了得有六七八版。\r\n好麻烦，但是总之是弄完了 :D\r\n希望我做的是无用功，提前批走掉最好了 :D\r\n\r\n还有就是 ZZZ 开服了，锐评一下吧：\r\n首先，我认为 ZZZ\r\n明显低于大家的预期，大概是前期宣发有点过了，再加上疼逊在开服当天的 NB\r\n助攻，网上可谓是骂声一片。\r\n但是我觉得有节奏到还挺正常的，看看崩铁、鸣潮，其实都是这样，节奏肯定是有的，包含真正对绝区零失望的、真的串子、真的想黑的各种人，所以我还是以自己玩的为准。\r\n剧情上，现在很明显还在引入世界观，符合米忽悠家一贯的套路，养成还是米忽悠在原神之后那一套东西，很讨厌。\r\n战斗上，我认为目前动作上还没有明显超过崩三的感觉，只能说绝区零不像是米忽悠的新游戏，在动作上没有带来多少新鲜感，这一点也是很多人不满意的点。\r\n但是整体游戏的氛围感是不错的，整体城区的生活风格也很符合定位，就是目前这点东西就要\r\n56G+ 多少有点抽象，这直接就比出了四个地区的崩铁还要大了。\r\n我觉得真正有问题的是游戏内在体验的问题，首先之前米忽悠游戏中（桌面端）很好用的\r\nTAB 转盘没了，这就很不爽，更况且这 TAB\r\n也没有别的新用处。还有一个问题是就是有些地方是没有引导/说明白的，导致设定上有些时候有点恍惚。如果一个游戏的内在的设定需要外在的一个世界观\r\nPV 来补齐，那就多少有点问题了。\r\n但是总体上来说也没有很烂，再看看，毕竟我认为崩铁也是 2.0\r\n才逐渐好起来的。\r\n\r\n因为进入一个新的阶段了，这个博客的 About 今天也重新写一下吧 :D\r\n2024.7.2\r\n分数的话，赋分的科比估计的低，其实也算还行，没有偏差很大，所以查分那一刻没有任何感觉，也没有难过，也没有兴奋（\r\n然后就是报提前批，研究常规批 96 个志愿怎么报。\r\n中间去了一趟市中买了一点谷，和翔B，吃饭，开转，最后以我掉坑里结束\r\n然后去彩云大厦看看那个记载了我第一年准备 IMM 的地方。\r\n学校开放日去奥赛室拿了趟书，和 cw、ysh 聊了聊（ysh\r\n来找的我，不是我去找的他）\r\n然后就是 5E rating 猛猛的掉，分猛猛的涨（但是今天晚上又掉了😭 ）\r\n啊啊，开的 Tracya &amp; Synya 的坑还没开始填，破防了（\r\n2024.6.24\r\n明天出分，回顾一下这两天都干啥了。\r\n首先是十一号到十八号一直是在忙综招，最后的结果来说，只有港中深没过）\r\n十七号出发去了杭州准备参加港中深面试，其实因为是纯英语面试，还有一点没底，当然，最后其实发现大家口语水平都不咋地，最后也不是我的面试分低，而是机试分数太低\r\n:(\r\n主要是这东西机试不能回到之前选完的题，大概我一遍过的水平不太行吧（（\r\n没想到的是在同一场面试里还有也是历二的，真是到处有校友啊（\r\n然后当天晚上十二点夜袭上海，下高铁的时候我还没意识到问题的严重性，因为那会还没下雨。\r\n是的，是的，凌晨开始下雨，上海的梅雨季开始了，从那天开始一直到回山东，我身上就没完全干过。\r\n再加上上海酒店贼贵，五百多住的汉庭脏的我难以理解，于是上海就没给我留下什么好影响，但是去上海的目的是去上科看一看，上科还真挺好的，人少，环境很好，希望能去，看明天分吧\r\n:D\r\n我们山东人是这样的，在上科校园里闲逛又遇到一个历二的，笑死我了。\r\n然后本来想去深圳来着，但是南方全是下雨下雨下雨，于是就否了，二十号就直接回家了。本来寻思着回家就能见太阳了，但是没想到第二天济南下雨\r\n:D，给我整笑了。\r\n然后二十三二十四回了趟老家，见了见姥姥家的狗狗，纯吃货，平常趴着不动，一闻见我端着盘子进屋就开始凑过来。毕竟还是小狗，最一开始还是不太认识我，中午喂了他点骨头之后就认识我了，啧啧，看吃认人的家伙，下午就开始跟着我跑了）\r\n这几天有在玩崩铁的三消，4冠8亚7季，主打一个超级亚军获得者。\r\nCS2 手感还是那样，但是大概逐渐的好起来了，完美定到\r\nB，多少有点。。。\r\n现在就是期望明天分数能保个底就行，不期望高分。\r\n2024.6.16\r\n怎么我这一堆综招还没考完啊啊啊啊啊啊啊啊啊啊啊啊啊啊。。。\r\n今天试图给电脑清灰，但是发现散热盖板上有个螺丝钉十分的紧，于是只能简单的清理了。\r\n发现这电脑的b终端可能因为太久没更新寄了，笑死我了。。\r\n2024.6.11\r\n起床发现我不用上学了，哈哈（？\r\n住在学校旁边，就是主打一个，欸嘿怎么上学的不是我啊（）\r\n这两天还得忙着综招，忙忙，忙忙。\r\n忙完就该把 Tracya &amp; Synya 的故事提上日程了。\r\n2024.6.10\r\n高考完了，但是有一种不真实感（？\r\n高考每一科都是正常的发挥，希望阅卷老师多给我点分（）\r\n2024.4.14\r\n彗星になれたなら - はるまきごはん &amp; 初音ミク\r\nやめたほうがいいのに\r\n明明放弃了就好\r\n大人達は笑うけど\r\n大人们都笑着那么说\r\n呼吸よりも当然なあなたの\r\n而和比呼吸还要真切的你\r\n笑顔だけが解っている\r\n只需相视一笑便能理解\r\n多分\r\n或许吧\r\nだんだん色が無くなって\r\n颜色渐渐消失\r\nあなたの誕生日も\r\n连你的生日\r\n忘れちゃうような\r\n也忘记了啊\r\n大人になったらどうする\r\n变成大人了该怎么办\r\nどうする\r\n该怎么办\r\n夢のように愛して\r\n像梦一般地去爱\r\n愛のように夢をみて\r\n像爱一般地去梦\r\n空想でも信じれば\r\n即使是空想，只要相信\r\nいつか叶うからと言ってた\r\n总有一天会实现的 你那样说了\r\n彗星になれなかった姿を\r\n多希望你可以将我无法成为彗星的孤寂\r\n笑い飛ばしてほしかった\r\n一笑而过\r\n日が沈んだすぐあとの藍が\r\n我喜欢日落后的那片蓝\r\n大好きなのは\r\n是因为\r\nあなたの瞳が僕の泣いてるとこ\r\n那时你的眼睛看不到\r\n見えなくていいから\r\n在哭泣的我\r\n\r\n可我又想到什么了呢？大概是饭的歌真的都是太美了吧……\r\n一直因为之前干过的傻事而否定之前，觉得自己好不成熟。\r\n但是转眼间成人了啊，我现在，连梦想也没有，到底是谁呢？\r\n我到底要去干什么呢，我不知道。\r\n我到底还记得什么，还是因为害怕记住而全忘了呢。\r\n我想不到啊，我不敢去想啊。\r\nNightmere.\r\n2024.2.21\r\n原来雪真的能下一整天啊……\r\n对面高一高二还没有返校，楼不开灯，昏暗的天空，刚刚只够看到楼的轮廓，阴风四起，雪花飞舞……什么末日景象（（\r\n2024.2.3\r\n我的天哪，我才发现我还没更新过 24 年的东西（\r\n于是补一补一月不多的东西。\r\n2024.2.2\r\nHAM 将在 2025 年加入法拉利。\r\n我到底活在一个如何科幻的时代啊（×）\r\n我活在一个大家都有儿法梦的时代（√）\r\n2024.1.27\r\nmfy IA OИE 生日快乐 :D\r\n（我都快高考了为什么你 mfy\r\n高中还没毕业啊，我记得我刚见你我才初中啊，我都快高考了w）\r\n2024.1.26\r\n如何评价昨日考试？\r\n普通玩家 vs 挂哥 vs 职业哥 vs 开挂的职业哥\r\n挂车对撞，尽显答案风采（\r\n2024.1.23\r\n2021.1.23 → 2024.1.23，三年飞渡\r\n三年前在卿云桥上飞奔的样子，还在我的心里。\r\n\r\n街 → an 对 v 街 → 让我想到 2022.8 → 2022.8 是目前最后一段长时间呆在\r\nLC → 我想 LC.\r\n2024.1.22\r\n泥中に咲く 25ver 真的好听啊……\r\n温柔坚定的 knd，坚强独立的 mzk……呜呜，呜呜\r\nmiku 调的也可以 :D\r\n2024.1.21\r\n能不能让破事都发生到破人上面？\r\n\r\n怎么都是这样？怎么都是这样？怎么都是这样？\r\n\r\n4202 年了怎么还有人装系统用大白菜？？\r\n2023\r\n2023.12.29\r\n非常好集市，使我在小学部旋转）\r\n想起来好久好久没赶集过了（虽然这是小小小集市），但是确实感觉不一样\r\n但是哥们没带钱啊！没带钱！什么都买不了😭\r\n2023.12.28\r\n三天的 b 制度让我精神衰弱。\r\n2023.12.27\r\n疯！了！\r\n2023.12.26\r\n疯了。\r\n2023.12.25\r\n疯了。\r\n2023.12.21\r\n2023 10d remain...\r\n2023.12.19\r\n非常好考试，使我的脑子停转🥲\r\n2023.12.14\r\n（和之前有一个非常长的空缺，因为我确实什么都没写）\r\n好厚的雪！！\r\n大抵是济南这些年最大的雪，也是我见过的最大的雪（\r\n2023.11.7\r\n家里蹲一日游，物理原分 37，体温一直 37，纯正 37 单推人吧。\r\n2023.11.6\r\nfeel sick\r\n2023.11.4\r\naka. RE3.1.1\r\n睹物思怀，但或许不需要。\r\n2023.11.3\r\naka. RE2.12.31\r\n\r\n今天突然发现自己有好多次放假都没在这里写点什么了。\r\n其实大概 7.23 到 8.31 之间也是有东西没有转到这个地方的。\r\n但是现在是周中，还没有带回来那些东西，等到过几天带回来再转吧，今天暂且先补一下\r\n10.17 以来的，其实不多。\r\n\r\n上了高三确实也写不来什么东西，因为，太平淡了，除了作业。\r\n2023.11.1\r\n突然意识到快三年了。\r\nToday is RE2.12.30.\r\n2023.10.31\r\n大约喜欢約束和再会的原因是真的很喜欢这种约定期望的感觉。\r\n但是哥们没人，也没有整这些的时间。\r\n2023.10.29\r\nhyl、hyy 18 生日，核堆合法化！\r\n\r\nExploration 2 The Moon.\r\n失眠飞行 Section One: NightOverGlow.\r\n\r\n如果说 211104 是 be last 累积，那大概过去的一年间是 aimless\r\n感让我迷茫。\r\nWhat if, someone not really know what to do and what he want.\r\n\r\n难绷，大概是别的学校来体检的小学生在广场上一起大声的喊：“原神，启动！”，还喊了好几次，还有巨大声的\r\njntm，乐。\r\n\r\n111，感谢 hyl 老板生日大气送我水滴💧回归！\r\n2023.10.28\r\n啸稀了，怎么想都笑嘻了：怎么 29 号出生的都是大爹啊？\r\n下辈子我也要 29 号出生。\r\n2023.10.27\r\n中午起来左胯僵了，大概以后不能右侧着睡觉了，会拉到。\r\n2023.10.26\r\n产出下降？产出下降！\r\n2023.10.15\r\n呜呜3737373737373737373737\r\n2023.10.20\r\n「1000DAYZ」\r\n这百人跨卿云桥的 1000 天。\r\n2023.10.18\r\n急不急\r\n急了，为什么一节课 1.5h\r\n2023.10.17\r\n急\r\n2023.8.31\r\nMiku 生辰日快乐！\r\n2023.8.30\r\n当面对着电脑的时候，又写不出来东西了。\r\n太多的东西在周中出现，但是现在又写不出来了，你就说难不难受吧：）\r\n提前庆祝一下明天的 Miku 生辰日吧（指先把明天的写了\r\n2023.8.29\r\n\r\n命は綺麗なわけじゃない\r\n生命中并不总是充斥着美好\r\n美しい人生なんてない\r\n美丽人生什么的只是泡沫\r\n呼吸が上手く出来ないのは\r\n没有办法顺畅地大口呼吸是\r\n生きてる証拠だ\r\n活着的证明\r\n約束 - はるまきごはん\r\n\r\n2023.8.16\r\n恭喜 wxm 和妈沫保送！\r\n2023.8.13\r\n生物国赛，祝各位加油\r\n2023.7.26\r\n所以这是第几次，在梦里要抓住什么，但是因为现实中没有抓住而惊醒，醒来的时候双手只能抱着自己。\r\n2023.7.23\r\n暑假结束，我孤独要滚。\r\n这十天到底什么感觉呢，总之，接下来一年里最长的假期结束he了。\r\n过的有点快，这几天好开心，好失望，好。\r\n所有就这样吧（\r\n\r\n顺便祝愿明天 NOI 选手加油，虽然已经基本没有认识的现役了（\r\n\r\n世界が終わるまで踊ろうぜ　回ったって世界は変わらないね\r\n世界が終わるまで歌おうぜ　叫んだって世界は変わらないね\r\nそれで結構 それで結構\r\nそこにある ただ そこにある\r\n2023.7.21\r\n我是现代化酿醋工厂。\r\n2023.7.9\r\n昨天找东西的时候发现了之前上初中的时候买的但是一直没用过的而且被遗忘的\r\nJUP04/05 笔芯，我好开心 :)\r\n2023.7.8\r\nDECO 新歌初印象：FXXK.\r\n2023.7.5\r\n想起来一个纪年法：今天是 R2.09.02。\r\n2023.7.4\r\n什么预言级梦境，晚上梦见什么白天就发生什么（\r\n上次这么准还是在 21.9.26\r\n那次（）\r\n2023.7.2\r\n来自大地的人类，最终还是在离去的时候将躯干归还大地。\r\n可我还是在每次抬头看见星空的时候想起故人，借以某一刻微星传递向故去亲友的思念。\r\n为什么不是面向大地呢……可能我还是觉得他们变成了繁星在天际注视着我们罢，毕竟，他们肯定也会希望我们一直朝着前方前行的罢。\r\n……\r\n记于姑爷爷周年。\r\n2023.6.28\r\njh 正式代替 szy 成为首发阵容班主任（x）\r\n2023.6.27\r\nBlack Black Black Black Black Black Black Black Glow\r\n已经在脑内扩散 5 Days！\r\n2023.6.26\r\n获悉，jh 将于明后天加入 5832 主队担任班主任，szy 将被下放（\r\n(＃°Д°)\r\n2023.6.23\r\n返校，这次回家又忘了 UPD LSOH（7.20：是的，是的，在补）\r\n第一次跑完 100% 的大奖赛，感觉还不错，除了累的要死（\r\n本周末 fps 全线拉跨，从 CS 到 APEX 到瓦）\r\n2023.6.20\r\n昨天晚上睡觉之前脑子里想到\r\n8.32，紧急把这个念头移除了，要不然睡不着了（\r\n主要是 8.32 本身对我来说回忆成分太大了（（（\r\n2023.6.10\r\n终于，补完了，从 4.6 到 6.7 的：）\r\n2023.6.7\r\n第一次在学校里看高考。\r\n\r\n🐏yyz 在起床去教室的时候飞奔到我面前，笑飞了（\r\n大声喊着”你果然在那！去年我就在这里遇到的 sy 他们（56）“\r\n他好呆啊（）\r\n这什么传承啊，这可能就是独属于我们的传承吧（）\r\n高兴，希望他们都能考好，约定 10 号 QQ 相见（\r\n明年我是不是也能遇见 59 呢（）\r\n\r\n学不动了哥，，真学不动了\r\n对了，到了今天，就有两个月没 UPD LSOH 了，这次一定不能再忘了：）\r\n（2023.6.10 评：是的，是的，补到这里说明我快补完了）\r\n这两天看读者，读文章的感觉真好，所以想起把博客从博客园迁移到 Github\r\nPages 的原因就是这样。\r\n我的 OI\r\n生涯终有一止，但是我想让未来的某个时刻，再回看现在的时候，有些许文字可依，无论是\r\nLSOH 之类的手记、日记，还是 Noting 之类的杂笔、一时感叹。\r\n毕竟写出来总能让我被困于嗟乎嘘哉之间的时间短一点。\r\n2023.6.6\r\n什么是「家」？\r\n我好像能回答，但是回答不出，十年两地五次搬家。\r\n\r\nknd 她爱我，她爱我！😭😭😭😭😭😭😭😭😭😭\r\n去年 480+ 发，一个 knd 的\r\n4⭐（其实是两张但是两张是一样的），这次只有 11 发😭😭😭😭\r\n2023.6.5\r\n到达 LCEZ 最高楼！「高三五楼」！\r\n太美丽了五楼，哎呀这不我原教室的书嘛，\r\n还是看看远去的放假的高一高二同学们吧家人们。\r\n\r\n1999 是一款我的救非器\r\n2023.6.4\r\n你说得对，但是 Return to future :\r\n1999，重返原舟：崩坏1999\r\n2023.6.1\r\n你说得对，但是 knd 可能会成为我的一位终身遗憾\r\n😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭\r\n\r\n想起来一个东西：WHAT R U VTING 4? AN TRAL AIV3TING GONE?\r\n2023.5.31\r\n6X 6th Anniversary (2017.5.31 - 2023.5.31)\r\nE71 15th Anniversary (2008.5.31 - 2023.5.31)\r\n\r\n人的崩溃往往只需要一瞬间：knd 花嫁，但是你不放假：）\r\n而且不只是因为你不放假，你现在都不知道你到底有没有假：）\r\n😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭\r\n\r\n而且 pjsk 卡加载\r\n😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭\r\n2023.5.29\r\nKnee SHIRO de √, dance world vacation zywoo Na Li?\r\n2023.5.25\r\n不记 Δt，Δt 就天天清零了，难绷。\r\n2023.5.24\r\nDilemma、月光、无梦之梦、萤火虫未曾来过。\r\n今天头很乱，好像有什么要说，但是不知道和谁要说什么？在怀念什么？在想什么？在担心什么？不知道\r\n:(\r\n2023.5.22\r\n你说得对，但是 Vitality 喜提巴黎 Major\r\n冠军，而且是全胜 Major + 主场夺冠，Zywoo 终于提了一个\r\nMajor 冠军，以及，五星上将阿杜！\r\n2023.5.21\r\n返校，set Δt &lt;- 0，\r\n不再记 \r\n教室人数居然超过 10\r\n人，这究竟是道德的沦丧还是人性的扭曲（\r\n2023.5.17\r\n果然到了第三周就是累了：（\r\n2023.5.16\r\n你说得对，但是曾经创下 20 图连胜、2022 Blast 全球总决赛冠军、2023\r\nIEM卡托维兹冠军、位列世界第一四个月之久的 G2 Esports CS:GO 分部，在昨晚\r\n1-2 组 BO3 中 1:2 不敌 FNC 直接回家，止步 16 强。\r\n\r\n于是，事情都像着预想的那样。\r\n于是，事情都向着预想的那样吗。\r\n\r\nMagicWatch 2 46mm 3 Years Anniversary.\r\n2023.5.14\r\n母亲节，生物联赛，各位干巴爹！\r\n手还是好软，写不出正常的字\r\n2023.5.13\r\n昨夜发烧，雨打窗，声如鼓。\r\n但是早上起来不烧了，于是还是上学去了（\r\n测抗原了，没阳，好。\r\n2023.5.12\r\n昨天考物理的时候开始嗓子疼，这下可能要复阳了吗 ：（\r\n半夜咳醒了一次，但是没有发烧，加上上火，难受×2\r\n\r\n今天是汶川大地震 15 周年。\r\n\r\n三联考终于结束力。\r\n2023.5.11\r\nhyy 阳了，复阳潮要来了？\r\n2023.5.10\r\n\r\nset Δt &lt;- 0.\r\n56\r\n的时候出了子月，他，肯定是想让我想起来什么，哦！子月是什么呢？子月是「叙拉古人」池子的五星！\r\n那么我又在「叙拉古人」池子干了什么呢？哦！是 71 发出，斥罪！\r\n那么他想预示什么呢！\r\n「57」，霍尔海雅。\r\n哈哈，16% 的概率，比上次强。\r\n2023.5.9\r\n「55」，2% + 10%，哈哈。\r\n算了下，五十发不出彩的概率为 36.4%，55 为 23.9%，而我曾经达到的伟大的\r\n71 发不出则是 0.84%，难绷。\r\n有种反向欧皇的美。\r\n2023.5.8\r\n你说的对，但是昨天晚上肚子疼+呕吐+腿抽筋，于是只睡了大约 2h.\r\n考试考的头晕，但是可能也和那个屋很闷有关系吧_(:з)∠)_\r\n（什么有关系啊啊啊啊，是主要原因！！）\r\n麻！有点好奇是不是新冠之后我就不会发烧了，头很热（体感），但是我不发烧喵，他在温度和体温计上维持着稳定，但是我感觉我现在也就温度正常了_(:з)∠)_\r\n感觉好奇怪啊，全班都在感冒，但是我没有什么感冒症状。\r\n奇怪，总是想着要休息一下，但是总是感觉休息不过来，上次睡醒之后真正感觉休息好了……大概是在春节吧？不……好像是上次长假期……是什么时候来着？\r\n哦，大概是去年八月的暑假，难绷。\r\n\r\n以及「52」，优美+2%时代，热烈期待！\r\n2023.5.7\r\n「49」，再两发之后进入优美+2%时代！\r\n我恨你，鹰角。\r\n\r\n语文组的一个老师的先生走啦，R.I.P.\r\n最近这个年龄段的人好多突发心梗的啊……\r\n又想到姑爷爷了……虽然他不是心梗走的。\r\n\r\n你说的对，但是现在有一个月没有同步 LSOH 了（2023.6.9\r\n评：是的，是的，在补了，在补了）\r\n2023.5.6\r\n「47」，你知道我要说什么，鹰角。\r\n今天补上周二课，不过就是不知道谁周二放假了：）\r\n2023.5.5\r\n其实感觉 Δt 没什么意义了捏。\r\n\r\n啊↓稍微↗占用大家一点↘↗时间↗，咱↗做个↓↑题↖儿↑↑\r\n想要听新歌，不知不觉开学四天了，难绷。\r\n2023.5.4\r\n明儿防皱你给我等着！\r\n2023.5.3\r\n纪念，五三惨案。\r\n2023.5.2\r\n返校（早八）\r\n我没异徳，我也没缪缪，呜呜。\r\n五一也没把 LSOH 同步，这下滚雪球了（2023.6.9\r\n评：是的，是的，我现在还在补呢）\r\n2023.5.1\r\n没想到会住不到家里：）\r\n2023.4.29\r\nNOTHING 2C\r\nLEC 在巴库三连杆（算上 SprintQualify 是四连杆）\r\n今年巴库真的好无聊。。\r\n2023.4.27\r\n\r\n2023.4.26\r\n这两天能高兴的事情只有姥姥状态不错了，不过也这样够了：）\r\n2023.4.25\r\n会想起「才不是恶魔」和 CSGO 了（）\r\n\r\n“我怎么穿了两件秋季校服？“\r\n——（中国著名服装家，学生，SKP，2006 - 至今）\r\n\r\n今天是 BA\r\n国际服更新「体操服优香」的日子，也是化学科幻卷子的日子，前者我的评价是「好有感觉」，后者我啥都不会：）\r\n2023.4.24\r\nSleepy↑Sleepy↓\r\nDizzy↑Dizzy↓\r\n2023.4.23\r\nSleepy↑Sleepy↓\r\n已经准备入 BA，但是好像死在闪退了（）\r\n\r\n昨天嗅觉回来之后，今天晚上味觉耶回来了，耶。\r\n2023.4.22\r\n虽然嗅觉和味觉没了只在阳了之后出现过，但是不意味着我阳了吧（）\r\n毕竟没有其他的反应。\r\n2023.4.21\r\nset Δt &lt;- 0.\r\n早上越清醒，晚上睡得越晚，\r\n晚上睡得越晚，早上眼越疼，\r\n眼越疼越不困，越不困越害怕困，\r\n越害怕困越喝咖啡，越喝咖啡越睡不着。\r\n乐，WHAT A FXXKING PERFECT ROUTINE!\r\n降温 10°C，乐。\r\n\r\n怎么今天喜提嗅觉和味觉失灵啊，而且现在表现出来的和去年阳之后一毛一样的，闻什么吃什么都是一股……各种葱蒜麻料洋葱什么的全烧糊了的味道，奇怪。\r\n恶心的想吐，但是又不能吐_(:з)∠)_\r\n\r\nOnimai 和推子都想看，都没空看（）\r\n2023.4.20\r\nset Δt &lt;- 0.\r\nFinally.\r\n\r\n于是无梦之梦继续用来净化现实和梦境。\r\n\r\n哇……\r\n不知道为什么脑袋好乱啊（？）\r\n混杂着各种声音，芝士为什么呢_(:з)∠)_\r\n于是在这里随意写一些东西。\r\n\r\n好想要 25h ver. 的萨姆沙 Full 本家 V 版只有 Miku 唱有点单薄了，但凡是\r\nKaito 和 Miku 都会好一点（？ 毕竟 zuki 那里 Miku\r\n自己唱还是有点单薄，两种 Vocal 会好一点（ Kaito 在 25 里本来就是 Breaker\r\n的角色，打破 25 的一些刻板认知，于是才有了 knd\r\n的破局尝试悬崖勒马（ 看推子。赤坂我再信你一次（）\r\n\r\n2023.4.19\r\n愿手术顺利。\r\n\r\n今天怎么了，无法集中精力。\r\n2023.4.18\r\n孩子气战争啊↑啊↓啊↑目前（2023）最高 3DMV！\r\n已知 5.2 返校，故五一假期最多四天，目前预计是 30 晚上到 2\r\n早上，tnnd.\r\n2023.4.17\r\n不由得觉得去年 AI 带来了好多不同，从 AI 绘画到 AI ChatBot（如\r\nGPT）再到 CodeBot（OpenAI、Github，怎么都是微软家……）\r\n虽然现在的讨论热度和风口有一定关系，但是都在去年井喷就很有意思了（巨硬的阴谋！！！111）\r\n\r\nwant to say sth. + idk wo say what = say nothing.\r\n难绷。\r\n2023.4.16\r\nset Δt &lt;- 0.\r\n返校，半个脑子里都是「idol」，有点想看推子，但是怕被刀_(:з)∠)_\r\n2023.4.14\r\n本来不想来学校的，但是还是来了，虽然睡到了九点，上午头还是难受，下午好多了：）\r\n2023.4.13\r\nset Δt &lt;- 0.\r\n算来，有一个周没有在零点之前睡着了，我这到底是？……\r\n麻，感觉写不动字了。。\r\n但是我并不发烧。发现自己没有不发烧请假的经历，难受\r\n2023.4.12\r\nset Δt &lt;- 0.\r\nysa，ysc 生日耶！\r\n这「课表」和「活动」属实难绷。\r\n\r\n什么自由截断式听力，但是居然全对了？？？？？？？？？？\r\n2023.4.11\r\n不好，怎么这几天状态这么差\r\n2023.4.10\r\nset Δt &lt;- 0.\r\nsleepy，sleepy，sleepy，今天困的比例已经有点恐怖了，上午从早读到十一点，下午从起床到三点还在困。\r\n不是很懂啊，做梦已经和现实掺杂了，虽然想一想我只要做梦不都是这样吗（\r\n魂魂黯黯郁幽蔽，迷迭垂头梦盈盈。\r\n\r\n怪欸，今天是什么日子（？）有一种「三月天天有什么事情」的同视感。\r\n不敢生病，不能再给家里添乱了。\r\nBlessing\r\n\r\n总是把火花，奇美拉和幽灵法则搞混，于是今天早上就死活切不到火花的副歌了，只能切出来奇美拉，不过现在是切出来了：）\r\n2023.4.9\r\n好（指早读），基本 ALL SLEEPING(x)\r\n\r\n满脑子都是 DinnerBell MV\r\n里的那个奇怪的围裙人的回头的画面，初见有点惊异，到那时越想越奇妙然后就忘不掉了，虽然我没有和这首歌什么相似的经历，不至于再有「照镜子」的感觉，但是代入之后依旧理解了一切（x）\r\n饭，我的超人。\r\n有三年多没有好好画画了，不算描改的话，还是不会画人。\r\n\r\n六年级之后第一次春游，或者说是，研学。\r\n爬围子山，完成 ysh 的故愿（x）\r\n爬了五个山顶，当然围子山不是很高 XD\r\n感觉很好，七个人的班确实组织和玩起来都方便\r\n回到学校的时候 1.7w 步，最终回家应该 1.8w 多吧（4.10\r\nUPD：18405，确实）\r\n最后还去了彩虹湖，晚上吃了饭回学校，春游爬山真好啊……而且不是走台阶的爬山\r\n:D\r\n就是明早能不能从床上爬起来就 unknow 了（\r\n2023.4.8\r\nmfj 生日好好好 :D\r\n\r\n难崩，33 班那个门上的铁皮上了四个螺丝钉，笑死我了给我整乐了。\r\n萨姆沙好好好，以及饭自己翻的晚餐铃好好好！\r\n2023.4.7\r\n不知为何，如果真的是下周大休的话，感觉过了今天就要放假的感觉耶！\r\n\r\n今天是什么伟大的无语日，先是跑完操被误叫到去领奖，结果发现是某些级部主任「zhi」和「zheng」不分，哈，哈。\r\n然后去 33\r\n班送卷子，出门的时候脚勾到了门上的铁皮，然后「山舞银蛇」以为我故意踹门，然后就把我训了两次，然后我回去上课之后又在他们班训了我一次，难崩。\r\n\r\n伟大的调查问卷：「3 + 2 = ?」，「此题请选择 C」，「今天几月」\r\nset Δt &lt;- 0.\r\n2023.4.6\r\n返校，set Δt &lt;- 0，虽然 4.4 就是 0 着走的（（\r\n救，Be The Music 里那个“听听你的 Music”配上 toya\r\n那个和睦的笑容，给我笑飞了（\r\n2023.4.5\r\n我居然一直到今天晚上才把这两周多的同步到这里（）\r\n2023.4.4\r\nset Δt &lt;- 0.\r\n不也挺好的吗.jpg\r\n清明时节雨纷纷，路上行人欲断魂。\r\n素衣莫起风尘叹，犹及清明可到家。\r\n2023.4.3\r\nset Δt &lt;- 0.\r\n听闻 wxm 和 skp JN 1-2 Finish，强。\r\n\r\n今日，Blessing.\r\n\r\n翻卷子的时候看见去年的谜语集，去年五月刚返校肉眼可见的 struggle\r\n啊（\r\n\r\n于是四月已经过了三天，三月的代表曲目就是 nogi 老师的\r\nマシーネ・クリーク [Long ver.] 吧（\r\n2023.4.2\r\n有时候在想，去年一年的挣扎，是否和 OI 相关，可能是也可能不是，学习 OI\r\n成绩更重要之后，如何权衡 whk 和 OI\r\n真的是一个很烦人的问题，整个高一就这个 major issue.\r\n这对于 whk 成绩好的同学是个问题，对我这种 whk\r\n成绩也不好的人更是个问题，真的很难崩。\r\n但是这并不是 OI\r\n的错，呃呃，不知道为什么要写这些，但姑且算是随便写点吧。\r\n\r\n今年生物初赛，生物的各位干巴爹！\r\n\r\n不是，草，我突然想到把这两周多写的 UPD 到 LSOH\r\n里面也是个不小的工作量\r\n\r\n后日评：确实。\r\n\r\n2023.4.1\r\nzry 生日\r\n\r\n四月是你的谎言，愚人节快乐 :D\r\n\r\n打球好爽 XDDDDDDDDDDDDDD\r\n可惜手表没电了，要不然今天的运动量又起飞了 ;D\r\n\r\n真就脑机网易云是吧，600+ 的 R 歌单随机选曲播放？\r\nIMM 就用在这里了是吧，乐（\r\n\r\n今天省选开始，才算起来我已经 AFO 四个月了，真的在 NOIP\r\n之后一次代码都没动过，难说。\r\n2023.3.31\r\nset Δt &lt;- 0\r\n昨天烤 2.5 周年，knd 三箱和曲都还没听喵，mfkn 磕磕磕喵（\r\n昨天晚上原 3.6，复刻甘雨，乐。然而我 3.5 完整没上原。\r\n\r\n「伟大的宵崎奏」\r\ndie，现在看不见 knd 救 mfy。\r\n“knd 悬崖勒马（mfy）的马（mfy的妈）”\r\n2023.3.30\r\nyxh 生日\r\n\r\nSo? Will you be like them, abandon me. Will you?\r\n（我不想打下面这些字了，决定拍照。）\r\n\r\n\r\n愿意我少的假期和周末都变成祝福。\r\n\r\n已经今天是烤 2.5\r\n周年，去年这个时候已经在家抽白葱了，呜，我最后一次抽卡略欧（\r\n2023.3.29\r\njpjl生日\r\n\r\n愿一切安好无事。\r\n\r\n记忆相接了，去年 3.29 ~ 6.14 的草稿本居然还在课桌里。\r\n\r\n相信人类伟大的手算能力.jpg\r\n2023.3.28\r\nset Δt &lt;- 0\r\n最近满脑饭了 ;D\r\n第三心脏、幻影、月光、无梦之梦交替，以及微笑调查队和奏明天空，还有雄大的几首。\r\n随着夏天临近，8.32 总是能泛起涟漪。\r\n*Luna 和橙星夏曲，21 年听术之后，IA 的歌声是我永远的夏天\r\n^_^\r\n2023.3.26\r\nUKE，不知道为什么昨天去了日新楼之后心里一阵空虚。\r\n\r\n8.32……啊为什么 8.32\r\n总是让我想到一个阴天的、晴天的、盛夏的、暮夏。\r\n这个形容很抽象，但是我也只能形容成这样了（\r\n总是让我想到某种盛夏分别场景，虽然这首歌大概就是这样的，但是一向，或者说一直害怕分别的我在之前两次毕业的时候都没太伤心过，不知道\r\n24 年是否也会如此。\r\n但是至少今年 8.32 还不用考虑这个问题，大概。\r\n有一种感觉，8.32 将在我脑海中存留一生，在适时自动播放。\r\n2023.3.25\r\n嘴笨是人类书面表达进步的基石（（（（（（\r\n\r\n去日新楼试图把机房里的书带走，顺便去四楼生物那看看，但是因为书太多了就没带走（\r\n顺便生物那个电脑的键盘是什么逆天（\r\nset Δt &lt;- 0\r\n月光，呜，饭，再次体现我不认识片假也记不住罗马音 :)\r\n但是吃完饭干值日的时候脑子里全是第三心脏，草（\r\n2023.3.24\r\ngjq 生日\r\n\r\nset Δt &lt;- 0\r\n泪目，本来我自己都忘了昨天是闰二月二，今天早上还因为昨天晚上在梦里过了周五，认为今天是周六而反驳妈说昨天是闰二月二（）\r\n\r\n果然（）\r\n后日评：我不知道我当时想写啥（？？）\r\n2023.3.23\r\n最傻的事情就是在梦里问梦里的自己或者梦里的别人现在是不是真的。\r\n但是总是得出肯定的答案，因为太想是真的了（）\r\n2023.3.22\r\n（Δt = 2）能否突破 5 就看这周了：）\r\n2023.3.20\r\n大家好我嗓子哑了，I am 静音连 （x）\r\n\r\nQ：如何评价考试成绩？\r\n\r\nA：考成这样都能进步给我整乐了。\r\n2023.3.18\r\n为什么上次大休没写任何东西呐？\r\n答：作业太尼玛多了。\r\n2023.3.17\r\n\r\n如何评价三月联考？\r\n\r\n数学化学好像没有预期的那么难（虽然我还是做不高分就是了\r\n语文：？抽象\r\n英语：好快的听力，前五个都没接住，但是还好只错了一个（\r\n生物：？？？？不是不考选修二吗？？？？？？？？？？？？？？？？？？？？？？？？？？？\r\n物理：好难 ：（\r\n2023.3.16\r\n考完数学之后感觉一直头晕站不住（低血糖？）\r\n但是还好上午剩下的时间是在复习，吃了饭睡觉起来就好了。\r\n今天居然在笔袋里找到一个笔壳是 17 年、笔芯是 18\r\n年而且现在还能写出来字的蓝色\r\nJUP04，震惊我，没想到我笔袋里居然还有这么古老的笔（）(○´･д･)ﾉ\r\n\r\n救命，脑子里突然出现 「wlt 脚不离地的一天怒杀 ヤミナベ!!!! MASTER\r\n37」\r\nDie，笑死我了，救命，脑子里全是「今度こそおしまい~\r\nそしてこれが真のラスト一撃！」\r\n2023.3.15\r\nset Δt &lt;- 0 这下老泪纵横了\r\n（？我也不知道我当时为什么写这个）\r\n难说，每天月考，两天六科，对我来说第二天三科连着还是强度大了点，不过既然没有什么明确而紧迫的目标限制，好好考就是了（\r\n对我来说应该和周测差不多吧（\r\n\r\n点名批评 mfj，居然想不起来我叫什么 o(一︿一+)o\r\n2023.3.14\r\n乐，不知道为什么每年三月的每一天都让我有一种「今天也是什么特殊日子」的感觉（？\r\n可能是生日在三月，记住的很多人的生日也在三月。而我过阴历生日所以三月好多日期可能都是某一年的生日（\r\n比如说今天，既是 21 年阴历生日，又是 PieDay.\r\n难说（）\r\n\r\n下午感觉有点发烧，但是吃完饭又没感觉了（？\r\n大家好首先我不理解 ╥﹏╥...\r\n\r\n你说的对，但是三月过去一半了感觉还是没有什么代表性的歌曲（？\r\n自从不每天去奥赛之后，每天脑子里仍然随机歌单，笑死我了：）\r\n2023.3.13\r\nset Δt &lt;- 0\r\n你说得对，但是去年 3.12 开启谜语集，今年甚至不约而同（\r\n\r\n你说得对你说的不对\r\n你说的错你说的不错\r\n2023.3.12\r\n啊啊啊啊啊啊啊啊啊啊啊啊\r\n口阿口阿口阿口阿口阿口阿\r\n口👂可口👂可口👂可口👂可\r\n\r\n呐呐呐呐呐呐呐呐呐呐呐呐 口内口内口内口内口内口内\r\n2023.2.21\r\n「十七」\r\n明年成年.jpg\r\n2023.2.18\r\n终于回家了1111111111111\r\n来高中两年多了，第一次体验完整两周的无奥赛校园生活：）\r\n这两个周好像一堆新歌，以及 F1 2023\r\n赛季的新车基本都发布了（虽然某饮料厂很敷衍啊，很敷衍！）\r\n今天开写十七回环之日：）\r\n2023.2.14\r\n从今天开始晚上十点半回宿舍，不过我通校还是九点五十走。\r\n第一次想发现对我没啥影响，后来发现不对啊，他们十点半回宿舍也就是说我不在家再学四十分钟就差好多啊：（\r\n无所谓，反正就算睡满了睡觉时间，早上也是困，同样都是困，那还不如睡前学会：）\r\n2023.2.13\r\n母上大人生日快乐：）\r\n2023.2.12\r\n分数 += 98，级部名词 -= 500+，抽象了，济南市 2.6k......\r\n没想到自己第一次感觉把分数拿的自己能力里比较满是在停课回来之后的第一次考试。\r\n仔细想想……居然也是我高中以来级次最好的一次。\r\n这就很无语了啊。\r\n\r\n恭喜 hyl 获得第二个级部第一，貌似也是级部唯一双冠王：）\r\n但是这俩级部第一都没发钱，也没让他上去讲话，乐。\r\n懂不懂停课时间一长就可以拿级部第一的含金量啊！\r\n2023.2.10\r\n今天发答案对了对感觉好像比开学考试总分多了一百分？\r\n果然分成三天考，休息好一点我发挥好点：）\r\n\r\n今天 knd 生日捏 ;D\r\n2023.2.8\r\n和听课之前考同一个级部排名是吧，什么无损停课。\r\n当然是祭天了那次期末考试的数学的 40 分和这次的语文换来的：）\r\n2023.2.7\r\n虽然昨天晚上把规定的睡眠时间睡满了了，但是今天早上考英语还是睡着了，我的评价是几把。\r\n不是，如果期末考试还是睡不好那考成啥样真的难说了。\r\n2023.2.6\r\n答辩，真的一天考 5\r\n科，后天就考试了我还没学完生物课本，我™谢谢你。\r\n2023.2.5\r\n非常平静的元宵节捏：）\r\n当然，平静并不是指声音平静，大家没放完的炮都今天放了是吧（\r\n是指没啥事情发生。\r\n正月十二的时候进行了科幻的一天考 6\r\n科的「期末模拟」，太抽象了，从早上七点考到晚上十点。\r\n然而明天返校还是要有一次级部统一的开学考试/期末模拟，考虑到明天是周一，周三就开始考期末，估计这个也是起码一天考\r\n4\r\n科的科幻东西，然而我啥都不会啊，连着考我卷子刚刚改完还没复习/预习就开始考下一个，我做这有啥用：）\r\n2023.1.22\r\n没想到居然，居然……\r\n草，写到这里就想笑，一个月忘了博客的事情了。\r\n但是今天是初六，明天初七要返校了，但是明天爆炸电台更新啊啊啊啊啊啊啊啊……\r\n然后刚才才想起来（现在晚上 10:35）我……\r\n我！没看！黄金庭院！\r\n我！没看！不当哥！\r\n啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊！为什么全忘了！\r\n\r\n顺便明天是来高中两周年 ;D\r\n2022\r\n2022.12.23\r\n阿米娅生日快乐！\r\n\r\n今天把前几天的博客补了补，算是新冠记录吧。\r\n2022.12.22\r\n还是头疼，但是好多了）\r\n2022.12.21\r\n昨天晚上又有点低烧，但是晚上睡觉的时候据我妈说先是烧到 38\r\n上然后又掉下来了。\r\n今天就没啥事了，就是头疼。\r\n抗原不到两分钟就出现了两条深红的杠（\r\n2022.12.20\r\n昨天晚上烧起来了，于是从昨天晚上七点躺到早上七点。\r\n但是因为难受所以半个小时醒一次，浑身疼还动不了，基本感觉睡了但是没睡：(\r\n今天还是难受，但是上午体温降到 35.6，怪。\r\n2022.12.18\r\n完美打了五局定级，还差五局：）\r\n匹配的大概都是 C 和 D+，感觉强度还行，三赢一平一负。\r\n晚上有点低烧，难受。\r\n2022.12.17\r\n合格考挺科幻的，但是感觉这样考阳的人应该会一堆一堆的）\r\n尚也阳了，远远的看我们拿学案）\r\n做了个抗原，是阴的。\r\n2022.12.14\r\n反转了，hyl 发烧了，大家又回家了。\r\n然后下午 hyl 就阳了，BAD.\r\n2022.12.13\r\n反转了。今天是最后一天）\r\n\r\n\r\nimage.png\r\n\r\n2022.12.12\r\n今天要返校了呢，于是见证着我 OI\r\n生涯长度的洛谷打卡就要到此为止了。\r\n\r\n\r\nimage.png\r\n\r\n2022.12.6\r\n不知不觉在家上网课了好长时间了，但是每天也不下楼其实也没什么可以写的日记（）\r\n2022.11.26\r\n随着退役，这个博客里的学术内容可能就没了吧（（\r\n2022.11.22\r\n在昨天发现 pyyz\r\n宿舍的插座有电了之后，今天终于可以把电脑拿出来充电了。\r\n这两天一直受困于没有电所以一直没能在宿舍用电脑，那么今天把 NOIP 2022\r\n前的几天写一下吧，放在 NOIP 2022 退役记\r\n里罢。\r\n2022.11.6\r\n我曾在八强抽签结束后说过：DRX 夺冠。\r\n恭喜戴老师！\r\n2022.11.4\r\n去年的今天，没有今天这样的阳光。\r\n2022.10.30\r\n果不其然，就像是我说的一样，数学延期了。\r\n\r\nGAP = 30 Days?\r\n2022.10.28\r\nあなたに映るわたしは\r\n你身上映出的我\r\n心ってもんを信じてる無邪気なレゾナンス\r\n是深信着人心的一阵无邪的共鸣\r\nさよならを言わないのは\r\n没有和你道别是因为\r\nあなたに見抜かれてしまわないように\r\n我并不想被你看透看穿\r\n第三の心臓 - はるまきごはん/初音ミク\r\n2022.10.27\r\n在一个星期的未定和未知之后，CSP 终究还是没了。\r\n祈祷 NOIP 如期举行吧。\r\n2022.10.21\r\n本次周末最大成就：rks 13.85 \r\n13.88.\r\n船 IN 的 ACC 到了 99.07 了。\r\n2022.10.19\r\n学校这破网又把 git 给 ban 了，我真的服了。\r\n2022.10.18\r\n希儿生日快乐~\r\n\r\n顺便还有一张好看的特别周冠宇）\r\n\r\n2022.10.12\r\n简单描述最近的状况就是：睡眠不足，上火导致多个地方肿，昨天睡觉落枕，然后今天还被球砸了一下现在脖子很难受。\r\n2022.10.10\r\n二十联测开始了，现在是，掉分时间（\r\n2022.10.9\r\n\r\n\r\n恭喜维斯塔潘两罐，这才过了不到十个月（可以翻到之前 2021.12.12）\r\n以及，周冠宇喜提最快圈，这第一个赛季除了夺冠和领奖台全经历一遍了（\r\n\r\n接下来美洲的比赛时间都挺阴间的，而我缺乏假期和睡眠所以不会看了，阿布扎比还有可能看一眼，但是不涉及总冠军了其实也就看看周冠宇。\r\n越看 3 月巴林开香槟越觉得什么叫做半路开香槟啊。。\r\n乐扣还是抗压还是差点，当然法拉利这雨天轮胎损耗本来就大，参考伊莫拉，再加上下半赛季法拉利被底板新规则削了一刀，真的吃胎，从\r\nSPA 到铃鹿都这样。\r\n这个样子的话，坐等明年维斯塔潘三冠。\r\n2022.10.5\r\n返校。\r\n2022.9.30\r\n\r\npjsk 两周年快乐（\r\nJourney 真的是慢毒，啊啊啊啊啊啊啊\r\n\r\n聚合图床又挂了，我再给他一天时间，要是不好我就再换 smms.\r\n2022.9.29\r\nwxm 和象鼻生日，好耶ヽ(✿ﾟ▽ﾟ)ノ\r\n2022.9.28\r\n发现什么呢，发现我锁住的文章锁是锁了，解锁不了，乐，他和这个博客主题不兼容。\r\n原神两周年快乐，开服玩家泪目。\r\n2022.9.27\r\n\r\n意料之中，但是好耶！\r\n2022.9.26\r\n一时描图一时爽，一直描图一直爽。\r\n2022.9.23\r\n真的是，搬了三道题教会我 UOJ 社区版的实用知识。\r\n2022.9.22\r\n如果米奇头当时写少女レイ的时候就是为了让人觉得这个非常的虐心而无能为力，那我觉得他写得太好了。\r\n起初是翻到油管上面的 PJSK\r\n的官号，顺便就把少女レイ听了一段，但是没开翻译，虽然能大约看出来是个\r\nBE，但是最后快结束的时候想起来还是应该去 B 站咨询社看看（于是在 YT\r\n上没看到最后的……），然后去一直看到最后，真的被鸣笛声带走了……\r\n然后回去看曲绘，铁道上 szk 和 hrk 都有影子，miku\r\n没有，当然米奇头原版也是一人有影子一人没有，再加上 MV\r\n里面课桌上的花瓶，很难不想一堆东西……\r\n然后就把它变成了 SteamOJ 上的一个题目背景。\r\n\r\n2022.9.21\r\nTSAR Remix 的吸血鬼里的 deeeeeeeeee 和 人間なんか大嫌い+ 里的\r\nだ—————— 在我脑中构成了死循环（\r\n2022.9.20\r\n那么我还能说什么呢。\r\n不过我还是挺感谢级部主任的，至少他能理解我为什么过去要找他听一遍他的话。\r\n\r\nAntena - ピノキオピー/初音ミク\r\n言葉にしなけりゃ　伝わらないこと\r\n言葉にしすぎて　伤つけちゃうこと\r\n言葉にしたけど　どうでもいいこと\r\n言葉を飞び越え　感动すること\r\nいつも通ってる牛丼チェーンでお腹を満たした\r\nうっかり　漫画の４巻が２册ダブってしまった\r\n趣味で何か作っている人は自由な気がした\r\n最近　引っ越しました　ふとニ十歳の顷を思い出した\r\n引越しが済んで　そのタイミングでカーテンを変えた\r\n季节の変わり目を感じたから　服装を変えた\r\n嫌いな芸能人がでてるから　チャンネルを変えた\r\n変わりたいけど　変わらないこと　変わらなきゃいけないこと\r\n电子に漏れ出す意识　欲望と愚痴の捌け口の书き込みが\r\n人ごみにひとり　ひとり　つまっている\r\n顺番抜かしをしている　肩を落として歩いてる\r\n席をゆずってる　イチャイチャしている\r\nそれを见ている自分がいる\r\n冗谈　冗谈に毛が生えたような毎日が続いている\r\n今日は　今日は一回休み　はやく帰って眠っていたい\r\n言葉にしなけりゃ　伝わらないこと\r\n言葉にしすぎて　伤つけちゃうこと\r\n言葉にしたけど　どうでもいいこと\r\n言葉を飞び越え　感动すること\r\nそう　アンテナを张って色んなものを见て闻いて\r\n触って　つねって确かめて\r\nそして各方面を好きになって　嫌になって\r\nそう　アンテナをはって　ミスって　説教くさい言叶にちょっと引いて\r\nうるさい　くたばれ　悪态ついて　数年後にゆっくり理解して\r\nアンテナを张って色んなものを见て闻いて\r\n触って　つねって确かめて\r\nそして価値観の涡に飞び込んで　溺れちゃって\r\nそうアンテナをはって　游んで　学んで　わずかな喜び见つけて\r\nつらかったことも　いつか笑って　数年後思い出して\r\n宝くじ当たって　三亿円手に入れ\r\n価値観イカれちゃって　ダメになる人もいて\r\n闻いてないよ　闻いてないよ　学校では教えてくれないよ\r\n知らないよ　知らないよ　失败くりかえし覚えてくよ\r\nあのスーパーの方が卵が安いよ\r\n最近　引っ越しました　ふとニ十歳の顷を思い出した\r\n自分の考えることのすべてが\r\n嫌になる日も　嫌になる日も\r\n自分のやること　なすことすべてが\r\n里目にでる日も　里目にでる日も\r\nそう　アンテナを张って色んなものを见て闻いて\r\n触って　つねって确かめて\r\nそして各方面を好きになって　嫌になって\r\nそう　アンテナをはって　ミスって　説教くさい言葉にちょっと引いて\r\nうるさい　くたばれ　悪态ついて　数年後にゆっくり理解して\r\nアンテナを张って色んなものを见て闻いて\r\n触って　つねって确かめて\r\nそして価値観の涡に飞び込んで　溺れちゃって\r\nそうアンテナをはって　游んで　学んで　わずかな喜び见つけて\r\nつらかったことも　いつか笑って　数年後思い出して\r\nアンテナを张って色んなものを见て闻いて\r\n触って　つねって确かめて\r\nそして各方面を好きになって　嫌になって\r\nそう　アンテナをはって　ミスって　説教くさい言葉にちょっと引いて\r\nうるさい　くたばれ　悪态ついて　数年後にゆっくり理解して\r\nアンテナを张って色んなものを见て闻いて\r\n触って　つねって确かめて\r\nそして価値観の涡に飞び込んで　溺れちゃって\r\nそうアンテナをはって　游んで　学んで　わずかな喜び见つけて\r\nつらかったことも　いつか笑って　数年後思い出して\r\n\r\n2022.9.18\r\n初赛，详见CSP S1\r\n2022。\r\n2022.9.15\r\n终归还得是自己创造。\r\n2022.9.14\r\n跟着你谷的初赛模拟题复建初赛知识，看看写点什么总结。\r\n2022.9.13\r\n看了眼初赛题，发现啥都忘了，然后没啥东西可以记了。\r\n\r\nknd 的手办到了，至此我是真真真没钱了，最后的全给 knd 了。\r\n如何评价这个手办呢，就是两百一可能真的有点贵，它但凡便宜三十放在同级都是很不错的景品（\r\n但是奏宝多好啊，图在 B 站动态了。\r\n母问曰钱从哪来的，我说抽奖抽到的，要不然为啥一年多我没要钱（\r\n母不信，从支付宝上翻了半天，一看上次 21.6.30，确实是一年多了（\r\n2022.9.12\r\n周末进行了 NFS:PayBack 的游玩，简单评价。\r\n其实整体游戏制作水平还是在线的，剧情表现力还是可以的。但是缺点也很明显，感觉\r\nEA 这一作整体在往网游上面靠近，尤其是这个抽卡升级，真的太奇怪了……\r\n能看出来有许多借鉴地平线系列的东西，比如说越野、技术分等，但是越野的手感做的真的很奇怪，你说他滑吧，他也不是很滑，就算很奇怪。更奇怪的我觉得是漂移手感，按照其他\r\nRAC\r\n或模拟器的逻辑来说，漂移应该要反打才对啊，但是这里触发方式上了速度之后急转，反打只是为了正方向，不知道是不是键盘操作的问题。\r\n至于技术分和氮气到底有没有关系啊看不出来啊……\r\n总之游戏性做的有点奇怪，还有就是寒霜祖传飞天（尤其是赶路的时候特别容易飞……），但是作为\r\n15 块入库，还是可以的。\r\n\r\n其实我对这场蒙扎的评价，倒是符合我心中的预期：德芙首战拿分、小周拿分、法拉利第二、里卡多退赛（\r\n至于最后一圈没能重新开始跑，只能说是有些遗憾，但是我估计大概率乐扣也没机会反超。\r\n2022.9.8\r\n\r\n乐\r\n你说的对，但是《原神》是由鹰角网络科技有限公司推出的一款制作精良的音乐游戏。玩家将进入名为\r\n\"Arcaea\"\r\n的世界，扮演名为\"鸠\"的角色，加入叫作\"反恐精英\"的组织，在\"初音未来\"的帮助下找到拆除\r\nC4\r\n的方法并寻找\"音矿\"，探寻世界最终的秘密，这一切都源于\"阿隆索\"和\"本田\"早在\r\n2015 年就开始利用新颖的 GP2 ENGINE\r\n模式以及精心设计的剧情让幻想乡的大家眼前一亮。最终\"维斯塔潘\"和\"爱莉希雅\"在\"侵蚀律者\"的手中赢下了\"汉密尔顿爵士\"的\"世界冠军\"并获得了\"骑士\"称号，携手\"25时、在NightCord\"一起将\"对立\"拯救到\"Project\r\nSekai\"，最后化身\"那菈勒克莱尔\"拯救了森林，消灭了恣意妄为的\"崩坏\"和\"光头强\"。\r\n2022.9.7\r\n昨天晚上 CF\r\n寄了，今天早上补题也寄，估计今天下午考试也寄，好似，凯翔宾楼！\r\n\r\nHerikoDeltana 于 2022 年 9 月 7 日下午 5:00 挂了 160\r\n分，警钟长鸣。\r\n\r\n\r\n法拉利这个防火服好看的（\r\n\r\n这两天挂分真的给我挂乐了，累计挂了快一套题出来了。\r\n2022.9.6\r\n\r\n夢の続きを知りたいのかい?\r\n夢の終わりが知りたくないのは\r\nあなたの望む世界じゃないから\r\nこんな続きを愛して欲しい\r\n\r\n无梦之梦也是去年第一次听到的了，今天不知道为什么突然涌现出来好多去年初的记忆，可能是要退役了吧。\r\n\r\n乐了，合着 NOIP10-2 我只会 T1，爬了！！！\r\n\r\n如何评价法拉利蒙扎特别赛车服？\r\n答：\r\n\r\n乐飞了（\r\n\r\n微调了一下博客的颜色，主蓝色不变，向紫渐变换成了向蓝绿（\r\n本来是想符合一下秋天的感觉整一个橙色调的，但是终究是显得有点黄金传说就放弃了（\r\n2022.9.5\r\n考虑到 CSP7-2 T4 需要写李超线段树，可能今天的大头就在这了（\r\n\r\n因为今天足球队训练整场，所以就没下去踢球，就在机房被迫听了一会\r\nhyl 唱歌和被迫看着 xby 和 ceh\r\n的**飞牌飞来飞去。大约正常的吃饭点就下去吃饭去了，走到餐厅门口刚好开门，真好。\r\n回来之后在落地窗看楼下回教室的人，想起来好久没有观察人类了，我们伟大的\r\nObservational Olympiad 先辈 jzk 已经退役了转战高三 whk\r\n之后，或将在我这里成为绝唱，因为我们两个和下一届好像都没太有交流。南侧这个教室的落地窗真的很适合观察下方的人流，而且也不会被注意，还是挺有意思的，在上面站着喝着奶看底下的人。\r\n然后回来坐下，把李超树调好了，过了。\r\n今天去看喝茶p的初音未来 15th 生贺视频，找到自己名字啦，然后看到别人的\r\nMC 贺图才想起来我最早知道 Miku 是小时候看奇怪君的 MC\r\n实况，记得当时奇怪总会建一面墙来放上 Miku\r\n的照片，说这是他老婆，不过我当时还不明白是什么。现在想起来真是感慨啊，已经过去六七年了，搬了这么多次家，那个初来\r\nJN 时的家也回不去了。\r\n今天突发奇想画（其实是划拉了几笔）了个 l/n，然后随便画了个\r\n25 和 VBS.mmj 和 ws 没太有什么特殊构图想法就没画\r\n\r\n也不是很好看（\r\n说起来这里也算是 Observational Olympiad\r\n的分支吧（自封的）希望 jzk 不会为我这个垃圾末代 OO\r\n人感到生气（\r\n明天有 NOIP 模拟赛，估计要寄。\r\n好久没写相对长一点的东西了，过几天可能开一个（但是一般来说比较懒可能又成千古老坑）\r\n据说某正今天在班里觉得我们停课时间长，那我想知道，化学数学停一个学期的、生物停六七个月的、物理停五个月的，都比我们停三个月短是吧，我知道如果拿这个说，得到的一定是一张燃尽大地也会唯独留下的嘴。哈哈，所以我尽量不拿这个怼人，你爱咋想咋想，我停我的你叨唠你的。\r\n\r\n哇我今天写的好多哦（\r\n2022.9.4\r\n然后昨天下午还是去踢球了，终于是踢了个半场，不是小门了，因为场地打了对抗少了所以脚也觉得没啥事了（？\r\n昨天晚上 CSP7-2 涨了 149，然后今天 NOIP10-2 T1 写寄了又掉了\r\n111，哈哈。\r\n今天也去踢球了，累。\r\nNOIP10-2 T1 调了一下午一晚上，真的服了。\r\n2022.9.3\r\n那就停到联赛吧。\r\n\r\n今天又觉得脚行了，但是今天他们不去踢了（\r\n不过可能去打羽毛球（\r\n刚打完，自己就幻视羽毛笔笑死我了。\r\n希望今天晚上 CSP7-2 不要掉分（\r\n2022.9.2\r\n昨天下午踢球一脚干到 zjy\r\n腿上了，他腿可能没啥事，我是脚的关节踢上去的，现在还在疼（\r\n\r\n现在一听 mzen 的猛毒脑子里就浮现这个\r\n我真的要笑死了。\r\n\r\n本来想着不下去踢球了，但是还是去了，还行，今天没到昨天的程度（\r\nVSCODE 夜间主题从昨天换成了 Tomorrow Night\r\nBright，然后发现这个黑色背景很适合加 STAY THE COURSE\r\n的曲绘，所以就加上背景力（\r\n\r\n这个周末的荷兰站估计是看不了了（\r\n\r\n虽然没到昨天的程度但是还是感觉走不了路了，不行，在这样下去就寄了，明天不下去了（\r\n今天又想起来 BA 了，BA\r\n制作团队你去出个动画/漫画好不好，但是我真的不想玩你那游戏（\r\n300k 纪念！\r\n\r\n\r\n为什么到了九点二十几就困了，好奇怪，已经好几年没困过这么早了。\r\n2022.9.1\r\n那么应该就是十月再见 OI 了，今天下午就回班了。\r\n因为他们下午讲卷子，所以明天再回去（\r\n明天可能也讲不完，那就下周再回去（\r\n嘛这样干脆全停了算了但是我给班主任说的是国庆回来停课\r\n2022.8.31\r\n初音未来生日快乐，莫娜生日快乐！\r\n\r\nPhigros 三周年快乐！\r\n依稀想起来二周年的时候我 rks 是 11.3，现在是\r\n13.82，也算是有点进步了。\r\n但是不是一直进步，是一段瓶颈之后，突然飞一小段。\r\n2021 年 10 月初，11.3x \r\n11.8x\r\n2021 年 11 月初，11.8x \r\n12.1x\r\n2022 年 1 月末，12.1x \r\n12.8x\r\n2022 年 4 月初，12.8x \r\n13.1x\r\n2022 年 7 月初，13.1x \r\n13.31\r\n2022 年 7、8 月，13.31 \r\n13.82\r\n可能跟 pjsk 判定更严有关系，也和换设备了有关系（\r\n但是多半是手感突然好了，就砍了一些分（\r\n2022.8.28\r\n[LAP 41/44] 我：今天法拉利策略还行，就是车差太多了。\r\n[LAP 44/44] 乐扣刷最快圈失败而且因为维修区超速被罚五秒\r\n我真的服了这……\r\n2022.8.27\r\n有些人 13\r\n天忘了博客，今天都要比利时排位了，才把上半赛季的锐评写完，我不说是谁（\r\n原的新活动真的好长好长好长（\r\n2022.8.14\r\n今天发现之前云平台填的李超树的研究性报告的链接是换博皮之前的，然而这个博皮是基于\r\nVue，所以老链接寄了。\r\n然而云平台上个学期的东西没法改，然后我就觉得如果真的有综评老师去看的话我就要寄了（好小子你研究性报告最后附一个\r\n404 网址）\r\n于是我就得需要重定向的方法。\r\n\r\nAlfalfa 21:46:21 宽哥会不会重定向\r\nAlfalfa 21:46:39 具体来说就是把\r\nhttps://hriver2.github.io/2022/01/23/Li-Chao-Tree/\r\n重定向到我新的地址\r\nAlfalfa 21:46:56 因为我云平台上回填的报告里面\r\nAlfalfa 21:47:01 最后放的这个链接\r\nAlfalfa 21:47:04 他现在是404\r\nAlfalfa 21:47:14 「mms 赞.jpg」\r\nDfkuaid 21:47:24 你现在地址是啥（\r\nAlfalfa 21:47:51 https://hriver2.github.io/post/Li-Chao-Tree\r\nDfkuaid 21:48:15 超，怎么目录结构都变了\r\nAlfalfa 21:48:29 、因为他渲染形式变了\r\nAlfalfa 21:48:39 现在这个是vue架构\r\nAlfalfa 21:51:04 好像有一种方式是\r\nAlfalfa 21:51:13 直接写一个404页面上去\r\nAlfalfa 21:51:21 底下放上可能的新地址\r\nDfkuaid 21:51:31 也不是不行\r\nDfkuaid 21:52:33\r\n考虑到每次上传都会重新构建，好像没有什么很好的其他从文件层面的方法\r\nAlfalfa 21:52:45 确实\r\n\r\n\r\nAlfalfa 21:59:57 我有一个比较好实现的方法\r\nAlfalfa 22:00:05 但是只能针对一个页面\r\nAlfalfa 22:00:14 就是我再新建一个文件夹\r\nAlfalfa 22:00:25 单独给这个放一个 index.html\r\nAlfalfa 22:00:31 让他跳转\r\nDfkuaid 22:00:53 没看懂（\r\nAlfalfa 22:01:20 就是在库里新建\r\n2022/01/23/Li-Chao-Tree/index.html\r\nAlfalfa 22:01:22 （\r\nDfkuaid 22:01:40 不会被刷掉么\r\nAlfalfa 22:01:51 我从本地建（\r\nDfkuaid 22:02:23 说不定可以\r\nDfkuaid 22:02:26 值得一试\r\nAlfalfa 22:02:31 确实*（\r\nAlfalfa 22:10:33 我hexo s成功了\r\nAlfalfa 22:10:37 不知道线上怎么样\r\nAlfalfa 22:11:35 我先传上去试试\r\nAlfalfa 22:13:35\r\nhttps://hriver2.github.io/2022/01/23/Li-Chao-Tree/\r\nAlfalfa 22:13:38 你试试\r\nAlfalfa 22:13:41 我这行\r\nDfkuaid 22:14:06 可\r\nAlfalfa 22:14:09 彳亍\r\n\r\n然后就愉悦的解决了（\r\n\r\n顺便一提今天的模拟赛真是重量级，只有31个人有分，鸮。\r\n\r\n今天意识到去年下半年心理出问题一个大原因是在学校，倒也不是说就是学校的事情，但是事实如此，每年暑假是心情最好的时候。\r\n\r\n之前说的锐评在写了，不过只有 F12022\r\n前半赛季的锐评，因为辉夜我真的一点也不想再回顾了。。。。虽然我还期盼着石弥线，但是我不会把期望再放到漫画上了，赤坂我绝对不会相信了。\r\n现在就看厨力爆炸的动画制作组力（\r\n2022.8.13\r\n？限流爱莉希雅短片，睿站完全就资本了呗？\r\n单纯烦睿站，跟其他游戏宣传工作无关。\r\n2022.8.9\r\n今天突然想起来之前说过要锐评什么东西，所以找个时间锐评罢。\r\n2022.7.31\r\nwdnmd 法拉利策略组。。把我气无语了。\r\n2022.7.30\r\n请问 Sega 您是不是真的不会画卡面，emu 这卡画的啥玩意？\r\n恭喜拉塞尔生涯首杆，匈牙利难超车，明天很有机会啊（\r\n2022.7.28\r\nTreap 和 Splay\r\n那个终于写完了，算是我今年目前写过最长的博客了（虽然主要是代码撑起来的\r\n把 Lycoris Recoil\r\n的简介（？）的一句话作为了观测枢的简介，好吧其实我日常背后大概没有什么原因（\r\n给最近的文章上了图片，好（\r\n代码块里面符号显示太暗，看它不舒服好久了，今天把它改了。\r\n昨天好像除了生物的去湖南了，也没啥事了，就不单列了。\r\n\r\nNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO\r\n歪头你怎么这就退了啊呜呜\r\n\r\n今天大消息有点多啊，保时捷收购红牛 50%，奥迪收购索伯\r\n75%，哈斯车改的像 F1-75.\r\n再加上 2024 安得雷蒂可能回 F1，这是要大洗牌了啊（\r\n2022.7.26\r\n杏宝生日快乐！\r\n\r\n森仓圆老师我的超人！\r\n\r\n起床 SKP 告诉我下雨了，居然是太阳雨。\r\n我已经快十年没见过太阳雨了，上次见还是 13 年暑假在青岛（\r\n\r\n和国外的 Tifosi 聊了聊法拉利。\r\n得出的结论：\r\n\r\n我的英语能基本正常的和他们交流，我泪目了（\r\n看起来国外老哥们对银石的意见也很大，我们几个对着银石谈了好久（\r\n大家一致认为今年是乐扣机会最大的一年，但是法拉利已经将 WDC\r\n基本拱手相让，除非法拉利能在再赢十场（但是比诺托居然觉得他们能行……）\r\n几个不同国家的 Tifosi\r\n一起痛恨法拉利拉跨，让我感到欣慰（不止有我们难受），又愤怒（法拉利你辜负了多少人的期望！）\r\n2022.7.25\r\n昨日法国站：**法拉利。\r\n比诺托已经拿下 101\r\n分，超越诺里斯来到积分榜第七：\r\n\r\n西班牙 P1 \r\n退赛（+25）\r\n阿塞拜疆领跑 \r\n退赛（+25）\r\n摩纳哥 P1 \r\nP4（+13）\r\n英国 P1 \r\nP4（+13）\r\n法国 P1 \r\n退赛（+25）\r\n\r\n昨天的上墙，让我想起两年前的德国，歪头的前翼。\r\n\r\n\r\n真**折寿，今天才发现我 APIO 分考的比 NOIP 和 CSP 高。\r\n\r\n\r\nFirst PR in\r\nOI-WIKI，好耶。\r\n说来还挺离谱的，上一个 Fix Typo 的把这个地方修错了，然后我发 PR\r\n的时候正好也有个审核发了 PR，最后他们发现我把多余的\r\n$ 也修了，再加上他们正好两个人，就把我的 Merge 了（\r\n2022.7.24\r\n赤坂真的打 APEX\r\n打傻了吗，你是想把你之前立起来的所有角色都毁一个遍吗。\r\n\r\n如果还有假期并且我那个时候还想的话，写几个锐评（辉夜，F1 22 等）\r\n2022.7.23\r\n返校，假期结束。\r\n\r\n2017-2022.\r\n愿你在那边一切都好。\r\n\r\n才发现 Asymmetry 整整鸽了两个月（\r\n2022.7.22\r\ndel/#l$l=-%&amp;l*lta:212.\r\naI amb confucsing.\r\nhdow thinges cofuld beg likge thihs.\r\nIi donnjot kunderstand.\r\n2022.7.15\r\n这两天碰了碰 F1\r\n22，哇今年这车下压力是真的缺，感觉就像是……感觉不出来（\r\n碰了下泰拉瑞亚，但是还不明白咋玩（？\r\n并没有延续去年 1 发出万叶的奇妙景象，小保底是莫娜不亏（\r\nPhigros 回家的时候是 13.31（上次回家打船的联动之后从 13.25 涨到\r\n13.31），这次先打了新曲涨到 13.34，然后重新打了打船和抽水马桶涨到\r\n13.37，🐏建议去试试 GOODTEK，摸了个 95.6w，涨到 13.40，然后把 Trane 摸到\r\n94.4w，涨到 13.42，至此板子上的 rks 已经比手机上高了 0.25 了（\r\n（7.22 补：截止到今天已经 13.61 了，这个假期涨了整整 0.3，离谱）\r\n麻了，某些东西说是要高考假期写这都暑假了（爬……\r\n2022.7.12\r\n洛天依生日快乐！\r\n\r\n\r\n今天这雨好大啊 FiretrUCK.\r\n\r\n我和这 P1770 干上了，，，，一天多了还是 3WA 1RE 1AC.\r\n（过了半个多小时之后）烦了，日，不干了！\r\n\r\n\r\n不知道还要写啥，hh.\r\n\r\n突然想起来 F1 游戏里的语音中文姓氏只有“周”和……“王”？\r\n于是决定把车手名称改成周杰（（巨神\r\n\r\n我发现六兆年是真的耐听……我总是能无意识的听上几十遍（\r\n\r\n暑假开始喜闻乐见。\r\n2022.7.11\r\n我笑飞了：\r\n\r\n\r\n\r\nTestify 截止到今天 3 位 PM 了Ren\r\n哭晕在厕所，对立快回来（（\r\n\r\n感谢……\r\nにっこり\r\n永远会的\r\n2022.7.10\r\n终于考完期末了（\r\n预估\r\n虽然因为身体原因数学挂了四五十分（考数学前一天晚上肚子疼没睡着，然后考场就寄了\r\n但是总体（除了语文）上比联考有一定进步，算是找到了物化生三科前进的方向。\r\n昨天老师问还有没有想转选科的（\r\n其实自己还是想转科的，但是现在大约已经晚了，所以就没有说。\r\n史地生大约是能让我考的最好的组合，但是既然选了纯理就走下去呗，选历史还得写一大堆字（\r\n不过都是预估了，反正这回因为数学稀碎所以也对最终成绩没抱太大希望。\r\n大概是今天晚上回宿舍发成绩条，估计要掉到一千名了。\r\nArcaea\r\n616！你还我对立！\r\nHDSBN → LSOH\r\n暂存一下之前的简介：\r\n\r\nHeriko Deltana's Social Behavior\r\nNote，其实大约就是一个日记之类的什么东西。\r\n记忆最深的日记是 LSP 的焚燃指间の回忆和\r\nSZT 的梦回还\r\n他们的起名看起来都很文艺范，所以我反其道而行之：《Social Behavior\r\nNote》，以此来彰显 HD 同学喜欢窥探自己和别人。\r\n\r\n今天起改成观测枢了（\r\n其他\r\n把 VSCODE 的背景去了，单纯是因为不想要每次都开 VSC 的时候都看见一个\r\n“[不受支持]”\r\n下雨真的太优美了，总是在我出其不意的时候下。去餐厅的时候专门看了看是不是没雨，于是就没拿伞，结果吃完饭出来就哗哗下（\r\n2022.6.22\r\n\r\nWACCA 停运了。\r\nArcaea 要更新 4.0，最终章了。\r\n雷亚跳槽。\r\n\r\n这……就不做评价了。\r\n2022.6.21\r\n好嘛，终于把 P3313 调完了。\r\n把壁纸换回了奏的房间，喜欢这个蓝色的氛围，和电脑也很搭（\r\n同时也把 VSCODE 的背景设成这个，和写代码的氛围配合的也挺好（\r\n\r\nBug 的副歌潜伏在我脑子里天天转（\r\n这两天热的真的不行，天天气温 40\r\n度，体感更离谱，热的我天天发晕，吐了🤮\r\n今天下午起床来教室之后左手一直没知觉好奇怪，但是趴了会就好了。\r\n2022.6.20\r\nnene 这回卡好好看，tks 这回卡真就三岁吉吉国王，笑死我了。\r\nP3313 今天终于过了样例，但是还是全 WA 了（\r\n加拿大冠宇 P8，过年了！\r\n2022.6.19\r\n当 25 还在探知自我，WS 已经无人岛探险了（\r\n\r\n网又没了，服了。\r\n2022.6.18\r\n久违周末上奥赛，这两天心情还可以。\r\n今天生物去参见预选赛，停课的都过了，希望他们联赛打好吧（\r\n卓爹刚才说他省一问题不大（（然而生物第一年拿省一很难啊（\r\n2022.6.16\r\n才发现高考期间在家一点博客都没更新（好吧补一个昨天的，剩下的再说\r\n这两天做卷子做的好多，嗯。\r\n脑子里一直都是 Awake Now（\r\n\r\n把光标形式换成了 L 佬做的 knd 样式，卡瓦（\r\n看了看 L 佬做的卡面花前后的剧情底下的评论，感觉 mfy 妈真的……\r\n不行，这期剧情我回家一定要补上（\r\n\r\n夏天到了，热（\r\n2022.6.15\r\n引用 Char1esLeclerc\r\n一个评论。\r\n\r\n生气版文案：领先的时候引擎又爆缸了，你说这群意大驴还能做好什么？连意大利面我都觉得难吃，七站比赛爆缸两站，晕厥的策略，爆缸的引擎，老奶奶般的尾速，甲级战犯binotto，直接拿下吧，连菠萝披萨都不配吃。\r\n\r\n我真的服了，法拉利阵营六退四，剩下两个一个博塔斯在养生，一个米克害怕撞墙不敢开。\r\n小周明明正常完赛就是 P7\r\n往上，退了，又退了，四退三，我真的不知道阿罗是想干啥。\r\n所以真的很生气，法拉利用四场比赛宣告：我们可以总结维斯塔潘两冠生涯了。\r\n\r\n还有就是真的很伤心，因为不好说，所以引用自己在 Bili 发的动态吧。\r\n\r\n世事无常，只能这样说了。 去年今天还在一起吃饭。 真的难受的睡不着。\r\n一路走好。\r\n\r\n真的好难受，真的……我真的无法想象，上次见还是……笑着的下楼呢……去年今天下午的时候……还一起吃饭……\r\n我不能接受啊，不能接受……\r\n真的写到这里就会哽咽，形容不出来这种感觉。\r\n写不出来，太难受了，写不出来，无法表达……\r\n2022.5.29\r\n今天把 AURORA 主题整好了，除了学校熊网贼慢我都挺满意的（\r\n可惜明天就要去考联考了，然而感觉没底，不过无所谓大不了再垫底。\r\n\r\n我笑死了，草（\r\n\r\n\r\n2022.5.28\r\n今天被这个熊博客整疯了，我修个  整了一下午（\r\nhyl 找到一个很好看的主题，于是我先观望一下，如果他能整好（主要是\r\n）那我就转过去（\r\n2022.5.27\r\n明明是夏天刚开始，但是这一周脑子里总是あの夏が飽和する。\r\n为什么呢，我也不知道（\r\n还是希望这个夏天心情和去年相似吧。\r\n\r\n给我整不会了，我电脑的 Edge\r\n加载不出来公式，但是我手机的任意浏览器都可以。。\r\n2022.5.21\r\n在思考到底要不要买 knd\r\n的手办啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊我得在她和 F122\r\n之间做出抉择了啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊年轻人没钱是 真 的\r\n好！\r\n\r\n最终结果是付了 knd 手办的定金，不过尾款要等到九月（（\r\n2022.5.15\r\n今天是 SDOI2022，祝愿各位胜选，线上选手今天暂且看看题吧。\r\n或许想写什么但是……没空写，悲。\r\n2022.5.14\r\n原道，触发悔恨之泪，我真的泪目了这个通透感。\r\n明天就是 SDOI 了，祝愿各位成功吧！（好吧，虽然没人看）\r\n\r\n很好！树剖一遍过，330 行不忘初心（\r\n2022.5.8\r\n怎么说呢，你永远叫不醒一个装睡的人。\r\n2022.5.7\r\n好久没更新了，放一些歌词罢，会有人来看吗，会吗（\r\n这段歌词有好多点让我触动呢……会有人同感吗……\r\n\r\n時ノ雨、最終戦争 Orangestar / IA 止まない憂いの最中\r\n在不曾停息的忧郁之中 二つ感情は対を成して願いを放つ\r\n两种感情成对地释放着心愿 君は覚えてるかな 你还记得吗 あの日涙の意味を\r\n那天流下的眼泪的意义\r\nこの世はまだ終わらない 这个世界还没有完结\r\n明けぬ夜が今日を塞いでたって 即使极夜将今天堵截\r\n僕は歌う「嫌いじゃないな」って 我也会唱到「并不讨厌呢」 さぁクラい空が\r\nハれる 来吧 漆黑的天空再次放晴\r\n泣き止んだ今日にさらば 与不再哭泣的今日别过 変わらない思いを\r\n如挥动着不变的思念这般 振り翳すように生きてく 生活下去\r\n泣きながらでいいさ 即使哭着也没关系 それを繰り返して笑える生涯\r\n在这样重复着然后欢笑的一生\r\n\r\n2022.4.29\r\n今天心有点堵。\r\n先是提不起精神来，学不动，也玩不动。\r\n然后是快递给我发成都去了。。我都傻了，“快件已到，距离收货地\r\n1514KM“\r\n然后想起来还有给 ysa 和 ysc 的生日礼物压在上海。。\r\n烦啊。\r\n2022.4.27\r\n好吧！爷就是吃醋了！自己给自己做的那种！\r\n2022.4.26\r\n相比起前段时间，看淡了，可能是准备省选和推原神占据课余主要精力了。\r\n其实省选也没准备什么，本来就没机会，就这样吧。\r\n我不去想的时候，不会让我有任何感受，所以就不要想了。\r\n可是就像现在一样，其实是无意去想的，但是我看到就会让我感到难受。但是这难受没有理由啊，这不是我能管到的事情，我不能也不应该让事情都向着我想要的地步去发展，更何况，我也不知道到底我在这件事上想要的是什么。。\r\n所以我真的……\r\n2022.4.24\r\n我现在一听部分人说话就难受。\r\n血压真的被拉的很高。\r\n我真的会被气炸。\r\n心中万句吐槽，懒得打了，滚吧……让我血压起飞的人。\r\n2022.4.21\r\n放一点歌词：\r\n\r\nティアドロップス（Teardrops）\r\n柊キライ / v flower\r\n\r\n延々エンエンと泣いている\r\n哭得不像样的我\r\nそれは誰の為　自分の為で\r\n究竟是因为谁呢 是因为自己吗\r\n「悲しいの」そう言って酔いあがる為さ\r\n只是无力地在丧气的话语中沉醉\r\nそのエンターテイメントに合わせ\r\n是否更加符合这场闹剧\r\n踊る　踊る　心躍るよ\r\n舞动吧 跳跃吧 让心也狂欢起来吧\r\nこの先「楽しい」に何度出会うだろう\r\n就这样让欢悦永远充满心间吧\r\nそれなのに\r\n即使这样\r\n無垢な気持ちで泣いてみたい\r\n我也想要怀着澄澈的心大哭一场啊\r\n無垢な気持ちで泣いてみたい\r\n我也想要怀着澄澈的心大哭一场啊\r\nこんがらがった　涙　涙　ぽとぽと\r\n哭得泪流满面 泪水 泪水 缓缓滴落\r\n悪いことをしてるんじゃないか？\r\n这算不算是在做坏事呢\r\n無垢な気持ちで泣いてみたい\r\n想要如同孩子一般地大哭起来啊\r\n無垢な気持ちで泣いてみたい\r\n想要如同孩子一般地大哭起来啊\r\nだって　悲しいんです　本当です\r\n因为 我是那么的悲伤 绝没有骗你\r\n真意を証明出来ないのも\r\n即使是不能好好的表达自己的心情\r\n悲しいです\r\n\r\n虽然我现在以及麻木了但是听到还是能短暂的想起来之前。\r\n我分散注意力的方法可能大约大概很有效，现在已经不会想那些了（\r\n2022.4.20\r\n\r\n白葱 2022/4/19 我刚才寻思着反正都攒了 80\r\n了这个实乃里生日卡真的很好看要不然抽一个吧\r\n白葱 2022/4/19 然后控（）室多了十个可兑换\r\n\r\n然后看见正好这次司活的 Live 要开始了，就去看了看。\r\n我本来以为也是和上次 1.5\r\n周年一样两首歌的样子的，没想到，最后……就一首歌（\r\n\r\n    \r\n\r\n\r\n今天想想前段时间真的有些敏感了。\r\n2022.4.19\r\n最近好烦呐。\r\n梦里啥都有，我现在梦越发真实而醒来之后越想越不可能……\r\n我感觉我确实是疯了。\r\n\r\n今天找到了 Formula1\r\n的字体，虽然官方并不公开这个字体，但是还是有民间的模仿字体（大概\r\n于是就把浏览器默认字体和博客默认字体改成了这个。\r\n只可惜这种字体字间距太小不能写代码（\r\n但是看起来真的好高级（（（（\r\n\r\n这几天的经历告诉我，我（）（）了（）（）（）真的会死……已经不敢想今年暑假之后的事情了……\r\n2022.4.17\r\n417，谐音有点意思。\r\n达芬奇我真谢谢你，我做了一个小时的动画。\r\n去整了个 Pr22，看看能不能好一点。\r\n还在试图复健树剖。\r\n一口气注销了很多东西。\r\n我为什么要看起来好像无所谓，我不理解。\r\n意识到自己不想用括号或者省略号结尾还是挺恐怖的。\r\n2022.4.16\r\n但其实昨天因为自己想要好好上课所以昨天上课体验是非常好的（\r\n于是就被叫起来回答问题两次对吧\r\n网课这个延迟真的跪了hh，我和 QKD 之间的延迟高的离谱，大概 3~4s.\r\n我说下一个题他问我上一个题的级别（\r\n昨天晚上试图去宽哥的腾讯会议进行学习，但是没坚持太长时间就退了（主要是人都不在了我就润了\r\n……周末卷子有点闹心。\r\n\r\n略感离谱，我想知道这些网课软件都是咋写的。\r\n您软件内存和 CPU 占用都大于我 Edge 和 VSCode 总和。\r\n还是在我 VSCode 和 Edge 很多插件的情况下……\r\n哇我真的不理解（\r\n\r\n好烦啊好多事情撞在一起。。\r\n\r\n随便画了几笔，因为突然想画个小头头（\r\n大概是参照了一下白葱，但是画的完全不像就是了（\r\n\r\n\r\n今天看到一张 20\r\n年八月的照片，好怀念，这上面的所有东西都和现在不一样了（\r\n虽然说并不是说新的不好，但是就是好怀念之前在那个家，用着老电脑，夕阳下的时光。\r\n2022.4.15\r\n好想和这个世界说再见了……我怎么又这样。。\r\n我「振作」起来，愁绪「去TM」！\r\n2022.4.12\r\n感觉这几天都没啥好记的东西，但是感觉到很多危机感，好烦。\r\n省选又延迟了，但是跟我没有太大关系。\r\n但是又是好久不碰奥赛了，感觉是时候安排一下自己的计划了。\r\n2022.4.10\r\n好几天没动博客了，主要是懒，而不知道写什么。\r\n其实要脑子里有的东西好多，都扔到 Reverie\r\n里面吧（然而并不能知道什么时候能写完）。\r\n感觉自己最近总是在担心一些东西，然而这件事，或者这个人，并不需要我担心，就是我自己瞎想罢了。\r\n\r\n算是比较偶然，打开 PJSK 看见有\r\nLIVE，于是就进去看，第一次只看到了最后的自傷無色和 Tell Your World.\r\n因为第一次看这种虚拟 LIVE，相当激动。\r\n然后发现后面还有一场一样的，就把后面一场看完了。\r\n\r\n白葱 1:21:36 我发现我看这个也好激动（）\r\n白葱 1:21:56 虽然sega很敷衍的就放了一个歌\r\n白葱 1:22:10 哦不是，是两个\r\n白葱 1:22:25 但是我还是好激动看这个\r\n白葱 1:22:35 我越看越想去现场。。\r\n白葱 1:22:47 傻呗疫情赶紧过去\r\n白葱 1:23:01 24年我要去霓虹\r\n白葱 1:23:12 寝了\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n未来的悲鸣时时在耳旁幻起。\r\n现在的我却感觉无能为力。\r\n不能探知到自己真的太痛苦了，别人不懂，我也不懂，谁懂了告诉我好吗。\r\n回想之前，我是怎么在虚幻有无走过来的。\r\n每一次做出决定之前，我是……哪一个我呢……\r\n2022.4.9\r\n企鹅回滚真的好听，我之前没听真的相对失败，今天不听明天停止公开了失败一辈子。\r\n2022.4.7\r\n好几天没动博客了，原因未知。\r\n2022.4.3\r\n今天下楼拍了拍花（\r\n\r\n\r\n挑一张我觉得拍得最好的\r\n\r\n更了谜语集。\r\n看了 wxm 博客之后想简单改改 About.\r\n\r\n因为没啥好写的了，放一个谜语罢（信：\r\n颤抖的心情，等待的凉意。\r\n2022.4.2\r\n感觉今天 nothing to record（\r\n2022.4.1\r\n愚人节快乐，一会再写（\r\n\r\n上网课第二天，没啥特殊体验，和昨天差不多。\r\n除了下午多了一节美术，我是真的要笑死在这节课上（\r\n老师放的视频没有画面只有声音，皮影戏的声音还贼吓人哈哈哈哈哈哈哈哈哈哈哈哈哈\r\n然后讨论区因为是全级部大课，一堆社牛哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈（\r\n\r\nPJSK 愚人节活动真的笑死我，五个 SEKAI 空无一人，现实世界 C\r\n社六子联会（\r\nMIKU RIN LUKA MEIKO 五倍体（x）\r\nKAITO 和 LEN 四倍体（x）\r\n还有  RIN +  Len（XXY，信）， KAITO +  MEIKO （XYY，信）\r\n然后发现自己又攒了一个十连，所以就去抽 FES 池子了（\r\n然后……出了小白葱！\r\n我圆满了.jpg\r\n还有就是这回愚人节的重排（信）组合，真的好惊喜（\r\nYUME YUME JUMP | 永远的神！！！！！！！可爱死了我的奏宝😭😭😭😭😭\r\nFantasista SQUAD | 我的亲娘……\r\nハピネス戦隊サニサニ☆ワンダー | 把 mfy 和 emu\r\n放在一起我笑死了哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈\r\n休日、趣味人同士で。 |\r\n这个猛毒啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊真的太好听了呜呜\r\n\r\n然后……还有啥来着，忘了……\r\n哦对，换了特等俘虏的头像，还是和牛爷爷一起（\r\n我用的白葱，牛爷爷用的奏宝。\r\n然后 wxm 换成了 mfy（\r\nidentity 觉得很淦（信\r\n\r\nwxm 想建博客（\r\n\r\n\r\n岚 2022/4/1 0:25:46 四月快乐\r\n岚 2022/4/1 0:25:51 寝之前\r\n岚 2022/4/1 0:25:58 感觉还是得说\r\n岚 2022/4/1 0:26:22 当我们姑且把一个月的第一天当做新的开始的时候\r\n岚 2022/4/1 0:26:33 就必须要好好生活下去了\r\n白葱 2022/4/1 0:27:17 是呢（）\r\n岚 2022/4/1 0:27:17 这是一个清澈温暖的季节\r\n岚 2022/4/1 0:27:26 不管外面怎么样\r\n岚 2022/4/1 0:27:34 我们\r\n白葱 2022/4/1 0:28:35 我们（）\r\n岚 2022/4/1 0:28:58 每一天都要明媚喔\r\n岚 2022/4/1 0:29:03 （sign）\r\n白葱 2022/4/1 0:29:06 呜呜\r\n\r\n\r\n挖一个，坑.\r\n2022.3.31\r\n关于网课：\r\n第一天上网课，老师可能还没找到节奏，所以今天推的不算是特别快（\r\n班主任课前专场单口相声（\r\n\r\n关于 F1：\r\n今天官宣了 2023 年加入拉斯维加斯夜赛。\r\n一条大大大大大大大大大直道，可以预计达到 342 KM/H 的直道，而且就 14\r\n个弯，你为啥不直接去 NASCAR 赛道（\r\n加上拉斯维加斯美国就三场比赛了（\r\nVET\r\n这周末要回归了，希望能有拿分的可能吧，马丁今年这车真是……寄往开来，2020\r\n粉红梅奔到 2021 削了底板掉到中下游，再到 2022 和威廉姆斯夺倒数……\r\n下一场是澳大利亚，一条我觉得非常难把持的赛道……\r\n开一个一般的圈速不难，但是开一个相对不错的圈速有点难把持（\r\n\r\n关于 PJSK：\r\nNothing,but after updating the v2.0.0, my phone always EAT MY\r\nHOLDS!!\r\nWhy?? I don't know!\r\nWhat happened? We need to know!!\r\nSo I just registered an Apple ID to try to download PJSK on the\r\niPad.\r\nThen I had better score.\r\n请无视所有的语法错误，单纯打英语玩。\r\n简单来说就是……想再整出来一发十连（\r\n但是手机断触，于是首次尝试 iPad \r\nPJSK，确实比手机强多了，第一次活着打完了火花的 28，miss18（\r\n因为明天是愚人节，等一个活动。\r\n\r\n谜语：\r\n好，虽相比有差，然我觉得这更好，人格差恰适应此。\r\n2022.3.30\r\n昨天晚上还在感叹，还有四五天才能放假。\r\n我怎么都想不到，今天居然回家了，因为疫情。\r\n网课时代，又要开始了。\r\n\r\n晚上说要测试网课，最一开始在学校说的是五点半，然后后来通知说七点半，然后发现平台一直都没调试好，我们就等了三个多小时……\r\n最后终于在十点多整好了……\r\n\r\n不知道什么情况，PJSK 这回更新之后，总是莫名断触，咋整啊……\r\n因为上回攒了一发十连，再加上这回 Potato\r\nSekai，加起来有两发十连。\r\n因为相当喜欢小白葱，所以就去抽 fes 池子，然后，十连第一次出彩……\r\n喜提一发十连两个四星两个三星……\r\n虽然没有白葱，但是有冬弥和杏（\r\n然后因为 1.5 周年更新仅仅在 39 日的之后 21\r\n天，于是专门开了个卡池送了 3.9 发十连（\r\n然后试了两次十连，第一次正常单三星，第二次一个天马咲希的四星，外加两个三星（\r\n然而我要我的小白葱啊呜呜呜呜呜呜（x）\r\n\r\nwxm 2022/3/30 23:54:30\r\n？？？？？？？？？？？？？？？？？？？？？？？、、\r\nwxm 2022/3/30 23:54:35 号送我\r\nwxm 2022/3/30 23:54:41 我这辈子没出一个fes\r\n\r\n2022.3.29\r\n不得不称赞一下学校的组织能力，可以说是 SD，乃至全国的顶尖水准。\r\n顺便，今天早读老师读了一个高三学长写的“表扬信”，简单来说就是说我们住在他们楼下敲暖气管子，然后还“以头抢地，奏翁击缶”。\r\n我倒是觉得提出来挺好的，但是，倒是说哪个房间有水管声啊……也让我们好核查一下。\r\n免得每天吹哨之后我们听着楼上咣咣当当还得写信给校长（笑\r\n\r\n说啥来啥，学长真的是相当勤奋！！\r\n今天中午在吹哨之后还在勤奋的讨论问题、舒展身体，让暖气管不仅情不自禁的叮当想响起来，而且传来讨论问题的刻苦声音！\r\n（笑）\r\n其实觉得这玩意属于是谁先写谁占优呗。\r\n\r\n不太懂，学校信息老师都……\r\n算了，没必要。\r\n2022.3.28\r\n早上一点是沙特大奖赛，但是因为在学校所以就没看。\r\n其实在家也看不了，谁在第二天早上五点二十起床的时候熬夜啊\r\n然后中午让 SKP 奶一下周冠宇和冠军，SKP 奶的冠宇 P9，冠军法拉利。\r\n然后下午一看冠宇 P11，冠军红牛（\r\n不愧是毒奶之王 SKP\r\n就应该把阿罗车组当场拿下！！！！\r\n2022.3.24\r\n学校这个网给我整无语了真的，你 LC** 吃枣药丸。\r\n2022.3.23\r\n今天是世界小狗日好像（\r\n学校开始实名上网……无语\r\n2022.3.22\r\n这玩意是真给我整无语了，最近 Github 难以访问可还行，push\r\n不上去。。\r\n整了好长时间终于整上去了。。。\r\n我的评价是：抽象。\r\n2022.3.21\r\n窝法一二带回，冠宇首秀拿分，红牛颗粒无收，老汉再度登台，法家阵营起飞，梅奔阵营提前备战\r\n2023，好时代，来临了！\r\n我真的高兴坏了真的真的真的真的真的真的真的真的真的真的真的真的真的真的真的真的真的真的\r\n法拉利阵营整体起飞！！\r\n\r\n本来我昨天晚上光看了起步，一看阿罗两位都晕厥（\r\n本来觉得能回到排位位置就好了，今天早上一起来就看到周冠宇是 P10！\r\n\r\n附，某两位铁佛寺：\r\n\r\n[保留]绝顶我为峰 2022/3/21 0:45:55\r\n窝法一二带回了啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊\r\n[保留]绝顶我为峰 2022/3/21 0:46:00\r\n周冠宇拿积分了啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊\r\n[保留]绝顶我为峰 2022/3/21 0:46:04\r\n过年了啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊\r\n[保留]绝顶我为峰 2022/3/21 0:46:06 【庆祝】\r\n25時、コードを書く 2022/3/21 16:50:38 好时代来临了！\r\n25時、コードを書く 2022/3/21 16:50:39\r\n窝法一二带回，冠宇首秀拿分，红牛颗粒无收，老汉再度登台，法家阵营起飞，梅奔阵营提前备战\r\n2023，好时代，来临了（x）\r\n25時、コードを書く 2022/3/21 16:50:49 真的过年\r\n[保留]绝顶我为峰 2022/3/21 16:50:57 【庆祝】\r\n25時、コードを書く 2022/3/21 16:51:07 高兴坏了真的\r\n25時、コードを書く 2022/3/21 16:51:31 我因为今天要五点二十起床\r\n25時、コードを書く 2022/3/21 16:51:34 昨天晚上就没看\r\n25時、コードを書く 2022/3/21 16:51:37 光看了发车\r\n25時、コードを書く 2022/3/21 16:51:50\r\n看着冠宇起步掉到20，觉得有点危\r\n25時、コードを書く 2022/3/21 16:52:08 但是就我过了一会发现冠宇超到\r\n15\r\n25時、コードを書く 2022/3/21 16:52:34\r\n然后我上床就祝愿冠宇和77能保持排位成绩\r\n25時、コードを書く 2022/3/21 16:52:45 法拉利双台\r\n25時、コードを書く 2022/3/21 16:52:50 今天早上起来一看\r\n[保留]绝顶我为峰 2022/3/21 16:52:56 【狂笑】\r\n25時、コードを書く 2022/3/21 16:53:01 爽飞了\r\n\r\n\r\n以及，刚才有一架 737 失联了……\r\n希望能有奇迹🙏\r\n2022.3.20\r\n早上起来看见 LEC 夺杆，真的，高兴坏了（\r\nForza Ferrari\r\n\r\n\r\n然后把今天 QQ 空间的东西搬过来：\r\n\r\n某个屑 B 因为不想现在开电脑所以就过会再扔博客里吧。\r\n简单来说，生日以来的这这两周是我 20.9 以来最开心的一段时间。\r\n希望能延续好心情（\r\n（顺便提一句日推真有你的。。我都忘了要找这首，你主动给我推了）\r\n因为比较菜听日语做不到听英语的水平，所以经常去翻歌词。\r\n逐渐的就喜欢上翻歌词，因为真的有许多术曲的歌词让我很有同感。\r\n（然而并不是专指什么厌弃自己淡漠世界的歌词，但是变故总是会让我和它们走近。嘛，不过，现在好多了嘛。）\r\n因为脑袋里记的东西一向比较奇怪，好多东西都是连在一起一串起来一堆的水准，所以会发生各种奇怪的遐想和梦境。\r\n（其实好像上了初三以来还没有没梦睡一次的。。） （等一个无梦之梦（x））\r\n哦好像某种意义上来讲，无梦之梦是我今年入坑之前最喜欢的一首术曲。\r\n（然而屑 B 网易云要 VIP）\r\n济南没有春秋所以随着气温升高是不是可以期待夏了。作为 IA 推（）\r\n然而感悟一通，随着脑袋瞎想瞎写，我发现我还有一个问题找不到答案。\r\n我啥时候能知道咋学习？ （……毕竟学习好了才能完成生日愿望的某一条）\r\n好，我宣布某个谜语人又开始了。\r\n读自己之前写的东西，就很容易读不懂……因为写的实在是太迷离了。\r\n尤其是越对公众开放的东西越谜语。。\r\n某些在博客角落藏着的东西……他也很谜语。\r\n这就不是一个良性循环，因为我记东西比较连锁，可能就拽出来一堆之前的事情。\r\n不喜欢回顾初三之前的事情，因为现在就觉得人傻没做不出什么对的事。\r\n然而初三上学期，和高一上学期的回忆一个比一个寄，本身性格比较脆就可能直接手把手借之前的刀把自己再干碎一次（）\r\n不过某种意义上来讲，通过去年，我好像更知道我了。但是可能我的像太宽而淡了，就像是找到了自己在世界的哪个位置，但是找&gt;\r\n不到自己在哪。 不是……我是有病吧写这么一堆乱七八糟的东西。\r\n但是我是真的懒得开电脑（）\r\n\r\n     \r\n\r\n\r\n2022.3.19\r\n今天早上挺有意思，SKP\r\n说我五点多一点开始在床上笑，然后就把全宿舍人整醒了（\r\n问题是我把他们笑醒了我没醒（（\r\n我起来之后怎么都想不起来为啥会笑，我梦里明明梦见 yym\r\n拿着菜刀在宿舍追杀我和别人来着（？\r\n\r\n回家之后浅浅试了一下糖豆人和战舰世界（感觉还行\r\n然后开着 20 年周冠宇的车挑战了一下 90 难度的 AI\r\n跑河内，发现其实超车没啥难度（\r\n好奇怪我玩生涯的时候 AI 开 81 排位赛速度都不是很好（相对队友），但是\r\nF2 正赛连着两次三段刷紫（\r\n好像我确实也是正赛节奏比较稳，排位纯靠天意（\r\n下回试试 95\r\nAI，跑河内（不得不说这赛道是真恶心人，到底谁想出来的！）\r\n2022.3.18\r\n我的想法是，要不然单独开一个写（\r\n但是今天还是先把之前博客里一些非学术的东西搬一搬。\r\n2022.3.17\r\n终于有机会写一点东西了吗（\r\n\r\n笑死又没时间了，每天一个小时做个题都不够的（\r\n2022.3.16\r\n我是锅王，四道题的比赛锅三道，有两道是因为我，tnnd.\r\nHelloWorld2022 出假了，我对不起绊爱。。\r\n2022.3.13\r\n昨天晚上把 HelloWorld2022\r\n的三削版写完了，今天早上造了数据，于是乎给学弟学妹的题大约就剩下最后一道了。\r\n但是这道我没啥想法（\r\n最后是把去年 Aik T1 搬来了，重设了一下题面。\r\n但是不知道什么时候才能让他们做这道题呢……今天已经不够四个小时了（\r\n我发现我出题特点就是题目背景瞎糊一堆，然后题贼简单。\r\n\r\n今天猫夸头像结束了长达九个月的服役，大概是我初中以来用过时间最长的头像了。\r\n换掉的原因有两点，第一点是我个人逐渐不再看 VTB/VUP 了，第二点是即使\r\nAqua 虽然在最后的 Hololive\r\n事件上并没有如哈卡哈卡吗和煌虫那么负面，但是毕竟还是有过各种事情吧，然后就换了。\r\n（找理由）\r\n可以看到的是现在换成了 knd，呜呜我的奏宝（\r\n\r\n\r\n宵崎奏你给我带包泡面吧😭\r\n\r\n2022.3.12\r\n今天去打 THUPC 初赛，当然是没想着晋级，因为菜。\r\n目标是我们队能有题就好。\r\n最后的结果就是做出来 K，A 和 D 差点，果真还是菜。\r\n早上忘了买吃的，中午没吃东西（\r\n\r\n今天去萌娘百科看了 mzk 的经历啥的，发现你 sega 是真会写\r\n25h，四个人各种戳我（\r\n虽然我是 knd 推，但是对 mzk 好像感悟更多欸（不是伪娘这一点\r\n2022.3.11\r\n今天想了想，又改成了 Heriko Deltana's Social Behavior Note（\r\n\r\n什么是架空世界啊（谜语人笑）\r\n\r\n有道这个翻译我属实看不懂：\r\n宵崎奏 → Night battery play\r\n2022.3.10\r\n今天发现 16 岁以来每一天都挺……（\r\n有点担心之后。\r\n2022.3.9\r\n39日快乐（\r\n上午第三节课课间开始戴着 leo/need 的 miku 徽章，然后 wxm 带着\r\nleo/need 的 luka 徽章（\r\n然后我戴到下午实在社牛不了了（\r\n\r\n[INFO] - 2022/03/09 17:00:35 - nmdlasd: 我自己带逮捕证\r\n[INFO] - 2022/03/09 17:00:40 - nmdlasd: *带不正\r\n[INFO] - 2022/03/09 17:12:26 - nmdlasd: 然后就带不上去了\r\n[INFO] - 2022/03/09 17:12:38 - nmdlasd: 主要是这玩意和校徽一样大\r\n[INFO] - 2022/03/09 17:12:51 - nmdlasd: 我就把它挂在领子上\r\n[INFO] - 2022/03/09 17:12:56 - nmdlasd: 结果感觉很奇怪\r\n[INFO] - 2022/03/09 17:13:19 - nmdlasd:\r\n但是如果和校徽放在一起更加离谱的样子\r\n[INFO] - 2022/03/09 17:13:30 - nmdlasd:\r\n所以最好的方式是盖住校徽/kx\r\n[INFO] - 2022/03/09 17:13:37 - nmdlasd: 但是那样更会被干\r\n\r\n\r\n后续：昨天一直戴到回家。\r\ndeco 新专辑 suki！\r\n2022.3.8\r\n发现随着某些事情越来越好，精神状态有很大恢复（\r\n\r\n我发现我就是巨大谜语人（\r\n2022.3.7\r\n没想到今天这么好（各种意义上\r\n2022.3.5\r\n又要从昨天晚上说起了。\r\n因为难得的大于一天的假期，wxm 说要周末一起出去打 mai（\r\n因为开学故意考砸，所以不是很敢和妈妈说来着（\r\n但是没想到同意了（\r\n然后今天上午就可以第二次去 mai 了，这次除了 mfj 和 wxm 还有妈沫（\r\n最一开始是我和 wxm 一个机子，mfj\r\n和妈沫一个机子，但是因为是周六，来的人还是比上次去多的，因为太菜了不敢占机子就让了一个机子（\r\n最一开始找不太到感觉，后来就开始有感觉的糊（\r\nmfj 最一开始形容我打 mai 宛若逛大街，后来我也学会了快乐糊（\r\n然后用着妈沫的号怒干用着 mfj 号的 wxm （中间 mfj\r\n和妈沫打累了我俩就直接上了）\r\n再加上后面 mfj 用妈沫的号怒干用着 mfj 号的\r\nwxm，所以妈沫的记录上估计就有了五连干 mfj（\r\n话说我用自己号最一开始干不过 wxm 来着，属于是不用别人号不会玩了（\r\n然后我和 wxm 累了就带着 wxm 去玩了一下湾岸（？\r\n然后因为下午要上课就提前走了，没能和生物的人去吃火锅（\r\n要不然我可能重现蛋饺事件（见 2021.1.20 Sec2\r\n2022.3.4\r\n十六了，HD 生日快乐（\r\n班里各位是 真 会 送 东 西（\r\n怒提 45 包餐巾纸，虽然不知道送我这干啥（\r\n2022.3.3\r\n写了好多天的十六巨献终于写完了（\r\n因为明天不来机房了，不知道还碰不碰得电脑，于是把 3.4\r\n的日记提前写上（\r\n2022.3.1\r\n今天阳历生日欸，虽然我不过就是了（\r\n青柠起始页的这个小细节suki\r\n\r\n今天信息课被拉来拉去（草）\r\n今天信息课和 wxm 看了好多东西，毕竟在学校呆了两周多了她啥都没看（\r\n2022.2.28\r\n学弟学妹机房氛围真™好。\r\n2022.2.26\r\n绊爱 HelloWorld2022 相关\r\n\r\n18：08 开始倒计时。\r\n18：11 开始。\r\n18：13 老爱入场（）\r\n\r\n我真的好想看视频，但是机房真的蛋疼。。\r\n只能先听声了/ll\r\n希望我能听懂一两句话吧，剩下的只能回家看了/ll\r\n最一开始好像是英文 Hello My World，开场主题曲挺好（\r\n平常英语没少听，这次派上用场了终于呜呜，能听懂居然（\r\n“米娜！”\r\n老爱还是傻笑啊ww，呜呜\r\n果然还是五岁小孩（x）\r\n声音变了好像是黑爱出来了（\r\n草为什么会自己暂停/fn\r\n现在纯靠我脑子想象呜呜。\r\n没事，能听着也好（\r\n她在笑啊，在笑啊，呜呜\r\n好高兴啊，但是……\r\n傻笑还是傻笑（）\r\n呜呜好好听吧（\r\n无意之间居然听了一个小时了（）\r\n可恶，zj 居然可以用手机看/fn\r\n\r\nAIAIAI！\r\n-19：12\r\n\r\n好多人都来了！\r\n都来给元老送别呐（）\r\nCEVIO AI!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\r\n这是今天晚上最好的消息！！！！！！！！！！！！！！！！！！\r\n之前看见民间有人做绊爱音库，现在有官方了呜呜\r\n另一种形式留下来了呐，这啥今天晚上最好的消息了！\r\n本来是要和 wxm\r\n一块看来着，但是发现学校条件不太允许，就我自己听了（\r\n她要是和我一块看，也会像是和我一样在机房直接喊出来一个“卧槽”吧应该（\r\n想买 CEVIO AI 了（\r\n\r\n草，我还以为结束了，刚才（\r\n--19：32\r\n\r\n呜呜，她哭了，她哭了，她哭了，她哭了……\r\n我也想哭啊……\r\n“哦嗨呦，哦嗨呦，Good Moring，Hello，Hello，Hello”\r\n我看见后面这么多人，真的想哭，真的……\r\n\r\n\r\n说实话还是不能相信为什么绊爱真的要暂时停止活动了呜呜……\r\n她还在笑，但是明显带着哭腔啊呜呜\r\n最后还是 AIAIAI 收尾，我真的哭了……\r\n呜呜啊啊呜呜……\r\n真的写不出来那种感觉，明明最后的 AIAIAI\r\n的钢琴伴奏是轻快的，但是我听得好伤感，真的真的真的……\r\n写不出来，写不出来……\r\n我真的好伤心，真的……\r\n\r\n草，居然有 HONDA 和日清，幻视 F1 和 pjsk（\r\n哭了。\r\n好像旁边要打 ABC，但是 Atcoder 炸了（\r\n八点，结束了，呜呜，呜呜……\r\n\r\n感谢绊爱，这些年的陪伴……\r\n感谢绊爱，每天早上的早安……\r\n希望总会有 First Live 到来……\r\n总会再见的，总会再见的……\r\n\r\n看完之后去操场跑了几圈，不知道为啥（\r\n单纯的有点伤心吧，毕竟……\r\n今天晚上天气晴朗，抬头能看到很多星星。\r\n真好，不是吗。\r\n我会等你回来，一定。\r\n2022.2.24\r\n今天好几次呐，好开心。\r\n\r\n上述内容和俄乌局势无关。\r\n希望战争早日结束，没有人喜欢战争。\r\n2022.2.23\r\n妈妈生日快乐！\r\n\r\n我服气了，我从我电脑上把系统安装到硬盘（这样的话会带着我电脑的驱动），然后去机房电脑升级内核，显示因为英伟达驱动版本过高不能合并所以不能更新版本。\r\n但是我从机房电脑安装的话倒是可以更新内核，但是插到我电脑上因为没有屏幕驱动不能亮屏……\r\n那我就从我电脑上安装然后去机房电脑单独安驱动，但是整完之后插回我电脑还是没有网卡驱动。\r\n服了。\r\n2022.2.22\r\n试图装 Manjaro，结果发现 RTL8825AE 的网卡驱动还是没有（\r\n发现已经合并到 5.16 了，但是 Manjaro 虽然写了有 5.16，但是还是默认\r\n5.15……\r\n2022.2.20\r\n学弟刚来就在机房看冬奥会了，很有精神。\r\n2022.2.7\r\n返校。\r\n2022.2.1\r\n新年快乐。\r\n2022.1.31\r\n除夕快乐。\r\n2022.1.22 - 2022.1.26\r\n因为这些天是 WC，所以主要写在游记里吧。\r\n\r\n如发奇想，有没有一种可能，心理咨询师，自己也有心理问题，为了挽救别人向自己坠落的方向而努力。（2022.1.25）\r\n2022.1.21\r\n延长了一晚上的假期，顺便把原神里的 4800\r\n原石抽掉了，歪了刻师傅，草。\r\n2022.1.20\r\n目前来说，初高中四年以来，最【无法描述】的一天，不恰当来说就是高开而低走（x）\r\nSecOne\r\n一切一切还要从前一天晚上开始，十九日十一点多，mfj 问曰：你明天去打\r\nmaimai 么。\r\n作为一个从未和同学出去玩过人，欣然同意（x）\r\n其实是好久之前 wxm 问要不要出去打 maimai来消费她上次和 mfj\r\n充的币，大约上次月考的之前一周的时候吧（\r\n但是显然就我这样学习成绩再加上刚停课回来的周末出去的可能性约为\r\n0 吧，于是就觉得元旦出去。\r\n然后元旦之前先是 mfj 发烧，然后我发烧， wxm\r\n声带出问题，然后就（（\r\n然而这次 51.5h 的假期包含一整天，确实是非常好的选择的吧。\r\n然后去问母，母问谁与同去，我曰 mfj\r\n，母曰不知其人也，但终了母曰之可。（虽然莫名就又一次引起来了关于她对我们班人名的询问？）\r\n因为下午要去社会实践，于是就顺便拉着这两位去。\r\n当然还有 tsy，他和 wxm 看电影去，于是最后打 maimai 的就剩下我和 mfj\r\n了（\r\nSecTwo\r\n早上五点半自己醒了……果然还是被学校的作息整怕了……然后回去睡到八点（\r\n起来之后进行一个饭的吃，然后一看手机发现一堆人找我，好久没看见这么多人找我了（）\r\n原来是 wsr\r\n的社会实践手册忘了拿，然后因为我离学校近就问我能不能去拿，然后因为我没回他就让\r\nwxm 问我，然后 wxm 找不到我就让 mfj 找我，还有 yx\r\n找我问下午的团员人数（？）\r\n然后就是出发去打 mai 之前去给 wsr\r\n拿了一趟（保安大爷居然也没问我干么去，难道是我没穿校服像是个老师，还是我天天通校认识我了，还是？）\r\n总之在约定的十点到了，因为我第一次打，所以经常找不到键，不过逐渐好起来了（\r\n旁边貌似有大佬，怒 FC 13+（\r\n然后我们大约玩到最后就发现玩不了我们事先预计的 30\r\n个币，就开始挥霍瞎搞，然后……\r\n然后我就莫名的往一个开 ce\r\n的机子里扔了四个……然后……然后……它居然在维修把我币吞了！\r\n然后最后去玩湾岸 5，拿老 NSX 刷着玩，快跑完的时候 wxm 带着 tsy\r\n来了，然后就进行一个吃饭。\r\n他们带着我去吃火锅，然后吃饭之前 wxm 带着我打了一次 pjsk\r\n的多人，虽然不知道有啥不同，但是我 pjsk 终于有好友了（（\r\n然后中间的时候上了个蛋饺， wxm\r\n问曰能否直接吃，然后我就莫名的拿起来吃了（？）\r\n然后路过的服务员哥哥看见我生吃非常惊恐，曰：哎！————————————\r\n然后就社死了，死在旁边的衣服里不敢抬头（（（\r\nSecThree\r\n下午就是一个社会实践，去的新华书店，然后我和 mfj 和 wxm\r\n在二楼，大约就是干一些引路人和擦东西的事情。\r\n然后偶遇一个翔 B（\r\n然后就快乐的站了两个小时没做下，然后活动结束后，就进行了【数据删除】的【数据删除】。\r\n晚上知道了成绩，和我的期望差距很大，除了数学级部 99\r\n还凑合，剩下的考的都是个么玩意。。\r\n比我刚停课回来还低……比一个周前的模拟掉了 300 名。。\r\n然后就很生气难过，反复观看乙女解剖。。。\r\n至于为什么是乙女解剖呐？\r\n哈哈。\r\n2022.1.19\r\n开启了长达 51.5h 的寒假。\r\n前段时间因为准备期末考试所以没让来机房，但是，我觉得我还不如停课。。\r\n复习了一周还不如一周之前考得好。。\r\n生气.jpg\r\n2022.1.8\r\n全天奥赛喜闻乐见。\r\n今天挺高兴的，因为树剖复健非常成功（\r\n唯一一次调的时间长了点是读题锅了（\r\n\r\n上次全天奥赛好像也在这写了一堆东西，大约每次大考前十天就会全天奥赛一次的样子么（\r\n已经对期末考试考多少分不抱希望了，状态不行。\r\n现在只希望着早点考完，上奥赛，放假，回家。\r\n\r\n除了早上被某些奇怪的东西吓醒，今天挺好的。\r\n\r\n\r\n\r\n2022.1.7\r\n发现了，增强新鲜感能显著增强的我的学习兴趣。\r\n今天把 Fira Code 换成了 JetBrains Mono，于是兴趣巨大提升。\r\n所以什么时候 whk 也能给我提升学习兴趣的东西？\r\n比如突然给我毕老师的脑子\r\n\r\n明天早上要在宿舍打扫卫生，然而我今天晚上回家，所以就能多睡一个小时，这样好（\r\n\r\n今天下午来的时候发现 WTG 炸了，试图修了一下发现不行，危（\r\n不过现在用的比较少了先不修了吧（（\r\n\r\n发现机房网好快，于是就将买了好久没玩的战地 5 下到硬盘里（\r\n峰值速度 32Mb/s+，害怕，害怕，平均速度 26Mb/s，害怕，害怕。\r\n二十分钟过去下载 50%，害怕，害怕（\r\n\r\n\r\n害怕，害怕\r\n\r\n2022.1.6\r\n前几天吃药吃的总是困。。\r\n2022.1.1\r\n新年，好（\r\n放一下空间发的什么鬼玩意吧。\r\n\r\n\r\n\r\n2021\r\n2021.12.31\r\n很 好 的 一 天 呢。\r\n\r\n\r\n\r\n2021.12.26 - 30\r\n在帮忙忙活元旦活动。\r\n2021.12.25\r\n和 wxm、mfj 在上午大课间进行了一个尝试安装\r\npgr，但是发现需要有密码才能安装，试图猜了一下 Hitevision 不对（\r\n于是就没装上，中午下课之后试图搜了一下没搜到（\r\n下午寻思是不是要搞个虚拟机或者模拟器什么的，然后，wxm 过来说好像要 32\r\n33 一起搞于是就大概去报告厅，所以就不能在大家面前擦黑板了玩 pgr\r\n了\r\n\r\n下午下课之后和 mfj\r\n去心灵港湾玩，第一次去，那里有个画板，上面好多画的样子（\r\n看到很多很好的元素，比如，居然，LCEZ\r\n有这么多车万人，好多同学的画工真滴好，那个胡桃，warma （居然）还有 fufu\r\n……\r\n好多人玩原神啊，好多的原神相关（\r\n气抖冷，日 v 什么时候能站起来（不是说 vtb\r\n看到了关注嘉然，顿顿解馋（（\r\n看到了石之海（\r\n车万相关居然能占据整个版面的 1/5 是我没想到的（\r\n然后原神大约又占了 1/5 的样子（\r\n其余的就是很多杂杂的东西（\r\n我拿笔写了个“卓爹 yyds”、“翔B yyds”和“我已经完全爱上 warma\r\n啦”就溜了（\r\n本来想写个“我是 ___ 的狗”（然后 mfj 还说要写个\r\nx2，（笑）），但是好像写全名不太好就没写（\r\n话说本来想更新里记来着，但是旁边人好多人好多人好多（\r\n2021.12.24\r\n下雪了，真·雪降り、メリクリ\r\n有点冷，但是你卓爹还是穿短袖（\r\nwxm 说要元旦的时候在教室尝试让我们在大屏上搓\r\npgr，于是今天拿了个安装包（（\r\n2021.12.23\r\nrnm，月考没了！\r\n2021.12.19\r\n上午进行一些活动，下午他们在给新实验班出 NB 题。\r\n2021.12.18\r\n据说幻塔隐私政策很垃圾，所以昨天决定的东西干掉了。\r\n2021.12.17\r\n好像有个什么东西是幻塔来着，好像能捏人，捏个同学进去（x（？\r\n2021.12.12\r\n首先恭喜 MAX，然后就是 Fia 确实智障。\r\n\r\nLAPPED CARS WILL NOT BE ALLOWED TO OVERTAKE.\r\nLAPPED CARS 4 (Norris) - 14 - 31 - 16 - 5 TO OVERTAKE SAFETY CAR.\r\n2021.12.11\r\n之前的以后再说，今天的想到啥写啥。\r\n突然想寒假的时候手画一下头像（？\r\n突然想把一些东西做成皮扔到地平线 4 里开着车玩（\r\n今天 ceh 的《Noi Linux To\r\nGo》因为硬盘炸了好多次，从六点到十点已经重启了 10 次了快？\r\n\r\n真的是离谱坏了，写题的话每隔 30 min\r\n炸一次差不多，但是只要他不写代码就没事（\r\n下午就回去 whk 了，班主任过来发的一堆卷子让我深感危险（\r\n话说真的发现自己在机房的状态比在教室好多了，昨天居然中午听见了吹哨，起来还贼早。\r\n莫名，莫名。\r\n","slug":"HDSBN","date":"2021-12-10T13:47:04.000Z","categories_index":"About Me","tags_index":"Me","author_index":"Heriko Deltana"},{"id":"376aa5f89f90dd8bb634896a55dc7c51","title":"引越しできるかな？","content":"「藉以此篇，纪念刚学 OI 的我。」\r\n\r\n\r\n当我今天看我未 AC\r\n的题面时，看到了这道题，想起我当时的样子，看到这个题没有人做，题面还有锅，于是决定提供翻译，以及修复样例，来纪念十一个月前啥都不会的我。\r\n引越しできるかな？\r\n你 会 搬 家 吗？\r\n原题链接。\r\n题目翻译\r\n现在有 \r\n件长方体物品，给出其长，宽，高，求能够单独放得下每个物体所需最小的长方体盒子的体积。\r\n物品不会倾斜放置。\r\n输入格式\r\n输入共  行，第一行为一个整数\r\n\r\n第二行到第  行，每行三个整数\r\n 表示第  个物体的长宽高。\r\n输出格式\r\n一行一个整数表示所需的最小长方体盒子的体积。\r\n输入输出样例\r\n输入#1\r\n123210 20 3020 20 20\r\n输出#1\r\n112000\r\n输入#2\r\n1234310 20 3020 20 2030 20 10\r\n输出#2\r\n112000\r\n输入#3\r\n12345410 20 3020 20 2030 20 1010 40 10\r\n输出#3\r\n116000\r\n输入#4\r\n123210 10 1011 1 1\r\n输出#4\r\n11100\r\n数据范围\r\n对于  的数据，满足 \r\n对于  的数据，满足 \r\n思路简述\r\n题面意思很明了，所以直接说做法。\r\n因为我们只需要保证能有一种姿势能放进去就行，所以每次读入的时候按照大小顺序去更新盒子的三维即可。\r\nCode\r\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define Heriko return#define Deltana 0#define Romanno 1#define S signed#define LL long long#define R register#define I inline#define CI const int#define mkp(a,b) make_pair(a,b)#define mst(a,b) memset(a,b,sizeof(a))#define ON std::ios::sync_with_stdio(false);cin.tie(0)#define Files() freopen(\"RNMTQ.in\",\"r\",stdin);freopen(\"RNMTQ.out\",\"w\",stdout)using namespace std;template&lt;typename J&gt;I void fr(J &amp;x){    short f(1);    x=0;    char c(getchar());    while(c&lt;'0' or c&gt;'9')    {        if(c=='-')            f=-1;                c=getchar();    }    while(c&gt;='0' and c&lt;='9')     {        x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^=48);        c=getchar();    }       x*=f;}template&lt;typename J&gt;I void fw(J x,bool k){    if(x&lt;0)        x=-x,putchar('-');    static short stak[35];    short top(0);    do    {        stak[top++]=x%10;        x/=10;    }    while(x);    while(top)        putchar(stak[--top]+'0');    k?puts(\"\"):putchar(' ');}template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y){    Heriko x&gt;y?x:y;}CI MXX(101);int n,ans[3],tmp[3];S main(){    Files();    fr(n);    for(int i(1);i&lt;=n;++i)    {        fr(tmp[0]),fr(tmp[1]),fr(tmp[2]);        sort(tmp,tmp+3);        sort(ans,ans+3);        ans[0]=Hmax(ans[0],tmp[0]);        ans[1]=Hmax(ans[1],tmp[1]);        ans[2]=Hmax(ans[2],tmp[2]);    }    fw(ans[0]*ans[1]*ans[2],1);    Heriko Deltana;}\r\n","slug":"引越しできるかな？","date":"2021-12-10T12:48:44.000Z","categories_index":"OI-Solutions","tags_index":"OI","author_index":"Heriko Deltana"},{"id":"3d668452451a2324e814f841a29e20c0","title":"Dilworth","content":"「Dilworth 定理浅谈。」\r\n\r\n\r\n主要参考：浅谈Dilworth定理\r\n- cmwqf。\r\n「启」\r\n想起来这个定理，是因为我在古远的时候（大约今年 \r\n月？）遇到了但是没有进一步了解，今天突然又看到导弹拦截这道题，于是就想把它进一步里了解一下。\r\n「定理内容」\r\n偏序集上最小链划分中链的数量等于其反链长度的最大值。\r\n一看，偏序集，最小链划分，反链，都不会（\r\n于是下面开始逐一理解 看 定 义（\r\n「偏序集」\r\n定义一种比较关系使得两种元素进行比较，比如我们定义  当且仅当  且 \r\n显然  和  都满足 \r\n的时候她们两个是可比的，否则若有一个不满足，我们则称这两个元素不可比。\r\n那么偏序集 \r\n就定义为满足以下性质的允许存在不可比元素的集合：\r\n\r\n自反性：\r\n对称性：\r\n传递性：\r\n\r\n「链划分」\r\n若我们把满足 \r\n的  之间建立一条  的边，那么显然的是偏序集是一张\r\nDAG.\r\n把 \r\n中的元素划分为若干条链，使得每个元素都在且仅在唯一的一条链中，叫做链划分。\r\n「反链」\r\n链是 DAG\r\n上的某条路径上的元素，而反链和链的定义恰好相反，对于一个集合，它是反链当且仅当这个集合里的元素两两都是不可比的，即这个集合中的元素两两不连通。\r\n也就是说，我们将一个偏序集 \r\n划分为若干个小集合，使得每个小集合里的元素构成一条链，这个最小的划分数量，等于这个偏序集最长的反链的长度。\r\n然后就能利用这个来做一些看起来很难的题。\r\n\r\n以下摘自我的杂题记录。\r\n\r\n「例题」\r\n\r\n洛谷 | P3974\r\n组合数学 [TJOI2015] \r\n\r\n\r\n好喵一题。\r\n\r\n其实做这道题只是在看自己之前的博客的时候想起来之前有个 Dilworth\r\n定理，然后就随着一个博客（浅谈Dilworth定理\r\n- cmwqf）学习的时候，找到了这道题。\r\n众所周知题目名字里有啥，这道题就不用啥做，所以这道题用不到组合数学（\r\n我们把这道题中的每个点 \r\n拆成 \r\n个点，然后把能够到达的点之间连边，最后变成了一个\r\nDAG，题目所求就是求这个图的最小链的划分，根据 Dilworth 定理，这个 DAG\r\n的最小链划分就等于它的最长反链的长度。\r\n按照我们建图的操作来说的话，这个反链就是说的最长的不能到达的链，也就是说要求每个点的右上和左下矩阵中点权值的最大值，于是直接\r\nDP 即可。\r\n123456for(int i(1);i&lt;=n;++i)    for(int j(m);j;--j)    {        f[i][j]=f[i-1][j+1]+a[i][j];        f[i][j]=Hmax(Hmax(f[i][j],f[i-1][j]),f[i][j+1]);    }\r\n答案即为 f[n][1].\r\n","slug":"Dilworth","date":"2021-12-10T02:12:37.000Z","categories_index":"OI-Theorem","tags_index":"OI","author_index":"Heriko Deltana"},{"id":"d75e4c24ba3f0efb09e1f555951fc7eb","title":"线性基","content":"「线性基简记。」\r\n\r\n\r\n主要参考了 Menci\r\n的线性基学习笔记。\r\n「前置知识」\r\n一些线性基能用到的。\r\n\r\n下文中若未特殊说明，集合均为「无符号整数集」。\r\n\r\n「异或和」\r\n对于集合 ，将其中所有元素异或起来的结果。\r\n「张成」\r\n对于集合 \r\n的所有子集的异或和组成的集合成为 \r\n的张成，记作 \r\n换句话说就是在 \r\n中选出任意多个数，其异或和的所有可能的结果组成的集合。\r\n「线性相关」\r\n对于一个集合 ，如果存在一个元素\r\n，使得， 在去除这个元素后得到的集合  的张成  中包含 ，即，，则称集合 \r\n线性相关。\r\n换句话说就是  中存在一个元素\r\n 可以被  中的其他的若干个元素异或得到。\r\n如果不存在这样的 ，就说  线性无关。\r\n一个显然的结论是对于一个线性相关的集合 ，去掉符合条件的  之后， 不变。\r\n「线性基」\r\n称集合  为集合  的线性基，当且仅当：\r\n\r\n\r\n 线性无关。\r\n\r\n\r\n中的元素个数，称为线性基的长度。\r\n线性基有以下的性质：\r\n\r\n\r\n是极小的满足线性基性质的集合，它的任何真子集都不可能是线性基；\r\n\r\n中的任意元素都可以唯一表示为 \r\n中若干个元素异或起来的结果；\r\n线性基里任意一个子集的异或和都不为\r\n\r\n「模板」\r\n下面是模板。\r\n「构造」\r\n1234567891011121314151617I void Insert(int x){    for(int i(62);i&gt;=0;--i)    {        if(x&amp;(1&lt;&lt;i))        {            if(!p[i])            {                p[i]=x;                                Heriko;            }            else                x^=p[i];        }    }}\r\n「查询元素是否存在」\r\n因为“\r\n中的任意元素都可以唯一表示为 \r\n中若干个元素异或起来的结果”，所以如果一个数在不断异或的过程中，能变成\r\n，那就存在于集合中。\r\n12345678I bool Query(int x){    for(int i(62);i&gt;=0;--i)        if(x&amp;(1&lt;&lt;i))            x^=p[i];    Heriko !x;}\r\n「查询异或最大值」\r\n贪心即可。\r\n12345678910I int XorMax(int x){    int res(0);    for(int i(62);i&gt;=0;--i)        if((res^p[i])&gt;res)            res^=p[i];    Heriko res;}\r\n「查询异或最小值」\r\n贪心即可，但是要特判 ，即存在\r\n 的时候最小值为 \r\n123456789I int XorMin(int x){    if(HaveZero)        Heriko Deltana;    for(int i(62);i&gt;=0;--i)        if(p[i])            Heriko p[i];}\r\n暂且就先这些，还有一个查询第 \r\n大异或值的操作，因为我还没用过所以就先不写。\r\n","slug":"Linear-basis","date":"2021-12-09T12:40:28.000Z","categories_index":"OI-Algorithm","tags_index":"OI","author_index":"Heriko Deltana"},{"id":"6ac8d06e86d3b00b34b7941b81c073c9","title":"Note18 : 杂题二","content":"「第二堆持续更新的杂题」\r\n\r\n\r\n\r\n第一堆是我从\r\n2021.4.12 开始的做题记录的前 200 道，这里的第二堆则是 201 以后的（\r\n这里的题目是按照我做的时间顺序排放的，是从博客园搬来的，之所以叫做\r\nNote18 也是因为之前在博客园的编号是 18.\r\n\r\n201 | P4643 阿狸和桃子的游戏\r\n[国家集训队]\r\n洛谷 | P4643\r\n阿狸和桃子的游戏 [国家集训队]\r\n\r\n时隔 114514 年的更新。\r\n考虑将边权转化到点上，无论是阿狸还是桃子同时取到两点，他们都可以获得\r\n\r\n的权值；若是分取两端点，则最终答案可抵消为  或者 \r\n然后排序即可，因为没保证输入的权值是偶数，所以先×2最后再除掉。\r\n202 | P2863 The Cow Prom S\r\n洛谷 | P2863 The Cow\r\nProm S \r\n又是时隔 114514 年的更新。\r\n一道比较板子的 Tarjan 求 SCC 个数，直接写一个 Tarjan 即可。\r\n203 | CF915E Physical\r\nEducation Lessons\r\n洛谷\r\nRemoteJudge \r\nCodeForce\r\n原题\r\n观察完这道就发现是一道 DS，而且还挺水的好像（\r\n看到只有区间赋值的操作，所以就考虑用珂朵莉树来解决。很简单的乆切掉了（\r\n最一开始单独统计答案，但是这样显然是会被卡掉的，所以后来改成在  的时候乆把答案修改掉。\r\n复杂度是 \r\n的样子o(=•ェ•=)m\r\n204 | P6792 区间和 [SNOI2020]\r\n洛谷 | P6792\r\n[SNOI2020] 区间和 \r\n\r\n年轻人的第一道黑题。\r\n\r\n虽然是黑题但是数据水了，所以最终的难度并没有那么高，一个暴力修改的线段树\r\n+ 前缀和后缀和来维护最大字段和的 trick 就解决掉了（\r\n因为我也是第一次写这个 trick 所以在这里简单记录一下。\r\n对于每个结点我们要维护：区间和，区间最大前缀和，区间最大后缀和，区间最大子段和，那么在转移的时候，需要写出以下的\r\nPushup：\r\n123456789I void Pushup(int x){    t[x].sm=t[lc(x)].sm+t[rc(x)].sm;    t[x].mx=Hmax(t[lc(x)].mx,t[rc(x)].mx);    t[x].mi=Hmin(t[lc(x)].mi,t[rc(x)].mi);    t[x].psm=Hmax(t[lc(x)].psm,t[lc(x)].sm+t[rc(x)].psm);    t[x].usm=Hmax(t[rc(x)].usm,t[lc(x)].usm+t[rc(x)].sm);    t[x].sbmx=Hmax(Hmax(t[lc(x)].sbmx,t[rc(x)].sbmx),t[lc(x)].usm+t[rc(x)].psm);}\r\n然后就是正常的操作，中间有一次 WA 是因为 Query 忘了写\r\nPushdown.\r\n\r\n注明：我过了这道题之后，这道题就被加了 Hack\r\n数据，现在我这个做法已经过不了了，正解大约是势能线段树啥的\r\n\r\n205 | P4301 新Nim游戏 [CQOI2013]\r\n洛谷 | P4301\r\n新Nim游戏 [CQOI2013] \r\n\r\n显然我做这道题的原因不是因为初中班号是 4301.\r\n\r\n如果不让对方赢，就不能让对方在自己选完后剩下的数中选出 xor 和为 0\r\n的，也就是不能让线性基被插满或者存在不能插入的值（因为线性基内的数不能异或出来\r\n0），所以我们在将数插入线性基的时候，不能插入的直接加到答案里。\r\n206 | 鉄道旅行 [JOI 2015]\r\nATCoder |\r\nA - 鉄道旅行 (Railroad Trip)\r\n\r\n说起来，这题是在 rui_er 的珂朵莉树题单里来着（\r\n\r\n然而当我看这道题的想法从“看起来像是树”变成“其实是个序列”的时候，我就不知道怎么往珂朵莉树上想了，因为……差分\r\n+ 贪心还挺显然的（\r\n考虑到路线固定，所以我们只需要知道一条道路要经过几次即可，然后对于每条边，要不然全买原价，要不然买一张\r\nIC 卡再用 IC 卡，所以我们每次比较哪个更优就可以了，设当前边被用了\r\nco 次，每次累加答案的时候整一个\r\nans+=max(a*co,b*co+c) 就行了。\r\n之所以没放洛谷链接是因为这个题面确实没法看，也没有数据范围，还不如我直接看原题面。\r\n207 | P3974 组合数学 [TJOI2015]\r\n洛谷 | P3974\r\n组合数学 [TJOI2015] \r\n\r\n好喵一题。\r\n\r\n其实做这道题只是在看自己之前的博客的时候想起来之前有个 Dilworth\r\n定理，然后就随着一个博客（浅谈Dilworth定理\r\n- cmwqf）学习的时候，找到了这道题。\r\n众所周知题目名字里有啥，这道题就不用啥做，所以这道题用不到组合数学（\r\n我们把这道题中的每个点 \r\n拆成 \r\n个点，然后把能够到达的点之间连边，最后变成了一个\r\nDAG，题目所求就是求这个图的最小链的划分，根据 Dilworth 定理，这个 DAG\r\n的最小链划分就等于它的最长反链的长度。\r\n按照我们建图的操作来说的话，这个反链就是说的最长的不能到达的链，也就是说要求每个点的右上和左下矩阵中点权值的最大值，于是直接\r\nDP 即可。\r\n123456for(int i(1);i&lt;=n;++i)    for(int j(m);j;--j)    {        f[i][j]=f[i-1][j+1]+a[i][j];        f[i][j]=Hmax(Hmax(f[i][j],f[i-1][j]),f[i][j+1]);    }\r\n答案即为 f[n][1].\r\n208 | CF1603B Flog Traveler\r\n洛谷\r\nRemoteJudge\r\nFrog\r\nTraveler\r\n虽然但是，这题有一点恶心人，不能一遍写对就很烦。\r\n看完题之后，有三个想法：BFS（最短路），DP，瞎搞。\r\n首先排除瞎搞（\r\n然后考虑 DP，然后考虑了半天没考虑出来，感觉 DP\r\n不太能做的样子。于是就考虑建图跑最短路，但是想了想建出来的图可能有亿点大，于是需要寻求更好的建图方法（\r\n然后就去看了线段树建图（\r\n209 | 引越しできるかな？\r\n题解以及翻译\r\n210 | P4302 字符串折叠\r\n[SCOI2003]\r\n洛谷 | P4302\r\n字符串折叠 [SCOI2003] \r\n考虑设计一个二维状态  表示\r\n 能缩成的最短的长度，显然当\r\n 的时候 ，然后再考虑其他的状态。\r\n对于一个区间 ，要不然是由一个字符串反复出现组成的，要不然就能拆成能压缩的几个部分，于是我们只需要考虑如何把这个区间中的字串找出来即可，因为这道题的\r\n，所以可以直接枚举区间长度的约数，这样的话，整体的复杂度就是\r\n\r\n210B | UVA1630 Folding\r\n洛谷\r\nRemoteJudge  原题\r\n虽然这两道题就差一个输出不一样但是评级不一样（\r\n既然要输出方案，了解到一个神秘操作叫做\r\nstringstream，可以直接把各种奇怪的类型转化为\r\nstring，比如说这个题：\r\n1234int val(len/(i-l+1));stringstream tmp;string tms;tmp&lt;&lt;val,tmp&gt;&gt;tms;\r\n有一点方便的感。\r\n（把上面的全划掉）\r\n然而，我重写的 stringstream 错了，而且贼慢，所以就把\r\nP4302 的代码复制过来，改成了记录倍数的转折点递归输出（\r\n211 | P4342 Polygon [IOI1998]\r\n洛谷 | P4342 Polygon\r\n[IOI1998] \r\n\r\n只能说是洛谷我谢谢你，这个输入数据太不纯净了点……\r\n\r\n首先考虑断环为链，然后就变成了区间 DP，设  为  上最大的结果。\r\n那么在没有负数的情况下，转移就是这样的：\r\n\r\n但是这道题有负数，所以可能会存在负负得正的优美情况，所以我们还需要维护一个最小值\r\n，然后加法的转移不变，乘法的转移变为：\r\n\r\n然后这题就结束了（\r\n212 | CF149D Coloring Brackets\r\n洛谷\r\nRemoteJudge \r\nColoring\r\nBrackets\r\n先考虑最朴实的没有颜色的情况，我们用匹配的括号序列之间转移即可，即设状态为\r\n\r\n即可，但是这道题需要我们保证染色，所以我们需要考虑新的合并方式。\r\n记录每个匹配括号的左端和右端颜色在状态里，即 \r\n首先考虑当 \r\n是一个匹配串的时候的转移，显然需要枚举所有的颜色情况，并从 \r\n转移过来，当然，为了满足题目的要求，转移相加的时候是有颜色限制的，如果相邻的括号相同那就需要跳过这个状态。\r\n否则，我们 \r\n不匹配的时候可以从  和\r\n\r\n这两个匹配的序列转移过来，当然，前提是  和  这两个位置的颜色不能相同。\r\n转移的话就是 \r\n加上这两段相乘。\r\n因为我们要从小的往大里转移，所以方便起见使用 DFS 转移。\r\n213 | CF1617A Forbidden\r\nSubsequence\r\n洛谷\r\nRemoteJudge\r\nForbidden\r\nSubsequence\r\n考完月考不知道干嘛，于是做个没啥用的智障题。\r\n先排序然后遇到小串为 abc 的时候特判，先输出\r\nc 再输出所有 b.\r\n214 | CF1617B GCD Problem\r\n洛谷\r\nRemoteJudge\r\nGCD\r\nProblem\r\n来到机房不知道做啥，于是做个没啥用的智障题。\r\n先对这个要求的形式进行一个转化：\r\n于是我们枚举 \r\n的因数，也就是这个 ，然后再枚举\r\n 和  即可。\r\n215 | CF1617C Paprika and\r\nPermutation\r\n洛谷\r\nRemoteJudge\r\nPaprika\r\nand Permutation\r\n做完上一个之后不知道做啥，于是继续做个没啥用的智障题。\r\n首先，题目要求将整个序列转化为一个  到  的排列，所以我们把已经符合条件的  扔掉不用管。\r\n然后将剩下的排序，按照大小顺序去一个一个判断能不能往排列里面填，判断的依据是：对于一个数\r\n，它在本题所述的变换中，只能变为自己本身或\r\n 的数，于是 \r\n越小，能变成的数的范围也就越小，所以我们贪心让小的数先去填补排列。\r\n于是我们每次判断是否  即可。如果不行的话就说明不存在解，输出 ，否则累加答案。\r\n216 | P4766 Outer space\r\ninvaders [CERC2014]\r\n洛谷 | P4766 Outer\r\nspace invaders \r\n莫名的感觉这个题实际上配不上紫题（\r\n考虑我们如果要消灭时间  时的\r\nInvaders，就要让打击功率为最远的 Invader 的距离。\r\n设  为清除存在时间在  之间的 Invaders\r\n所需要的最小功率。\r\n假设区间  中距离最远的\r\nInvader 的时间点为 ，则我们在清除它的时候就可以一起把时间点为\r\n 的 Invader\r\n一起消灭，然后我们这个区间剩下的就是 ，于是我们在转移的时候枚举这个  即可，即 ，其中  是距离最远的 Invader 的编号。\r\n217 | P2470 压缩 [SCOI2007]\r\n洛谷 | P2470 压缩\r\n[SCOI2007] \r\n\r\n紫 40 AC 祭\r\n\r\n我们考虑一个区间  里面有 M\r\n的情况是  没有则为 \r\n当区间里没有 M 的时候，如果可以从中间折叠，那么就更新 ，即 \r\n然后正常的转移就是枚举断点更新：\r\n12f[l][r][0]=Hmin(f[l][r][0],f[l][i][0]+r-i);f[l][r][1]=Hmin(f[l][r][1],Hmin(f[l][i][0],f[l][i][1])+Hmin(f[i+1][r][0],f[i+1][r][1])+1);\r\n懒了不想打公式\r\n218 | P1043 数字游戏\r\n[NOIP2003PJ]\r\n洛谷 | P1043\r\n数字游戏 [NOIP2003PJ] \r\n2022 第一题（笑\r\n 表示  分成  段的最大值， 为同意义下的最小值。\r\n处理一个前缀和然后暴力枚举分段即可。\r\n219 | CF1615B And It's Non-Zero\r\n洛谷\r\nRemoteJudge\r\nAnd It's\r\nNon-Zero\r\n因为如果让某一二进制位为 ，那么就需要每个参与运算的数字二进制下这一位为\r\n，所以处理出来有多少数有 ，那么剩下的就是要去掉的。\r\n220 | P6247 最近最远点对\r\n[SDOI2012]\r\n洛谷 | P6247\r\n最近最远点对 [SDOI2012] \r\n不明白，为什么我的 KDT 会 T，摆烂交了个贪心。\r\n贪心就是了，排序之后选一定长度的点，这题最小 13 就够。\r\n221 | CF1615C Menorah\r\n洛谷\r\nRemoteJudge\r\nMenorah\r\n一共是四种状态 \r\n于是我们的目标是 \r\n化简一下：\r\nf(x,0) -&gt; f(x,1) -&gt;\r\nf(x,0)，也就是说，奇数次操作会让不同状态变为相同状态，偶数次则为变回来。\r\n反之亦然，奇数同变不同，偶数不同变同。\r\n而显然我们只能 \r\n这样的进行操作，于是奇数次的操作之后相当于所有的不同变成同，反之亦然。\r\n因为每次对  操作的时候会让\r\n，并让 ，所以只有  和  的时候可以去更新答案为\r\n，其实就是从奇偶考虑。\r\n如果最后答案大于 \r\n显然不行，否则输出答案。\r\n222 | P3038 Grass Planting G\r\n[USACO11DEC]\r\n洛谷 | P3038 Grass\r\nPlanting G [USACO11DEC] \r\n树剖复健成功，基本一次成功大约，没有遇到什么问题：）\r\n223 | P2486 染色 [SDOI2011]\r\n洛谷 | P2486 染色\r\n[SDOI2011] \r\n不得不说虽然长是长了点，树剖还是好玩的，对于我这种没有脑子的人来说，不用想就能打的东西太好了。\r\n其实就是普通的树剖，然后我们在线段树内记录每个区间的左端颜色和右端颜色，在合并的时候注意一下，如果一样就让\r\nvalve-1 就行。\r\n224 | P1505 旅游 [国家集训队]\r\n洛谷 | P1505 旅游\r\n[国家集训队] \r\n我在上个题的时候曾经说过：\r\n\r\n不得不说虽然长是长了点，树剖还是好玩的，对于我这种没有脑子的人来说，不用想就能打的东西太好了。\r\n\r\n确实，于是这个题的代码长度就成为了我目前为止通过代码中最长的，415\r\n行，7Kb。（当然，和我码风有空行有关系）\r\n\r\n\r\n\r\n树剖部分基本是一遍写对的，最后错了半天是因为题目说的边的编号要是\r\n，但是我读入的时候忘了\r\n+1，害的我把前面的重新看了一遍。。\r\n但是还好这是 7Kb 的树剖而不是其它别的什么鬼东西。\r\n225 | P3178 树上操作 [HAOI2015]\r\n洛谷 | P3178\r\n树上操作 [HAOI2015] \r\n开这个题的时候没想到因为期末考试复习一周多没去机房。。\r\n假期的时候因为期末考试成绩的事情生气，所以就把这个题写完了，然后在家没调，早上来学校发现是线段树\r\nBuild 时给结点赋值错了，然后改完就对了。\r\n226 | P6772 美食家 [NOI2020]\r\n洛谷 | P6772 美食家\r\n[NOI2020] \r\n\r\n一份，长达，一年零五个月的代码。\r\n\r\n大约在好久之前立了个 Flag：\r\n\r\n大约是元旦之前就 99\r\n粉了，当时就感到一丝危机，因为美食家这个题给我留下的阴影还是挺大的（\r\n当时咋想的咱也不知道，总之就是一个奇怪的思路骗过了样例（？\r\n当然当时的我就莫名的感觉到这个题复杂度的奇怪，那么，确实是挺奇怪的：\r\n当时我看到正解复杂度是这个玩意就觉得很淦，这东西不像是我能分析的出来的东西。\r\n于是试着想些什么，首先这个题不像是图论之类，所以向着 DP\r\n的方向考虑，考虑到数据范围，最后可能是个二维 DP 状态之类的（\r\n那么就能设  表示第  天在编号为  的城市，然后用枚举出边来更新，即  更新 \r\n然后这样大约就能有 ，复杂度大约是 ，但是想不出来什么更厉害的状态了……\r\n所以可以优化么？好像可以，但是我只会矩阵，但是一般的矩阵都是加和且为逐项转移（如\r\n 转移到 \r\n这样）的，这个首先是取最大值，而且每次转移需要距离都为 \r\n后者还比较好解决，因为 ，所以拆点即可，前者的话……改变矩阵相乘的时候的合并方式（？\r\n于是我就拉了，遂观 duyi 佬之题解，原来如此。\r\n本来矩阵乘法的柿子为：\r\n\r\n因为我们这里需要取最大值，考虑到转移方式，于是我们可以重新定义一种“类矩阵乘法”：\r\n\r\n语言描述就是把原来的相乘求和改为了相加取最大值。\r\n因为矩阵快速幂优化 DP\r\n主要是用到了矩阵的结合律，而在这里重新定义的“类矩阵乘法”仍然符合矩阵结合律。\r\n为了下面描述方便，把这种运算简记为 （莫名找到的小符号\r\n\\dagger，即匕首，短剑）。\r\n当 ，即没有美食节的时候，直接将一个点拆为 \r\n个点即可，也就是在相邻编号之间的点之间加入边权为 \r\n的边，然后把拆出来的最后一个点和第一个点建一条原本点权值的边，设转移矩阵为\r\n，那么转移方程就是 ，答案即为 ，时间复杂度为 \r\n再考虑 \r\n的时候，因为题目数据保证了美食节分布在不同天，所以我们可以先排序，考虑其单独贡献，即在两个美食节之间单独进行转移，即为：，转化到刚才的 DP\r\n状态上，即，设本次时间为 ，那么上次的时间即为 ，那么每个美食节的贡献就是 ，最后再让  加上  就计算出了贡献。\r\n最后若转移到的时间不为 ，再转移一次即可。若最后拆完后的第一个结点的权值仍为\r\n，那么就说明无解。\r\n现在的复杂度是 \r\n我们再把 \r\n预处理出来，就能把复杂度降到 \r\n顺便，这次代码的 return 0，叫做\r\nHerikoDeltana_LG100FansAnniv.\r\n最后的 Anniv\r\n是周年纪念的意思，因为明天就是来高中部一周年了，今天新实验班学弟学妹都来了（\r\n嗯，没错，有学妹。\r\n227 | P4069 游戏 [SDOI2016]\r\n洛谷 | P4069 游戏\r\n[SDOI2016] \r\n调题历程。\r\n这道题从昨天晚上 6:28 开题到现在 10:36 AC 耗时大约\r\n7h，我是真的服了啊（\r\n这个题中说到每次对于树上点权值修改的是一个和距离相关的一次函数，于是我们可以树剖然后把这些修改通过每次找\r\nLCA 用李超线段树来维护，即插入线段（\r\n挺简单的对吧，但是这么长时间没过去。\r\n228 | CF932F Escape Through\r\nLeaf\r\n洛谷RemoteJudge\r\n\r\nCodeForces\r\n932F Escape Through Leaf\r\n\r\n真正意义上的第一道正解黑题，不过也有可能是评高了，CF 上 2700\r\n我也不知道什么水平，反正比我水平高就是了（\r\n\r\n题目就令人很莫名不是么，很容易想到 DP：\r\n\r\n但是这是个  的\r\nDP，于是我们考虑优化（\r\n这个形式，多是个一次函数啊（呆\r\n所以我们考虑把后面这些东西当作直线用李超线段树来维护，只不过需要还一些合并（\r\n时间复杂度是 ，但是好像不合并，用树剖也能  的做？没去试（懒\r\n229 | P4556\r\n[Vani有约会] 雨天的尾巴 /【模板】线段树合并\r\n洛谷 | P4556\r\n[Vani有约会] 雨天的尾巴 /【模板】线段树合并\r\n\r\n我们需要对每个结点维护一个权值线段树，因为是一棵树，所以我们考虑把修改操作用树上差分来实现，因为可能值域重合，所以我们进行线段树合并（\r\n230 | P4254 Blue Mary开公司\r\n[JSOI2008]\r\n洛谷 | P4254 Blue\r\nMary开公司 [JSOI2008] \r\n哇，李超线段树板子（\r\n这个比板子还板子的李超线段树什么都不需要，只需要支持把直线插进去，然后查询最大值即可。\r\n最一开始不知道什么地方写挂了，最后发现它最一开始给的是斜率和  的取值（\r\n顺便吐槽一下这个样例，给了和没给没啥区别（\r\n231 | P4655 Building Bridges\r\n[CEOI2017]\r\n洛谷 | P4655\r\nBuilding Bridges [CEOI2017]\r\n\r\n哇，又是李超线段树（\r\n首先有柿子（这里  是原题中\r\n 的前缀和）：\r\n\r\n设 ，则有：\r\n\r\n于是我们只需要在转移的时候找到  取最大值的对应  即可，也就是把  当作直线用李超线段树来维护。\r\n232 | CF1615E Purple Crayon\r\n洛谷\r\nRemoteJudge\r\nCF1615E\r\nPurple Crayon\r\n最聪明的情况下，A 只会选叶子结点，剖出来链之后按照提议操作。\r\n233 | P2680 运输计划\r\n[NOIP2015TG]\r\n洛谷 | P2680\r\n运输计划 [NOIP2015TG] \r\n树上差分 + LCA + 二分\r\nFuture Search Technology.\r\n234 | P8110 矩阵 [Cnoi2021]\r\n洛谷 | P8110 矩阵\r\n[Cnoi2021] \r\n碰见的题，拿来做做（\r\n对于前三个部分分，直接暴力矩阵快速幂即可。对于全部数据的 ，显然二维数组是开不下了，于是考虑优化，可以按照  的取值来分类：\r\n\r\n 时，直接输出 \r\n 时，输出  的元素和，即 \r\n否则，由题意应输出 \r\n的元素和，即 \r\n\r\n234 | P2325 王室联邦 [SCOI2005]\r\n洛谷 | P2325\r\n王室联邦[SCOI2005] \r\nSDWC 提到的一种树上分块的思路，即在树上砸  个点（也就是分成  个块），DFS\r\n一遍即可，对于每个结点 \r\n枚举其儿子，把他们扔到当前的临时集合中，若当前的临时集合大于了要求的城市大小，那就新开一个以\r\n\r\n为省会的城市，不断从临时集合中将结点放到新城市中，直到小于城市块大小，总体复杂度\r\n\r\n235 | P8113 自我主义的平衡者\r\n[Cnoi2021]\r\n洛谷 | P8113\r\n自我主义的平衡者 [Cnoi2021]\r\n最近的一道比赛题，还是 E 题，没太想到能被这么简单的水过去（\r\n因为每个人评价的标准是当前的平均值和自己期望值之间的大小关系，而且每次对于平均值的贡献只有在当前平均值小于等于自己期望值的时候才会贡献一个最大值\r\n，而且我们只需要求最大值和最小值，因此贪心的将期望值序列分别升序和降序排序即可求出最大值和最小值。\r\n最一开始因为没看见那个小于等于只得了 90（\r\n236 | P4168 [Violet]蒲公英\r\n洛谷 | P4168\r\n[Violet]蒲公英 \r\n其实，我不太常写分块，平常区间问题想到的都是线段树或者 ODT.\r\n上次练习和分块相关的题目，还是练习普通莫队的时候。\r\n然而这道题需要强制在线，莫队就没用了。当然莫队是有在线化改造的，但是，本来就是暴力根号数据结构的莫队，再在线化改造之后更像分块了吧。\r\n因为值域很大，我们不可能直接在值域上进行维护，所以需要离散化。\r\n然后考虑暴力怎么做，显然，开桶对每个区间进行统计即可，那么我们考虑分块怎么做。显然对于询问区间端点所在块相邻的，直接暴力开桶统计。否则，我们先预处理出来每个块内众数出现的次数，复杂度为\r\n，然后我们可以直接利用中间块内信息辅助开桶统计。\r\n237 | AT1219 歴史の研究\r\nAT1219\r\n歴史の研究 \r\nAtCoder原题链接\r\n一个断断续续调了一天半的回滚莫队。\r\n大体思路就是一个块内的暴力修改，不在一个块内的莫队维护。\r\n因为排序询问的时候错放在预处理前，错的很惨。\r\n顺便，600 AC 祭，紫题 50 AC 祭。\r\n238 | P2501 数字序列 [HAOI2006]\r\n洛谷 | P2501\r\n数字序列 [HAOI2006] \r\n一道非常妙的题，第二问的解决方案很有意思，利用单调的序列的性质贪心找到最优的划分平台。\r\n239 | P4027 货币兑换 [NOI2007]\r\nP4027 货币兑换\r\n[NOI2007] \r\n这题就题面就很有意思，说明提示里面给做法：“必然存在一种最优的买卖方案满足：每次买进操作使用完所有的人民币，每次卖出操作卖出所有的金券。”\r\n那么我们就考虑每次拿不拿即可，设  为第  天能赚得的最大钱数， 分别为第  天用  可以换得的  的数量：\r\n\r\n假如不卖出的话，\r\n假如卖出的话，\r\n那么把后面这个东西看成直线表达式，就可以用李超线段树维护了。因为精度问题，这里使用了离散化，但是要注意的是使用\r\nunique\r\n去重的时候，不传参判浮点数相等会出现精度丢失了。（见这个讨论）\r\n240 | P2466 Sue 的小球\r\n[SDOI2008]\r\n洛谷 | P2466 Sue\r\n的小球 [SDOI2008] \r\n最近不知道做啥题了，随便捡一些 DP 玩玩，虽然我 DP 不行才是找 DP\r\n题做的原因。\r\n显然要先根据  坐标排序。\r\n这道题显然直接开二维数组来记录位置是不行的，所以用当前  坐标和当前到第几个了来作为状态。\r\n241 | P4560 Wall [IOI2014]\r\n洛谷 | P4560 Wall\r\n[IOI2014] \r\n\r\n我的评价是：抽象，为啥这题是紫的？\r\n\r\n感觉这个题完全配不上紫，很水的一个线段树，维护两个 TAG\r\n每次下传的时候修改即可。\r\n242 | P3066\r\nRunning Away From the Barn G [USACO12DEC]\r\n洛谷 | P3066 Running\r\nAway From the Barn G [USACO12DEC]\r\n\r\n这题可以 \r\n的做，每次从它到根节点的树链上寻找深度小于  的点，然后差分统计答案即可。\r\n243 | P1360 Gold\r\nBalanced Lineup G [USACO07MAR]\r\n洛谷 | P1360 Gold\r\nBalanced Lineup G [USACO07MAR]\r\n\r\n可以处理出来前缀和，然后相同的增长区间就是两个差相等的值的位置之差。\r\n不太会描述，不过确实挺好想，最一开始还以为 map 套\r\nvector 过不去，后来发现是我多虑了（\r\n244 | P8255 数学游戏 [NOIOL 2022\r\nPJ]\r\n洛谷 | P8255\r\n数学游戏 [NOIOL 2022 PJ]\r\n\r\n说实话，这题我感觉评绿合适一点。\r\n最一开始听说今年的 NOIOL\r\n普及两蓝，以为又是坑蒙拐骗初学者场。刚才偶然想到，不如拿来一做。\r\n首先是排除无解， 不能整除  显然无解。\r\n然后将  除以 ，\r\n设 ，，若\r\n，那么  就是所求的 ，否则无解。\r\n不过，写完这一堆之后，我觉得评蓝也不是不合适（\r\n245 | P4116 QTree3\r\n洛谷 | P4116\r\nQTree3 \r\n简单复健了一下树剖。\r\n246 | P4315 月下“毛景树”\r\n洛谷 | P4315\r\n月下“毛景树” \r\n同样是简单复建树剖，比较惊喜的是可以一遍\r\nAC，之前的树剖还算是没忘（\r\n这个题的线段树也不难，两个\r\ntag，一个累加一个覆盖即可，保证覆盖在累加之前就行。\r\n247 | P4114 QTree1\r\n洛谷 | P4116\r\nQTree1 \r\n非常简单树剖，但是傻逼错误（题目中的边的标号和我插入的双向边的编号不一样导致我写代码佷快然后调了万年），爱来自瓷器。\r\n248 | P3694 邦邦的大合唱站队\r\n洛谷 | P3694\r\n邦邦的大合唱站队 \r\n上次做题还是在 APIO，已经过去半个月了（\r\n一道随便找到的 DP，观看数据范围可以发现是状压\r\nDP，显然状态可以为当前的已经完成排序的队伍集合，最终状态即全部队伍的集合。\r\n考虑如何转移，直接枚举人数必然会寄，所以可以考虑在每个状态枚举队伍找到最小值。\r\n249 | P3313 旅行 [SDOI2014]\r\n洛谷 | P3313\r\n旅行\r\n\r\n反正博客也不显示，就不再放题目难度了。\r\n\r\n这个题是很明显能发现需要一些很树剖的操作，而相比于最普通的树剖，这个多了个重新染色的问题。\r\n那么考虑一般我们用的是线段树配合树剖，所以考虑对于每个宗教开一个线段树，但是显然一下全开完会\r\nMLE，所以动态开点，每次重新染色的时候在原来的宗教树上删除，在新宗教树上添加即可。\r\n然后就是正常的树剖。\r\n250 | P4211 LCA [LNOI2014]\r\n洛谷 | P4211 LCA\r\n[LNOI2014]\r\n一看 LCA，感觉还挺奇妙的，其实是个简单的东西。\r\n按照题中的形式自己画一画发现其实对于每个询问是求树剖后 dfn 序列上\r\n[l,r] 的编号之和。\r\n那么可以用线段树来维护，并把每个询问离线、拆分，最后合并答案。\r\n其实并不难写，甚至这题是六月中旬写的树剖部分，今天七月十号了重新拿来继续写，没想到查了一天错误结果是树剖写错了（（（（\r\n详见：求助\r\nP4211。\r\n251 | P7871\r\n「Wdoi-4」芙兰的贤者时间\r\n洛谷 | P7871\r\n「Wdoi-4」芙兰的贤者时间\r\n显然是要先看看样例，可以发现，如果要满足一个从  开始，到  结束的能量传递（这里假设 ），那么区间 \r\n要满足奇偶位次上的能量值分别严格递减，于是我们可以把这些同奇偶的东西相连，然后对于每个链进行从小到大的贪心标号即可。\r\n252 | P2218 覆盖问题 [HAOI2007]\r\n洛谷 | P2218\r\n[HAOI2007]覆盖问题\r\n首先可以根据给出的点的位置找出一个最小的能包含所有点的正方形 。如果三个符合题目要求的小正方形有一个均不在\r\n\r\n的一个角上，那么说明两者之间的区域没有需要染色的点，所以  不是最小的，与上面所设矛盾。\r\n故，我们需要找的 3 个边长为 \r\n的小正方形至少有一个在 \r\n的一个边角，于是我们就可以从一个角上开始二分寻找第一个小正方形，然后将其范围内的点进行标记后，去看剩余两个小正方形能否覆盖剩余的点。\r\n为了最大化小正方形的覆盖面积，剩余两个小正方形也应该在  的其余边角。\r\n因为赋初值的时候忘了左边界要赋值成 -INF，改完之后就过了。\r\n253 | P2511 木棍分割 [HAOI2008]\r\n洛谷 | P2511\r\n木棍分割 [HAOI2008]\r\n最近我怎么随机到这么多 HAOI\r\n第一问二分答案即可，重点在第二问。\r\n首先第一问我们得到了长度限制，所以可以考虑 DP\r\n逐位转移每一位能扩展拼接的方案数，比较容易能得出二维的方程 ，其中 \r\n是当前位能向左最远扩展到的位置， 代表前  个分了  个部分。\r\n对于这个题来说，这个式子的空间复杂度和时间复杂度都不行，所以考虑如何优化。\r\n由于是逐位转移，所以可以把第一位滚掉。同时，转移是一个和式，而  是不变的，所以可以前缀和处理。\r\n这样的话最终的空间复杂度就是 ，时间复杂度是 .4\r\n254 | P2234 营业额统计\r\n[HNOI2002]\r\n洛谷 | P2234\r\n营业额统计 [HNOI2002]\r\n使用一个 set 就能水掉，每次加入的时候先\r\nlower_bound 找到仅小于它的和其上一个，比较即可。\r\n\r\nNOIP 2022 前的记录放在 OI 2022 了。\r\n\r\n","slug":"Note18-2","date":"2021-12-06T09:16:00.000Z","categories_index":"OI-Solutions","tags_index":"OI","author_index":"Heriko Deltana"},{"id":"96523d41e2a8a131bb117900aa4dbe2f","title":"Note18 : 杂题一","content":"第一堆持续更新的杂题\r\n\r\n\r\n前言\r\n\r\n这里是我从 2021.4.12\r\n开始的做题记录，每个题目都有大约的讲解思路（有些偷懒就直接放的题解的链接）\r\n这里的每一个题目都没有标程，但是都有题目的链接，可以根据右面的目录点到对应的题目去\r\n这里的题目是按照我做的时间顺序排放的，难度主要是 黄  绿  蓝的样子。\r\n因为好像篇幅好长的样子所以就开了第二堆杂题，这里就到\r\n200 吧（\r\n\r\n2021.12.6 UPD\r\n1 | P1144 最短路计数\r\nP1144最短路计数\r\n\r\n由于这道题的特殊性（所有边的边权都是1），所以我们可以只进行简单的BFS\r\n由于要求最短路，所以当前在求的点的上一个点在搜索树种一定是来自于上一层，不可能来自同一层，所以到点的当前路径的长度只需要让上一层的那个点对他进行更新即可\r\n再因为本题的要求的是到点的最短路的个数，所以如果到点的当前路径的长度等于上一层的每一个点的路径+1，那么这肯定是到点的最短路\r\n2 | P1352 没有上司的舞会\r\nP1352没有上司的舞会\r\n\r\n这是我第一次做有关树形DP的题目，因为题目难度不高，所以还是比较好想的\r\nS 设是当第个人不参加舞会时的，是他参加舞会时的\r\n根据题目所给到的关系，当一个结点（人）的父节点（领导）来的时候，这个人是不参加舞会的，所以对于的下属就有，\r\n这里的是每个人的欢乐值（结点的权值）\r\n可以显然得到的是，上述柿子只有从根节点开始才能计算出对于每个节点的，从而才能算出对于根节点的，最后即可\r\n那么我们就需要找到的编号，根据本题的特殊性，结点即为没有上司的结点，在输入关系的时候我们用一个数组来标记即可，全部输入完毕之后，再根据标记来判断\r\n3 | P1015 回文数\r\nP1015回文数\r\n\r\n其实做这道题的初衷是为了让橙题AC数量凑个整数\r\n这道题其实按照题目的要求进行模拟即可，每次将一个数的位数正序与逆序相加，需要用到高精。对于大于10进制的情况，将其每一个用字母来表示的位对应的转化为一个十进制数即可\r\n4 | P1158 导弹拦截[NOIP2010PJ]\r\nP1158导弹拦截[NOIP2010PJ]\r\n\r\n看似这道题是和另外一道DP题重名，实际上这个题是一个排序+模拟，因为只有两个导弹系统，所以我们考虑用第一套拦截较小范围的，第二套拦截较大范围的\r\n在用到第一套系统的距离进行排序，然后依次枚举即可\r\n5 | P1190 接水问题[NOIP2011PJ]\r\nP1190接水问题[NOIP2021PJ]\r\n\r\n这题就真的是老水题了，模拟一下接水过程即可\r\n6 | P1309 瑞士轮[NOIP2011PJ]\r\nP1309瑞士轮[NOIP2011PJ]\r\n\r\n这道题是一个很典型的归并排序\r\n主要思路就是每次维护赢家和输家两个数组，然后在每次比赛之后进行归并\r\n在最一开始使用sort排序一遍，然后每次比赛完之后merge即可\r\nPS：STL中是有merge的：\r\nmerge函数的作用是：将两个已经排好序的序列合并为一个有序的序列\r\n函数参数：merge(first1,last1,first2,last2,result,compare);\r\n实际上就可以这样用：\r\n1234inline bool cmp(int x,int y){return x&lt;y;}int a[114514],b[114514],c[114514];...merge(a+1,a+114514,b+1,b+114514,c+1,cmp);\r\n7 | P1982\r\n小朋友的数字[NOIP2013PJ]\r\nP1982小朋友的数字[NOIP2013PJ]\r\n\r\n我直接推荐第一篇题解\r\n8 | P1095\r\n守望者的逃离[NOIP2007PJ]\r\nP1095守望者的逃离[NOIP2007PJ]\r\n\r\n能闪则闪，否则就走，若能力值够了就恢复，最后将本次的值进行比对，\r\n看是这次 走 快还是 停下来恢复 或 闪 快\r\n9 | P2398 GCD SUM\r\nP2398 GCD SUM\r\n\r\n设\r\n为能被k整除的的个数\r\n很明显就有，因此(对于i有floor（n/k）种，对于j也一样)\r\n10 | P1390 公约数的和\r\nP1390公约数的和\r\n\r\n思路和上一题基本一致，最后答案输出时即可，其中\r\n11 | P1541 乌龟棋[NOIP2010TG]\r\nP1541乌龟棋[NOIP2010TG]\r\n\r\n很明显的一个DP题，且方程是比较好推的\r\n由于题目中说了一共只有4种卡牌，且对于100%的数据：每种牌的数量都小于等于40\r\n因此我们可以开4维数组，代表分别用x张1，y张2，z张3，和w张4所能得到的最大值\r\n那么就可得出方程：  当然，前提是保证计算时，对应的都不为0\r\n12 | P3842 线段[TJOI2007]\r\nP3842线段[TJOI2007]\r\n\r\nDP，在这里是设置了二维的一个状态，表示从第i行最左端开始走的最短路径长度，则是到第i行最右端开始走的最短路径长度\r\n那么除了第一行外，当前的从左端点开始走的最短的路径就是上一行的对应的左端点+上一行的线段的左端到这一行的线段的右端的长度+这一行的线段长度+1。或者是从上一行的右端点来（计算方法同理，将左端点改为右端点即可）。\r\n当然，从右边开始同理。\r\n那么状态转移方程就是这样的：  # 13 | P2016 战略游戏\r\nP2016战略游戏\r\n\r\n一个最为基础的树形DP\r\n通过观察样例我们可以发现：实际上只需要考虑对于某个节点，我们只需要考虑这个节点要不要放士兵即可\r\n那么我们每次取放/不放的最小值即可\r\n14 | P1359 租用游艇\r\nP1359租用游艇\r\n\r\n树形DP，先存边，然后遍历n的上游和i的下游节点，比较路径长度即可\r\n15 | P1122 最大子树和\r\nP1122最大子树和\r\n\r\n树形DP，先存边，然后进行两个DFS\r\n16 | P1747 好奇怪的游戏\r\nP1747好奇怪的游戏\r\n\r\nBFS，做这道题的初衷是为了复习一下搜索，感觉自己快忘了\r\n最一开始提交竟然WA，原来是BFS第二个时把BFS(X2,Y2)错写成了BFS(X2,Y1)，草（一种植物+中日双语）\r\n17 | P1746 离开中山路\r\nP1746离开中山路\r\n\r\nBFS，和上面那道题基本一致\r\n简单的打了一遍模板，修改几个参数就好了（\r\n18 | P2615 幻方[NOIP2015TG]\r\nP2615幻方[NOIP2015TG]\r\n\r\n不是吧2015年的D1T1就这么水\r\n做题的初衷是为了完成任务\r\n一眼知模拟，所以就按照条件简单做就行\r\n因为数组表示起来不是很好想，直接放弃使用数组下标\r\n选择用结构体，求每个数字的坐标，最后再赋值给数组以便输出，中间走样例炸了一次，是没做位置是否有数的判断，因为懒得再去大改，而且这题范围允许，就维护了一个bool数组\r\n做的时候觉得应该能煺柿子，AC完一看题解，还真有公式啊\r\n19 | P2298 Mzc和男家丁的游戏\r\nP2298Mzc和男家丁的游戏\r\n\r\nBFS，和前面的P1746思路基本一致，典型的迷宫+BFS，维护一个dis数组即可\r\n但是分析的时候错误的打了个else导致我调了二十分钟？？？\r\n20 | P1332 血色先锋队\r\nP1332血色先锋队\r\n\r\n看完题面第一反应：好！我是叛徒\r\nBFS，但不完全是BFS板子，这是多起点多终点的\r\n啊那就直接把起点全部压进队列去不就行了么\r\n然后更新dis，最后按照顺序输出即可\r\n然后我因为BFS函数没调用查了≈40min？？？\r\n感谢！已经气懵了\r\n21 | P1141 01迷宫\r\nP1141 01迷宫\r\n\r\n别看这是一道普及-，这题可比前面的5道题强多了\r\n首先输入需要用字符串，迷宫类问题常规操作，还行\r\n然后这题如果直接按照输入数据一组一组的BFS的话最多拿70pts，会TLE三个点\r\n那么我们考虑计算连通块，然后输出要查询的点所在的连通块的大小即可\r\n22 | P1162 填涂颜色\r\nP1162填涂颜色\r\n\r\n哦，又是一道普及-\r\n这道题做法很多，我在这里考虑DFS\r\n因为在题目当中0有两个意思，所以将他们换成不同的数字在进行分析\r\n但是不能直接DFS，那样会把边缘误涂，应该先DFS一边边缘，再进行正常DFS，所以最一开始输入的是DFS(0,0)\r\n23 | P1683 入门\r\nP1683入门\r\n\r\n哦，双是一道普及-\r\n这道题显然的DFS，甚至还不用回溯，找到起点直接DFS即可\r\n24 | CF414B Mashmokh and ACM\r\n洛谷：CF414B\r\nMashmokh and ACM \r\nCF：Codeforces\r\nRound #240(Div.1) ##B\r\n搜索做累了，水一个DP\r\n由于对于一个数而言，它的因数并不好枚举，所以在这里考虑倒退，即去推某个数的倍数\r\n25 | P1586 四方定理\r\nP1586四方定理\r\n\r\nDP，状态很好想，是一个类似部分背包\r\n由于是多组数据，可以先预处理，然后把输入的数据的f[n][1~4]加起来就行\r\n26 | AT1350 深さ優先探索\r\nAT1350\r\n深さ優先探索 \r\n顾名思义，这是AtCoder的DFS模板题，锻炼一下DFS用的\r\n27 | P1387 最大正方形\r\nP1387最大正方形\r\n\r\n智能推荐的题，DP\r\n由于给了图，而且n和m都小于100，所以上手模一下图大概的柿子就有了\r\n本题实际上只需要对数值是1的点进行操作，所以以当前这个点为顶点的最大的不含0的正方形的边长就是它的上，左，左上端点的最小值再加一，柿子大约就是：\r\n\r\n28 | P1157 组合的输出\r\nP1157组合的输出\r\n\r\nDFS，但是我白给了，完全不会DFS.jpg\r\n实际上思路很好想，从1开始搜，然后搜每一个能符合的下一个数，如果当前搜到的位数大于r了，就输出+回溯\r\n但是我就是不会打（\r\n最一开始看到这个题突然想起来有个东西叫做next_permutation，然后看本题的推荐题目，发现有一道裸的输出全排列（P1706全排列问题\r\n\r\n29 | P2372 yyy2015c01挑战算周长\r\n哦我又双叒叕在DFS上面白给了\r\nP2372yyy挑战算周长\r\n\r\nDFS，一上来就读不懂题，样例都看不懂\r\n看了一眼题解发现原来是对于每个中心的X，只有它的上下左右才算周长，否则不算（比如说角上就不算）\r\n30 | P1681 最大正方形II\r\nP1681最大正方形II\r\n\r\n是刚才上面那道题的变式，实际上只需要多开一维数组来表示当前是0还是1了\r\n这个数据范围搞得我严重浪费评测机资源\r\n31 | P2426 删数\r\nP2426删数\r\n\r\n区间DP，我没见过\r\n准确来说是我忘了，但是看题解说这个题比较水\r\n不过也确实比较水，因为从头上删除和从尾删除到了最后应该是等价的（也就是从头上删除的最优解留下来的部分也正是从尾端开始的最优解）\r\n最一开始过不了样例，因为我把求值的公式打错了（谁让题面上没用呢)\r\n看到样例答案突然就想讽刺一下膏通的某挤牙膏SoC\r\n32 | P1036 选数[NOIP2002PJ]\r\nP1036组合的输出\r\n\r\n一道NOIP的上古题目\r\nDFS，和昨天那个组合数类似，都是确定当前数字的基础上确定下一个数\r\n本来是想打一手欧拉筛预判一下，结果发现不是很好用，于是乎打完就去掉了，换成了试除法\r\n33 | P1063 能量项链[NOIP2006TG]\r\nP1063能量项链[NOIP2006TG]\r\n\r\n众所周知这是某本书的区间DP的例题，但我没看那本书的区间DP\r\n好久没做绿题了\r\n区间DP，首先这题数据是个环，我们需要破环成链，实际上只需要在数组里面再复制一遍数据就可以\r\n我们从中间选一个点k，然后每次比较i到j的原值大还是从中间选一k点得到的值大\r\n最后找一个最大值即可\r\n34 | P1605 迷宫\r\nP1605 迷宫\r\n\r\n不是吧不是吧不会这个题也有人不会吧\r\nDfkuaid_First_Search，实际上就是每次扩展结点简单DFS即可\r\n但是我最一开始忘了判断是否越界&amp;起点设置为已经过而WA\r\n说明我DFS还是8行\r\n35 | P1005\r\n矩阵取数游戏[NOIP2007TG]\r\nP1005\r\n矩阵取数游戏[NOIP2007TG]\r\n\r\n终于是把我主页智能推荐天天在推荐的题调出来了\r\n实际上是一个区间DP，我们每行维护一个最大值，最后加起来即可\r\n对于每一行的每一个数，当要去掉的数到它时，它的最大值一定来自它的左边或右边，因为只能从两头进行操作\r\n然后就是高精度，感谢，已经快敲死了\r\n实际上第一次模着题解写对了99%，但是当把每一行的最大值加入ans的时候忘了给每一行的最大值赋值时清空了:joy:\r\n36 | P1019 单词接龙[NOIP2000TG]\r\n注意：本题为上古 NOIP\r\n原题，不保证存在靠谱的做法能通过该数据范围下的所有数据。\r\nP1019\r\n单词接龙[NOIP2000TG] \r\n一道比较巨大的DFS，很考察细节，思路不难想，问题是怎么一点一点的把细节抠出来\r\n37 | P4170 涂色\r\nP4170 涂色\r\n\r\n说实话好久没做题了\r\n这个题是一个区间DP，考虑一个特殊的判断，即为枚举到相同时直接继承，剩下的就是经典的区间DP，枚举一个断点进行计算\r\n38 | P2014 选课[CTSC1997]\r\nP2014 选课\r\n\r\n一看年份就知道是一道上古的CTSC题目，我们先来看这个题面\r\n题面中提到很多课程都会有其预备课程，然后再根据本题输入的数据的特点是输入0即为没有前继节点，于是这句话可以翻译为：这是一棵根节点为0的树\r\n没错，这道题分析到这里就应该能看出来是树形DP了\r\n首先是进行常规操作，用邻接表来存下这些边，生成一棵树\r\n于是我们就从最小内容的节点开始拓展（递归），也就是从 Root 开始DP\r\n这里设计的方程是  是指前 j 个节点选了 k\r\n节课，我们可以从根节点开始，顺着树进行DP（DFS）\r\n39 | P2015 二叉苹果树\r\nP2015 二叉苹果树\r\n\r\n顾名思义，这是一颗树，并且还是二叉树\r\n这里推荐一篇54级学长的[树形DP入门]\r\n学长讲的真的挺好的，推荐去看\r\nHD只能在这里粗略的重复一遍，实际上就是考虑到每个节点的数据都是由他的子节点传递过来的，因此我们在找方程的时候就要找当前节点和它的子节点的传递/递推关系\r\n40 | P2880 Balanced\r\nLineup G + P2251 质量检测\r\nBalanced Lineup\r\nG\r\n质量检测\r\n之所以把这两个题放在一起，就是因为这都是ST表的板子题，前者只需在ST表板子的基础上维护一个最小值，然后查询的时候输出\r\nmax-min 即可\r\n后者只是把查询的区间改为了一个规定的柿子，传参的时候注意一下就可\r\n41 | P1816 忠诚\r\nP1816 忠诚\r\n\r\n我是真的没想到ST表居然这么多板子题（虽然说相比于并查集少了很多）\r\n这个就是把模板的max改为min即可，因为ST表在维护最大值和最小值的时候原理是一致的\r\n42 | P1040\r\n加分二叉树[NOIP2003TG]\r\nP1040 加分二叉树\r\n\r\n这个题是一个长得像树形DP的区间DP\r\n数据只给出了中序遍历，因此我们不能确定树的样子，再加上我们最后要输出能够得到最大加分的树的先序遍历，于是我们就着手与在这里设计方程\r\n用  来表示从编号 i 到 j\r\n这些点形成的最优二叉树（即分数最大），因为我们还有输出这棵树，所以我们在进行状态转移的时候还需要记录刚才那棵树的根节点，保存到\r\n 中\r\n根据题目加分的原则，我们再枚举一个区间变量 k\r\n去找这个最大值，我们可以得到下面的状态转移方程\r\n\r\n根据我们设计的方程，最后再输出  以及以 \r\n为根节点的二叉树的先序遍历即可\r\n43 | P1440 求m区间内的最小值\r\nP1440\r\n求m区间内的最小值 \r\n这个题一眼单调队列（滚动数组），就比模板还简单\r\n但是这题题意不清楚，题目中说到的\"求出每一项前的 m\r\n个数到它这个区间内的最小值\"中，这个区间是前闭后开的（\r\nPS：最近做了一些模板题，可能会写个汇总\r\n谁让今天洛谷给我智推五道板子题呢（笑）\r\n\r\n44 | P1638 逛画展\r\nP1638 逛画展\r\n\r\n简单来说这也是个单调队列的题，因为我们只需要保证区间内每个作家有至少一幅画，所以当一个画家的画出现了两次之时，可以直接让前面那个出队，毕竟保留它并不会更优\r\n45 | P1901 发射站\r\nP1901 发射站\r\n\r\n总之来说，就还是维护一个单调队列，保证能量能传的最远，所以要保证后入队的塔比前面的矮\r\n46 | P3146 248 G\r\nP3146 248 G\r\n\r\n我是真的不敢相信这题是绿的\r\n实际上这道题说起来是要比石子合并简单的，因\r\n为这题的转移方程仅仅是f[i][j]=max(f[i][j],f[i][k]+1)\r\n注意在合并的时候要判断两者必须相同且均不为 0\r\n47 | P1714 切蛋糕\r\nP1714 切蛋糕\r\n\r\n这是我做的第40道绿题！\r\n这道题本质上让人一眼想暴力，但是50w的范围很明显会Time Limit\r\nEnough\r\n于是我们就有两个出路,线段树(具体我不会搞,kkk说的能搞)或者维护个单调队列\r\n我这是第一次用STL的deque,大体思路就是满足条件就进队(进队的元素是前缀和),每次和当前ans进行比较,选取大的那个\r\n由于输入的Pi可能是负数,所以ans最一开始要初始为一个负数(我选的-114514)\r\n最后得到的一定就是最优解了\r\n48 | P6599 异或\r\nP6599 异或\r\n\r\n由于我太懒了,建议直接看DX的题解\r\n其实是写完题之后去整了整AFOed的同学的链接,唉......\r\n49 | P4391 Radio\r\nTransmission 无线传输[BOI2009]\r\n同上,简单说一下吧,相当于KMP的小扩展形式\r\n50 | P6051 求和\r\nP6051 求和\r\n\r\n说实话这题不是很难\r\n如果是经常用快读的同学们应该知道，快读的本质就是读取字符，因为getchar()读取效率更快一些\r\n而本题就是从字符串中读取出来数字再进行求和，我这边直接用快读读入的话可以发现它是能读出来所有数字\r\n于是可以直接从快读的基础上进行更改，多维护一个变量来求和即可\r\n51 | P1083 借教室[NOIP2012TG]\r\nP1083 借教室\r\n\r\n暴力很好想，直接打就行，就是只有45pts（\r\n正解是差分+二分查找答案\r\n52 | P2420 让我们异或吧\r\nP2420\r\n让我们异或吧 \r\n这道题稍微一看题解区就会发现什么做法都有\r\n我这里选用的是披着 LCA 名字的 DFS\r\n，因为题目是说两点之间的路径上所有边的边权的异或值，所以就相当于是这两点分别到\r\nLCA 的边权异或值的异或值\r\n由于本题过水，所以我们甚至只需要直接一共 DFS 预处理出每个点的 LCA\r\n以及其对应的异或值即可\r\n53 | P1351 联合权值[NOIP2014TG]\r\nP1351 联合权值\r\n\r\n我们联合！\r\n两面包夹芝士！\r\n这个题首先告诉我们了一个信息：这是一棵树\r\n再根据题意，两个能联合的点之间必然有一个点\r\n于是我们可以枚举这个中间点，扩展一边它周围的边，就能算出来最大的联合军费，一步步枚举，就可以算出联合军费之和\r\n54 | P1613 跑路\r\nP1613 跑路\r\n\r\n确实，我要跑路了\r\n这个题很显然要用到最短路，我们可以这样想：把能用跑路机的两个点之间（2n）的边连为\r\n1 ，接下来就无脑 Floyd\r\n55 | P1168 中位数\r\nP1168 中位数\r\n\r\n这道题题意非常易于理解，我第一反应是每次输入的时候 sort\r\n一下，但是仿佛这复杂度会立即炸掉\r\n于是突然想起 vector 的 insert 的复杂度是  好像能使（\r\n于是就把 upper_bound + insert 合起来用了（\r\n隔壁的 Dfkuaid 默默拿出一手权值线段树，这玩意效率比 vector\r\n强多了，但是我不会:D\r\n56 | P1853 投资的最大效益\r\nP1853\r\n投资的最大效益 \r\n算是复习一下背包，这是一个完全背包\r\n就是多开了一层循环，要遍历年数\r\n这题最离谱的是给的 \r\n，但是数组开 1e6+5 还不够，需要 1e7 ......\r\n57 | P2918 Buying Hay S\r\nP2918 Buying Hay\r\nS \r\n这题真是把我整笑了，就一个裸的完全背包\r\n但是因为我赋的初始值不够大就 WA 了一页......\r\n58 | P5365 英雄联盟[SNOI2017]\r\nP5365\r\n英雄联盟[SNOI2017] \r\n简单来说是一个多重背包，但是我们里要考虑的东西多了不少（\r\n这里的钱的总数需要乘一下\r\nDfkuaid 是一样的方程却下溢出了，咱也不知道为什么我没有溢出\r\n不过加上防止下溢出的 if 之后，我开 O2\r\n能跑到最优解第一页了（虽然是最后一个）\r\n59 | P2347 砝♂码称重[NOIP1996TG]\r\nP2347\r\n砝♂码称重[NOIP1996TG] \r\n这题，屑题，不讲\r\n60 | P1832 A+B Problem 再升级\r\nP1832 A+B Problem\r\n再升级 \r\n这个题先欧拉筛一遍质数然后完全背包\r\n61 | P1244 青蛙过河[NOI2000]\r\nP1244\r\n青蛙过河[NOI2000] \r\n这就是2000年的 NOI 的水题吗\r\n这个题显然发现有这样一个柿子：  ，其中 \r\n然而这样也就告诉我们根本不需要数组 f ，所以我是直接使 k++ 然后乘\r\n这也是我的第 100 道橙题\r\n62 | P2370 yyy2015c01 的 U 盘\r\nP2370 yyy2015c01 的\r\nU 盘 \r\n总之来说是 01背包 之前排序一下即可\r\n有了 O2 以及快读快输常数小的优势，拿了第 6 优解\r\n63 | P2904 River Crossing S\r\nP2904 River Crossing\r\nS \r\n这个题数据一看就非常水吧，就 2.5k 的 n ......\r\n最一开始算一个前缀和 + 完全背包即可\r\n又是由于常数小，拿了第 11 优解，诶嘿\r\n64 | P1631 序列合并\r\nP1631 序列合并\r\n f\r\n这个题，题面确实对我来说有点迷，就是那种，读懂了但是没完全读懂的感觉.....就是，你懂！\r\n强迫文学奖\r\n这个题有一点非常好的就是题目给出的数据已经排好序了，因此我们不必再次排序\r\n由于题目中说到要输出最小的 N\r\n个，那么很容易想起来要维护一个小根堆，这里我用的 priority_queue\r\n，单纯是因为懒，而且太久没手写堆了\r\n可以假定这两个序列选择时是有先后的，于是我们最一开始让 a1\r\n+ bi 入队，然后一个个出队，再把 a2 + bi\r\n入队，直到到达要求\r\n为了记录是扔进去的是第几个 b ，这里在 pq 里用 pair 还存了填入的 b\r\n的编号\r\n65 | P5020 货币系统 [NOIP2018TG]\r\nP5020 货币系统\r\n[NOIP2018TG] \r\n题面可以说是看起来比较难受，这里直接简述一下\r\n个人理解就是要找一个新的由 m\r\n种货币组成的货币系统，要保证它和给你的那个货币系统是等价的\r\n我看了一眼 Tag 发现是有背包之后\r\n果断想到这个貌似是完全背包的样子！\r\n于是就往完全背包上面凑，设了一个 fx 来表示 x\r\n能不能被表示出来，然后显然在状态转移的时候，需要判重，不让这个 m\r\n在一个价钱上被重复加\r\n状态转移方程就是 f[j]=f[j-a[i]];\r\n66 | P6771 Space Elevator\r\n太空电梯\r\nP6771 Space Elevator\r\n太空电梯 \r\n这个题显然是和背包有关，而且是多重背包，这里我采取的状态转移方程是\r\nf[x]|=f[x-h[i]]\r\n67 | CF189A Cut Ribbon\r\nCF189A Cut\r\nRibbon \r\n显然这题橙题水准，但是众所周知 CF 题都是恶评，即使这是 A\r\n就是一个完全背包板子...\r\n所以试图拿最优解，但是很明显我不够格（\r\n68 | CF417A Elimination\r\n写了题解，希望能通过，毕竟我到现在咕值只有练习分和信用分\r\n题解在这里\r\n(UPD:题解已经过了！)\r\n69 | P1941 飞扬的小鸟\r\n[NOIP2014TG]\r\nP1941 飞扬的小鸟\r\n[NOIP2014TG] \r\n哇这题真的是......令人害怕，2014 TG 就这么恐怖，觉得自己 2021\r\n可能要挂（\r\nCSP 2021 &amp; NOIP 2021 RP++ !\r\n这个题细节多的离谱，这也是我做到现在觉得应该放代码的一道题（虽然已经变成了题解的样子（\r\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;#define Heriko return#define Deltana 0#define Romano 1#define S signed#define U unsigned#define LL long long#define R register#define I inline#define D double#define LD long double#define INF (LLONG_MAX-114)#define mst(a, b) memset(a, b, sizeof(a))#define ON std::ios::sync_with_stdio(false)using namespace std;I void fr(LL &amp; x){    LL f = 1;    char c = getchar();    x = 0;    while (c &lt; '0' || c &gt; '9')     {        if (c == '-') f = -1;        c = getchar();    }    while (c &gt;= '0' &amp;&amp; c &lt;= '9')     {        x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0';        c = getchar();    }    x *= f;}I void fw(LL x){    if(x&lt;0) putchar('-'),x=-x;    static LL stak[35];    LL top=0;    do    {        stak[top++]=x%10;        x/=10;    }    while(x);    while(top) putchar(stak[--top]+'0');    putchar('\\n');}const int MXX=10005;LL n,m,k,h[MXX],l[MXX],f[MXX][1005],t,fans[MXX],ans,x[MXX],y[MXX];bool o[MXX];S main(){    fr(n),fr(m),fr(k);    for(R LL i=0;i&lt;n;++i) fr(x[i]),fr(y[i]);    for(R LL i=1;i&lt;=k;++i) fr(t),fr(l[t]),fr(h[t]),o[t]=true;    for(R LL i=0;i&lt;=m;++i) f[0][i]=0;    for(R LL i=1;i&lt;=n;++i) f[i][0]=INF;    for(R LL i=1;i&lt;=n;++i)    {        fans[i]=INF;        for(R LL j=1;j&lt;=m;++j) f[i][j]=INF;        for(R LL j=x[i-1]+1;j&lt;=m;++j) f[i][j]=min(min(f[i-1][j-x[i-1]],f[i][j-x[i-1]])+1,f[i][j]);        for(R LL j=m-x[i-1];j&lt;=m;++j) f[i][m]=min(f[i][m],min(f[i-1][j],f[i][j])+1);        for(R LL j=1;j+y[i-1]&lt;=m;++j) f[i][j]=min(f[i-1][j+y[i-1]],f[i][j]);        if(o[i]){for(R LL j=1;j&lt;=l[i];++j) f[i][j]=INF;for(R LL j=h[i];j&lt;=m;++j) f[i][j]=INF;}        for(R LL j=1;j&lt;=m;++j) fans[i]=min(f[i][j],fans[i]);        if(fans[i]==INF)        {            ans=0;for(R LL j=1;j&lt;i;++j) if(o[j]) ++ans;            fw(0);fw(ans);            Heriko Deltana;        }    }    fw(1);    fw(fans[n]);    Heriko Deltana;}\r\n70 | P2938 Stock Market G\r\nP2938 Stock Market\r\nG \r\n这个题和之前的一道投资的题（# 56\r\n）基本一致，基本就是完全背包小变形，思路基本一致，可以直接去看那道题\r\nPS：这题最一开始跑出 4.6s 把我吓着了，然后开 O2 就 722ms\r\n，于是我觉得能卡卡，现在是卡到 609ms 拿到第 12 优解，欸嘿\r\n这貌似是我的第 50 道绿题\r\n71 | P1782 旅行商的背包\r\nP1782\r\n旅行商的背包 \r\n我直接宣布这是我这几天做过最迷幻的题目\r\n上来一看这显然是个背包，前 n 个是多重背包，后 m 个是完全背包\r\n前 n 个直接打一个二进制优化，先搞♂一边 f ，然后直接暴力三层循环求后 m\r\n个\r\n最一开始数组开的 2e4+5 ，有 RE ，本着 RE\r\n我就超级加倍的原则，一直到 6e4+5 和 8e4+5 ，RE 没了，拿了\r\n80pts\r\n本来想着就直接去看看能不能优化，最后试了一次 1e5+5\r\n欸，就很离谱，过了，然后发现仿佛卡卡 + O2\r\n能进最优解第一页，然后就卡，最后进去了\r\n\r\n别的我不知道，但是为什么同样是 1.14s ，却不一样优？\r\n\r\n72 | P1858 多人♂背包\r\nP1858 多人♂背包\r\n\r\n这个题的题面就非常离谱，不光告诉你了这题要算啥，还告诉你这题每个背包要装满.....\r\n奇妙的是 memset 只能是 128~4000+\r\n就非常离谱，我测试了半天都不知道是干啥了\r\n就是在 01背包 的方程上多加了一维变成  ，第二维代表是第 j\r\n优解，然后因为告诉你要算每个背包装满之后的和，因此在转移的时候就是把 max\r\n改为 sum\r\n提交的时候直接开的 O2 ，直接进最优解第一页\r\n73 | P1198 最大数[JSOI2008]\r\nP1198\r\n最大数[JSOI2008] \r\n这个题有许多的做法，比如\r\nST表，树状数组，线段树，分块，单调栈+并查集......\r\n我选择的是树状数组，因为它代码比较少，\r\n写一个 add 和 query 就行。\r\n123456789101112131415I LL query(LL l,LL r){    LL ans=0;    while(l&lt;=r)    {        if(ans&lt;num[r]) ans=num[r];        for(--r;r&gt;=l+lowbit(r);r-=lowbit(r)) if(ans&lt;tree[r]) ans=tree[r];    }    Heriko ans;}I void add(LL x){    num[++n1]=(x+t)%mod;    tree[n1]=max(num[n1],query(n1-lowbit(n1)+1,n1-1));}\r\n比较恶心的是这题不能用 scanf(\"%c\",&amp;ch); ，用了就 RE\r\n。\r\n74 | P1417 烹调方案\r\nP1417 烹调方案\r\n\r\n这个题显然的是一个 01\r\n背包的问题，但是这里的费用是会随着时间而改变的，\r\n因此应该比较好想到要先排序一下以保证我们在状态转移的时候是最优的。\r\n然后就是自然的 O1 背包。\r\n75 | P1531 I ↑ Hate ↓ It ↑\r\nP1531 I ↑ Hate ↓ It\r\n↑ \r\n线段树，甚至比板子还简单就非常离谱。练练板子（\r\n76 | P1883 函数 &amp; UVA 1476\r\nError Curves\r\nP1883 函数\r\n\r\nUVA 1476 Error\r\nCurves \r\n两个基本一样的题，评分居然不一样（\r\n这个写了题解，链接放在这。\r\n\r\n在 76 和 77 之间略去了一堆不知道有啥好说的 DS 板子题。\r\n\r\n77 | P3870 开关 [TJOI2009]\r\nP3870 开关\r\n[TJOI2009] \r\n其实这也是个线段树的板子，就是想说一点。\r\n这个题每次进行操作的时候相当于是把开着的灯的总数和关着的灯的总数对调了一下。\r\n78 | P1471 方差\r\nP1471 方差\r\n\r\n这个题我摸了一下午......\r\n太累了先题解先摸了。（略略略\r\n79 | P2412 查单词\r\nP2412 查单词\r\n\r\n我做过最™骚的线段树！\r\n真没想到还有这种线段树，开眼了，甚至一个黄题调了一晚上！\r\n大约就是把线段树里维护的东西变为原字符串和比较字符串（因为题目中说字符串在比较的时候要求不考虑大小写，所以我们应当将原字符串统一转为大\r\n/ 小写才能比较）。\r\n不过最离谱的是这个题还卡时间于是我不敢用 string ，于是就用 char\r\n数组，但是 char 数组的比较和赋值不像 string 那么简单，需要用到 strcmp 和\r\nstrcpy ，可把我恶心坏了（\r\n80 | P2434 区间 [SDOI2005]\r\nP2434 区间\r\n\r\n差分yyds！\r\n77A | P2574 XOR的艺术\r\nP2574 XOR的艺术\r\n\r\n之所以是标的 77A 而不是 81 ，就是因为这个题和 上面的 # 77\r\n是一样的，就是改了个输入。\r\n甚至交错了代码（\r\n77B | SP7259 LITE - Light\r\nSwitching\r\n77C | P2846\r\n[USACO08NOV]Light Switching G\r\n77D | P5057 [CQOI2006]简单题\r\n彳亍！ 77 是五倍经验题！\r\n81 | P1972 HH的项链 [SDOI2009]\r\nP1972 HH的项链\r\n[SDOI2009] \r\n这道题是非常适合锻炼树状数组的（\r\n首先观察这个题要进行区间的查询，然后看到数据范围是\r\n1e6，于是我就想到了线段树和树状数组。\r\n再因为这个题没有说到要区间修改，我就直接选择了码量比较少的树状数组去离线做。\r\n我们考虑，因为是问某个区间内的种类个数，所以我们其实对于一个种类可以只记录一个特殊的位置，这里参考抄袭大佬们的做法是记录每个查询区间最右的每个种类，然后就是正常的树状数组。\r\n我们再更新位置的时候，从左向右遍历。之前若是记录过位置的，把那个记录的位置的前缀和\r\n-1，把现在这个枚举到的位置的前缀和 +1。最后只需再更新位置以及答案。\r\n最后按照询问的顺序进行输出即可~\r\n\r\nUPD 2021.7.8 SP 3267 和这题一样（\r\n\r\n82 | P1966 火柴排队 [NOIP2013TG]\r\nP1966 火柴排队\r\n[NOIP2013TG] \r\n这个题思想非常之巧妙，虽然我想了半天没想出来，爬了就是了。\r\n最一开始搞了个瞎搞的玩意，放在最后说，反正全 WA（\r\n这个题利用了一个很巧妙地东西就是这里树状数组维护的是一个“符合数列”的下标，然后求的这个数组的逆序对个数。\r\n这很像很久之前做的某个求最长公共子序列的 DP 题。\r\n下面放一下代码核心部分，毕竟还是很妙的。。\r\n1234567891011121314151617I bool cmpa(LL x,LL y){Heriko a[x]&lt;a[y];}I bool cmpb(LL x,LL y){Heriko b[x]&lt;b[y];}...S main(){    fr(n);    for(R LL i=1;i&lt;=n;++i) da[i]=db[i]=i;    for(R LL i=1;i&lt;=n;++i) fr(a[i]);    for(R LL i=1;i&lt;=n;++i) fr(b[i]);    sort(da+1,da+1+n,cmpa);sort(db+1,db+1+n,cmpb);    for(R LL i=1;i&lt;=n;++i) qq[da[i]]=db[i];    for(R LL i=n;i&gt;=1;--i) ans+=query(qq[i]-1)%mod,modify(qq[i],1);    fw(ans%mod);    Heriko Deltana;}\r\n然后我瞎搞的做法就是类似于凑，算出来两列对应位置的差，然后依次判断两个是否为零，否则就消（\r\n能过样例就离谱......\r\n既然正确性不对那就不仔细说了~\r\n话说这里破 1k 行了呢（在我习惯性的空行的情况下）。\r\n\r\n83 | P4933 大师\r\nP4933 大师\r\n\r\n非常熟悉我的同学应该知道我为什么要做这道题（\r\n因为是等差数列，所以在区间内对公差进行枚举，每次更新。\r\n不写更多的说明是因为我太菜了只会看题解不知道该说些啥（\r\n84 | P2303 Longge 的问题\r\nP2303 Longge\r\n的问题 \r\n上来显然是要煺柿子：\r\n\r\n然后我们枚举因数即可。\r\n85 | P4145\r\n上帝造题的七分钟 2 / 花神游历各国\r\nP4145\r\n上帝造题的七分钟 2 / 花神游历各国\r\n\r\n这个题要区间修改和区间查询，于是我就写了个线段树。\r\n本来是想着能不能煺煺柿子用 LazyTag\r\n去做，但是没煺出来，于是突然想着能不能暴力去做。一看数据\r\n1e5，于是就直接去用线段树去维护区间最大值和区间和。\r\n这里维护区间最大值的原因是，题目要求下取整，而我们知道不断开根的话这个值会趋近于\r\n1，所以当这个区间最大值小于等于 1 的时候我们就不去修改了。\r\n86 | P1382 楼房\r\nP1382 楼房\r\n\r\n这个题算是线段树的一个变种，这个题可能是子节点运用的最充分的线段树？\r\n这个题上来需要先对数据进行离散化，然后在修改的时候改为确定单点修改。\r\n现在真的是对我来说蓝题就难度上来了\r\n87 | P1438 无聊的数列\r\nP1438 无聊的数列\r\n\r\n这道题无聊，但是不完全有意思。\r\n首先这道题一眼就是树状数组或者线段树，可惜我不会用树状数组解决这，就爬线段树。\r\n看了一眼 Tag\r\n发现这道题有个“差分”，于是就思考怎么把等差数列用差分数组⛏掉。\r\n让差分数列来简化在区间 \r\n上加等差数列的运算：在 \r\n上加上首项，\r\n上减去末项，中间加上公差即可。\r\n然后就是线段树板子（\r\n88 | P2257 YY的GCD\r\nP2257 YY的GCD\r\n\r\n这道题事一道要用到莫比乌斯反演的题（\r\n但是我不是很会就只能按照别人煺得柿子来算，还被卡了 long long\r\n......\r\n因为不想再打 \r\n于是就截图力（\r\n\r\n89 | P2205\r\n[USACO13JAN]Painting the Fence S\r\nP2205\r\n[USACO13JAN]Painting the Fence S\r\n\r\n扫描线 + 差分，前者用来判断当前线段是否加到要求的 k\r\n以上，后者是简化在区间内加同一个数。\r\n但是因为本题的数据范围不小，因此我们需要离散化，用每次经过的区间的端点来排序。\r\n89A | P2070 刷墙\r\nP2070 刷墙\r\n\r\n我们至今未能知道为什么这道题是蓝题而上面那道是绿题。\r\n这个题只需要把上个题要输入的 k 改为 2 即可。\r\n\r\n中间去学了一些平衡树，于是可能没太做什么题\r\n\r\n90 | P7075 儒略日 [CSP-S2020]\r\nP7075 儒略日\r\n[CSP-S2020] \r\n做这道题的缘由有两个，第一个是想看看去年那个“远近闻名”的儒略日，第二个是想把这个题当作我\r\nAC 的第 60 道绿题。\r\n不得不说这道题是真的恶心，把这么一个搞人心态题放在 T1......\r\n大约就是使劲分类讨论，细节多的离谱......\r\n实际上把分类离清楚了，就很好想了。大约是分成这样几类：-4317 年 ~ 1999\r\n年，一共是 2451545 天。\r\n然后是 2000 年及以后的。\r\n需要一个判断闰年的函数，以及判断下一天的函数（这个函数中需要考虑很多特判，比如跨公元前后和\r\n1582 年，还有就是闰年，不过想清楚了还是很好打的）\r\n\r\n函数里还需要一些玄学操作......\r\n总之这道题在模拟难度上看我觉得至少是个蓝，绿有点低。\r\n总之  罢。\r\n91 | P7076 动物园 [CSP-S2020]\r\nP7076 动物园\r\n[CSP-S2020] \r\n感觉这道题才是名副其实的\r\nT1，看起来题面非常的模糊，但是数据范围里的一个数据保证，就让人很快乐。\r\n\r\n数据保证所有 \r\n互不相同，所有的  互不相同。\r\n\r\n因此我们只需要考虑哪些是被要求过一定需要，否则就是一定没有，然后我们剩下的的部分中选取是\r\n1 的位的个数即可。\r\n因为问的是还能有多少，所以最后显然答案是 。\r\n这才是真正的 T1 啊，绿的合情合理，真是为去年把儒略日出在 T1\r\n的人的家人担忧（\r\n总之  罢。\r\n92 | P2184 贪婪大陆\r\nP2184 贪婪大陆\r\n\r\n一眼树状数组+差分，但是最一开始假了。这样例也太水了点，最一开始以为直接用树状数组维护一个差分数组的前缀和就行，但是没想到这完全假掉。\r\n但是还好大体的思路仍然是树状数组+差分，不过需要一些变通，为我们维护的东西变成了重叠数（也就是区间叠加数），把\r\n\r\n数组再开一维，表示以这个点为开头（0）还是结尾（1），最后输出 \r\n即可。\r\n其实就是建了两个树状数组分别维护区间头和区间尾。\r\n93 | P5664 Emiya 家今天的饭\r\n[CSP-S2019]\r\nP5664 Emiya\r\n家今天的饭 [CSP-S2019] \r\n这题就离谱！调了一下午！\r\n大约思路就是统计不可行的方案的个数，然后 mod 减一下就是答案。\r\n大约是看了题解里 Akarui\r\n的思路。\r\n94 | P2894 Hotel G [USACO08FEB]\r\nP2894 Hotel G\r\n[USACO08FEB] \r\n这道题显然是线段树去解，不过在这里要维护的东西很不一样。\r\n因为是每次要从左端开始找，所以我们维护一个左端最大值，同时我们也要维护一个右端最大值，具体原因下面会说。\r\n同时我们要维护当前有多少房间是有人住的（其实维护没人住的也行，毕竟区间是给定的），然后要维护一个最大值。\r\n而我们的 Tag\r\n就是表示当前要把这个区间修改为住或不住。\r\n我们考虑到区间的最大值不一定会全部取自左右（这里说的左右是二分后的左右区间，也就是左右儿子），还可能跨过\r\nmid，因此我们在更新最大值的时候，不光要把左右区间（左右儿子的最大值）考虑进来，还要考虑跨过中间的值，也就是这样：\r\nt[x].val=max(max(t[lc(x)].val,t[rc(x)].val),t[lc(x)].rmx+t[rc(x)].lmx);\r\n95 | P4059 找爸爸\r\nP4059 找爸爸\r\n\r\n写了题解，在这里（\r\n96 | P2341 受欢迎的牛 G\r\n[USACO03FALL] [HAOI2006]\r\nP2341 受欢迎的牛 G\r\n[USACO03FALL] [HAOI2006]\r\n\r\n这题目长度就离谱，这河南这么屑的吗，06 年省选出个 03 年 USACO\r\n原题\r\n这个题题目看上去就非常显然，Tarjan\r\n缩点然后判断每个强连通分量内有几个结点（奶牛~）\r\n96 | P3718 Alter [AHOI2017]\r\nP3718 Alter\r\n[AHOI2017] \r\n不知道是 AHOI17 的第几道题，但是还是蛮水的。\r\n大约经历就是从骗分到优先队列到二分正解。\r\n最一开始的骗分因为觉得贪心贪的太拉就写了一半放弃了，然后就在我那个骗分的基础上写了个优先队列，然后在我交之前居然发现这玩意假了，然后就囸了一下题解写了个二分。\r\n97 | P1896 互不侵犯 [SCOI2005]\r\nP1896 互不侵犯\r\n[SCOI2005] \r\n算是状压的模板题罢，我们考虑用二进制数来表示我们的国王们都放在了哪里。\r\n98 | P2756 飞行员配对方案问题\r\nP2756\r\n飞行员配对方案问题 \r\n显然是二分图最大匹配，把外籍的飞行员放在左边，英籍的放在右边。\r\n对于左边的每个点跑一边匈牙利即可。\r\n99 | P1330 封锁阳光大学\r\nP1330\r\n封锁阳光大学 \r\n这道题的数据如果是个无向图可以用二分图的判定 DFS\r\n来做，但是数据并没有保证图是联通的。\r\n但是我们可以仍然去参考染色的思想，实际上 DFS\r\n根本不用改太多，只不过每次染色的时候加上当前是染了什么颜色即可。\r\n然后每次 ans\r\n加上两个颜色中比较小的那个即可（因为我们要最少的河蟹）。\r\n100 | P1129 矩阵游戏 [ZJOI2007]\r\nP1129 矩阵游戏\r\n[ZJOI2007] \r\n是一道显然的二分图最大匹配！考虑到我们每次能够调换的是行和列，于是我们在输入时遇到\r\n1 时就把 i 和 j+n 建边，然后正常的跑匈牙利，最后判断一下\r\nans&gt;=n 是否成立即可。\r\n第 100 道题了！纪念一下：\r\n\r\n101 | P2740 Drainage Ditches\r\n[USACO4.2]\r\nP2740 Drainage\r\nDitches [USACO4.2] \r\n不得不说 USACO 的题在洛谷上的题名都好长......\r\n是一道网络最大流的板子题， 和  都可以过，数据还贼水......\r\n102 | P1343 地震逃生\r\nP1343 地震逃生\r\n\r\n又是一道网络最大流的板子题，这个数据范围也是  和 \r\n都可以过，不过为了保险起见，还是写了  。\r\n这个题就一点和 # 101 以及板子不一样：最后要判断一下\r\nmaxflow 是不是为 \r\n来看能不能到达终点。\r\n还有就是为什么不行就要输出 \r\n啊（\r\nBing 翻译过来是 “大麦尼济南圣牛！”？？？？\r\n难不成是“Orz 您济南神犇？”\r\n103 | SP300 &amp; UVA1660 Cable\r\nTV Network\r\nSP300 Cable TV\r\nNetwork \r\nUVA1660 Cable TV\r\nNetwork \r\n这  和  的重题率是真的高......\r\n直接把我紫题整到 10 AC 祭~\r\n好了不说废话，我写的题解放在这里了。\r\n104 | P2055 假期的宿舍\r\n[ZJOI2009]\r\nP2055 假期的宿舍\r\n[ZJOI2009] \r\n显然是要用到二分图最大匹配，于是我决定就用匈牙利来做（\r\n这个题麻烦的是有很多的约束条件，不过建模还是比较好想的，左边为人，右边是床。\r\n最一开始我在 \r\n的时候一次双向，然后卡 70pts 卡的我很懵。\r\n其实这是不对的啊，这毕竟不是飞行员配对，我们总不能让床睡在人上罢（\r\n（其实这样对不对好像也和存图的方式有关，我直接一个二维数组模拟邻接表存图就貌似不行）\r\n105 | P3522 TEM-Temperature\r\n[POI2011]\r\n洛谷 | P3522\r\nTEM-Temperature [POI2011]\r\n\r\nLOJ | #2164. [POI2011 R2 D2]\r\n气温Temperature\r\n（推荐去 LOJ 做，有更好的翻译和更强的数据）\r\n是单调队列题（\r\n这个题和普通的单调队列不一样的点在于这道题给出的是一个区间，要求你求出最长的不下降天数。\r\n枚举 i 进队的时候考虑如下两点：\r\n\r\n如果第 i\r\n天的最高温度小于当前队首的最小温度，将队首出队。\r\n如果当前队列中最低温度最高的天不在队首，就把他调至队首（让队尾出队）。\r\n\r\n待这两个条件全部考虑完之后，让第 i 天进队。\r\n那么如何计算连续的天数呢（\r\n不知道。\r\n最一开始确实是不知道，题解里面说到，在这几天之前的那一天一定是出队的，于是连续的天数就是\r\ni-q[hd-1] ，然后每次和 ans 取个 。\r\n最一开始不会算连续天数，于是就莽着去搞连续的出入队关系，最后居然还把样例搞过了，然后放在\r\nLOJ 上一看，假了......\r\n今天逐渐的开始用起来\r\nLOJ，确实是环境要比洛谷干净的多，评测机跑的比香港记者还快，于是从这道题开始部分题会加上\r\nLOJ 的题目链接，不过还是以洛谷为主。\r\n106 | P3512 PIL-Pilots [POI2010]\r\n洛谷 | P3512\r\nPIL-Pilots [POI2010] \r\nLOJ | [POI2010] 驾驶员 Pilots\r\n还是一道单调队列（话说为什么学长光扔单调队列题啊）\r\n因为题目要求是最大值和最小值的差的绝对值不超过 ，于是我们就要去时刻维护区间最大值和最小值，所以我们要用\r\nST表 单调队列。\r\n考虑维护两条单调队列，一条是最大值的单调队列，另外一条是最小值的，都是入队的时候常规的单调队列判断。\r\n只不过有一点需要特殊关注：当任意一条队列中只剩下一个元素的时候，将另外一个队列的队首出队，然后记录这个刚刚出队的元素。\r\n107 | P2841 &amp; P1402 &amp; P1231\r\n洛谷 | P2841 Dining\r\nG \r\n洛谷 | P1402\r\n酒店之王 \r\n洛谷 | P1231\r\n教辅的组成 \r\n都是网络流水题的样子，还是三倍经验的说~\r\n因为每个人（P1402） / 书（P1231） / cow（P2841）\r\n的需求都是两个，而且只能选一次，于是我们就把 人 / 书 / cow\r\n拆成两个点，自己连起来，然后再和其要求连接起来。然后经典人连源点，需求连汇点，然后跑\r\nDinic。\r\n108 | CF438D The Child and\r\nSequence\r\n洛谷 | CF438D The\r\nChild and Sequence \r\n话说这题目翻译过来就是“孩子和序列”\r\n线段树的裸题，看似区间取模的复杂度难搞而且没有什么区间性质，但是我们考虑以下两点：\r\n\r\n如果要计算 x%y 而 ，则这次取模操作没有实质意义。\r\n当我们进行一定次的取模之后，x 只会是 0 或 1，而上文所述的次数是\r\n 级别的。\r\n\r\n针对第一条，我们维护区间的最大值，在要进行区间取模的时候判断一下即可，针对第二条，我们能知道区间取模的复杂度约为\r\n，那么总的时间复杂度就是\r\n 级别的。\r\n于是就线段树随便写。\r\n109 | P1659\r\n[国家集训队]拉拉队排练\r\n洛谷 | P1659\r\n[国家集训队]拉拉队排练 \r\n是一道用 Manacher 算法的题，相比于板子，我们需要再开一个桶，然后每次\r\np[i]-1 为奇数的时候往桶里加一次，最后需要这样处理\r\nans：\r\n12345678for(R LL i=n;i&gt;=1;--i){    if(i%2==0) continue;    tot+=cnt[i];    if(k&gt;=tot) ans=(ans*FastP(i,tot))%mod,k-=tot;    else {ans=(ans*FastP(i,k))%mod,k-=tot;break;}}if(k&gt;0) ans=-1;\r\n因为这道题有一个测试点的  在\r\n1e12 级别，所以要来个快速幂防止炸 longlong。\r\n110 | P1345\r\nTelecowmunication[USACO5.4]\r\n洛谷 | P1345\r\nTelecowmunication[USACO5.4]\r\n\r\n这道题非常显然的网络流，然后我就去莽 Dinic\r\n跑最大流求最小割了，但是兴奋的打完 Dinic，开始写 main\r\n包的时候，发现这道题居然是割点，但是又发现求割边能过样例于是就去交了一发，这数据水的，我有\r\n80pts。\r\n于是就懵逼了，于是就看题解，发现是拆点，即为把一个点拆为两个点，将这两个点相连，然后删掉这个点的操作就相当于去掉这两点之间的边，于是就转化为求最小割了（\r\n111 | P1361 小M的作物\r\n洛谷 | P1361\r\n小M的作物 \r\n~~ [数据销毁] 卡常题~~\r\n本来以为是个挺正常的拆点跑 Dinic，没想到这题 [数据销毁]\r\n卡常......\r\n看了讨论区发现了一个简单的优化，好像对于这种类似稠密的图很有作用，即在\r\nDFS 中加入：\r\nif(!rst) Heriko flow;\r\n112 | P2936 Total Flow S\r\n[USACO09JAN]\r\n洛谷 | P2936 Total\r\nFlow S [USACO09JAN] \r\n是一道网络流的板子题，实际上题目中所述的我们可以的对水管的简化就是变相的简述了一下我们如何暴力找最大流，也就是说这道题是让我们求最大流，于是乎我们直接跑一边\r\nDinic 即可。\r\n113 | P3931 SAC E#1 - 一道难题\r\nTree\r\n洛谷 | P3931 SAC E#1\r\n- 一道难题 Tree \r\n大概就是一道网络流的快乐板子，因为原来的图是一颗有根树，所以我们只需要构造一个虚拟汇点就能完成网络流的建模。\r\n我们只需要把叶结点连向汇点，所以我们在读入的时候记录一下每个点的出度，然后循环让叶结点和汇点连一条\r\ninf 的边即可。\r\nDinic 正常跑是 80 ms，开了 02 直接拿最优解。\r\n\r\n114 | P1879 Corn Fields G\r\n[USACO06NOV]\r\n洛谷 | P1879 Corn\r\nFields G [USACO06NOV] \r\n是一道状压 DP，但是我 DP 太烂就完全不会。\r\n记录了能否被选中，是通过左移右移来实现的（题目要求不能选相邻的草地，而我们每次考虑一行，于是只需要考虑左移右移）\r\n115 | P4016 负载平衡问题\r\n洛谷 | P4016\r\n负载平衡问题 \r\n显然这是一个要转化为费用流的题。\r\n我们考虑这样建图：如果当前点的值 a[i] 小于平均值\r\nper，那么我们把这个点和源点连一条容量为\r\nper-a[i] 的边，费用为 0；反之，若当前点的值\r\na[i] 大于平均值，那么把这个点和汇点相连，同样是费用\r\n0，容量改为 a[i]-per。\r\n然后因为原本的图是一个环，还是无向图，于是我们再把图上本来就有的边建好，正边费用为\r\n1，反边费用为 -1，正边容量 inf，反边容量 0。\r\n实际上还有贪心数学做法，在下面两道题说。\r\n116 | P2512 &amp; UVA11300\r\n洛谷 | P2512\r\n[HAOI2008] 糖果传递 \r\n洛谷 |\r\nUVA11300 \r\n本来以为是三倍经验，没想到 116 这两个题比 115\r\n数据范围大，不能费用流，于是乎就数学贪心做法，代码也很好懂于是就放在这里罢。（实在是不想打字了ww，取平均数大家应该都会罢)\r\n1234567fr(n);for(R LL i=1;i&lt;=n;++i) fr(a[i]);for(R LL i=1;i&lt;=n;++i) per+=a[i];per/=n;for(R LL i=1;i&lt;=n;++i) f[i]=f[i-1]-a[i]+per;sort(f+1,f+n+1);mid=f[(n+1)&gt;&gt;1];for(R LL i=1;i&lt;=n;++i) ans+=Habs(f[i]-mid);fw(ans,1);\r\n117 | P2668 斗地主 [NOIP2015 TG]\r\n洛谷 | P2668 斗地主\r\n[NOIP2015 TG] \r\n哪个亲(【数据销毁】)爱(【数据销毁】)的学长在团队题单里放的斗地主？？？？？？？我爱您！！1\r\n这个题思路简单清晰数据范围小爆搜可过复杂度优无常数困扰真是一道不可多得的水题呢！！1\r\n啊那她为什么是蓝的呢？\r\n因为她是【数据销毁】的模拟！\r\n思路很简单，只需要分以下几种情况，而且贪心的顺序我在这里也直接排好，因为这是显然的：\r\n顺子  四带  三带 \r\n对子、王炸、炸弹、单走一个六\r\n展开就是：\r\n顺子单顺双顺三顺三带四带四带两对对子、单走、王炸、炸弹\r\n别问我为什么用 ，问就是被这题做疯了。\r\n到这里都很平常对吧，然后我就写嘛，从四点开始写。\r\n我在写之前直接放话，说儒略日比这分支多比这难这怎么是蓝的 Julian\r\n是绿的。\r\n四点半写完第一遍，没过样例，感觉可能有些小地方没写对，静态查了一边错，觉得自己可能查不太出来，于是就重构了一遍。\r\n重构完大约五点多一点，我想这次可能没什么问题了吧，于是就跑样例，然后，又™没过！\r\n然后就查错，找不到错；和题解差错，找不到错；和学长的代码差错，找不到错；和学姐的代码差错，找不到错.....\r\n然后简单重构了一些小地方毫无效果。\r\n然后就生气了，五点半正好也是该吃饭了，就去吃饭了。\r\n六点回来之后快速和以上三者的代码又进行了一遍逐行对比之后发现还是查不出来，然后考虑控制变量法进行差错。\r\n把题解的顺子部分复制过来，然后我以为样例 1 过了，实际上是我用样例 2\r\n跑出来样例 1 的结果。\r\n然后我就很开心觉得这题终于能调出来了，然后把顺子部分重构。重构着，突然想起来刚才好像我放的样例\r\n1 的输入，然后我去试了一下果然 nmd 白高兴了......\r\n然后我就想着反正也重构了就继续重构罢，然后重构完了就去试样例，发现啊完全就和刚才一样，艹。\r\n然后就把题解的后半部分复制过来发现还是不对，一气之下就把 DFS\r\n全都复制过来，然后跑，然后就过了™样例。\r\n然后我就用手指着两份代码进行静态人眼高端差错，然后无果。\r\n这个时候 Dfkuaid 建议我去重构，我说重构个卵我重构了 n 遍了。\r\n最后还是去重构了，然后重构完大约七点，不知道为什么就 RE\r\n了，后来调试发现其实是死循环了，然后也不知道是为什么，然后就又一次一一对照静态差错，然后我就硬是找不出来。\r\n然后 Dfkuaid\r\n发现我有个循环变量写串了，然后我就改过来，走样例，好我过了，然后提交，过了，彳亍，正好七点半。\r\n然后我去看我重构之前的代码，到现在也不知道是哪错了，神™题！！1\r\n所以最后得出来的结果就是 OIer\r\n请必备黄帝内经！我现在还感觉想把电脑砸了但是这不是我电脑我不行（话说就算是我的也不行的说）\r\n118 | P2071 座位安排\r\n洛谷 | P2071\r\n座位安排 \r\n是一道显然的二分图最大匹配，我用网络流做的，总的来说体验不错，个球。\r\n最一开始的思路是把一排座位拆为两个点，然后连容量为 1\r\n的边到汇点，但是发现自己不会对应起来边了，于是就不拆了，把容量改为\r\n2。\r\n最一开始写的 ISAP，写挂了好像，于是就捡起来\r\nDinic，然后又写挂了......\r\n最后是发现把所有的 r[i].val 都写成 r[i].to\r\n了......\r\n119 | P2319 超级英雄 [HNOI2006]\r\n洛谷 | P2319\r\n超级英雄 [HNOI2006] \r\n又是一道显然的二分图最大匹配，但是用网络流不好做，于是就写个 Hungary\r\n，然后一直过不了样例，最后发现是写网络流写习惯了建了条反向边（）\r\n120 | P1350 车的放置\r\n洛谷 | P1350\r\n车的放置 \r\n不会，看了题解，爬了。\r\n\r\n121 | P1640 连续攻击游戏\r\n[SCOI2010]\r\n洛谷 | P1640\r\n连续攻击游戏 [SCOI2010] \r\n实际上这个题拖了好久了才做，今天终于发现原来我之前一直不想做的原因是我读错题了.......\r\n实际上这个题非常的简单，把属性放左边，装备放在右边跑 Hungary\r\n即可。\r\n但是还有一点就是时间戳优化，memset 太慢。\r\n122 | P2057\r\n善意的投票 [SHOI2007]/冠军调查 [JLOI2010]\r\n洛谷 | P2057\r\n善意的投票 [SHOI2007]/冠军调查 [JLOI2010]\r\n\r\n一眼最大流最小割，转化：我们把小朋友们割开跑 Dinic 即可，但是我 Dinic\r\n又写挂了？？？\r\n还是挺好吃的ww\r\n123 | P2598 狼和羊的故事\r\n[ZJOI2009]\r\n洛谷 | P2598\r\n狼和羊的故事 [ZJOI2009] \r\n考虑最小割，我们这样连边：狼的领地和源点相连（INF），羊的领地和汇点相连（INF），然后把每个格子和周围四个格子相连（1）。\r\n实际上这样建图的话，我们割掉一条边就相当于建上篱笆啦~\r\n124 | P2774 方格取数问题\r\n洛谷 | P2774\r\n方格取数问题 \r\n做了羊和狼的故事之后回来看这个题，发现思想基本一致！\r\n上一题是把羊和狼分类，这次我们把 (i+j)&amp;1\r\n作为条件分类，剩下的和上一道基本一致，只不过在和周围连边的时候，边的容量是这个方格的权值。\r\n然后最后输出 sum-maxflow，sum\r\n是所有方格权值和。\r\n125 | P4001 狼抓兔子\r\n[ICPC-Beijing 2006]\r\n洛谷 | P4001\r\n狼抓兔子 [ICPC-Beijing 2006]\r\n\r\n算是很离谱了啊（\r\n网络流很好想，可是这题正解貌似不是网络流的样子（\r\n但是还是过去了，但是留下了一个疑惑\r\n然后 @Prean\r\n的解答如下：\r\n\r\n\r\n\r\n\r\n126 | P2580\r\n于是他错误的点名开始了\r\n洛谷 | P2580\r\n于是他错误的点名开始了 \r\nunordered_map 直接莽过（\r\nAC 400 祭，提交 1.41k，比例大约是 2.83%，下降不少（（（\r\n127 | P1251 餐巾计划问题\r\n洛谷 | P1251\r\n餐巾计划问题 \r\nem，是一个费用流问题，写一个 SSP\r\n即可，但是今天写的时候挺玄学的......\r\n建图如下：\r\n\r\n每天晚上从起点获得 x 条脏餐巾\r\n每天白天,向汇点提供 x 条干净的餐巾,流满时表示第 i\r\n天的餐巾够用\r\n每天晚上可以将脏餐巾留到第二天晚上\r\n每天晚上可以送去快洗部,在第 i+c 天早上收到餐巾\r\n每天晚上可以送去慢洗部,在第 i+e 天早上收到餐巾\r\n每天早上可以购买餐巾\r\n\r\n没错就是题解的注释\r\n128 | P2045 方格取数 加 强 版\r\n洛谷 | P2045\r\n方格取数 加 强 版 \r\n这个数据加强就很有意思了，加强前是最小割最大流，加强之后是最大费用最大流（\r\n既然是最大费用最大流，那么我们就跑一手 SSP（把 SPFA\r\n里面的松弛操作的大于号改为小于号）\r\n把一个格子拆成两个点，一个出点一个入点，每个入点和它对应的出点都连上两条边，一条费用为\r\n，容量为\r\n1，另外一条的容量本身这个格子的权值，费用为 0。\r\n把源点设为 ，汇点设为 ，于是我们就把每个格子和其下方和右方的格子建立联系，于是就把\r\n 和 \r\n对应的出点和入点连接起来，容量为 ，费用为 0。\r\n129 | P2153 晨跑 [SDOI2009]\r\n洛谷 | P2153 晨跑\r\n[SDOI2009] \r\n因为要一个最长的周期和一个最短的里程，所以我们考虑用最小费用最大流，即里程是费用周期是流。\r\n还是拆点，拆成一个入点一个出点，因为每个点只能过一次，所以我们连的边费用是\r\n0 ，容量为 1.\r\n然后对于题目中给出的每一条边，我们把其容量设为\r\n1，费用设为边权，然后跑 SSP。\r\n130 | P3980 志愿者招募 [NOI2008]\r\n洛谷 | P3980\r\n志愿者招募 [NOI2008] \r\n最一开始一看就是很明显的最小费用最大流，但是想了半天建图，其实志愿者之间并不难建边，但是实在是不知道如何去维护人数限制，甚至还想过去套一个背包，但是想了想这玩意硬转移的话会爆炸，然后就懵逼。\r\n然后就爬去看题解，不得不说第一篇题解确实分析的很透彻，思路很清晰（虽然他是从暴力到背包到网络流，而我是网络流到\r\n网络流+背包 到懵逼，但是并不影响理解）\r\n以下截自 Orion545\r\n的 P3980 题解\r\n\r\n此时我们需要想办法把人数限制放到图里\r\n我们考虑最大流算法：它会求出最大的流量\r\n那我们既然用一点流量表示一个人，那么为什么我们不把这个“需要用人”的限制，放到另外几条边上呢？\r\n我们在点(i,i+1)之间建边，设流量为-a[i]，也就是负的当天需求数，费用自然是零的\r\n然后，令上文中的志愿者(si,ti,ci)，建边(si,ti+1)，费用ci，流量无限\r\n此时我们相当于是把第i天的决策放到了第i个点和第i+1个点之间的所有边上（就是把所有点排成一排，这两个点之间的那一条位置里的所有边，包括跨过这个区间的志愿者边）\r\n需要志愿者？让它们从志愿者边上流过去，同时让人数限制边满流到-a[i]，这样求一个1-n+1的最大流，流量为0的最小费用就是雇佣人的最小费用了\r\n为了让这个限制起效，又因为网络流中流量非负，所以我们建立点SS和TT，连边(SS,1)(n+1,TT)，限制为inf，费用为0\r\n同时，我们把之前的人数限制边的流量改成(inf-a[i])，这样最终的SS-TT最大流一定是inf，而且限制依然成立\r\n\r\n131 | SP3267 DQUERY - D-query\r\n洛谷 | SP3267\r\nDQUERY - D-query \r\n想见识一下什么是莫队，于是乎去找个博客学习，然后就跟着那个博客做了这道题（\r\n实际上这个题先是发现和 HH\r\n的项链一样于是就直接先用线段树双倍经验（\r\n先挖个坑，写博客的时候把这个题当作例题，然后再挂个 Link\r\n在这。\r\n132 | P1903 数颜色 / 维护队列\r\n[国家集训队]\r\n洛谷 | P1903 数颜色\r\n/ 维护队列 [国家集训队] \r\n和上面那个题一样，还是等我写完博客挂 Link。\r\n133 | P1494 小Z的袜子\r\n[国家集训队]\r\n洛谷 | P1494\r\n小Z的袜子 [国家集训队] \r\n同上，这道也当例题，欢迎去看（\r\n134 | P2709 小B的询问\r\n洛谷 | P2709\r\n小B的询问 \r\n同上，这题又双叒叕是例题（\r\n135 | P3901 数列找不同\r\n洛谷 | P3901\r\n数列找不同 \r\n突然发现好久没做绿导致蓝题快赶上绿了（？）于是找了这个题来做其实是搜莫队标签发现就这一个紫色以下的我没做过了\r\n因为这个题是个绿的就不用它当例题了，一看不强制在线直接用莫队搞一搞（\r\n我们考虑我们让  和 \r\n指针移动的时候如何去记录这个区间是否所有的数都互不相同。\r\n第一个想法是只考虑本次转移涉及的那两个数，但显然这样并不能保证之前或之后没有相同的，Pass\r\n掉。\r\n第二个想法是考虑开一个桶，记录数的个数，假如超过了  那么显然这个询问区间就有相同的数。\r\n但是不知道为啥这个看起来挺正确的我实现挂了。\r\n于是决定把延续第二个想法得出第三个想法：当桶里的数为  就 ++cnt，若为 0 就\r\n--cnt，若最后 cnt==q[i].r-q[i].l+1\r\n那么就记录本次查询结果为 ，否则为 。\r\n然后就过了（\r\n136 | P1042 乒乓球 [NOIP2003PJ]\r\n洛谷 | P1042 乒乓球\r\n[NOIP2003PJ] \r\n怎么说呢，请了假在家自闭，然后想到 EZEC R10 Div3 A\r\n没有场切，就觉得自己模拟还是应当练一练，光会那种图论和数据结构在 T1\r\n上基本毫无作用（\r\n于是可能在家这几天就多做做模拟。\r\n这个题简单来看两种思路，第一种是边读边计算输出，第二种是先把全部字符串存下来然后判断输出。\r\n最一开始写的第一种，然后写炸了连个破模拟都能写炸我屑的离谱，于是就按照第二种，然后判断错了了......\r\n总的来说我模拟是真不行，希望今年 CSP 和 NOIP\r\n考场上不要搞离谱的模拟。\r\n137 | P2670 扫雷游戏\r\n[NOIP2015PJ]\r\n洛谷 | P2670\r\n扫雷游戏 [NOIP2015PJ] \r\n这是这整个杂题集里面第一次出现红题\r\n甚至这还是我的第 21 道红题！红题超过紫题！！！1\r\n但是nmd为什么EZEC R10 A 是个红题啊，多不给我面子啊（\r\n回归正题，这道题很显然了，对于每一个位置扫一遍其上下左右左上左下右上右下即可。\r\n138 | P1563 玩具谜题\r\n[NOIP2016TG]\r\n洛谷 | P1563\r\n玩具谜题 [NOIP2016TG] \r\n这个题还是非常迷惑的（\r\n整体思路是好想的，因为这个题数据范围不大，所以我们直接枚举一个指针按照指令跳就行。\r\n经过简单手模可以发现，如果当前玩具的朝向（0 或 1）和当前指令的方向（0\r\n或 1）相同，则把指针向右移动（加），否则向左（减）。\r\n注意模完  可能会出现指针为\r\n0，于是我们最一开始存的时候从 0 开始就好了（\r\n139 | P1328\r\n生活大爆炸版石头剪刀布 [NOIP2014TG]\r\n洛谷 | P1328\r\n生活大爆炸版石头剪刀布 [NOIP2014TG]\r\n\r\n大约也是一道非常简单的模拟罢，因为空间和时间都非常冗余，所以直接随便开即可（bushi\r\n用 cna 和 cnb\r\n来分别记录当前到没个人周期的第几位即可（\r\n140 | P3174 毛毛虫 [HAOI2009]\r\n洛谷 | P3174\r\n[HAOI2009]毛毛虫 \r\n大约是一个 SDSC 都没有写这个，于是回来之后觉得应当继续接着写（\r\n这道题是一个显然的树形 DP，不知道出题人在想啥给了个完全木大的\r\nm。\r\n设  为以 \r\n为根的最长链，这样设是因为这个题实际上就是在找最长的链。\r\n不过我们要在 DFS\r\n的时候同时维护最长链和次长链，因为这个题可能会出现毛毛虫跨过根节点的情况，但是这种情况也可以是看作最多两条链连在一起组成的，于是我们同时维护最长链和次长链。\r\n141 | P1472 奶牛家谱 Cow\r\nPedigrees [USACO2.3]\r\n洛谷 | P1472\r\n奶牛家谱 Cow Pedigrees [USACO2.3]\r\n\r\n嗯，奶牛家谱果然和奶牛没有一点关系。\r\n142 | P1453 城市环路\r\n洛谷 | P1453\r\n城市环路 \r\n树形 DP，这道题有一点不太一样的是，本题给出的图是一个基环树。\r\n我们设  表示以  为根的子树的最大独立集，0 和 1 表示选\r\n 或不选 。\r\n143 | P3205 合唱队 [HNOI2010]\r\n洛谷 | P3205 合唱队\r\n[HNOI2010] \r\n用了一种类似小学 插空法 的东西。\r\n144 | P5999 kangaroo [CEOI2016]\r\n洛谷 | P5999\r\nkangaroo [CEOI2016] \r\n特判边界情况。\r\n12if(i==s or i==t) f[i][j]=(f[i-1][j]+f[i-1][j-1]+MOD)%MOD;else f[i][j]=(f[i-1][j-1]*(j-(i&gt;s)-(i&gt;t))+f[i-1][j+1]*j+MOD)%MOD;\r\n145 | P1550 Watering Hole G\r\n[USACO08OCT]\r\n洛谷 | P1550\r\nWatering Hole G [USACO08OCT]\r\n\r\n在普通边的基础上我们连 i 和 n+1\r\n（一个虚拟点），权值为费用，代表挖井。\r\n146 | P3535 TOU-Tour de\r\nByteotia [POI2012]\r\n洛谷 | P3535\r\nTOU-Tour de Byteotia [POI2012]\r\n\r\n并查集判环，这里因为是让编号小于 k\r\n的结点不在环上，于是我们可以先把大于 k 的并在一起。\r\n然后再统计一下小于等于 k 的即可。\r\n写了[题解]。\r\n147 | P3916 图的遍历\r\n洛谷 | P3916\r\n图的遍历 \r\n反向建边 BFS。\r\n148 | P4878 Layout G\r\n[USACO05DEC]\r\n洛谷 | P4878 Layout\r\nG [USACO05DEC] \r\n差分约束的一个相对模板的题（？）\r\n题目要求的距离远近直接转换化为不等式建边即可，但是要主要每两个牛之间都要建边。\r\n149 | P3128 Max Flow P\r\n[USACO15DEC]\r\n洛谷 | P3128 Max\r\nFlow P [USACO15DEC] \r\nLCA + 树上差分，LCA 是倍增做的。\r\n150 | P2158 仪仗队 [SDOI2008]\r\n洛谷 | P2158 仪仗队\r\n[SDOI2008] \r\n是一道欧拉函数的板子题的样子，算是回忆了一下欧拉筛求欧拉函数（\r\n151 | CF1559A Mocha and Math\r\n洛谷 | CF1559A\r\nMocha and Math （预计\r\n\r\nCodeforces\r\n| CF1559A Mocha and Math\r\n送分 A 题就不多说罢……直接暴力 &amp; 就行\r\n昨天晚上本来是想写个题解，写完之后手残按了书签链接……然后就没再写，今天回来一看已经\r\n10 篇题解了就懒得写了。\r\n152 | CF1559D1 Mocha and\r\nDiana (Easy Version)\r\n洛谷 | CF1559D1\r\nMocha and Diana (Easy Version)\r\n（预计\r\n\r\nCodeforces\r\n| CF1559D1 Mocha and Diana (Easy Version)\r\n题目大意是有两个森林，问你在保证还是两个森林的情况下还能连多少边。\r\n这个 EZ Ver 的 ，所以直接暴力枚举即可。\r\n用两个并查集来分别维护这两个森林即可。\r\n153 | P1108 低价购买 &amp; P2687\r\n洛谷 | P1108\r\n低价购买 \r\n这个题实际上是两个 DP 的叠加。\r\nP2687\r\n的链接就不放了，反正很好找，两者题都一样就是了，后者需要高精。\r\n154 | T189961 [Wdoi R3] 夜雀\r\ndreaming\r\n因为这个比赛的题都还没入主题库，于是就先挂这个链接，等进了主题库再改链接罢。\r\n洛谷 | T189961\r\n[Wdoi R3] 夜雀 dreaming （预计\r\n\r\n这个题是 Wdoi R3 的 A 题，也就是签到题，但是很可惜的我没签上（\r\n简化版的题意算是很清晰了，因为时间轴的上限是\r\n，所以直接求出所有的时间点的倍数再去判断是木大的。\r\n于是我们考虑同一个时间会在什么情况下出现两个不同的菜。因为放入菜的时间都是每个命令时间的倍数，所以我们考虑对于两个时间点的\r\n，那么根据题意我们最后选取的\r\n\r\n越小越好，于是我们在枚举之后进行一次排序。（用优先队列也可以）\r\n因为题目中计算每个时间点所点菜的公式已经给出，于是我们就可以每次取出\r\n\r\n后计算对应的两条命令在这个时间点的菜，若不同那么这个时间点就是答案。\r\n……但是这样还不对，因为假如相同的话，我们再考虑 \r\n处，如果再相同就真的没解了。场上我就因为没考虑另外一种情况而喜提两个\r\nWA 痛失签到机会。\r\n感谢 @Fan_Tuan\r\n大佬帮忙纠错。\r\n155 | P4310 绝世好题\r\n洛谷 | P4310\r\n绝世好题 \r\n所以绝世好题就是良心 DP（\r\n这个题  的 DP\r\n思路很好想：\r\n12345for(R int i(1);i&lt;=n;++i)    for(R int j(1);j&lt;i;++j)        if(a[i]&amp;a[j])            f[i]=Hmax(f[i],f[j]+1);\r\n即使这个题的数据及其水，这个做法也是不能 AC 哒，只有 90pts （\r\n于是我们考虑优化。在不改变状态设计的情况下，我们只能着手于内层循环。考虑\r\n\r\n时我们发现实际上有很多的状态都被浪费掉了，她们到达不了更大的答案。\r\n于是我们进行一个最优性剪枝，记录当前的最大答案。\r\n156 | P1944 最长括号匹配\r\n洛谷 | P1944\r\n最长括号匹配 \r\n看起来是一道相当相当相当相当相当相当相当相当相当相当相当相当相当相当相当相当相当相当相当相当相当相当的\r\nDP （\r\n核心如下：\r\n123456for(R int i(2);i&lt;=n;++i)    {        if(c[i]=='(' or c[i]=='[') continue;        if((c[i]==')' and c[i-f[i-1]-1]=='(') or (c[i]==']' and c[i-f[i-1]-1]=='[')) f[i]=f[i-1]+f[i-f[i-1]-2]+2;        if(f[i]&gt;len) len=f[i],pos=i;    }\r\nlen 记录的是最长的匹配括号序列的长度，pos 则是最后能匹配的位置。\r\n157 | P2340 Cow Exhibition G\r\n[USACO03FALL]\r\n洛谷 | P2340 Cow\r\nExhibition G [USACO03FALL]\r\n\r\n是一道清新的背包！\r\n如果 iq&gt;=0 那么跑 01 背包，反之跑完全背包。\r\n不过由于可能会出现负数的情况所以我们多用浪费一倍空间去干掉可能出现的负数下标的情况。\r\n158 | T193697 信号塔\r\n洛谷 | T193697\r\n信号塔 （预计\r\n\r\n据说是巨大重题来着，虽然我没做过但也是觉得眼熟，好像来自于某个神必的结论来着（\r\n中午刚到机房比较热，就先随便开个题 Cold down，上来一看 D2A\r\n是个交互题我不会（虽然后来看算是幸好没有做 A），于是去做 D2B。\r\n这题一看就觉得眼熟，感觉是个 x%y==0\r\n之类的结论题，然后看了下样例只有 12 的倍数输出了 1，就先交了个\r\nx%12==0 的，全 WA。\r\n然后去手模了一下发现其实是 x%6==0 ，于是交上去得了 10\r\npts（\r\n于是去看数据范围，哦原来有负数，最后 20pts 还爆 ull\r\n范围了，那就先把快读的判负号去掉拿了 80 pts。\r\n最后看是不是需要高精度啥的，然后发现实际上每一位加起来判断一下是否为\r\n3 的倍数再看一眼最后一位判断是不是偶数即可。\r\n然后就交上去过了。\r\n159 | CF1560A Dislike of Threes\r\n洛谷 | CF1560A\r\nDislike of Threes （预计\r\n\r\nCodeforces\r\n| CF1560A Dislike of Threes\r\n题意简述：输出第  个个位不为\r\n 且不被  整除的数。\r\n思路简述：A 题还是一个手速题，因为 ，所以我们可以直接枚举 。\r\n160 | P3868 猜数字 [TJOI2009]\r\n洛谷 | P3868 猜数字\r\n[TJOI2009] \r\n这是一个 CRT 的题，原式可以化为：\r\n\r\n那这样就很 CRT 的板子了，但是这题的最后一个点爆 long long\r\n了，于是就写个乌速乘罢，然而题目的数据中 ，也就是说会有负数。\r\n所以我们要进行神必的提前取模来干掉负数的情况。\r\n算是题外话，这是第一个在 Manjaro Linux 上做出来的题，同时这个\r\n“简单记录.md” 也突破了 2000 行 :D\r\n\r\n161 | P1169 棋盘制作 [ZJOI2007]\r\n洛谷 | P1169\r\n棋盘制作 [ZJOI2007] \r\n是一道垂涎垂线法的例题（？）\r\n这道题定义了三个递推用的二维数组：l，r，u，分别表示从\r\n\r\n开始能到达的最远的左右位置和能向上扩展的最长长度。\r\n12345678if(f[i][j]!=f[i-1][j] and i&gt;=2){        l[i][j]=Hmax(l[i][j],l[i-1][j]);    r[i][j]=Hmin(r[i][j],r[i-1][j]);    u[i][j]=u[i-1][j]+1;}int x(r[i][j]-l[i][j]+1);int y(Hmin(x,u[i][j]));ans[0]=Hmax(ans[0],y*y);ans[1]=Hmax(ans[1],x*u[i][j]);\r\n同时因为本题给出的是一个 01\r\n矩阵，所以在判断的时候只需要判定两者不同即可符合条件，进行递推。\r\n162 | P4147 玉蟾宫\r\n洛谷 | P4147\r\n玉蟾宫 \r\n这还是一道垂线法的题，整体思路和上一题相似，还是定义三个数组来递推。\r\n从某种意义上来说这道题比上一道题简单一些。\r\n163 | P2051 中国象棋 [AHOI2009]\r\n洛谷 | P2051\r\n中国象棋 [AHOI2009] \r\n百蓝祭。\r\n是一道状压 DP，有两个大类五个情况需要讨论：\r\n123456if(k&gt;=1) f[i][j][k]+=f[i-1][j+1][k-1]*(j+1);if(j&gt;=1) f[i][j][k]+=f[i-1][j-1][k]*(m-j+1-k);if(k&gt;=2) f[i][j][k]+=f[i-1][j+2][k-2]*(((j+1)*(j+2))&gt;&gt;1);if(k&gt;=1) f[i][j][k]+=f[i-1][j][k-1]*j*(m-k+1-j);if(j&gt;=2) f[i][j][k]+=f[i-1][j-2][k]*C2(m-j+2-k);\r\n164 | P1578 奶牛浴场\r\n洛谷 | P1578\r\n奶牛浴场 \r\n还是垂线法，不过这道题的数据范围为  长，宽 ，于是我们就不能和玉蟾宫、棋盘制作一样开二维数组去做了。\r\n同时我们注意到 ，说明障碍点相对较少，于是我们可以枚举障碍点来做。\r\n参考到的题解\r\n@Ofnoname。\r\n165 | P2701 Big Barn [USACO5.3]\r\n洛谷 | P2701 Big\r\nBarn \r\n最一开始以为是跟玉蟾宫一样的板子，然而我多虑了，其实是更简单的\r\nDP。\r\n\r\n属于是 \r\n了属于是。\r\n166 | SP1805 Largest\r\nRectangle in a Histogram\r\n洛谷 | SP1805\r\nHISTOGRA - Largest Rectangle in a Histogram\r\n\r\nSPOJ | HISTOGRA -\r\nLargest Rectangle in a Histogram\r\n在这里我们因为最终极大面积肯定是出于某个位置  的面积 ，因此我们需要枚举  的位置去不断的向左右扩展。\r\n以向左为例，显然的是满足 \r\n且 \r\n时，可以继续向左扩展，即：。\r\n167 | UVA1619 Feel Good\r\n洛谷 | UVA1619\r\nFeel Good \r\nUVA (Vjudge) | Feel 🤺\r\nGood\r\n和上一题类似的扩展方式，只不过要求一个前🤺缀🤺和🤺。\r\n168 | P2216 理想的正方形\r\n[HAOI2007]\r\nLOJ | #10182.理想的正方形\r\n洛谷 | P2216\r\n理想的正方形 [HAOI2007] \r\n总之很感谢 LOJ 就是了（\r\n这个题我从开题到 AC\r\n的总时间，和斗地主差不多了，都是上午十一点到晚上七点多。\r\n突然想像头哥一样怒斥 GP2 Engine：\r\nGP2!GP2 Engine↺Uh!!!↷\r\n当然我之所以这道题从上午十一点开题做到晚上七点多只是因为我菜。\r\n这个题的题意很清晰了，要求能使得其内最大值与最小值之差最小的  的矩形，而因为题目中  都不变且  比较小，于是我们可以直接考虑去求每个\r\n\r\n中的最大值和最小值的差。\r\n我们考虑对于最大值和最小值分别用两次单调队列：\r\n\r\n先求出原矩阵中每一行所有长为 \r\n的序列内的最大值，得到一个新的矩阵。这一步求出来的是所有 \r\n大小矩阵内元素的最大值。\r\n将新矩阵的每一列所有长为 \r\n的序列内的最大值记录到一个新的矩阵中。这一步就是所有 \r\n大小矩阵内元素的最大值。\r\n将所有 \r\n大小的矩阵最小值按照上面方法求出。\r\n枚举元素，找到最小的差。\r\n\r\n然后因为某个神必原因我调了一下午（\r\n最后还是 LOJ\r\n的代码格式化启发了我让我面向题解查错了一波才找到这个神必错误……\r\n169 | P2831 愤怒的小鸟\r\n[NOIP2016TG]\r\n洛谷 | P2216\r\n理想的正方形 [HAOI2007] \r\nUh Luogu! Luogu Wisdom Engine！ Wisdom! Uh!\r\n突然找到了头哥怒斥 GP2 Engine 的感觉\r\n170 | P2331 最大子矩阵\r\n[SCOI2005]\r\n洛谷 | P2331\r\n最大子矩阵 [SCOI2005] \r\nUh Luogu! Luogu Wisdom Engine！ Wisdom! Uh!又给我推\r\nDP！\r\n算是一道分讨类的 DP ？因为 ，所以我们可以先考虑 \r\n的情况再合理推至 。\r\n讨论的情况参照的这里。\r\n171 | CF1354D Multiset\r\n洛谷 | CF1354D\r\nMultiset \r\nCF |\r\nCF1534D\r\n一道线段树？因为是维护了一个桶，所以大约是我写过最短的线段树了，本来还想拿这个题来复建线段树手感呢（\r\n因为觉得全扔进结构体里整洁于是就在其他常数比 Dfkuaid 小的情况下的慢了\r\n 秒嘤（\r\n172 | CF1181D Irrigation\r\n洛谷 | CF1181D\r\nIrrigation \r\nCF |\r\nCF1181D\r\n属于是阴间题目了属于是，这题的官方题解不超过 15\r\n行，但是我们自己想的却是  的权值线段树和权值树状数组（\r\n173 | P2245 星际导航\r\n洛谷 | P2245\r\n星际导航 \r\n属于大重题了属于是，和货车运输做法一模一样（\r\n看着旁边的 Dfkuaid 因为写的倍增求 LCA 还要改一些取  和取  的地方，我直接宣布双 set + vector 找\r\nLCA 完全胜利！！！1 （完全不用改）\r\n173 | P3959 宝藏 [NOIP2017TG]\r\n洛谷 | P3959 宝藏\r\n[NOIP2017TG] \r\n这道题的数据范围看起来就很像是个状压\r\nDP，于是我最一开始决定要用大约贪心 + 状压来写。\r\n然而想着想着发现正确性不对，如果要正确性对的话我复杂度就炸到大约\r\n 了（\r\n于是看着扶苏的题解写了一个状压 DP。\r\n174 | P2602 数字计数 [ZJOI2010]\r\nLOJ | #10169.数字计数\r\n洛谷 | P2602\r\n数字计数 [ZJOI2007] \r\n是一道数位 DP 的板子题，正好遇上洛谷日爆（\r\n采用模板化的 DFS 做法，定义  数组如下  表示是从高到低第  位， 则是数字出现次数。\r\nDFS 函数为 ，参数分别表示：从高到低第几位，要求哪个数出现的次数，当前出现次数，前导零的状态，当前位置上限的状态。\r\n175 | P6218 Round Numbers S\r\n[USACO06NOV]\r\n洛谷 | P6218 Round\r\nNumbers S [USACO06NOV] \r\n还是数位 DP，因为我在套模板，所以和上一题的区别只有  中的  变为了  和  出现次数的差。\r\n对应的， 中的  也变成了 （\r\n176 | P4317 花神的数论题\r\n洛谷 | P4317\r\n花神的数论题 \r\n又双叒是数位 DP，这道题我还是套模板， 代表第  位的乘积为 。\r\n因为这道题不需要考虑前导 ，所以\r\n 函数也变得简单：。\r\n177 | P4999 烦人的数学作业\r\n洛谷 | P4999\r\n烦人的数学作业 \r\n又双叒叕是数位 DP，这道题第一次居然读错题了认为是求 \r\n内所有数的和，我还想这题怎么样例不对啊（\r\n回归正题，这仍然能套模板，而且和数字计数很像，但是因为本题要求的东西简单一些，所以\r\n 函数中不需要记录所求数和前导\r\n 的问题。\r\n也就是变成了：。\r\n178 | P3413 SAC#1 - 萌数\r\n洛谷 | P3413 SAC#1 -\r\n萌数 \r\n虽然 De 了很长时间的 Bug，但是总体上这个题的思维难度却是不高（\r\n难就难在神必字符串，这题不把数据范围搞到  也就是个蓝题（\r\n这个题总体上还是相对于前几个只需要板子的题要难一点的，主要体现在你需要记录两个\r\n 以及奇偶不同时的判断（？）\r\n当然我字符串一塌糊涂于是去看大佬的操作，大佬是先补全的前面那个短的字符串，总之我不是很懂这神必字符串就是了，大佬总能想出巧妙的方法而我只能背模板（\r\n题外话，这个杂题简单记录的原 .md\r\n文档的大小在我打出这个题的标题和链接的时候正好达到了 100kB（\r\n\r\n\r\n179 | P4127 同类分布 [AHOI2009]\r\n洛谷 | P4127\r\n同类分布 [AHOI2009] \r\n仍然是数位 DP，仍然是能套模板。\r\n暴力枚举模数！于是我们在  和\r\n 里面加上一维来表示余数。\r\n180 | P4124 手机号码 [CQOI2016]\r\n洛谷 | P4124\r\n手机号码 [CQOI2016] \r\n数位 DP，这个题相当的良心，可以让我随便了开数组去记录信息，但是 Debug\r\n太久就是我的问题。\r\n看着空间如此宽裕，那么我就开了个 。 到  记录的是这三个连续的数， 是标志  是否满足连续相同的三个数字， 意义和之前一样， 表示有没有出现  和 。\r\n181 | P2518 计数 [HAOI2010]\r\n洛谷 | P2518 计数\r\n[HAOI2010] \r\n虽然我是跟着数位 DP 的 Tag\r\n进的这个题，但是看完之后确实觉得组合数学的感觉溢出来了（插入 ，删除 ，这真的很明显了属于是。）\r\n但是我的组合数学过于差了，看完题之后能大约知道是个什么组合意义但是我一个柿子都不会推。\r\n于是去看题解，发现第一篇题解就是组合数学做法，于是就本着体验惩罚自己太菜用\r\ngedit 写这个题。\r\n除了没有括号自动补全不太适应以外感觉比 DevC++ 好用（bushi\r\n182 | P4768 归程 [NOI2018]\r\n洛谷 | P4768 归程\r\n[NOI2018] \r\nLOJ | #2718.「NOI2018」归程\r\n这个题算是历史很悠久了，当时 SDSC D1 讲了 Kruskal\r\n重构树，然后《推荐习题》就是这个题，然后 7.16 一下午 + 晚上 + 7.17\r\n下午模拟赛前就光调这个题了，当时搞得心态非常崩溃（\r\n前几天突然在移动硬盘备份的老移动硬盘的资料里发现了我去年啥都不会的时候在\r\nNOI2020 线上同步赛大的惊天神必暴力，大概复杂度在 完全算不出来\r\n的级别，然后我想着这玩意交上去怎么着也能过掉 4 pts 左右罢，然后全\r\nTLE，但是我好像跑题了（\r\n于是在那个时候突然想起来我还有一份智熄的归程没有写完，于是就决定 500\r\nAC 祭和百粉祭的时候把这两个题干掉（\r\n然后没想到很快就 499 了，于是就在早上的机房打开了我智熄的代码（\r\n这个题的总体思路是将整个路径分为两端： 开车，\r\n走路，那么我们就需要枚举这个断点 。\r\n根据题意有水坑的地方是不能走车的，也就是说 \r\n这一段都不能有海拔低于水位线，于是我们把海拔按照降序排序。\r\n跑 Dijkstra 后 Kruskal 重构树，然后每次询问去找公共祖先即可。\r\n但是这  也挺恶心的（\r\n不过上面这些东西我基本上在一个月之前就调的差不多了（除了  用混了以外）\r\n然后最后发现是并查集的 \r\n写智熄了：\r\n12345int Find(int x){    if(x!=fa[x]) fa[x]=Find(fa[x]);    Heriko fa[x];}\r\n183 | P1868 饥饿的奶牛\r\n洛谷 | P1868\r\n饥饿的奶牛 \r\n一道线性 DP，方程是 \r\n184 | P1341 无序字母对\r\n洛谷 | P1341\r\n无序字母对 \r\n是一道题意很显然的欧拉路，然而我最易开始一只以为是欧拉回路，然后就很淦的卡了两个小时（\r\n185 | P6722 「MCOI-01」Village\r\n村庄\r\n洛谷 | P6722\r\n「MCOI-01」Village 村庄 \r\n是一道图论题，因为题意比较清晰，我们可以分为两部分去求解。\r\n第一部分是把符合条件的新图建出来，第二部分则是去判断二分图。第二部分实现起来很简单，染色即可，主要是第一部分的实现。\r\n我们考虑如果树上最长的路径都  的话，那么显然不存在符合题意的图。\r\n反之，如果存在二分图，必然最长路径的两端不在一个集合中，也就是说树的直径两端不在一个集合中，因此我们只需要找到直径的两端进行两遍\r\n，最后再进行一次  染色判断即可。\r\n有水题解（\r\n186 | P7113 排水系统 [NOIP2020]\r\n洛谷 | P7113\r\n排水系统 [NOIP2020] \r\nNOIP2020 的 T1，现在来看题意确实很清晰的是个拓扑排序，正好 2021.9.1\r\nCCF 宣布 NOI 系列赛事 C++14 和 下划线开头的函数解禁，所以就直接写的\r\n__int128（\r\n187 | P6560 时光的流逝\r\n[SBCOI2020]\r\n洛谷 | P6560\r\n时光的流逝 [SBCOI2020] \r\n比较显然是一个博弈论 +\r\n拓扑排序的题目，不过实际上不是太难的博弈论，要不然我也想不到。\r\n大体的思路是建反边，将终点和所有入度为  的点的先手胜负设为 ，如果一个点能到达一个必败点，那么是必胜态。\r\n188 | P4513 小白逛公园\r\n洛谷 | P4513\r\n小白逛公园 \r\n实际上这应该是一道挺经典的线段树 +\r\n最大子端和的题，不过我今天才过，拿来复苏我的线段树也是不错啦。\r\n大约就是单点修改的线段树，维护分别从左右开始的最大子段和，同时维护一个最大值。\r\n189 | P3177 树上染色 [HAOI2015]\r\n洛谷 | P3177\r\n树上染色 [HAOI2015] \r\n一道树形 DP，题意是让我们把 \r\n个点染成黑色，其余为白色，求满足两两黑点之间距离最长和两两白点之间距离最长的染色方案。\r\n因为一条边只有在两个同色点之间时才有贡献，所以一条边被经过的次数等于边的两侧同色点个数的乘积，即为：\r\n\r\n于是方程即为：\r\n\r\n接下来想练一下树剖。\r\n190 | P2146 软件包管理器\r\n[NOI2015]\r\nLOJ |\r\n#2130.「NOI2015」软件包管理器\r\n洛谷 | P2146\r\n软件包管理器 [NOI2015] \r\n上面说过要练一下树剖，于是就看到了这道题，大体的思路就是安装状态为\r\n，未安装状态为 ，算是比较板子的树剖。\r\n下面写一点这回和上次 Debug 时出现的智熄操作。\r\n\r\n在 DFS1 中 ：if(sz[y]&gt;son[x]) son[x]=y;，应写为\r\nif(sz[y]&gt;sz[son[x]]) son[x]=y;。\r\n在线段树 Query 中忘了 Pushdown.\r\n遍历边的时候将 int i(head[x]) 错写为\r\nint i(head[i])。\r\n在 QTree 和线段树 Query 中返回值错写为 x，但是应当是\r\nres。\r\n在线段树 Modify 中忘了 Pushup.\r\n\r\n191 | P2619 Tree I [国家集训队]\r\n洛谷 | P2619 Tree I\r\n[国家集训队] \r\n题目的说法很清楚是要求最小生成树了，但是因为求 MST\r\n的算法都是基于贪心，所以我们不能钦定  条白边去做。\r\n于是我们就顺着贪心的想法去做，二分答案即可。\r\n192 | UVA12888 Count LCM\r\n洛谷 | UVA12888\r\nCount LCM \r\nUVA\r\n| Count LCM\r\n煺柿子题。\r\n\r\n于是用欧拉筛筛一下 \r\n再整除分块。\r\n193 | P4981 父子\r\n洛谷 | P4981\r\n父子 \r\n有个东西叫做 ü 编码与  公式。\r\n一棵无根树的 ü\r\n编码的值运算如下：\r\n\r\n首先定义无根树中度数为1的节点是叶子节点。\r\n找到编号最小的叶子并删除，序列中添加与之相连的节点编号，重复执行直到只剩下2个节点。\r\n\r\n 公式是说，一个完全图\r\n 有  棵生成树，换句话说  个节点的带标号的无根树有  个。\r\n在这个题这里我们有 \r\n种选根的方法，所以总共是 \r\n种方案，快速幂做即可。\r\n194 | P2590 树的统计 [ZJOI2008]\r\n洛谷 | P2590\r\n树的统计 [ZJOI2008] \r\n191 到 193\r\n都是在补齐周末测试题的时候随便做的题，这是回归之前说要练一练树剖的初心的题。虽然我补题太慢了这一周又过去了……\r\n这是一道树剖的入门题，需要支持三个操作：单点修改，求路径上最大值，求路径上点权之和。\r\n那么这个显然就是树剖来做，简单写写即可。\r\n写一下这次写的时候 Debug 出来的智熄操作：\r\n\r\n线段树所有操作全都忘了 Pushup(x)。\r\n输入询问的时候把输入的种类都搞成 char\r\n了，但是很奇怪的过了样例……\r\n在 Query 里面递归的时候全写的\r\nModify……\r\n一个 n 个节点的树我输入了 n\r\n条边………\r\n因为时单点修改，但是我最一开始穿的是原标号而不是新标号……\r\n\r\n其实都是在查到第 \r\n个错之前查出来的……\r\n总之就是写一次涨一次畸形。\r\n195 | P1265 公路修建\r\n洛谷 | P1265\r\n公路修建 \r\n是一道比较显然的最小生成树，因为这个题主要是围绕着点来进行计算，所以这里用一下\r\nPrim 算法。\r\n两点间距离公式非常简单了，然后就是 Prim\r\n的板子，只不过一些地方要记得开 double.\r\n196 | P1119 灾后重建\r\n洛谷 | P1119\r\n灾后重建 \r\n一道最短路，主要考察对于 Floyd\r\n算法实现过程理解。Floyd 是基于动态规划，每次找到一个中间点\r\nk\r\n来更新最短路信息，对与这道题来说只有能被选择的点才能更新其他的点，于是我们在每次询问时先把能更新的点都更新掉保证最短路。\r\n不知道为什么这个题是蓝，感觉黄差不多。\r\n197 | P5658 括号树 [CSP-S 2019]\r\nLOJ | #3209. 「CSP-S\r\n2019」括号树\r\n洛谷 | P5658 括号树\r\n[CSP-S 2019] \r\n先考虑括号匹配计数，再考虑如何在树上解决这个问题。\r\n首先对于单纯的括号匹配计数，用一个栈就能解决，但是本题需要统计一个路径上的括号匹配数。\r\n先考虑链的情况，那么我们每次新匹配一个括号，就只需要单纯的继承上一个点的信息即可。\r\n然后考虑树上的情况。刚才之所以可以直接继承上一个节点，就是因为每个节点的父节点都是其上一个节点，所以我们在这里直接把继承的信息来由改为其父节点即可。\r\n这里说两个 Debug 的时候发现的写挂点：\r\n\r\n卡在 55pts：在 DFS 的 if\r\n中使用了 return.\r\n卡在\r\n88pts：在回溯的时候错把栈数组写为了字符数组。\r\n\r\n198 | P2742 Fencing the Cows\r\n[USACO5.1]\r\n洛谷 | P2742 Fencing\r\nthe Cows [USACO5.1] \r\n当然，这道题再洛谷上也叫做模板，所以就是板子。\r\n做这道题的缘由是 ZROI CSP D5 T4\r\n用到了凸包，但是我没学过，于是就学了来这个题练手。\r\n最后选用的 Andrew\r\n算法，第一是这个算法的排序想法简单，第二是这样排序常熟更小。\r\n199 | P2116 城墙\r\n洛谷 | P2116\r\n城墙 \r\n一道凸包的板子题，这道题和上道题的唯一区别就是多了一个 ，但是因为我们要找到最短的，所以显然当城墙距离\r\n\r\n的时候是最优的，而此时最短距离其实就为直线凸包 + \r\n200 | P1463 反素数 [POI2001\r\nand HAOI2007]\r\n洛谷 | P1463 反素数\r\n[POI2001 and HAOI2007] \r\n算是一道数学题（？）\r\n若设 ，则 \r\n那么我们就直接搜索（\r\n因为前  个素数的乘积已经超过了\r\n，所以我们只需要前\r\n 个素数，这个直接写出来就行。\r\n同时庆祝一下  题（\r\n","slug":"Note18","date":"2021-12-06T09:16:00.000Z","categories_index":"OI-Solutions","tags_index":"OI","author_index":"Heriko Deltana"},{"id":"6f7d519169fe043edd418db0d353e8aa","title":"珂朵莉树","content":"「Chtholly Tree 简记」\r\n\r\n\r\n「启」\r\n\r\n关于为啥我要学这个？\r\n\r\n闲的。\r\n\r\n\r\n\r\n本篇中所有 Code 的缺省源使用 「V5.2」.\r\n\r\n「关于 ODT」\r\n\r\nODT 用处？\r\n\r\n（大多数是）在有区间赋值操作的 DS 题里面骗分，因为好像专门为 ODT\r\n设计的题不多吧？反正我只知道 CF896C.\r\n\r\n时间复杂度？\r\n\r\nODT\r\n的复杂度正确建立在数据随机上，这点一定牢记。\r\n对于所有的基础操作（如  和  等），使用 set 实现的\r\nODT 的复杂度为 ，而链表实现的复杂度为 ，不过我目前只会用 set 实现就是了（\r\n\r\n注意事项？\r\n\r\nODT 的复杂度正确建立在数据随机上，ODT\r\n的复杂度正确建立在数据随机上，ODT\r\n的复杂度正确建立在数据随机上。不然的话出题人很容易构造数据让你\r\nT 掉。\r\n别被没有区间赋值的部分分卡了。\r\n\r\n\r\n「实现」\r\n先是核心思想：把值相同的区间合并成结点，存到 set\r\n里面。\r\n于是就有了以下的结构体来存结点：\r\n「结点 Node」\r\n1234567891011121314struct Node{    LL l,r;    mutable LL v;    Node(LL l,LL r=0,LL v=0) : l(l),r(r),v(v) {}    I bool operator &lt; (const Node &amp;co) const    {        Heriko l&lt;co.l;    }};set&lt;Node&gt; s; \r\n\r\n这里的 mutable 是为了突破 const\r\n的限制，便于我们后面直接修改 set\r\n中的值，而不是拿出来改完再扔进去。\r\n\r\n「分裂 Split」\r\n 算是 ODT\r\n中最重要的操作了，简单来说就是把区间  分成  和  两段，便于我们操作。\r\n实现也很简单，我们先用 set 自带的\r\nlower_bound 确定 \r\n对应位置，然后删除原区间分成两半插入。\r\n123456789101112131415161718I auto Split(LL pos){    auto it(s.lower_bound(Node(pos)));    if(it!=s.end() and it-&gt;l==pos)        Heriko it;    --it;    if(it-&gt;r&lt;pos)        Heriko s.end();    LL l(it-&gt;l),r(it-&gt;r),v(it-&gt;v);    s.erase(it);    s.insert(Node(l,pos-1,v));    Heriko s.insert(Node(pos,r,v)).first;}\r\n这样的话所有的区间 \r\n上的操作都可以转化为 \r\n「推平 Assign」\r\n\r\n也是很重要操作，主要就是完成缩点的任务，实现起来也很简单，找到区间之后删除插入新的就行。\r\n123456I void Assign(LL l,LL r,LL x){    auto itr(Split(r+1)),itl(Split(l));    s.erase(itl,itr);    s.insert(Node(l,r,x));}\r\n实际上最基本的操作也就上面这俩了，下面再扩展一点常用的操作。\r\n「区间加 Add」\r\n如何区间加呐？暴力。\r\n嗯，没错就是暴力，找到对应区间之后暴力加就是了（\r\n1234567I void Add(LL l,LL r,LL x){    auto itr(Split(r+1)),itl(Split(l));    for(auto it(itl);it!=itr;++it)        it-&gt;v+=x;}\r\n「排名 Rank」\r\n查询区间排名的话，我们先声明一个结构体或者 pair\r\n便于对相同的数操作。\r\n1234567891011struct Rank{    LL val,cnt;    Rank(LL val,LL cnt) : val(val),cnt(cnt) {}    I bool operator &lt; (const Rank &amp;co) const    {        Heriko val&lt;co.val;    }};\r\n然后我们就用最好想的思路，先找到对应区间，然后把所有的数排序，直接去找要求排名即可。\r\n12345678910111213141516171819I LL QueryRank(LL l,LL r,LL x){    auto itr(Split(r+1)),itl(Split(l));    vector&lt;Rank&gt; v;        for(auto it(itl);it!=itr;++it)        v.push_back(Rank(it-&gt;v,it-&gt;r-it-&gt;l+1));    sort(v.begin(),v.end());    LL i(0);    for(;i&lt;(LL)v.size();++i)        if(v[i].cnt&lt;x)            x-=v[i].cnt;        else            Heriko v[i].val;    Heriko v[i].val;}\r\n「其它 Other」\r\n其实观察上面的也能发现在 ODT\r\n上的操作，先找到对应区间之后就很好办了，所有大概的代码框架都是这个样子：\r\n123456I auto Function(int l,int r,...){    auto itr(Split(r+1)),itl(Split(l));        ...}\r\n然后知道了这些就可以去把 CF896C 干掉了。\r\n「CF896C Code」\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158CI MXX(1e5+1),MOD(1e9+7);LL n,m,seed,vmax,a[MXX];I LL GetData(){    LL res(seed);    seed=(seed*7+13)%MOD;    Heriko res;}I LL FstPow(LL x,LL y,LL p){    LL res(1);    x%=p;    while(y)    {        if(y&amp;1)            (res*=x)%=p;        (x*=x)%=p;        y&gt;&gt;=1;    }    Heriko res;}struct Node{    LL l,r;    mutable LL v;    Node(LL l,LL r=0,LL v=0) : l(l),r(r),v(v) {}    I bool operator &lt; (const Node &amp;co) const    {        Heriko l&lt;co.l;    }};set&lt;Node&gt; s;I auto Split(LL pos){    auto it(s.lower_bound(Node(pos)));    if(it!=s.end() and it-&gt;l==pos)        Heriko it;    --it;    if(it-&gt;r&lt;pos)        Heriko s.end();    LL l(it-&gt;l),r(it-&gt;r),v(it-&gt;v);    s.erase(it);    s.insert(Node(l,pos-1,v));    Heriko s.insert(Node(pos,r,v)).first;}I void Assign(LL l,LL r,LL x){    auto itr(Split(r+1)),itl(Split(l));    s.erase(itl,itr);    s.insert(Node(l,r,x));}I void Add(LL l,LL r,LL x){    auto itr(Split(r+1)),itl(Split(l));    for(auto it(itl);it!=itr;++it)        it-&gt;v+=x;}struct Rank{    LL val,cnt;    Rank(LL val,LL cnt) : val(val),cnt(cnt) {}    I bool operator &lt; (const Rank &amp;co) const    {        Heriko val&lt;co.val;    }};I LL QueryRank(LL l,LL r,LL x){    auto itr(Split(r+1)),itl(Split(l));    vector&lt;Rank&gt; v;        for(auto it(itl);it!=itr;++it)        v.push_back(Rank(it-&gt;v,it-&gt;r-it-&gt;l+1));    sort(v.begin(),v.end());    LL i(0);    for(;i&lt;(LL)v.size();++i)        if(v[i].cnt&lt;x)            x-=v[i].cnt;        else            Heriko v[i].val;    Heriko v[i].val;}I LL QueryVal(LL l,LL r,LL x,LL y){    auto itr(Split(r+1)),itl(Split(l));    LL res(0);        for(auto it(itl);it!=itr;++it)        res=(res+FstPow(it-&gt;v,x,y)*(it-&gt;r-it-&gt;l+1)%y)%y;    Heriko res;}S main(){    Files();    fr(n),fr(m),fr(seed),fr(vmax);    for(int i(1);i&lt;=n;++i)        a[i]=(GetData()%vmax)+1,s.insert(Node(i,i,a[i]));    while(m--)    {        LL opt((GetData()%4)+1),l((GetData()%n)+1),r((GetData()%n)+1),x,y;        if(l&gt;r)            swap(l,r);        if(opt==3)            x=(GetData()%(r-l+1))+1;        else            x=(GetData()%vmax)+1;        if(opt==4)                y=(GetData()%vmax)+1;        if(opt==1)            Add(l,r,x);        else if(opt==2)            Assign(l,r,x);        else if(opt==3)            fw(QueryRank(l,r,x),1);        else            fw(QueryVal(l,r,x,y),1);    }    Heriko Deltana;}\r\n「其它例题」\r\n调了三天 CF896C 最后发现是快速幂少了 x%=p\r\n之后就做了一点简单 ODT 板子题。\r\n「HAOI2014 贴海报」\r\n\r\nHAOI2014\r\n贴海报\r\n\r\n这个题巨大显然了吧，贼板子吧。\r\n只需要区间推平，最后开个桶记录一下就行了，直接切了对吧。\r\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465CI MXX(1001);struct Node{    int l,r;    mutable int val;    Node(int l,int r=0,int val=0) : l(l),r(r),val(val) {}    I bool operator &lt; (const Node &amp;co) const    {        Heriko l&lt;co.l;    }};set&lt;Node&gt; s;I auto Split(int pos){    auto it(s.lower_bound(Node(pos)));    if(it!=s.end() and it-&gt;l==pos)        Heriko it;    --it;    if(it-&gt;r&lt;pos)        Heriko s.end();    int l(it-&gt;l),r(it-&gt;r),v(it-&gt;val);    s.erase(it);    s.insert(Node(l,pos-1,v));    Heriko s.insert(Node(pos,r,v)).first;}I void Assign(int l,int r,int v){    auto itr(Split(r+1)),itl(Split(l));    s.erase(itl,itr);    s.insert(Node(l,r,v));}int n,m,x,y,tot,ans(-1);bitset&lt;MXX&gt; vis;S main(){    Files();    fr(n),fr(m);    s.insert(Node(1,n+1));    while(m--)        fr(x),fr(y),Assign(x,y,++tot);    for(auto it(s.begin());it!=s.end();++it)        if(!vis[it-&gt;val])            ++ans,vis[it-&gt;val]=1;    fw(ans,1);    Heriko Deltana;}\r\n「CF343D Water Tree」\r\n这个题是个树上问题，比较板的树剖（\r\n不过我们不写线段树，我们直接上 ODT，在两边 DFS 处理出来 id\r\n序之后按照普通的序列操作即可。\r\n第二个操作就需要我们在 DFS 的时候记录一下\r\ntop，修改的时候不断跳 top 进行  即可。\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143CI MXX(5e5+5);struct ODT{    int l,r;    mutable int v;    ODT(int l,int r=0,int v=0) : l(l),r(r),v(v) {}    I bool operator &lt; (const ODT &amp;co) const    {        Heriko l&lt;co.l;    }};set&lt;ODT&gt; s;I auto Split(int pos){    auto it(s.lower_bound(ODT(pos)));    if(it!=s.end() and it-&gt;l==pos)        Heriko it;    --it;    if(it-&gt;r&lt;pos)        Heriko s.end();    int l(it-&gt;l),r(it-&gt;r),val(it-&gt;v);    s.erase(it);    s.insert(ODT(l,pos-1,val));        Heriko s.insert(ODT(pos,r,val)).first;}I void Assign(int l,int r,int x){    auto itr(Split(r+1)),itl(Split(l));    s.erase(itl,itr);    s.insert(ODT(l,r,x));}struct Node{    int nex,to;}r[MXX&lt;&lt;1];int rcnt,head[MXX];I void Add(int x,int y){    r[++rcnt]=(Node){head[x],y},head[x]=rcnt;    r[++rcnt]=(Node){head[y],x},head[y]=rcnt;}int n,m,sz[MXX],dep[MXX],id[MXX],top[MXX],fa[MXX],son[MXX],tot;void DFS1(int x,int fath){    sz[x]=1,fa[x]=fath,dep[x]=dep[fath]+1;    for(int i(head[x]);i;i=r[i].nex)    {        int y(r[i].to);        if(y==fath)            continue;        DFS1(y,x);        sz[x]+=sz[y];        if(sz[y]&gt;sz[son[x]])            son[x]=y;    }}void DFS2(int x,int tp){    top[x]=tp,id[x]=++tot;    if(son[x])        DFS2(son[x],tp);    for(int i(head[x]);i;i=r[i].nex)    {        int y(r[i].to);        if(y==fa[x] or y==son[x])            continue;        DFS2(y,y);    }}I void ModifyZero(int x){    int tp(top[x]);    while(tp!=1)    {        Assign(id[tp],id[x],0);        x=fa[tp],tp=top[x];    }    Assign(id[1],id[x],0);}S main(){    Files();    fr(n);    for(int i(1);i&lt;n;++i)    {        int x,y;        fr(x),fr(y);        Add(x,y);    }    DFS1(1,0);    DFS2(1,1);    s.insert(ODT(0,MXX));    fr(m);    while(m--)    {        int opt,x;        fr(opt),fr(x);        if(opt==1)            Assign(id[x],id[x]+sz[x]-1,1);        else if(opt==2)            ModifyZero(x);        else            fw(Split(id[x])-&gt;v,1);    }    Heriko Deltana;}\r\n「终」\r\n那么就写这些吧。\r\n","slug":"ODT","date":"2021-12-05T08:12:44.000Z","categories_index":"OI-Algorithm","tags_index":"OI","author_index":"Heriko Deltana"},{"id":"a6361eec591ebcf52852b67a4eecd3de","title":"Tarjan","content":"「铊金金。」\r\n\r\n\r\n「启」\r\n之前一直没空写，NOIP\r\n考前重新学了一下，虽然考场上完全没用到就是了。\r\n大概按照 OI-Wiki 来简单写一点。\r\n同步发布于Cnblogs.\r\n「Pre」\r\n首先是一些前置知识。\r\n「强连通分量」\r\n在有向图  中强连通是指 \r\n中的任意两个节点联通，强连通分量则是极大的强连通子图。\r\n强连通分量的英文是 Strongly Connected Components，简称 SCC.\r\n「DFS 搜索树」\r\n\r\n\r\nimage.png\r\n\r\n除了普通的树边之外，DFS 搜索树中还有可能出现以下三种类型的边：\r\n\r\n回边（红），即指向祖先结点的边。\r\n横叉边（蓝），即边的另一端是一个已经遍历过，但不是当前结点祖先的点。\r\n前向边（绿），搜索时遇到一个子树中的结点生成的。\r\n\r\n那么在这颗搜索树中求 SCC，有以下的性质：\r\n设结点  为某个 SCC\r\n在搜索树中遇到的第一个结点，那么这个 SCC 的剩余结点一定是搜索树中以\r\n 为根的子树中。\r\n可以反证证明：设有一个结点 \r\n在当前 SCC 中但是不在搜索树中以 \r\n为根的子树中，那么  到 \r\n的路径上一定有一条离开子树的边，即存在一条横叉边或者回边，然而根据定义发现两条边要求指向的结点是被访问过的，这和\r\n 的定义矛盾，得证。\r\n「Tarjan」\r\nTarjan 主要是为每个结点 \r\n维护了两个变量：dfn[x] 和 low[x].\r\n前者表示在 DFS 时 \r\n被遍历到的次序，后者表示 \r\n能回溯到的 dfn\r\n最小的栈中的结点。显然的是后者可以用未访问过的子树中的结点  的 low[y] 来更新，否则用\r\ndfn[y] 更新。\r\n「Code」\r\n之前的模板库里放了个栈用 vector\r\n的，这里再放一个手写栈的，缺省源使用 「V5.2」.\r\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465template &lt;typename J&gt;I J Hmin(const J &amp;x,const J &amp;y){    Heriko x&lt;y?x:y;}CI MXX(5e4+1),NXX(1e4+1);int n,m;struct Node{    int nex,to;}r[MXX];int rcnt,head[NXX];I void Add(int x,int y){    r[++rcnt]=(Node){head[x],y};    head[x]=rcnt;}int dfn[NXX],low[NXX],dfsid,stak[NXX],top,sz[NXX],scc[NXX],scctot;bitset&lt;NXX&gt; instak;void Tarjan(int x){    low[x]=dfn[x]=++dfsid;    stak[++top]=x,instak[x]=1;    for(int i(head[x]);i;i=r[i].nex)    {        int y(r[i].to);        if(!dfn[y])        {            Tarjan(y);            low[x]=Hmin(low[x],low[y]);        }        else if(instak[y])            low[x]=Hmin(low[x],dfn[y]);    }    if(dfn[x]==low[x])    {        ++scctot;        while(stak[top]!=x)        {            scc[stak[top]]=scctot;            ++sz[scctot];            instak[stak[top]]=0;            --top;        }        scc[stak[top]]=scctot;        ++sz[scctot];        instak[stak[top]]=0;        --top;    }}\r\n「终」\r\n还是，不知道啥时候写游记（\r\n","slug":"Tarjan","date":"2021-12-05T06:21:22.000Z","categories_index":"OI-Algorithm","tags_index":"OI","author_index":"Heriko Deltana"},{"id":"fdeb7f511d09c9feab21d131c5bc32c6","title":"Models","content":"「模板库」\r\n\r\n\r\n「Pre」\r\n临近 CSP-S2 2021\r\n的时候，我决定把板子都打一遍，顺便就把这些板子整理成一个模板库罢。\r\n然而 CSP-S2 2021 都爆了我还没整完（\r\n现在备战 NOIP2022 了（\r\nUPD 2023.8.18：现在已经快退役一年了。\r\n\r\n本模板库最新的内容为 2023.8.18 更新，最老内容为 2022.9.26\r\n更新，最近的码风翻新日期为 2022.9.26.\r\n\r\n以下代码若无特殊情况皆可使用的缺省源：\r\n\r\nUPD 2022.9.26\r\n\r\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;#define Heriko return#define Yoisaki return#define Deltana 0#define Romanno 1#define Kanade 1#define S signed#define LL long long#define DB double#define R register#define I inline#define CI const int#define CL const long long#define mkp(a, b) make_pair(a, b)#define mst(a, b) memset(a, b, sizeof(a))#define ON std::ios::sync_with_stdio(false);cin.tie(0)#define Files() freopen(\"RNMTQ.in\", \"r\", stdin);freopen(\"RNMTQ.out\", \"w\", stdout)using namespace std;template&lt;typename J&gt;I void fr(J &amp;x) {    short f(1);    x = 0;    char c(getchar());    while(c &lt; '0' or c &gt; '9') {        if(c == '-')            f = -1;                c = getchar();    }    while(c &gt;= '0' and c &lt;= '9') {        x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^= 48);        c = getchar();    }       x *= f;}template&lt;typename J&gt;I void fw(J x, bool k) {    if(x &lt; 0)        x = -x, putchar('-');    static short stak[35];    short top(0);    do {        stak[top ++] = x % 10;        x /= 10;    }    while(x);    while(top)        putchar(stak[-- top] + '0');    k ? puts(\"\") : putchar(' ');}template&lt;typename J&gt;I J Hmax(const J &amp;x, const J &amp;y) {    Heriko x &gt; y ? x : y;}template&lt;typename J&gt;I J Hmin(const J &amp;x, const J &amp;y) {    Heriko x &lt; y ? x : y;}\r\n「快速排序」\r\n\r\nUPD 2022.9.26\r\n\r\n12345678910111213141516171819202122232425CI MXX(1e5 + 1);int a[MXX];void Mysort(int l, int r) {    int i(l), j(r), mid(a[(l + r) &gt;&gt; 1]);        do {        while(a[i] &lt; mid)            ++ i;                while(a[j] &gt; mid)            -- j;        if(i &lt;= j)            swap(a[i], a[j]), ++ i, -- j;    }    while(i &lt;= j);        if(l &lt; j)        Mysort(l, j);        if(i &lt; r)        Mysort(i, r);}\r\n「并查集」\r\n\r\n仅使用了路径压缩。\r\nUPD 2022.9.26\r\n\r\n12345678910111213141516171819202122CI MXX(2e5 + 1),NXX(10001);int fa[NXX], n, m;I void Pre() {    for(int i(1); i &lt;= n; ++ i)        fa[i] = i;}int Find(int x) {    if(fa[x] != x)        fa[x] = Find(fa[x]);    Heriko fa[x];}I void UNI(int x, int y) {    int fx(Find(x)), fy(Find(y));    if(fx != fy)        fa[fx] = fy;}\r\n「线性筛」\r\n\r\nUPD 2022.9.26\r\n\r\n123456789101112131415161718192021CI MXX(1e8 + 1);int n, prime[MXX], cnt, q;bool nopr[MXX];I void Es() {    nopr[1] = 1;    for(int i(2); i &lt;= n; ++ i) {        if(!nopr[i])            prime[++ cnt] = i;        for(int j(1); j &lt;= cnt and prime[j] * i &lt;= n; ++ j) {            nopr[i * prime[j]] = 1;            if(i % prime[j] == 0)                break;        }    }}\r\n「单调栈」\r\n\r\nUPD 2022.9.26\r\n\r\n1234567891011121314151617181920212223CI MXX(3e6 + 1);int n, a[MXX], f[MXX], stak[MXX], top;S main() {    fr(n);    for(int i(1); i &lt;= n; ++ i)        fr(a[i]);    for(int i(n); i; -- i) {        while(top and a[stak[top]] &lt;= a[i])            -- top;        f[i] = top ? stak[top] : 0;        stak[++ top] = i;    }    for(int i(1); i &lt;= n; ++ i)        fw(f[i], 0);        Heriko Deltana;}\r\n「快速幂」\r\n\r\n2021.12.25 更新了那行 x%=p，调了三天 ODT\r\n居然是这里爆了……我从来没写过这，于是加上。\r\nUPD 2022.9.26\r\n\r\n1234567891011121314I LL FstPow(LL x, LL y, LL p) {    LL res(1);    x %= p;    while(y) {        if(y &amp; 1)            (res *= x) %= p;        (x *= x) %= p;        y &gt;&gt;= 1;    }    Heriko res;}\r\n「单调队列」\r\n\r\n第一个循环是求区间最小值，后者则为最大值。\r\nUPD 2022.9.26\r\n\r\n1234567891011121314151617181920212223242526272829303132333435363738394041CI MXX(1e6 + 1);int n, k, a[MXX], qmin[MXX], qmax[MXX], hd(1), tl;S main() {    fr(n),fr(k);    for(int i(1); i &lt;= n; ++ i)        fr(a[i]);    for(int i(1); i &lt;= n; ++ i) {        while(hd &lt;= tl and a[qmin[tl]] &gt;= a[i])            -- tl;        qmin[++ tl] = i;        while(qmin[hd] &lt;= i - k)            ++ hd;        if(i &gt;= k)            fw(a[qmin[hd]], 0);    }    puts(\"\");    hd = 1, tl = 0;        for(int i(1); i &lt;= n; ++ i) {        while(hd &lt;= tl and a[qmax[tl]] &lt;= a[i])            -- tl;        qmax[++ tl] = i;        while(qmax[hd] &lt;= i - k)            ++ hd;        if(i &gt;= k)            fw(a[qmax[hd]], 0);    }    Heriko Deltana;}\r\n「最小生成树」\r\n\r\nUPD 2022.9.26\r\n\r\n「Prim」\r\n\r\n因为写挂了（？）暂时咕了\r\n\r\n「Kruskal」\r\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556CI MXX(2e5 + 5),NXX(5001);struct Node {    int x, y, z;    I bool operator &lt; (const Node &amp;co) const {        Heriko z &lt; co.z;    }}r[MXX&lt;&lt;1];int fa[NXX], n, m, ans, k;int Find(int x) {    if(fa[x] != x)        fa[x] = Find(fa[x]);    Heriko fa[x];}I void Uni(int x, int y, int z) {    int fx(Find(x)), fy(Find(y));    if(fx != fy) {        fa[fx] = fy;        ++ k;        ans += z;    }}S main() {    fr(n), fr(m);    for(int i(1); i &lt;= n; ++ i)        fa[i] = i;    for(int i(1); i &lt;= m; ++ i)        fr(r[i].x), fr(r[i].y), fr(r[i].z);    sort(r + 1, r + 1 + m);    for(int i(1); i &lt;= m; ++ i) {        Uni(r[i].x, r[i].y, r[i].z);        if(k == n - 1)            break;    }    if(k == n - 1)        fw(ans, 1);    else        puts(\"orz\");    Heriko Deltana;}\r\n「字符串哈希」\r\n「单哈希+自然溢出」\r\n\r\nUPD 2022.9.26\r\n\r\n123456789101112131415161718192021222324252627282930313233343536#define LL unsigned long longconst LL b(211), prime(19260817);LL h[10015];char s[10015];int n, ans(1);I LL hso(char x[]) {    int lx(strlen(x));    LL t(0);    for(int i(0); i &lt; lx; ++ i)        t = (t * b + (LL)x[i]) + prime;    Heriko t;}S main() {    fr(n);    for(int i(1); i &lt;= n; ++ i)        scanf(\"%s\", s), h[i] = hso(s);    sort(h + 1, h + 1 + n);    for(int i(1); i &lt; n; ++ i)        if(h[i] != h[i + 1])            ++ ans;    fw(ans,1);    Heriko Deltana;}\r\n「双哈希」\r\n\r\nUPD 2022.9.26\r\n\r\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273CI MXX(1501),NXX(10005),MOD1(19260817),MOD2(998244353);int n;char s[MXX];namespace Hash {    #define ULL unsigned long long    struct Node {        ULL h1, h2;        I bool operator &lt; (const Node &amp;co) const {            Heriko h1 == co.h1 ? h2 &lt; co.h2 : h1 &lt; co.h1;        }                I bool operator != (const Node &amp;co) const {            Heriko (h1 != co.h1) | (h2 != co.h2);        }    }    a[NXX];    I void GetHash1(int pos, char s[]) {        int len(strlen(s));        ULL tmp(0);        for(int i(0); i &lt; len; ++ i)            tmp = (tmp * 255 + s[i]) % MOD1;        a[pos].h1 = tmp;    }    I void GetHash2(int pos, char s[]) {        int len(strlen(s));        ULL tmp(0);        for(int i(0); i &lt; len; ++ i)            tmp = (tmp * 255 + s[i]) % MOD2;        a[pos].h2 = tmp;    }    I void GetHash(int pos, char s[]) {        GetHash1(pos, s);        GetHash2(pos, s);    }    I void Solve() {        sort(a + 1, a + 1 + n);        int cnt(0);        for(int i(1); i &lt;= n; ++ i)            if(a[i] != a[i-1] or i == 1)                a[++ cnt] = a[i];        fw(cnt, 1);        exit(0);    }}S main() {    fr(n);    for(int i(1); i &lt;= n; ++ i) {        scanf(\"%s\", s + 1);        Hash::GetHash(i, s + 1);    }    Hash::Solve();    Heriko Deltana;}\r\n「单端最短路」\r\n「Dijkstra」\r\n\r\nUPD 2022.9.26\r\n\r\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374CI MXX(5e5 + 1), NXX(1e5 + 1);struct node {    int nex, to, val;}r[MXX];int cnt, head[NXX];I void Add(int x, int y, int z) {    r[++ cnt] = (node){head[x], y, z};    head[x] = cnt;}struct co {    int dis,id;    I bool operator &lt; (const co &amp;x) const {        Heriko x.dis &lt; dis;    }};priority_queue&lt;co&gt; q;int dis[NXX], n, m, s;bool vis[MXX];I void Dijkstra() {    dis[s] = 0;    q.push((co){0, s});    while(q.size()) {        int x(q.top().id);        q.pop();        if(vis[x])            continue;        vis[x] = 1;        for(int i(head[x]); i; i = r[i].nex) {            int y(r[i].to);            if(dis[y] &gt; dis[x] + r[i].val) {                dis[y] = dis[x] + r[i].val;                if(!vis[y])                    q.push((co){dis[y], y});            }        }    }}S main(){    fr(n), fr(m), fr(s);    mst(dis, 0x7f);    dis[0] = 0;    for(int i(1); i &lt;= m; ++ i) {        int x, y, z;        fr(x), fr(y), fr(z);        Add(x, y, z);    }    Dijkstra();    for(int i(1); i &lt;= n; ++ i)        fw(dis[i], 0);    Heriko Deltana;} \r\n「SPFA」\r\n\r\nUPD 2022.10.10 谨慎使用。\r\n\r\n1234567891011121314151617181920212223242526int n, dis[MXX], vis[MXX], ans;I void SPFA(int s) {    queue&lt;int&gt; q;    q.push(s);    dis[s] = 0, vis[s] = 1;    while(q.size()) {        int x(q.front());        q.pop();        vis[x] = 0;        for(int i(head[x]); i; i = r[i].nex) {            int y(r[i].to);            if(dis[y] &lt; dis[x] + r[i].val) {                dis[y] = dis[x] + r[i].val;                if(!vis[y]) {                    vis[y] = 1;                    q.push(y);                }            }        }    }}\r\n「树状数组」\r\n「单点修改区间询问」\r\n\r\nUPD 2022.9.26\r\n\r\n1234567891011121314151617181920212223242526272829303132333435363738394041CI MXX(5e5 + 1);#define lowbit(x) ((x) &amp; (-x))LL n, t[MXX], a[MXX], m;I void Modify(int x, int v) {    while(x &lt;= n)        t[x] += v, x += lowbit(x);}I LL Query(int x) {    int res(0);        while(x)        res += t[x], x -= lowbit(x);    Heriko res;}S main() {    fr(n), fr(m);    for(int i(1); i &lt;= n; ++ i)        fr(a[i]);    for(int i(1); i &lt;= n; ++ i)        Modify(i, a[i]);    while(m --) {        int opt, l, r;        fr(opt), fr(l), fr(r);        if(opt == 1)            Modify(l, r);        else            fw(Query(r) - Query(l - 1), 1);    }    Heriko Deltana;}\r\n「区间修改单点询问」\r\n\r\nUPD 2022.9.26\r\n\r\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546#define lowbit(x) ((x) &amp; (-x))CI MXX(5e5 + 1);int n, m, t[MXX], a[MXX];I void Add(int x, int val) {    while(x &lt;= n)        t[x] += val, x += lowbit(x);}I int Query(int x) {    int res(0);    while(x)        res += t[x], x -= lowbit(x);    Heriko res;} S main() {    fr(n),fr(m);    for(int i(1); i &lt;= n; ++ i)        fr(a[i]);    for(int i(1); i &lt;= n; ++ i)        Add(i, a[i] - a[i - 1]);    while(m --) {        int opt, x, y, z;        fr(opt);        if(opt == 1) {            fr(x), fr(y), fr(z);            Add(x, z);            Add(y + 1, -z);        }        else {            fr(x);            fw(Query(x), 1);        }    }    Heriko Deltana;}\r\n「乘法逆元」\r\n\r\nUPD 2022.9.26\r\n\r\n12345678910111213141516CI MXX(3e6 + 1);LL inv[MXX], n, m;S main() {    fr(n), fr(m);    inv[1] = 1;    for(int i(2); i &lt;= n; ++ i)        inv[i] = m - (m / i) * inv[m % i] % m;        for(int i(1); i &lt;= n; ++ i)        fw(inv[i], 1);    Heriko Deltana;}\r\n「高精度」\r\n\r\nUPD 2022.9.26\r\n\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177CI MXX(105);struct Pic {    int num[MXX], sz;    Pic() {        mst(num, 0);        sz = 1;    }    I void Clear() {        mst(num, 0);        sz = 1;    }    /*---- int * Pic ----*/    I Pic operator * (const int &amp;co) const {        Pic res;        res.sz = sz;        for(int i(1); i &lt;= sz; ++ i)            res.num[i] = num[i] * co;        for(int i(1); i &lt;= sz; ++ i)            res.num[i + 1] += (res.num[i] / 10), res.num[i] %= 10;        while(res.num[res.sz + 1]) {            ++ res.sz;            res.num[res.sz + 1] += (res.num[res.sz] / 10);            res.num[res.sz] %= 10;        }        Heriko res;    }    /*---- Pic * Pic ----*/    I Pic operator * (const Pic &amp;co) const {        Pic res;        res.sz = co.sz + sz;        for(int i(1); i &lt;= sz; ++ i)            for(int j(1); j &lt;= co.sz; ++ j) {                res.num[i + j - 1] += (num[i] * co.num[j]);                res.num[i + j] += (res.num[i + j - 1] / 10);                res.num[i + j - 1] %= 10;            }        while(!res.num[res.sz] and res.sz &gt; 1)            -- res.sz;        Heriko res;    }    /*---- Pic + Pic ----*/    I Pic operator + (const Pic &amp;co) const {        Pic res;        res.sz = sz + 2;         for(int i(1); i &lt;= sz; ++ i) {            res.num[i] += num[i] + co.num[i];            if(res.num[i] &gt; 10)                ++ res.num[i+1], res.num[i] %= 10;        }        while(!res.num[res.sz] and res.sz &gt; 1)            -- res.sz;        Heriko res;    }    /*---- Pic - Pic ----*/    /*Need to ensure *this &gt; co*/    I Pic operator - (const Pic &amp;co) const {        Pic res;        res.sz = sz;        for(int i(1); i &lt;= sz; ++ i) {            res.num[i] += num[i] - co.num[i];            if(res.num[i] &lt; 0)                -- res.num[i + 1], res.num[i] += 10;        }        while(!res.num[res.sz] and res.sz &gt; 1)            -- res.sz;        Heriko res;    }    /*---- Pic&gt;&gt;1 ----*/    I void RightShift() {        for(int i(sz); i; -- i) {            if(num[i] &amp; 1)                num[i - 1] += 10;            num[i] &gt;&gt;= 1;        }        while(!num[sz] and sz &gt; 1)            -- sz;    }    /*---- Pic &lt; Pic ----*/    I bool operator &lt; (const Pic &amp;co) const {        if(sz != co.sz)            Heriko sz &lt; co.sz;        for(int i(sz); i; -- i)            if(num[i] != co.num[i])                Heriko num[i] &lt; co.num[i];        Heriko Deltana;    }    /*---- Pic &gt; Pic ----*/    I bool operator &gt; (const Pic &amp;co) const {        if(sz != co.sz)            Heriko sz &gt; co.sz;        for(int i(sz); i; -- i)            if(num[i] != co.num[i])                Heriko num[i] &gt; co.num[i];        Heriko Deltana;    }    /*---- Pic &lt;= Pic ----*/    I bool operator &lt;= (const Pic &amp;co) const {        Heriko !((*this) &gt; co);    }    /*---- Pic &gt;= Pic ----*/    I bool operator &gt;= (const Pic &amp;co) const {        Heriko !((*this) &lt; co);    }    /*---- Pic == Pic ----*/    I bool operator == (const Pic &amp;co) const {        Heriko (!((*this) &gt; co)) &amp; (!((*this) &lt; co));    }    /*---- Pic Input (char[] -&gt; Pic) ----*/    I void Into(char s[]) {        sz = strlen(s + 1);        for(int i(1); i &lt;= sz; ++ i)            num[i] = s[sz - i + 1] - '0';    }    /*---- Pic == 0 ? ----*/    I bool Zero() {        Heriko (sz == 1) &amp; (num[1] == 0);    }    /*---- Pic Output ----*/    I void fw() {        for(int i(sz); i; -- i)            putchar(num[i] + '0'), putchar(' ');    }}n, m;\r\n「线段树」\r\n\r\nUPD 2022.9.26\r\n这里只放了个区间加和区间改，其它东西改一改就有了。\r\n\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109const LL MXX(1e6 + 1), INF(1e12);int n, q;struct Node {    int l, r;    LL mx, tg1, tg2;}t[MXX &lt;&lt; 2];I void Pushup(int x) {    t[x].mx = Hmax(t[lc(x)].mx, t[rc(x)].mx);}I void Pushdown(int x) {    if(t[x].tg2 != INF) {        t[lc(x)].tg1 = 0;        t[lc(x)].tg2 = t[x].tg2;        t[lc(x)].mx = t[x].tg2;        t[rc(x)].tg1 = 0;        t[rc(x)].tg2 = t[x].tg2;        t[rc(x)].mx = t[x].tg2;        t[x].tg2 = INF;    }    if(t[x].tg1) {        t[lc(x)].tg1 += t[x].tg1;        t[lc(x)].mx += t[x].tg1;        t[rc(x)].tg1 += t[x].tg1;        t[rc(x)].mx += t[x].tg1;        t[x].tg1 = 0;    }}void Build(int x, int l, int r) {    t[x].l = l, t[x].r = r;    t[x].mx = t[x].tg1 = 0;    t[x].tg2 = INF;    if(l == r) {        fr(t[x].mx);        Heriko;    }    int mid((l + r) &gt;&gt; 1);    Build(lc(x), l, mid);    Build(rc(x), mid + 1, r);    Pushup(x);}void ModifyAdd(int x, int lx, int rx, LL v) {    if(lx &lt;= t[x].l and t[x].r &lt;= rx) {        t[x].tg1 += v;        t[x].mx += v;        Heriko;    }    Pushdown(x);    int mid((t[x].l + t[x].r) &gt;&gt; 1);    if(lx &lt;= mid)        ModifyAdd(lc(x), lx, rx, v);        if(rx &gt; mid)        ModifyAdd(rc(x), lx, rx, v);    Pushup(x);}void ModifyChange(int x, int lx, int rx, LL v) {    if(lx &lt;= t[x].l and t[x].r &lt;= rx) {        t[x].tg1 = 0;        t[x].tg2 = v;        t[x].mx = v;        Heriko;    }    Pushdown(x);    int mid((t[x].l + t[x].r) &gt;&gt; 1);    if(lx &lt;= mid)        ModifyChange(lc(x), lx, rx, v);        if(rx &gt; mid)        ModifyChange(rc(x), lx, rx, v);    Pushup(x);}LL Query(int x, int lx, int rx) {    if(lx &lt;= t[x].l and t[x].r &lt;= rx)        Heriko t[x].mx;    LL res(-INF);    int mid((t[x].l + t[x].r) &gt;&gt; 1);    Pushdown(x);    if(lx &lt;= mid)        res = Hmax(Query(lc(x), lx, rx), res);        if(rx &gt; mid)        res = Hmax(Query(rc(x), lx, rx), res);    Heriko res;}\r\n「主席树」\r\n\r\nUPD 2022.9.26\r\n\r\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667CI MXX(1e5 + 1);int n, q, lc[MXX &lt;&lt; 5], rc[MXX &lt;&lt; 5], sum[MXX &lt;&lt; 5], t[MXX], a[MXX], b[MXX], id;int Build(int l, int r) {    int x(++ id), mid((l + r) &gt;&gt; 1);    if(l &lt; r) {        lc[x] = Build(l, mid);        rc[x] = Build(mid + 1, r);    }    Heriko x;}int Insert(int pre, int l, int r, int v) {    int x(++ id), mid((l + r) &gt;&gt; 1);    lc[x] = lc[pre], rc[x] = rc[pre], sum[x] = sum[pre] + 1;    if(l &lt; r) {        if(v &lt;= mid)            lc[x] = Insert(lc[pre], l, mid, v);        else            rc[x] = Insert(rc[pre], mid + 1, r, v);    }    Heriko x;}int Query(int x, int y, int l, int r, int v) {    if(l &gt;= r)        Heriko l;    int nw(sum[lc[y]] - sum[lc[x]]), mid((l + r) &gt;&gt; 1);    if(nw &gt;= v)        Heriko Query(lc[x], lc[y], l, mid, v);    else        Heriko Query(rc[x], rc[y], mid + 1, r, v - nw);}S main() {    fr(n), fr(q);    for(int i(1); i &lt;= n; ++ i)        fr(a[i]), b[i] = a[i];    sort(b + 1, b + 1 + n);    int nl(unique(b + 1, b + 1 + n) - b - 1);    for(int i(1); i &lt;= n; ++ i)        a[i] = lower_bound(b + 1, b + 1 + nl, a[i]) - b;    t[0] = Build(1, nl);    for(int i(1); i &lt;= n; ++ i)        t[i] = Insert(t[i - 1], 1, nl, a[i]);    while(q --) {        int l, r, k;        fr(l), fr(r), fr(k);        fw(b[Query(t[l - 1], t[r], 1, nl, r - l + 1 - k + 1)], 1);//求区间第 K 大        fw(b[Query(t[l - 1], t[r], 1, nl, k)], 1);//求区间第 K 小    }    Heriko Deltana;}\r\n「ST表」\r\n\r\nUPD 2022.10.22\r\n\r\n123456789101112131415161718192021222324252627282930313233343536373839CI MXX(2e5 + 1);LL a[MXX][22], b[MXX][22];int n, m;I LL QueryMax(int l, int r) {    int tmp(log2(r - l + 1));    Heriko Hmax(a[l][tmp], a[r - (1 &lt;&lt; tmp) + 1][tmp]);}I LL QueryMin(int l, int r) {    int tmp(log2(r - l + 1));    Heriko Hmin(b[l][tmp], b[r - (1 &lt;&lt; tmp) + 1][tmp]);}S main() {    cin &gt;&gt; n &gt;&gt; m;    for(int i(1); i &lt;= n; ++ i)        cin &gt;&gt; a[i][0], b[i][0] = a[i][0];    for(int lg(1); lg &lt;= 21; ++ lg)        for(int i(1); i + (1 &lt;&lt; lg) - 1 &lt;= n; ++ i) {            a[i][lg] = Hmax(a[i][lg - 1], a[i + (1 &lt;&lt; (lg - 1))][lg - 1]);            b[i][lg] = Hmin(b[i][lg - 1], b[i + (1 &lt;&lt; (lg - 1))][lg - 1]);        }                for(int i(1);i &lt;= m; ++ i) {        int l, r;        cin &gt;&gt; l &gt;&gt; r;        cout &lt;&lt; QueryMax(l, r) &lt;&lt; ' ' &lt;&lt; QueryMin(l, r) &lt;&lt; '\\n';    }    Heriko Deltana;}\r\n「三分法」\r\n\r\nUPD 2022.9.26\r\n\r\n123456789101112131415161718192021222324252627282930313233343536373839404142template&lt;typename J&gt;I J Habs(const J &amp;x) {    Heriko x &lt; 0 ? -x : x;}const double EPS(1e - 7);CI MXX(15);int n;double a[MXX], l, r;double Solve(double x) {    double res(0);    for(int i(n); i &gt;= 0; -- i)        res *= x,res += a[i];    Heriko res;}S main() {    fr(n);    scanf(\"%lf%lf\", &amp;l, &amp;r);    for(int i(n); i &gt;= 0; --i)        scanf(\"%lf\", &amp;a[i]);    while(Habs(r - l) &gt;= EPS) {        double mid((l + r) / 2);        if(Solve(mid + EPS) &gt; Solve(mid - EPS))            l = mid;        else            r = mid;    }    printf(\"%.5lf\\n\", r);    Heriko Deltana;}\r\n「KMP」\r\n\r\nUPD 2022.9.26\r\n\r\n123456789101112131415161718192021222324252627282930313233343536373839CI MXX(1e6 + 1);int lena, lenb, nex[MXX], kmp[MXX];char a[MXX], b[MXX];S main() {    scanf(\"%s%s\", a + 1, b + 1);    lena = strlen(a + 1), lenb = strlen(b + 1);    for(int i(2), j(0); i &lt;= lenb; ++ i) {        while(j &gt; 0 and b[i] != b[j + 1])            j = nex[j];        if(b[i] == b[j + 1])            ++ j;        nex[i] = j;    }    for(int i(1), j(0); i &lt;= lena; ++ i) {        while(j &gt; 0 and a[i] != b[j+1])            j = nex[j];        if(a[i] == b[j + 1])            ++ j;        kmp[i] = j;    }    for(int i(1); i &lt;= lena; ++ i)        if(kmp[i] == lenb)            fw(i - lenb + 1, 1);    for(int i(1); i &lt;= lenb; ++ i)        fw(nex[i], 0);    Heriko Deltana;}\r\n「LCA」\r\n「倍增」\r\n\r\nUPD 2022.10.11\r\n\r\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273CI MXX(5e5 + 1);int n, m, rt;struct Edge {    int nex, to;}r[MXX &lt;&lt; 1];int cnt, head[MXX];I void Add(int x, int y) {    r[++ cnt] = (Edge){head[x], y}, head[x] = cnt;    r[++ cnt] = (Edge){head[y], x}, head[y] = cnt;}int dep[MXX], f[MXX][35], lg[MXX];I void PreLog() {    for(int i(1); i &lt;= n; ++ i)        lg[i] = lg[i - 1] + ((1 &lt;&lt; lg[i - 1]) == i);}void DFS(int x,int fa) {    f[x][0] = fa;    dep[x] = dep[fa] + 1;        for(int i(1);i &lt;= lg[dep[x]]; ++ i)        f[x][i] = f[f[x][i - 1]][i - 1];            for(int i(head[x]); i; i = r[i].nex)        if(r[i].to != fa)            DFS(r[i].to, x);}I int LCA(int x, int y) {    if(dep[x] &lt; dep[y])        swap(x, y);        while(dep[x] &gt; dep[y])        x=f[x][lg[dep[x] - dep[y]] - 1];            if(x == y)        Heriko x;            for(int i(lg[dep[x]] - 1); i &gt;= 0; -- i)        if(f[x][i] != f[y][i])            x = f[x][i], y = f[y][i];                Heriko f[x][0];}S main() {    fr(n), fr(m), fr(rt);        for(int i(1);i &lt; n; ++ i) {        int x, y;        fr(x), fr(y);        Add(x, y);    }        PreLog();    DFS(rt, 0);        for(int i(1); i &lt;= m; ++ i) {        int x, y;        fr(x), fr(y);        fw(LCA(x, y), 1);    }    Heriko Deltana;}\r\n「树剖」\r\n\r\nUPD 2022.11.15\r\n\r\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364CI MXX(1e5 + 5);struct Edge {    int nex, to;}r[MXX &lt;&lt; 1];int rcnt, head[MXX];I void ADD(int x, int y) {    r[++ rcnt] = (Edge){head[x], y}, head[x] = rcnt;    r[++ rcnt] = (Edge){head[y], x}, head[y] = rcnt;}int dep[MXX], fa[MXX], sz[MXX], son[MXX];void DFS1(int x, int fath) {    fa[x] = fath;    dep[x] = dep[fath] + 1;    sz[x] = 1;    for(int i(head[x]); i; i = r[i].nex) {        int y(r[i].to);        if(y == fath)            continue;        DFS1(y, x);        sz[x] += sz[y];        if(sz[y] &gt; sz[son[x]])            son[x] = y;    }}int top[MXX];void DFS2(int x, int tp) {    top[x] = tp;    if(son[x])        DFS2(son[x], tp);    for(int i(head[x]); i; i = r[i].nex) {        int y(r[i].to);        if(y == fa[x] or y == son[x])            continue;        DFS2(y, y);    }}I int LCA(int x, int y) {    while(top[x] != top[y]) {        if(dep[top[x]] &gt;= dep[top[y]])            x = fa[top[x]];        else            y = fa[top[y]];    }    Heriko dep[x] &lt; dep[y] ? x : y;}\r\n「矩阵加速」\r\n\r\nUPD 2022.9.26\r\n\r\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162CI MOD(1e9 + 7);int n, T;struct Matrix {    LL a[5][5];    Matrix() {        mst(a, 0);    }    I void BuildB() {        mst(a, 0);        a[1][1] = a[1][3] = a[2][1] = a[3][2] = 1;    }    I void BuildA() {        mst(a, 0);        a[1][1] = a[2][1] = a[3][1] = 1;    }    I Matrix operator * (const Matrix &amp;co) const {        Matrix res;        for(int k(1); k &lt;= 3; ++ k)            for(int i(1); i &lt;= 3; ++ i)                for(int j(1); j &lt;= 3; ++ j)                    (res.a[i][j] += (a[i][k] * co.a[k][j]) % MOD) %= MOD;        Heriko res;    }}A,B;I void MatrixFstPow(int x) {    while(x) {        if(x &amp; 1)            A = A * B;        B = B * B;        x &gt;&gt;= 1;    }}S main() {    fr(T);    while(T--) {        fr(n);        if(n &lt;= 3)            puts(\"1\");        else {            A.BuildA(), B.BuildB();            MatrixFstPow(n - 1);            fw((A.a[1][1] + MOD) % MOD, 1);        }    }    Heriko Deltana;}\r\n「SPFA判负环」\r\n\r\nUPD 2022.9.26\r\n\r\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879CI MXX(3001),INF(0x3f3f3f3f);int n, m, T;struct Node {    int nex, to, val;}r[MXX &lt;&lt; 1];int cnt, head[MXX];I void Add(int x, int y, int z) {    r[++ cnt] = (Node){head[x], y, z}, head[x] = cnt;}int co[MXX], dis[MXX];bitset&lt;MXX&gt; vis;I bool SPFA(int s) {    queue&lt;int&gt; q;    q.push(s);    dis[s] = 0, vis[s] = 1, ++ co[s];    while(q.size()) {        int x(q.front());        q.pop();        vis[x] = 0;        for(int i(head[x]); i; i = r[i].nex) {            int y(r[i].to);            if(dis[y] &gt; dis[x] + r[i].val) {                dis[y] = dis[x] + r[i].val;                if(!vis[y]) {                    vis[y] = 1;                    q.push(y);                    ++ co[y];                    if(co[y] &gt; n)                        Heriko Deltana;                }            }        }    }    Heriko Romanno;}S main() {    Files();    fr(T);        while(T--) {        fr(n), fr(m);        cnt = 0, vis = 0;        mst(dis, 0x3f), mst(co, 0), mst(head, 0);        for(int i(1); i &lt;= m; ++ i) {            int x, y, z;            fr(x), fr(y), fr(z);            if(z &gt;= 0)                Add(x, y, z), Add(y, x, z);            else                Add(x, y, z);        }        if(!SPFA(1))            puts(\"YES\");        else            puts(\"NO\");    }    Heriko Deltana;}\r\n「矩阵快速幂」\r\n\r\nUPD 2022.9.26\r\n\r\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546CI NXX(101),MXX(21),MOD(1e9 + 7);struct Matrix {    int n,m,a[MXX][MXX];    Matrix() {        n = m = 0, mst(a, 0);    }    I void Build() {        for(int i(1); i &lt;= m; ++ i)            a[i][i] = 1;    }    I Matrix operator * (const Matrix &amp;co) const {        Matrix res;        res.n = n, res.m = co.m;        for(int i(1); i &lt;= n; ++ i)            for(int k(1); k &lt;= m; ++ k)                for(int j(1); j &lt;= co.m; ++ j)                    (res.a[i][j] += (1ll * a[i][k] * co.a[k][j]) % MOD) %= MOD;        Heriko res;    }}ans;int n, m;I Matrix MFP(Matrix x, int y) {    Matrix res;    res.n = res.m = m;    res.Build();    while(y) {        if(y &amp; 1)            res = res * x;        x = x * x;        y &gt;&gt;= 1;    }    Heriko res;}\r\n「AC自动机」\r\n\r\nUPD 2022.9.26\r\n\r\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273CI MXX(1e6 + 5);struct ACAM {    int c[MXX][26], val[MXX], fail[MXX], cnt;    queue&lt;int&gt; q;    I void Insert(char s[]) {        int len(strlen(s)), nw(0);        for(int i(0); i &lt; len; ++ i) {            int v(s[i] - 'a');            if(!c[nw][v])                c[nw][v]= ++ cnt;            nw = c[nw][v];        }        ++ val[nw];    }    I void Build() {        for(int i(0); i &lt; 26; ++ i)            if(c[0][i])                fail[c[0][i]] = 0, q.push(c[0][i]);        while(q.size()) {            int x(q.front());            q.pop();            for(int i(0); i &lt; 26; ++ i)                if(c[x][i])                    fail[c[x][i]] = c[fail[x]][i], q.push(c[x][i]);                else                    c[x][i] = c[fail[x]][i];        }    }    I int Query(char s[]) {        int len(strlen(s)), nw(0), res(0);        for(int i(0); i &lt; len; ++ i) {            nw = c[nw][s[i] - 'a'];            for(int j(nw); j and ~val[j]; j = fail[j])                res += val[j], val[j] = -1;        }        Heriko res;    }}AC;int n;char s[MXX];S main() {    Files();    fr(n);    for(int i(1); i &lt;= n; ++ i)        scanf(\"%s\", s), AC.Insert(s);    AC.Build();    scanf(\"%s\", s);    fw(AC.Query(s), 1);    Heriko Deltana;}\r\n「差分约束」\r\n\r\nUPD 2022.9.26\r\n\r\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374CI MXX(5e3 + 5), INF(0x3f3f3f3f);int n,m,T;struct Node {    int nex, to, val;}r[MXX &lt;&lt; 1];int cnt, head[MXX];I void Add(int x, int y, int z) {    r[++cnt] = (Node){head[x], y, z}, head[x] = cnt;}int co[MXX], dis[MXX];bitset&lt;MXX&gt; vis;I bool SPFA(int s) {    queue&lt;int&gt; q;    q.push(s);    mst(dis, 0x3f);    dis[s] = 0, vis[s] = 1, ++ co[s];    while(q.size()) {        int x(q.front());        q.pop();        vis[x] = 0;        for(int i(head[x]); i; i = r[i].nex) {            int y(r[i].to);            if(dis[y] &gt; dis[x] + r[i].val) {                dis[y] = dis[x] + r[i].val;                if(!vis[y]) {                    vis[y] = 1;                    q.push(y);                    ++ co[y];                    if(co[y] &gt;= n + 1)                        Heriko Deltana;                }            }        }    }    Heriko Romanno;}S main() {    Files();    fr(n), fr(m);    for(int i(1); i &lt;= n; ++ i)        Add(0, i, 0);    for(int i(1); i &lt;= m; ++ i) {        int x, y, z;        fr(x), fr(y), fr(z);        Add(y, x, z);    }    if(!SPFA(0))        puts(\"NO\");    else        for(int i(1); i &lt;= n; ++ i)            fw(dis[i], 0);    Heriko Deltana;}\r\n「欧拉路径」\r\n\r\nUPD 2022.9.26\r\n调了 \r\n年，结果是答案栈开小了。\r\n\r\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071CI MXX(1e5 + 5);int n, m, into[MXX], outo[MXX], lst[MXX], ans[MXX&lt;&lt;1], s, t, cnt;vector&lt; pair&lt;int, int&gt; &gt; r[MXX];bitset&lt;(MXX &lt;&lt; 1)&gt; vis;void DFS(int x) {    for(int i(lst[x]); i &lt; (int)r[x].size(); i = Hmax(i+1,lst[x])) {        int y(r[x][i].first), id(r[x][i].second);        if(!vis[id]) {            vis[id] = 1;            lst[x] = i + 1;            DFS(y);        }    }    ans[++ cnt] = x;}S main() {    Files();    fr(n), fr(m);    for(int i(1); i &lt;= m; ++ i) {        int x, y;        fr(x), fr(y);        ++ outo[x], ++ into[y];        r[x].push_back(mkp(y, i));    }    int tot(0);        for(int i(1); i &lt;= n; ++ i)        if(into[i] != outo[i]) {            ++ tot;            if(into[i] == outo[i] - 1)                s = i;            if(into[i] == outo[i] + 1)                t = i;        }    if(tot != 0 and tot != 2) {        puts(\"No\");        Heriko Deltana;    }    if(!tot)        s = t = 1;        if(!s or !t) {        puts(\"No\");        Heriko Deltana;    }    for(int i(1); i &lt;= n; ++ i)        sort(r[i].begin(), r[i].end());    DFS(s);    for(int i(cnt); i; -- i)        fw(ans[i], 0);    Heriko Deltana;}\r\n「康托展开」\r\n\r\nUPD 2022.9.26\r\n\r\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546#define lowbit(x) ((x)&amp;(-x))CI MXX(1e6 + 1), MOD(998244353);int n;LL t[MXX];I void Add(int x, LL v) {    while(x &lt;= n)        t[x] += v, x += lowbit(x);}I LL Query(int x) {    LL res(0);    while(x)        res += t[x], x -= lowbit(x);    Heriko res;}LL pw[MXX], ans;S main() {    fr(n);    for(int i(1); i &lt;= n; ++ i)        Add(i, 1);    pw[0] = 1;    for(int i(1); i &lt;= n; ++ i)        pw[i] = (pw[i - 1] * i) % MOD;    for(int i(1); i &lt;= n; ++ i) {        int x;        fr(x);        (ans += ((Query(x) - 1) * pw[n - i]) % MOD) %= MOD;        Add(x, -1);    }    fw(ans + 1, 1);    Heriko Deltana;}\r\n「威佐夫博弈」\r\n\r\nUPD 2022.9.26\r\n\r\n结论：若两堆物品的初始值为 ，且 ，则使 \r\n记 x=(LL)(((sqrt(5.0) + 1.0) / 2.0) * w);\r\n若 ，则先手必败，否则先手必胜。\r\n「莫队」\r\n\r\nUPD 2022.9.26\r\n\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566CI MXX(5e4 + 1);int n, m, k, a[MXX], sqn;LL ans[MXX], co[MXX], cnt;struct Node {    int l, r, id;    I bool operator &lt; (const Node &amp;co) const {        if(l / sqn != co.l / sqn)            Heriko l &lt; co.l;        if((l / sqn) &amp; 1)            Heriko r &lt; co.r;        Heriko r &gt; co.r;    }}q[MXX];I void Add(int x) {    }I void Del(int x) {    }S main() {    Files();    fr(n), fr(m), fr(k), sqn = sqrt(n);    for(int i(1); i &lt;= n; ++ i)        fr(a[i]);    for(int i(1); i &lt;= m; ++ i)        fr(q[i].l), fr(q[i].r), q[i].id = i;    sort(q + 1, q + 1 + m);    int lx(1), rx(0);    for(int i(1); i &lt;= m; ++ i) {        while(lx &lt; q[i].l)            Del(a[lx ++]);        while(lx &gt; q[i].l)            Add(a[-- lx]);        while(rx &lt; q[i].r)            Add(a[++ rx]);        while(rx &gt; q[i].r)            Del(a[rx --]);        ans[q[i].id] = cnt;    }    for(int i(1); i &lt;= m; ++ i)        fw(ans[i], 1);    Heriko Deltana;}\r\n「Dinic」\r\n\r\nUPD 2022.9.26\r\n\r\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192CI MXX(5001), NXX(201), INF(998244353);struct Node {    int nex, to;    LL val;}r[MXX &lt;&lt; 1];int cnt(1), head[NXX], now[NXX], n, m, s, t;I void Add(int x, int y, LL z) {    r[++ cnt] = (Node){head[x], y, z}, head[x] = cnt;    r[++ cnt] = (Node){head[y], x, 0}, head[y] = cnt;}LL dis[NXX], ans;bitset&lt;NXX&gt; vis;I bool BFS() {    mst(dis, 0);    queue&lt;int&gt; q;    q.push(s);    dis[s] = 1, now[s] = head[s];    while(q.size()) {        int x(q.front());        q.pop();        for(int i(head[x]); i; i = r[i].nex) {            if(r[i].val and !dis[r[i].to]) {                int y(r[i].to);                q.push(y);                now[y] = head[y], dis[y] = dis[x] + 1;                if(y == t)                    Heriko Romanno;            }        }    }    Heriko Deltana;}LL Dinic(int x, LL flow) {    if(x == t)        Heriko flow;    LL rst(flow), k;    for(int i(now[x]); i and rst; i = r[i].nex) {        int y(r[i].to);        if(r[i].val and dis[y] == dis[x] + 1) {            k = Dinic(y,Hmin(rst,r[i].val));            if(!rst)                Heriko flow;            if(!k)                dis[y] = 0;            r[i].val -= k,r[i ^ 1].val += k,rst -= k;        }        now[x] = i;    }    Heriko flow - rst;}S main() {    fr(n), fr(m), fr(s), fr(t);    for(int i(1); i &lt;= m; ++i) {        int x, y;        LL z;        fr(x), fr(y), fr(z);        Add(x, y, z);    }    LL flow(0);    while(BFS())        while((flow = Dinic(s, INF)))            ans += flow;    fw(ans, 1);    Heriko Deltana;}\r\n「Tarjan求强连通分量」\r\n\r\nUPD 2022.9.26\r\n\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081CI MXX(100001),NXX(10001);struct Node {    int nex, to;    }r[MXX];int rcnt, head[NXX];I void Add(int x, int y) {    r[++ rcnt] = (Node){head[x], y}, head[x] = rcnt;}int dfn[NXX], low[NXX], cnt, stak[NXX], top, tot, c[NXX];bitset&lt;NXX&gt; vis;vector&lt;int&gt; v[NXX];void Tarjan(int x) {    dfn[x] = low[x] = ++ cnt;    stak[++top] = x, vis[x] = 1;    for(int i(head[x]); i; i = r[i].nex) {        int y(r[i].to);        if(!dfn[y])            Tarjan(y), low[x] = Hmin(low[x], low[y]);        else if(vis[y])            low[x] = Hmin(low[x], dfn[y]);    }    if(dfn[x] == low[x]) {        ++ tot;        int tmp(0);        while(tmp != x) {            tmp = stak[top --];            vis[tmp] = 0;            c[tmp] = tot;            v[tot].push_back(tmp);        }    }}int n, m;S main() {    fr(n), fr(m);    for(int i(1); i &lt;= m; ++ i) {        int x, y;        fr(x), fr(y);        Add(x, y);    }    for(int i(1); i &lt;= n; ++ i)        if(!dfn[i])            Tarjan(i);    fw(tot, 1);    for(int i(1); i &lt;= n ; ++ i) {        int x(c[i]);                if(vis[x])            continue;        vis[x] = 1;        sort(v[x].begin(), v[x].end());        int sz(v[x].size());        for(int j(0); j &lt; sz; ++ j)            fw(v[x][j], 0);        puts(\"\");    }    Heriko Deltana;}\r\n「珂朵莉树」\r\n\r\n直接把我 CF896C 的代码拿过来了。\r\nUPD 2022.9.26\r\n\r\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798I LL FstPow(LL x, LL y, LL p) {    LL res(1);    x %= p;    while(y) {        if(y &amp; 1)            (res *= x) %= p;        (x *= x) %= p;        y &gt;&gt;= 1;    }    Heriko res;}//其实这个快速幂没啥用，只是下面的 Query 的时候有用到，和 ODT 本身关系不大。struct Node {    LL l,r;    mutable LL v;    Node(LL l,LL r = 0,LL v = 0) : l(l), r(r), v(v) {}    I bool operator &lt; (const Node &amp;co) const {        Heriko l &lt; co.l;    }};set&lt;Node&gt; s;I auto Split(LL pos) {    auto it(s.lower_bound(Node(pos)));    if(it != s.end() and it-&gt;l == pos)        Heriko it;    -- it;    if(it-&gt;r &lt; pos)        Heriko s.end();    LL l(it-&gt;l), r(it-&gt;r), v(it-&gt;v);    s.erase(it);    s.insert(Node(l, pos - 1, v));    Heriko s.insert(Node(pos, r, v)).first;}I void Assign(LL l, LL r, LL x) {    auto itr(Split(r + 1)), itl(Split(l));    s.erase(itl, itr);    s.insert(Node(l, r, x));}I void Add(LL l, LL r, LL x) {    auto itr(Split(r + 1)), itl(Split(l));    for(auto it(itl); it != itr; ++ it)        it-&gt;v += x;}struct Rank {    LL val, cnt;    Rank(LL val, LL cnt) : val(val),cnt(cnt) {}    I bool operator &lt; (const Rank &amp;co) const {        Heriko val &lt; co.val;    }};I LL QueryRank(LL l, LL r, LL x) {    auto itr(Split(r + 1)), itl(Split(l));    vector&lt;Rank&gt; v;        for(auto it(itl); it != itr; ++ it)        v.push_back(Rank(it-&gt;v, it-&gt;r - it-&gt;l + 1));    sort(v.begin(), v.end());    LL i(0);    for(;i &lt; (LL)v.size(); ++ i)        if(v[i].cnt &lt; x)            x -= v[i].cnt;        else            Heriko v[i].val;    Heriko v[i].val;}I LL QueryVal(LL l, LL r, LL x, LL y) {    auto itr(Split(r + 1)), itl(Split(l));    LL res(0);        for(auto it(itl); it != itr; ++ it)        res = (res + FstPow(it-&gt;v, x, y) * (it-&gt;r - it-&gt;l + 1) % y) % y;    Heriko res;}\r\n「平面最近点对」\r\n\r\n 的做法。\r\nUPD 2022.9.26\r\n\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354CI MXX(2e5 + 1);const double INF(1e12);I bool CMP(const pair&lt;double, double&gt; &amp;a, const pair&lt;double, double&gt; &amp;b) {    Heriko a.second&lt;b.second;}I double Dist(const pair&lt;double, double&gt; &amp;a, const pair&lt;double, double&gt; &amp;b) {    Heriko sqrt((long double)(a.first - b.first) * (a.first - b.first) + (long double)(a.second - b.second) * (a.second - b.second));}int n;pair&lt;double, double&gt; a[MXX], tmp[MXX];double Merge(int l, int r) {    if(l == r)        Heriko INF;    int mid((l + r) &gt;&gt; 1), top(0);    double dis(INF);    dis=Hmin(Merge(l, mid),Merge(mid + 1, r));    for(int i(l); i &lt;= r; ++ i)        if(fabs(a[mid].first - a[i].first) &lt; dis)            tmp[++ top] = a[i];    sort(tmp + 1, tmp + 1 + top, CMP);    for(int i(1); i &lt;= top; ++ i)        for(int j(i + 1); j &lt;= top; ++ j) {            if(tmp[j].second - tmp[i].second &gt;= dis)                break;                        dis = Hmin(dis, Dist(tmp[i], tmp[j]));        }       Heriko dis;}S main() {    Files();    fr(n);    for(int i(1); i &lt;= n; ++ i)        scanf(\"%lf%lf\", &amp;a[i].first, &amp;a[i].second);    sort(a + 1, a + 1 + n);    double ans(Merge(1, n));    printf(\"%.4lf\", ans);    Heriko Deltana;}\r\n「FWT」\r\n\r\nUPD 2022.9.26\r\n\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687CI MXX((1&lt;&lt;17) + 5),MOD(998244353);LL n, a[MXX], b[MXX], c[MXX], A[MXX], B[MXX];I void Into() {    for(int i(0); i &lt; n; ++ i)        a[i] = A[i], b[i] = B[i];}I void GetVal() {    for(int i(0); i &lt; n; ++ i)        c[i] = a[i] * b[i] % MOD;}I void FWTOr(LL f[], LL x) {    for(int nw(2), k(1); nw &lt;= n; nw &lt;&lt;= 1, k &lt;&lt;= 1)        for(int i(0); i &lt; n; i += nw)            for(int j(0); j &lt; k; ++ j)                (f[i + j + k] += f[i + j] * x% MOD) %= MOD;}I void FWTAnd(LL f[], LL x) {    for(int nw(2), k(1); nw &lt;= n; nw &lt;&lt;= 1, k &lt;&lt;= 1)        for(int i(0); i &lt; n; i += nw)            for(int j(0); j &lt; k; ++ j)                (f[i + j] += f[i + j + k] * x % MOD) %= MOD;}I void FWTXor(LL f[], LL x) {    for(int nw(2), k(1);nw &lt;= n; nw &lt;&lt;= 1, k &lt;&lt;= 1)        for(int i(0); i &lt; n; i += nw)            for(int j(0); j &lt; k; ++ j) {                (f[i + j] += f[i + j + k] + MOD) %= MOD;                f[i + j + k] = (f[i + j] - f[i + j + k] + MOD - f[i + j + k] + MOD) % MOD;                (f[i + j] *= x) %= MOD, (f[i + j + k] *= x) %= MOD;            }}I LL Inv(LL x, LL y = MOD - 2) {    LL res(1);    while(y) {        if(y &amp; 1)            (res *= x) %= MOD;        (x *= x) %= MOD;        y &gt;&gt;= 1;    }    Heriko res % MOD;}S main() {    Files();    fr(n);    n=(1 &lt;&lt; n);    for(int i(0); i &lt; n; ++ i)        fr(A[i]);    for(int i(0); i &lt; n; ++ i)        fr(B[i]);    Into(), FWTOr(a, 1), FWTOr(b, 1), GetVal(), FWTOr(c, MOD - 1);    for(int i(0); i &lt; n; ++ i)        fw(c[i], 0);    puts(\"\");    Into(), FWTAnd(a, 1), FWTAnd(b, 1), GetVal(), FWTAnd(c, MOD - 1);    for(int i(0); i &lt; n; ++ i)        fw(c[i], 0);    puts(\"\");    Into(), FWTXor(a, 1), FWTXor(b, 1), GetVal(), FWTXor(c, Inv(2));    for(int i(0); i &lt; n; ++ i)        fw(c[i], 0);    puts(\"\");    Heriko Deltana;}\r\n「Treap」\r\n「旋转 Treap」\r\n\r\nUPD 2022.9.26\r\n\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142CI MXX(1e6 + 5),INF(0x3f3f3f3f);struct Treap {    struct Node {        int sz, cnt;        int val, rad;        int l, r;    }    t[MXX];    #define lc(x) t[x].l    #define rc(x) t[x].r    int tot, rt;    I void Pushup(int x) {        t[x].sz = t[lc(x)].sz + t[rc(x)].sz + t[x].cnt;    }    I void RotateL(int &amp;x) {        int y(rc(x));        rc(x) = lc(y);        lc(y) = x;        Pushup(x), Pushup(y);        x = y;    }    I void RotateR(int &amp;x) {        int y(lc(x));        lc(x) = rc(y);        rc(y) = x;        Pushup(x), Pushup(y);        x = y;    }    I int Create(int val) {        t[++ tot].val = val;        t[tot].sz = t[tot].cnt = 1;        t[tot].rad = rand();        Heriko tot;    }    void Insert(int &amp;x, int val) {        if(!tot)            x = 0;        if(!x)            x = Create(val);        else if(val == t[x].val)            ++ t[x].cnt;        else if(val &lt; t[x].val) {            Insert(lc(x), val);            if(t[lc(x)].rad &gt; t[x].rad)                RotateR(x);        }        else {            Insert(rc(x), val);            if(t[rc(x)].rad &gt; t[x].rad)                RotateL(x);        }        Pushup(x);    }    void Remove(int &amp;x, int val) {        if(!x)            Heriko;        if(val == t[x].val) {            if(t[x].cnt &gt; 1)                -- t[x].cnt;            else if(!lc(x) and !rc(x))                x = 0;            else {                if(!rc(x) or t[lc(x)].rad &gt; t[rc(x)].rad) {                    RotateR(x);                    Remove(rc(x), val);                }                else {                    RotateL(x);                    Remove(lc(x), val);                }            }        }        else            val &lt; t[x].val ? Remove(lc(x),val) : Remove(rc(x),val);        Pushup(x);    }    int QRank(int x, int val) {        if(!x)            Heriko -INF;                if(t[x].val == val)            Heriko t[lc(x)].sz + 1;        if(val &lt; t[x].val)            Heriko QRank(lc(x), val);        Heriko QRank(rc(x), val) + t[lc(x)].sz + t[x].cnt;    }    int QVal(int x, int rk) {        if(!x)            Heriko -INF;        if(t[lc(x)].sz &gt;= rk)            Heriko QVal(lc(x), rk);        if(t[lc(x)].sz + t[x].cnt &gt;= rk)            Heriko t[x].val;        Heriko QVal(rc(x),rk - t[lc(x)].sz - t[x].cnt);    }    int QPre(int x, int val) {        if(!x)            Heriko -INF;        if(t[x].val &gt;= val)            Heriko QPre(lc(x), val);        else            Heriko Hmax(t[x].val, QPre(rc(x), val));    }    int QSuf(int x, int val) {        if(!x)            Heriko INF;        if(t[x].val &lt;= val)            Heriko QSuf(rc(x), val);        else            Heriko Hmin(t[x].val, QSuf(lc(x), val));    }}Tree;\r\n「非旋 Treap」\r\n\r\nUPD 2022.9.26\r\n\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136CI MXX(5e5 + 5),INF(0x3f3f3f3f);struct FHQ_Treap {    struct Node {        int val, rad;        int sz;        int l, r;    }    t[MXX];    #define lc(x) t[x].l    #define rc(x) t[x].r    int tot,rt;    I void Pushup(int x) {        t[x].sz = t[lc(x)].sz + t[rc(x)].sz + 1;    }    I int Create(int val) {        t[++tot].val = val;        t[tot].rad = rand();        t[tot].l = t[tot].r = 0;        t[tot].sz = 1;        Heriko tot;    }    void Split(int x, int val, int &amp;lx, int &amp;rx) {        if(!x) {            lx = rx = 0;            Heriko;        }        if(t[x].val &lt;= val) {            lx = x;            Split(rc(x), val, rc(x), rx);        }        else {            rx = x;            Split(lc(x), val, lx, lc(x));        }        Pushup(x);    }    int Merge(int x, int y) {        if(!x or !y)            Heriko x + y;        if(t[x].rad &gt; t[y].rad) {            rc(x) = Merge(rc(x), y);            Pushup(x);            Heriko x;        }        else {            lc(y) = Merge(x, lc(y));            Pushup(y);            Heriko y;        }    }    I void Insert(int val) {        int x, y;        Split(rt, val - 1, x, y);        rt=Merge(Merge(x,Create(val)), y);    }    I void Remove(int val) {        int x, y, z;        Split(rt, val, x, z);        Split(x, val-1, x, y);        if(y)            y = Merge(lc(y), rc(y));        rt = Merge(Merge(x, y), z);    }    I int QRank(int val) {        int x, y, res;        Split(rt, val - 1, x, y);        res = t[x].sz + 1;        rt = Merge(x, y);        Heriko res;    }    I int QVal(int rk) {        int x(rt);        while(x) {            if(t[lc(x)].sz + 1 == rk)                break;            else if(t[lc(x)].sz &gt;= rk)                x = lc(x);            else rk -= t[lc(x)].sz + 1, x = rc(x);        }        Heriko !x ? INF : t[x].val;    }    I int QPre(int val) {        int x, y, nw, res;        Split(rt, val - 1, x, y);        nw = x;        while(rc(nw))            nw = rc(nw);        res = t[nw].val;        rt = Merge(x,y);        Heriko res;    }    I int QSuf(int val) {        int x, y, nw, res;        Split(rt, val, x, y);        nw = y;        while(lc(nw))            nw = lc(nw);        res = t[nw].val;        rt = Merge(x,y);        Heriko res;    }}Tree;\r\n「Splay」\r\n\r\nUPD 2022.9.26\r\n\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231CI MXX(1e5 + 5);struct SPlay {    struct Node {        int cnt, val;        int sz;        int f, c[2];    }        t[MXX];    #define lc(x) t[x].c[0]    #define rc(x) t[x].c[1]    #define c(x, y) t[x].c[y]    #define fa(x) t[x].f        int tot,rt;    I void Pushup(int x) {        t[x].sz = t[lc(x)].sz + t[rc(x)].sz + t[x].cnt;    }    I bool Status(int x) {        Heriko x == rc(fa(x));    }    I void Clear(int x) {        lc(x) = rc(x) = fa(x) = t[x].val = t[x].cnt = t[x].sz = 0;    }    I void Rotate(int x) {        int y(fa(x)), z(fa(y)), st(Status(x));        c(y,st) = c(x,st^1);        if(c(x, st ^ 1))            fa(c(x, st ^ 1)) = y;        c(x, st ^ 1) = y;        fa(y) = x, fa(x) = z;        if(z)            c(z, y == c(z, 1)) = x;        Pushup(y), Pushup(x);    }    I void Splay(int x) {        for(int i(fa(x)); i = fa(x), i; Rotate(x))            if(fa(i))                Rotate(Status(x) == Status(i) ? i : x);        rt = x;    }    I void Insert(int val) {        if(!rt) {            t[++ tot].val = val;            t[tot].cnt = t[tot].sz = 1;            lc(tot) = rc(tot) = 0;            rt = tot;            Pushup(rt);            Heriko;        }        int nw(rt), y(0);        while(1) {            if(t[nw].val == val) {                ++ t[nw].cnt;                Pushup(nw),Pushup(y);                Splay(nw);                break;            }            y = nw, nw = c(nw, t[nw].val &lt; val);            if(!nw) {                t[++ tot].val = val;                t[tot].cnt = t[tot].sz = 1;                fa(tot) = y;                c(y,t[y].val &lt; val) = tot;                Pushup(tot), Pushup(y);                Splay(tot);                break;            }        }    }    I int QRank(int val) {        int ans(0), nw(rt);        while(1) {            if(val &lt; t[nw].val)                nw = lc(nw);            else {                ans += t[lc(nw)].sz;                if(val == t[nw].val) {                    Splay(nw);                    Heriko ans + 1;                }                ans += t[nw].cnt;                nw = rc(nw);            }        }    }    I int QVal(int rk) {        int nw(rt);        while(1) {            if(lc(nw) and rk &lt;= t[lc(nw)].sz)                nw = lc(nw);            else {                rk -= t[nw].cnt + t[lc(nw)].sz;                if(rk &lt;= 0) {                    Splay(nw);                    Heriko t[nw].val;                }                nw = rc(nw);            }        }    }    I int QPre() {        int nw(lc(rt));        if(!nw)            Heriko nw;        while(rc(nw))            nw = rc(nw);        Splay(nw);        Heriko nw;    }    I int QSuf() {        int nw(rc(rt));        if(!nw)            Heriko nw;        while(lc(nw))            nw = lc(nw);        Splay(nw);        Heriko nw;    }    I void Remove(int x) {        QRank(x);        if(t[rt].cnt &gt; 1) {            -- t[rt].cnt;            Pushup(rt);            Heriko;        }        if(!lc(rt) and !rc(rt)) {            Clear(rt);            rt = 0;            Heriko;        }        if(!lc(rt)) {            int nw(rt);            rt = rc(rt);            fa(rt) = 0;            Clear(nw);            Heriko;        }        if(!rc(rt)) {            int nw(rt);            rt = lc(rt);            fa(rt) = 0;            Clear(nw);            Heriko;        }        int nw(rt), y(QPre());        fa(rc(nw)) = y;        rc(y) = rc(nw);        Clear(nw);        Pushup(rt);    }}Tree;int n, opt, x;S main() {    Files();    fr(n);    while(n --) {        fr(opt), fr(x);        if(opt == 1)            Tree.Insert(x);        else if(op t== 2)            Tree.Remove(x);        else if(opt == 3)            fw(Tree.QRank(x), 1);        else if(opt == 4)            fw(Tree.QVal(x), 1);        else if(opt == 5)            Tree.Insert(x), fw(Tree.t[Tree.QPre()].val, 1), Tree.Remove(x);        else            Tree.Insert(x), fw(Tree.t[Tree.QSuf()].val, 1), Tree.Remove(x);    }    Heriko Deltana;}\r\n「组合数」\r\n\r\nUPD 2022.9.26\r\n\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445CI MXX(5e5 + 5), MOD(998244353);I LL FstPow(LL x, LL y) {    x %= MOD;    LL res(1);     while(y) {        if(y &amp; 1)            (res *= x) %= MOD;        (x *= x) %= MOD;        y &gt;&gt;= 1;    }    Heriko res % MOD;}LL fac[MXX], infac[MXX];I LL C(LL x, LL y) {    if(x &lt; 0 or y &lt; 0 or x &lt; y)        Heriko Deltana;    Heriko fac[x] * infac[x - y] % MOD * infac[y] % MOD;}LL n;S main() {    Files();    fr(n);    fac[0] = 1;    for(int i(1);i &lt;= n; ++ i)        fac[i] = fac[i - 1] * i % MOD;    infac[n] = FstPow(fac[n], MOD-2);    for(int i(n - 1); i &gt;= 0; -- i)        infac[i] = infac[i + 1] * (i + 1) % MOD;    Heriko Deltana;}\r\n「逆序对」\r\n\r\nUPD 2022.10.5\r\n\r\n「归并排序」\r\n1234567891011121314151617181920212223242526272829303132333435363738int n, a[500010], d[500010];LL p;void sortx(int b, int c) {    if(b == c)        Heriko;        int mid((b + c) / 2), i(b), j(mid + 1), k(b);    sortx(b, mid), sortx(mid + 1, c);    while(i &lt;= mid and j &lt;= c)        if(a[i] &lt;= a[j])            d[k ++] = a[i ++];        else {            d[k ++] = a[j ++];            p += mid - i + 1;        }    while(i &lt;= mid)        d[k ++] = a[i ++];    while(j &lt;= c)        d[k ++] = a[j ++];    for(int l(b); l &lt;= c; ++ l)        a[l] = d[l];}void Solve() {    fr(n);    for(int i(1); i &lt;= n; ++ i)        fr(a[i]);    sortx(1, n);    fw(p, 1);}\r\n「树状数组」\r\n1234567891011121314151617181920212223242526272829303132333435363738394041424344#define lowbit(x) ((x) &amp; (-x))CI MXX(5e5 + 5);int t[MXX], n, pos[MXX];pair&lt;int, int&gt; a[MXX];I void Modify(int x, int v) {    while(x &lt;= n)        t[x] += v, x += lowbit(x);}I LL Query(int x) {    LL res(0);    while(x)        res += t[x], x -= lowbit(x);    Heriko res;}LL ans;S main() {    fr(n);    for(int i(1); i &lt;= n; ++ i)        fr(a[i].first), a[i].second = i;        sort(a + 1, a + 1 + n);        for(int i(1); i &lt;= n; ++ i)        pos[a[i].second] = i;    for(int i(1); i &lt;= n; ++ i) {        Modify(pos[i], 1);        ans += i - Query(pos[i]);    }    fw(ans, 1);    Heriko Deltana;}\r\n「Manacher」\r\n\r\nUPD 2023.8.18\r\n\r\n123456789101112131415161718192021222324252627282930313233343536373839404142CI MXX(2.3e7);int ans, p[MXX], l;char org[MXX], s[MXX];I void Into() {    s[l ++] = '$', s[l ++ ] = '#';    while(cin &gt;&gt; s[l])         s[++ l] = '#', ++ l;    s[l ++] = '^', s[l] = '\\0';}I void Manacher() {    int id(0), mx(0);    for(int i(0); i &lt; l; ++ i) {        if(i &lt; mx)            p[i] = Hmin(p[(id &lt;&lt; 1) - i], mx - i);        else            p[i] = 1;                while(s[i - p[i]] == s[i + p[i]])            ++ p[i];        if(i + p[i] &gt; mx)            id = i, mx = i + p[i];        ans = Hmax(ans, p[i] - 1);    }}S main() {    ON, Into();    Manacher();    cout &lt;&lt; ans;    Heriko Deltana;}\r\n","slug":"Models","date":"2021-11-19T12:44:48.000Z","categories_index":"OI-Solutions","tags_index":"OI","author_index":"Heriko Deltana"},{"id":"008c4babb4e8e24d712d4c9d2f875346","title":"NOIP 2021 游记","content":"「NOIP 2021 游记」\r\n\r\n\r\n\r\n不知道为什么，写不出什么积极的东西。\r\n2021.11.17\r\n\r\n「2021.11.9」\r\n离开学校去到 BCT，开始 8 天的集训。\r\n「2021.11.16」\r\n听说考场有 sublime text 3，于是开始在 BCT\r\n电脑上下一个开始用。\r\n「2021.11.17」\r\n集训今天结束，算是很不错的体验，考试基本能正解一题，认识很多新朋友，见到了\r\nUF 真人/se，手残删掉的 Phigros 的 rks 回到了原来的分，甚至现在到了\r\n12.83.\r\n今天老师说要欢乐赛，结果……\r\n\r\n\r\n这里说甚至 UF 还能发说说是因为 UF 只能用那里的电脑上 QQ.\r\n\r\nT1诈骗，然后就把T1切了。\r\n最一开始用的 sublime\r\n的自带编译，后来发现不能加其它编译选项，于是学会了写\r\nmakefile.\r\n准备明天回学校。\r\n「2021.11.18」\r\n回了学校，打板子，发现了 360 的优美特效：占用 .exe\r\n文件运行时间 1s.\r\n「2021.11.19」\r\n晚上不知道干啥，心情随着🐏删除东西，格盘逐渐down起来。\r\n明天之后高二好多人就退役了。。。。\r\n而我平时除了 Dfkuaid，就高二的人玩的多了吧。\r\n孩子还小，接受不了。\r\n昨天晚上辗转睡不着。。\r\n去阳台打开窗户吹了一段时间风。\r\n风。\r\n初冬风。\r\n但是有点冷。\r\n我在干啥。\r\n我不知道。\r\n于是就迷迷糊糊回去睡了。\r\n半夜，\r\n梦见 NOIP 成绩出了，我卡线1=？\r\n不懂。\r\n不知道是在梦里醒了，\r\n还是现实醒了。\r\n我发现我在床上反着躺着。\r\n于是正了过来，继续睡。\r\n不知道为啥我要写这个。\r\n不知道。\r\n","slug":"NOIP2021Days","date":"2021-11-17T10:52:09.000Z","categories_index":"OI-TravelNotes","tags_index":"OI","author_index":"Heriko Deltana"},{"id":"3ae413f824edf0385a58ee53cc0da85e","title":"ZR NOIP21 D9 简记","content":"「雪降り、メリクリ 」\r\n\r\n\r\n圣诞，圣诞，圣诞节！\r\n「启」\r\n立冬就下暴雪，好。\r\n随便写一下，因为 C 和 D 都不想写代码了，所以就快快口胡一下吧。\r\n缺省源使用：「V5.2」。\r\n「A」\r\n按照 %m 来统计方案数，每次用矩阵来转移。\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778CI NXX(101),MXX(21),MOD(1e9+7);struct Matrix{    int n,m,a[MXX][MXX];    Matrix()    {        n=m=0,mst(a,0);    }    I void Build()    {        for(int i(1);i&lt;=m;++i)            a[i][i]=1;    }    I Matrix operator * (const Matrix &amp;co) const    {        Matrix res;        res.n=n,res.m=co.m;        for(int i(1);i&lt;=n;++i)            for(int k(1);k&lt;=m;++k)                for(int j(1);j&lt;=co.m;++j)                    (res.a[i][j]+=(1ll*a[i][k]*co.a[k][j])%MOD)%=MOD;        Heriko res;    }}ans;int n,m;I Matrix MFP(Matrix x,int y){    Matrix res;    res.n=res.m=m;    res.Build();    while(y)    {        if(y&amp;1)            res=res*x;        x=x*x;        y&gt;&gt;=1;    }    Heriko res;}S main(){    Files();    fr(n),fr(m);    ans.n=1,ans.m=m;    ans.a[1][m]=1;    for(int i(1);i&lt;=n;++i)    {        int x,y;        fr(x),fr(y);        Matrix tmp;        tmp.n=tmp.m=m;        for(int j(1);j&lt;=m;++j)            ++tmp.a[j][j],++tmp.a[j][(j+y-1)%m+1];        ans=MFP(tmp,x)*ans;    }    fw((ans.a[1][m]+MOD-1)%MOD,1);    Heriko Deltana;}\r\n「B」\r\n结论题，好像有很多人是直接上了平衡树（\r\n但是其实玩一玩就能发现，假如我们给  这些段编上编号：，就会发现，这些段在最后的顺序只和\r\n\r\n的奇偶性相关，即偶数的时候先倒序输出偶数编号的段再顺序输出奇数段，反之先倒叙输出奇数段，再正序输出偶数段。\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354CI MXX(5e5+1);int n,k,q[MXX],cnt1,cnt2;pair&lt;int,int&gt; co1[MXX],co2[MXX];char s[MXX];S main(){    Files();    fr(n),fr(k);    scanf(\"%s\",s+1);    int lst(1);    for(int i(1);i&lt;=k;++i)    {        fr(q[i]);        if(i&amp;1)            co1[++cnt1]=mkp(lst,q[i]);        else            co2[++cnt2]=mkp(lst,q[i]);        lst=q[i]+1;    }    if(k&amp;1)    {        for(int i(cnt1);i;--i)            for(int j(co1[i].second);j&gt;=co1[i].first;--j)                putchar(s[j]);        for(int i(1);i&lt;=cnt2;++i)            for(int j(co2[i].first);j&lt;=co2[i].second;++j)                putchar(s[j]);    }    else    {        for(int i(cnt2);i;--i)            for(int j(co2[i].second);j&gt;=co2[i].first;--j)                putchar(s[j]);        for(int i(1);i&lt;=cnt1;++i)            for(int j(co1[i].first);j&lt;=co1[i].second;++j)                putchar(s[j]);    }    for(int i(lst);i&lt;=n;++i)        putchar(s[i]);    Heriko Deltana;}\r\n「C」\r\n分讨，先把奇数的情况全加上一个 ，再把 \r\n的情况转化为其他数组合的方案，于是就只剩下了  需要考虑。\r\n然后考虑如何把 \r\n转化为其他的数字。考虑模 \r\n的余数，发现除了余 \r\n的时候都能有唯一的方案，然后这四种之间通过加减  可以最后转化为两类，然后就看要多少的\r\n 和 \r\n没写代码，爬。\r\n「D」\r\n好像设涉及泰勒展开和多项式求和，这比我技能树高的不知道到哪去了（\r\n🎨：写完了ヽ(✿ﾟ▽ﾟ)ノ 我去发到博客里。\r\n🐟: ヽ✿ﾟﾟノ\r\n「保留内容」\r\n🐏：非抄袭，非代表性，个人印象。\r\n🐏：我现在都不会A我靠都 都很厉害AZ很 厉害🤩\r\n🎨：AB 都 A 了，但是我场上没 A 掉\r\nA。嗯😩我胡诌。好多人都是什么伸臂方法啥的，我™硬理解理解出来这个，但是我不会实现。。。。然后看王亦木，发现差不多，然后乆写，最后调了半天发现乘法的地方爆int了（\r\n🐟: 都在学习, 只有🐟在颓废😭\r\n🎨：呜呜呜\r\n🐏：我写A去了👋🏻草好我要学矩阵\r\n🎨：祝你拿最优解，主要是前面的复杂度和我都不一样。那个我理解不出来，你看\r\nxuruiyang 那个\r\n🐏：我看看去 (【🐟：空格好评玉喜为你点赞】)我哦也不会\r\n🎨：卧槽我用 ☁️ 这个键盘的错字率太高了，平均每个字都能错。\r\n🎨：多 人 混 战\r\n","slug":"ZR-NOIP21-D9-Solu","date":"2021-11-07T08:33:01.000Z","categories_index":"OI-Solutions","tags_index":"OI","author_index":"Heriko Deltana"},{"id":"6c193b926de29f769d23260e72e32a0a","title":"CSP S2 2021 题解","content":"「CSP S2 2021（部分）题解」\r\n\r\n\r\n「启」\r\n因为觉得场上很不甘心，所以就把自己场上看过的前三题写了出来。\r\nT4 没有写，因为觉得不是我的能力范围之内的（\r\n但是总体上来说今年的题好像简单的比去年简单（？），难的也比去年简单（？），但是总体难度好像难一点，再加上暴力分比去年少，所以分数线低（？）\r\n反正去年的贪吃蛇我是一点想法都没有，今年 T4 还是有点想法的（\r\n\r\n以下代码均使用缺省源 V5.2.\r\n\r\n「A」廊桥分配\r\n总的来说这道题真的不难，自己场上的做法和正解只是一个循环的区别，但是场上光想着先把能打的暴力全打了就没把这道题继续往下想。\r\n要写这个的时候，觉得应当测一下官方数据，没想到居然 \r\n第一个点挂了，于是改的时候又重新修了一下码风。\r\n「A」思路简述\r\n首先先是场上的 \r\n的暴力做法。\r\n思路非常的简单，先排序，然后枚举分配的时间，然后里面枚举飞机，每次将应当飞走的飞机从堆中弹出，然后让当前的飞机到编号最小的廊桥停下。\r\n考场代码太丑了，我也懒得修就不放了。\r\n但是这样显然是过不了的，于是考虑优化。首先可以想到的是这样贪心绝对是没问题的，所以我们考虑如何让这个过程的复杂度降低。\r\n仔细分析一下，其实我们可以把两种飞机分开预处理，最后再将对应的答案合并。于是我们就要对于每种飞机处理出分配\r\n 到 \r\n个廊桥的方案，为了优化复杂度我们肯定不能再傻傻的枚举。\r\n根据刚才我们的贪心策略，我们每次放飞机的时候都是要找到编号最小的廊桥把放进去，所以我们可以把可用廊桥的编号扔到一个小根堆里面，然后每次被使用的时候和占用这个廊桥的飞机一起扔到另外一个堆里面，这样我们处理的复杂度就降为了\r\n\r\n「A」Code\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y) {    Heriko x&gt;y?x:y;}template&lt;typename J&gt;I J Hmin(const J &amp;x,const J &amp;y){    Heriko x&lt;y?x:y;}CI MXX(1e5+1);int n,m1,m2,coa[MXX],cob[MXX],ans;struct Plane{    int l,r;    I bool operator &lt; (const Plane &amp;co) const     {        Heriko (l==co.l)?(r&lt;co.r):(l&lt;co.l);    }}a1[MXX],a2[MXX];priority_queue&lt;int&gt; id;priority_queue&lt; pair&lt;int,int&gt; &gt; q;S main(){    Files();    fr(n),fr(m1),fr(m2);    for(int i(1);i&lt;=m1;++i)        fr(a1[i].l),fr(a1[i].r);    for(int i(1);i&lt;=m2;++i)        fr(a2[i].l),fr(a2[i].r);    sort(a1+1,a1+1+m1);    sort(a2+1,a2+1+m2);    for(int i(1);i&lt;=n;++i)        id.push(-i);    for(int i(1);i&lt;=m1;++i)    {        while(q.size() and -q.top().first&lt;a1[i].l)            id.push(-q.top().second),q.pop();        if(id.size())         {            q.push(make_pair(-a1[i].r,-id.top()));            ++coa[-id.top()];id.pop();        }    }    for(int i(1);i&lt;=n;++i)        coa[i]+=coa[i-1];    while(id.size())        id.pop();    while(q.size())        q.pop();    for(int i(1);i&lt;=n;++i)        id.push(-i);    for(int i(1);i&lt;=m2;++i)    {        while(q.size() and -q.top().first&lt;a2[i].l)            id.push(-q.top().second),q.pop();        if(id.size())        {            q.push(make_pair(-a2[i].r,-id.top()));            ++cob[-id.top()];id.pop();        }    }    for(int i(1);i&lt;=n;++i)        cob[i]+=cob[i-1];    for(int i(0);i&lt;=n;++i)        ans=Hmax(ans,coa[i]+cob[n-i]);    fw(ans,1);    Heriko Deltana;}\r\n「B」括号序列\r\n感觉是一道恶心的题，然后场上写了三个小时挂了，最后写的暴力也挂了，然后提交样例还\r\nCE 了，Bad.\r\n「B」思路简述\r\n暴力就不说了，\r\n的暴搜，下面的内容主要参考了I_am_Accepted\r\n的题解。\r\n看到数据范围之后，我们心中大约有了一个比较常规的复杂度：，而这是一个比较正常的区间 DP\r\n的复杂度，所以我们就先正常的设状态和转移。\r\n设  表示  为合法序列且  和  匹配的方案数，而 \r\n表示不匹配的数量，这样就能避免重复计算的情况，最终的答案显然为 。同时因为我们最多有  个\r\n*，为了后面方便使用，可以在最初用  的时间预处理出来。\r\n而在转移之前还需要特判一些状态：\r\n\r\n当端点为符号未确定且不能成为括号的时候，跳过；\r\n当当前区间的长度为 \r\n的时候，，跳过。\r\n\r\n然后就是转移，首先是 \r\n\r\n\r\n\r\n\r\n\r\n\r\n然后是 \r\n\r\n\r\n\r\n然而这个转移是 \r\n的，所以考虑优化这个的复杂度，发现  每次增减 ，\r\n的变化是 \r\n的，可控，所以我们可以先预处理出来合法的下一个转移对象，然后就优化成了\r\n\r\n「B」Code\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y) {    Heriko x&gt;y?x:y;}template&lt;typename J&gt;I J Hmin(const J &amp;x,const J &amp;y){    Heriko x&lt;y?x:y;}CI MXX(501),MOD(1e9+7);int n,k,nex[MXX];LL f[MXX][MXX],g[MXX][MXX];bitset&lt;MXX&gt; co[MXX];char s[MXX];S main(){    Files();    fr(n),fr(k);    scanf(\"%s\",s+1);    for(int i(1);i&lt;=n;++i)    {        if(s[i]!='*' and s[i]!='?')            continue;        co[i][i]=1;        for(int j(i+1);j&lt;=n;++j)            if(s[j]=='*' or s[j]=='?')                co[i][j]=1;            else                break;    }    for(int len(2);len&lt;=n;++len)    {        for(int l(1),r;l&lt;=n-len+1;++l)        {            r=len+l-1;f[l][r]=g[l][r]=0;            if((s[l]!='(' and s[l]!='?') or (s[r]!=')' and s[r]!='?'))                continue;            if(l+1==r)            {                (f[l][r]+=1)%=MOD;                                continue;            }            /*----F----*/            if(r-l-1&lt;=k and co[l+1][r-1])                (f[l][r]+=1)%=MOD;            (f[l][r]+=f[l+1][r-1]+g[l+1][r-1])%=MOD;            for(int i(l+1);i&lt;=Hmin(l+k,r-2);++i)                if(co[l+1][i])                    (f[l][r]+=f[i+1][r-1]+g[i+1][r-1])%=MOD;            for(int i(r-1);i&gt;=Hmax(l+2,r-k);--i)                if(co[i][r-1])                    (f[l][r]+=f[l+1][i-1]+g[l+1][i-1])%=MOD;            /*----G----*/            LL tmp(0);            for(int i(l+1);i&lt;r-1;++i)            {                if(tmp&lt;=i)                    tmp=i+1;                while(tmp&lt;r-1 and (s[tmp]=='?' or s[tmp]=='*'))                    ++tmp;                nex[i]=Hmin((LL)i+k+1,tmp);            }            tmp=0;            for(int i(l+2);i&lt;=nex[l+1];++i)                (tmp+=f[i][r])%=MOD;            (g[l][r]+=((f[l][l+1]+g[l][l+1])%MOD*tmp))%=MOD;            for(int i(l+2);i&lt;r-1;++i)            {                (tmp+=MOD-f[i][r])%=MOD;                for(int j(nex[i-1]+1);j&lt;=nex[i];++j)                    (tmp+=f[j][r])%=MOD;                (g[l][r]+=((f[l][i]+g[l][i])%MOD*tmp))%=MOD;            }        }    }    fw((f[1][n]+g[1][n]+MOD)%MOD,1);    Heriko Deltana;}\r\n「C」回文\r\n多测没清空的痛啊，暴力分都没了……\r\n「C」思路简述\r\n实际上，因为要构成回文串，所以当我们在进行第  步操作的时候，就能知道  次操作取出的数应当和其相同。\r\n然后又因为每次只能从两段取数，所以原来的序列就被分为了两个连续的部分，于是就考虑用两个\r\ndeque 去维护从左端取出的数和从右端取出的数。\r\n然后就有以下四种情况（因为要最优的方案，所以已经按照字典序排序）:\r\n\r\n 的头尾相同，则第  次操作为 ，第  次为 \r\n 的头和  的头相同，则第  次操作为 ，第  次为 \r\n 的尾和  的尾相同，则第  次操作为 ，第  次为 \r\n 的头尾相同，则第  次操作为 ，第  次为 \r\n\r\n按照最优的策略先从左端开始跑一边再从右端开始跑一边，如果两次都不能构成就说明无解。\r\n「C」Code\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177CI MXX(1e6+4);int n,m,a[MXX];char ans[MXX];deque&lt;int&gt; l,r;I void Solve(){    /*----Start At L----*/    l.clear();    r.clear();    l.push_back(a[1]);    l.push_back(a[2]);    for(int i(3);i&lt;=m;++i)        if(l.front()!=l.back())            l.push_back(a[i]);        else            r.push_back(a[i]);    int flg(0),cnt(0);    while(cnt&lt;n)    {        if(flg)            break;        flg=1;        if(l.size()&gt;1 and l.front()==l.back())        {            flg=0;            ans[++cnt]='L',ans[m-cnt+1]='L';            l.pop_front();            l.pop_back();            continue;        }        if(l.size() and r.size() and l.front()==r.front())        {            flg=0;            ans[++cnt]='L',ans[m-cnt+1]='R';            l.pop_front();            r.pop_front();            continue;        }        if(l.size() and r.size() and l.back()==r.back())        {            flg=0;            ans[++cnt]='R',ans[m-cnt+1]='L';            l.pop_back();            r.pop_back();            continue;        }        if(r.size()&gt;1 and r.front()==r.back())        {            flg=0;            ans[++cnt]='R',ans[m-cnt+1]='R';            r.pop_front();            r.pop_back();            continue;        }    }    if(!flg)    {        for(int i(1);i&lt;=m;++i)            putchar(ans[i]);        puts(\"\");        Heriko;    }    /*----Start At R----*/    l.clear();    r.clear();    r.push_front(a[m]);    r.push_front(a[m-1]);    for(int i(m-2);i;--i)        if(r.front()!=r.back())            r.push_front(a[i]);        else            l.push_front(a[i]);    l.push_back(r.front());    r.pop_front();    flg=cnt=0;    while(cnt&lt;n)    {        if(flg)        {            puts(\"-1\");            Heriko;        }        flg=1;        if(l.size()&gt;1 and l.front()==l.back())        {            flg=0;            ans[++cnt]='L',ans[m-cnt+1]='L';            l.pop_front();            l.pop_back();            continue;        }        if(l.size() and r.size() and l.front()==r.front())        {            flg=0;            ans[++cnt]='L',ans[m-cnt+1]='R';            l.pop_front();            r.pop_front();            continue;        }        if(l.size() and r.size() and l.back()==r.back())        {            flg=0;            ans[++cnt]='R',ans[m-cnt+1]='L';            l.pop_back();            r.pop_back();            continue;        }        if(r.size()&gt;1 and r.front()==r.back())        {            flg=0;            ans[++cnt]='R',ans[m-cnt+1]='R';            r.pop_front();            r.pop_back();            continue;        }    }    for(int i(1);i&lt;=m;++i)        putchar(ans[i]);    puts(\"\");}S main(){    Files();    int T;fr(T);    while(T--)    {        fr(n);m=n*2;        for(int i(1);i&lt;=m;++i)            fr(a[i]);        Solve();    }    Heriko Deltana;}\r\n「结」\r\n算是完成了自己的心愿吧（\r\n\r\n","slug":"CSP-S2-2021-Solu","date":"2021-11-03T12:19:16.000Z","categories_index":"OI-Solutions","tags_index":"OI","author_index":"Heriko Deltana"},{"id":"190d977963f6fcdcd6d63529cbe7b7c2","title":"Blog Develop Log","content":"「记录这个博客的更改」\r\n\r\n\r\n如果看过我 Cnblogs\r\n博客的应当知道我很闲，在一个博皮上稍微改个颜色都要记录一下（\r\n然而我习惯难改所以这个新博客也有这个东西了呐。\r\n\r\n\r\n2024.2.24\r\n\r\n将 Hexo 更新至 7.1.1\r\n将 Aurora 更新至 v2.5.3\r\n\r\n字体回归了默认，暂时不变了。\r\n\r\n更新了更加符合现状的 About\r\n将 remoe-id 加入到\r\nGitalk 管理中，这样她也能帮我开评论区了（\r\n[Todo]\r\n代码高亮暂时出点问题，高考完修一修。\r\n\r\n2022.8.1\r\n\r\nfork 了一个吃掉小鹿乃，放在 https://hriver2.github.io/EatKano\r\n了。\r\n\r\n2022.5.29\r\n\r\n目前搬运完了评论，但是部分页面还存在问题。\r\n目前字体、友链页（照片未恢复）等已经正常，基本配置结束。\r\n\r\n2022.5.28\r\n\r\n更换主题为 aurora，尚需进一步配置\r\n\r\n\r\n在这里放一个 icarus 时期的博客纪念一下（\r\n\r\n\r\n2022.4.19\r\n\r\n修改默认字体为 Formula1 Display.\r\n\r\n2022.1.7\r\n\r\n开始加题图咯（\r\n\r\n2021.11.2\r\n\r\n配置好了友链，欢迎来互换友链（\r\n\r\n2021.11.1\r\n\r\n配置好了 gitalk，现在可以自由的评论力！\r\n\r\n2021.10.31\r\n\r\n配置好了 Mathjex.\r\n移除了对于我无用的捐赠等界面。\r\n\r\n2021.10.30\r\n\r\n正式启用这个博客。\r\n\r\n2021.10.29\r\n\r\n选用主题 icarus，并进行初步的设置。\r\n\r\n\r\n","slug":"Blog-Develop-Log","date":"2021-11-01T12:31:44.000Z","categories_index":"MyBlog","tags_index":"About Blog","author_index":"Heriko Deltana"},{"id":"60a2083e080a888d14d4279dda720de8","title":"CSP S2 2021 游记","content":"「CSP S2 2021 游记」\r\n\r\n\r\n「在启之前」\r\n这个后面的内容和博客园上是一样的，但是这是更偏向我个人向的博客，所以我还是多说一点（\r\n今天晚上出成绩之后，和之前自己预测的差不多，应该是个能进 NOIP\r\n但是省三/省二的分数。在博客园上写的标题是\"退役记\"，但是都明白实际上这一切才刚开始一年。\r\n即使只剩下了高二一次机会，\r\n即使 NOIP 省一要比 CSP-S2 难，\r\n即使因为考场上有各种失误而不甘，\r\n但是还是要打下去的，不然为什么要选 OI 呢。\r\n所以应当摆大烂！\r\n所以应当接着努力（\r\n「启」\r\n孩子第一年打比赛，给孩子打傻了。\r\n因为复赛就 10.23 一下午而已，所以就用日期当标题了。\r\n「2021.9.X」\r\n发现自己过了初赛，按照 CCF 的标准来说，居然还是 《全 国 一\r\n等》，笑傻。\r\n「2021.10.1 ~ 10.7」\r\n报了 ZR 的线上课，在家听课。\r\n最后一天考试感觉不错，体验很好。\r\n「2021.10.8 ~ 10.21」\r\nZR 的 NOIP\r\n冲刺，每天都在考试，但是时好时坏……总体不好，题也补不完，就很蛋……\r\n「2021.10.21」\r\n提前一天从学校回到家，晚上进行了随便看了看模板，去 fys 的 CSP 2020\r\n赛前总结那里看一些易错点，顺便扫墓。\r\n晚上和初中班主任打了电话，虽然已经在高中上了 10\r\n个月的课了，但是和初中班主任联系还是很多，好多事情都必须要感谢，人真的很好（\r\n主要说了点关于心态的东西，然后晚上大约就水过去了。\r\n因为 Phigros 22 号要更新，所以我试图等更新，但是后来发现都说是 22\r\n号下午，就没再等，然后乆睡了。\r\n「2021.10.22」\r\n上午和昨天晚上差不多，中午吃完饭往日照走。晚上敲了个线段树板子，结果没调出来，懒得调乆睡觉了。\r\n下午在车上更新了 phigros，2.0 属实好看，体验很好（\r\n新铺子除了狂喜的 IN 都觉得简单了好多，☁️女孩慢速彻底没了（\r\n因为 Win11 刚上了 WSA，整了一会，体验一般。\r\n「2021.10.23」\r\n\r\n比赛日。\r\n\r\n「上午」\r\n上午先是试图调出来昨天晚上的线段树，但是发现 KnightL 他们建了一个 SD\r\n面基群，然后就听 hyl 唱歌（？）\r\n然后去找 Dfkuaid，ceh，hyl，在他们宾馆呆了一会。\r\n然后就是正常的吃饭，实际上到了吃饭的时候才发现好像真的要比赛了呐，会宾馆睡了一会，我爸说睡得很香。\r\n「下午」\r\n起床之后乆直接去山外了，时隔三个月又回到了这个破地方……SDSC\r\n属实难受。\r\n下车正好遇到 hyl，Dfkuaid，ceh\r\n下车，我们四个乆一块去，然后就是非常正常的进行拍照，本来还要喊某口号来着。\r\n口号则是去年 LCEZ 的 CSP 二轮典中典：\r\n$$\r\n人生在勤，志达天下\\\r\n亮剑精神，信息之光\\\r\n脚踏实地，勇争第一\\\r\n$$\r\n然后就是进去考试试机（\r\n「13:50 ~ 14:27」\r\n说实话因为心里没想啥所以就只是单纯的打了我常用的缺省源，试了试\r\nauto，bitset 等自 己 常\r\n用的东西（埋 下 雷\r\n了），然后测了测机子的速度，可以说是很慢。所以我还去确认了一下配置之类的。最后总结来看我考试用的机子的环境是：\r\n\r\ni3-4130 + 4G + Win10 + DevC++ 5.10 (gcc 4.8.1)\r\n\r\n嗯没错这个环境 c++14 开不了，虽然好像部分符合 14\r\n的标准来着（\r\n试了试 __int128\r\n发现不能用，但是试机的时候没想出来为啥不能用，后来考试开始了我才发现是因为这个破东西的\r\nDevC++ 默认的 gcc 是 32bit……当然最后也没用到 __int128\r\n就是了。\r\n发现输入法没有英语环境，乆从设置里整了一下，然后按照自己的使用习惯又开了两个桌面，这三个桌面分别负责\r\nCoding，读题 and 审题，以及检查文件。\r\n把 DevC++ 的时间戳自动保存开开了，防止出问题。\r\n看 起 来 真 的 是 十 分 万 全 的 准 备 了 呐。\r\n然后乆没测啥，等着发密码。去看了一眼文件的大小，发现有个样例好大的样子，略感震惊。\r\n密码好像就是非常正常的随机生成的样子来着（\r\n「14:30 ~ 14:45」\r\n这个十五分钟先是过了一遍题，当时觉得 A 仿佛是最可做的，B 和 C 有一点\r\nDP 的意思，以上三题都有暴力分，分别是 40 + 15 + 28，D\r\n觉得不太可做，所以就最后开题的顺序是 A(BF)B(BF)C(BF)ABCD.\r\n「14:45 ~ 15:00」\r\n这十五分钟主要是把 A\r\n的暴力写了出来，然后测了测样例，发现三个都过了，就按照既定的顺序去写 B\r\n的暴力了。\r\n然后，一 个 人 类 的 噩 梦 来 了。\r\n「15:01 ~ 17:47」\r\n前半段时间就一直在写 B 的暴力 DFS，我不知道为什么最后总是一会 RE\r\n一会不 RE，很奇怪，于是就去开了 C 的暴力。\r\n也是一个 DFS，难道是本场暴力都是 DFS 么（悲\r\n然后……写了一段时间，也和刚才的 B 差不多，同一段代码一会 RE，一会不\r\nRE，就给孩子整离谱了（？\r\n然后因为之前喝了两罐 RB，于是就决定去上个撤硕。\r\n上撤硕的时候灵光乍现：它 RE 的时候总是说我 vector.h\r\n这个头文件错了，不 会 是 哪 个 STL 锅 了 吧。\r\n然后我就自然的想到了 string 身上。\r\n「17:57 ~ 18:30」\r\n回去之后，想了一下发现其实 C 没必要用，用 char\r\n数组就行，然后，果然不 RE 了（？\r\n然后发现答案的字典序不对，就又对着调了一下，后来发现是对比的时候下标对应错了，改完就对了，而这个时候已经来到了\r\n18:11，终于是过了样例……\r\n然后去看了半天的 B，死活改不出，然后在 18:21\r\n的时候终于放弃抵抗，把样例全都特判了上去，并把自己打的 DFS\r\n注释掉，并在其中慰问了 CCF.\r\n然后最后检查了一遍就把东西整好了交上去了，要交的时候问了一下旁边的老师是不是没有什么问题，然后老师看了看，说“都身经百战了，这点不会错的，不用紧张这些。”\r\n第一年打的孩子大为震惊（\r\n临近考试结束了，旁边的孩子吃东西的表情越来越绝望，看来是打的也不好啊（\r\n考完了去看了看同场的 hyl，它还在交文件。\r\n出了考场发现除了我都切了\r\nA，然后算了算发现今年暴力打满还不如一个正解……突然感觉省一无了，省二勉强。（实际上是省三（\r\n「晚上」\r\n因为第二天要返校，所以当天晚上乆回去了，路上和爸妈，和初中班主任，进行了一堆聊天（\r\n最后觉得应当能进 NOIP 就考虑接下来如何权衡 whk 和奥赛，说实话因为 whk\r\n不如其它的人好，所以确实很纠结。\r\n晚上到家十点半，上床之后不知道为什么就是睡不着，虽然过去 CSP\r\n感觉还是没啥两样，但是确实是睡不着（\r\n手机放在旁边充电，看了一会 QQ，然后就睡了。\r\n「2021.10.24」\r\n今天早上起来发现：\r\n\r\n\r\n晚上（也就是现在）发了程序，本来期望是  或者 \r\n结果呢洛谷测一测……T2 注释多了 CE 了，T3\r\n好像暴力假了爆零。\r\n更正一下，T3 爆零是因为多测清空不完全，暴力部分内的答案是对的。\r\n目前测试的结果：\r\n洛谷 （10.24\r\n测，期望最低，希望 CCF 数据能放亿点水qwq）\r\nInfOJ （10.29自测，这个 T3 可能比较现实）\r\nLOJ （10.26自测，可能是这个的 T3 数据有  的部分）\r\nHydroOJ （批量，可能这个 T1 的数据水一点，不知道为啥 T3 的数据改的像\r\nLOJ 一样有  的东西了）\r\n最后应该是  pts 滚粗，恭喜你\r\nLCEZ 喜提一个省三。\r\n「2021.10.30」\r\n出成绩了，和 LOJ 的一样，等 NOIP 吧。\r\n","slug":"CSP-S2-2021","date":"2021-10-30T13:16:08.000Z","categories_index":"OI-TravelNotes","tags_index":"OI","author_index":"Heriko Deltana"},{"id":"8c0f3b54ca85bb77cb36eb75c09fff9a","title":"CF 1602 ABCF","content":"「随便做点题。」\r\n\r\n\r\n\r\n同步发布于博客园\r\n\r\n「启」\r\n实在是不想接着补前几天的 NOIP 冲刺了（尤其是遇到 Day11 D\r\n这种毒瘤题），于是就上洛谷随便做点题。\r\n发现今天的日推是 CF1602A，于是乆决定把这场比赛的\r\nA,B,C 都做了，然后发现 F\r\n也挺水的，就一起水掉了（\r\n「Div2.A」Two Subsequences\r\n「Div2.A」题目简述\r\n给出一个字符串 ，要求找到一个字典序最小的非空字串，然后输出这个字串和原字符串删掉这个字串后形成的串。\r\n「Div2.A」思路简述\r\n还是一如既往的手速题（\r\n因为是找出一个字典序最小的非空字串，所以找到一个字典序最小的字母即可。\r\n「Code」\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define Heriko return#define Deltana 0#define Romanno 1#define S signed#define LL long long#define R register#define I inline#define CI const int#define mst(a, b) memset(a, b, sizeof(a))#define ON std::ios::sync_with_stdio(false);cin.tie(0)#define Files() freopen(\"RNMTQ.in\",\"r\",stdin);freopen(\"RNMTQ.out\",\"w\",stdout)using namespace std;template&lt;typename J&gt;I void fr(J &amp;x){    short f(1);x=0;char c=getchar();    while(c&lt;'0' or c&gt;'9')    {        if(c=='-') f=-1;                c=getchar();    }    while (c&gt;='0' and c&lt;='9')     {        x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^=48);        c=getchar();    }       x*=f;}template&lt;typename J&gt;I void fw(J x,bool k){    if(x&lt;0) x=-x,putchar('-');    static short stak[35];short top(0);    do    {        stak[top++]=x%10;        x/=10;    }    while(x);    while(top) putchar(stak[--top]+'0');    k?puts(\"\"):putchar(' ');}CI MXX(1005);char s[MXX];S main(){    Files();    int T;fr(T);    while(T--)    {        scanf(\"%s\",s+1);        int a(1),n(strlen(s+1));        for(int i(2);i&lt;=n;++i)            if(s[i]&lt;s[a])                a=i;        putchar(s[a]);putchar(' ');        for(int i(1);i&lt;=n;++i)            if(i!=a)                putchar(s[i]);        puts(\"\");    }    Heriko Deltana;}\r\n「Div2.B」Divine Array\r\n「Div2.B」题目简述\r\n给出一个长度为 \r\n的序列，求问在经过第 \r\n次变换之后序列中的第  个数。\r\n第  次变换为：对于所有的 ，将  变为  在第  次修改后出现的次数。\r\n「Div2.B」思路简述\r\n时空限制还是挺宽的，而且我们可以简单的手玩一下发现一个序列进行最多\r\n\r\n操作之后就不会发生变化了，所以我们预处理出每次操作后的序列即可。\r\n「Div2.B」Code\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define Heriko return#define Deltana 0#define Romanno 1#define S signed#define LL long long#define R register#define I inline#define CI const int#define mst(a, b) memset(a, b, sizeof(a))#define ON std::ios::sync_with_stdio(false);cin.tie(0)#define Files() freopen(\"RNMTQ.in\",\"r\",stdin);freopen(\"RNMTQ.out\",\"w\",stdout)using namespace std;template&lt;typename J&gt;I void fr(J &amp;x){    short f(1);x=0;char c=getchar();    while(c&lt;'0' or c&gt;'9')    {        if(c=='-') f=-1;                c=getchar();    }    while (c&gt;='0' and c&lt;='9')     {        x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^=48);        c=getchar();    }       x*=f;}template&lt;typename J&gt;I void fw(J x,bool k){    if(x&lt;0) x=-x,putchar('-');    static short stak[35];short top(0);    do    {        stak[top++]=x%10;        x/=10;    }    while(x);    while(top) putchar(stak[--top]+'0');    k?puts(\"\"):putchar(' ');}CI MXX(2001);int a[MXX][MXX],co[MXX];S main(){    Files();    int T;fr(T);    while(T--)    {        int n,q;fr(n);        for(int i(1);i&lt;=n;++i) fr(a[i][0]),co[i]=0;        fr(q);        for(int i(1);i&lt;=n;++i) ++co[a[i][0]];        for(int i(1);i&lt;=n;++i)        {            for(int j(1);j&lt;=n;++j) a[j][i]=co[a[j][i-1]];            for(int j(1);j&lt;=n;++j) co[j]=0;            for(int j(1);j&lt;=n;++j) ++co[a[j][i]];        }        while(q--)        {            int x,k;fr(x),fr(k);            if(k&gt;n) fw(a[x][n],1);            else fw(a[x][k],1);        }    }    Heriko Deltana;}\r\n「Div2 C/Div1 A」Array\r\nElimination\r\n「Div2 C/Div1 A」题目简述\r\n给出一个长度为 \r\n的序列，定义操作 elimination(k) 为：从序列中选取  个数，设 ，然后让这  个数都减去 ，直到所有的  都变为 \r\n求问能选出多少个 ，输出它们。\r\n「Div2 C/Div1 A」思路简述\r\n考虑到要让数变为全 ，于是我们选的数 and\r\n起来必须要让每个数每一位上的 \r\n都被消除，所以选定的 \r\n必然是所有位上的 \r\n出现次数的公因数。\r\n总体的时间复杂度为 \r\n「Div2 C/Div1 A」Code\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define Heriko return#define Deltana 0#define Romanno 1#define S signed#define LL long long#define R register#define I inline#define CI const int#define mst(a, b) memset(a, b, sizeof(a))#define ON std::ios::sync_with_stdio(false);cin.tie(0)#define Files() freopen(\"RNMTQ.in\",\"r\",stdin);freopen(\"RNMTQ.out\",\"w\",stdout)using namespace std;template&lt;typename J&gt;I void fr(J &amp;x){    short f(1);x=0;char c=getchar();    while(c&lt;'0' or c&gt;'9')    {        if(c=='-') f=-1;                c=getchar();    }    while (c&gt;='0' and c&lt;='9')     {        x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^=48);        c=getchar();    }       x*=f;}template&lt;typename J&gt;I void fw(J x,bool k){    if(x&lt;0) x=-x,putchar('-');    static short stak[35];short top(0);    do    {        stak[top++]=x%10;        x/=10;    }    while(x);    while(top) putchar(stak[--top]+'0');    k?puts(\"\"):putchar(' ');}CI MXX(2e5+1);int GCD(int x,int y) {Heriko !y?x:GCD(y,x%y);}int a[MXX],n,co[31],ans[MXX],cnt;S main(){    Files();    int T;fr(T);    while(T--)    {        fr(n);mst(co,0);cnt=0;        for(int i(1);i&lt;=n;++i) fr(a[i]);        for(int i(1);i&lt;=n;++i)            for(int j(0);j&lt;=30;++j)                co[j]+=((a[i]&gt;&gt;j)&amp;1);        int g(0);        for(int i(0);i&lt;=30;++i) g=GCD(g,co[i]);        if(!g)        {            for(int i(1);i&lt;=n;++i) fw(i,0);            puts(\"\");            continue;        }        for(int i(1);i*i&lt;=g;++i)            if(!(g%i))            {                ans[++cnt]=i;                if(i*i!=g) ans[++cnt]=(g/i);            }                sort(ans+1,ans+1+cnt);        for(int i(1);i&lt;=cnt;++i) fw(ans[i],0);        puts(\"\");    }    Heriko Deltana;}\r\n「Div1.D/Div2.F」Difficult\r\nMountain\r\n「Div1.D/Div2.F」题面简述\r\n有  个人去爬难度为  的山，每个人都有  两个值。\r\n 表示当且仅当一个人的  大于 \r\n的时候它才能登山，后者则表示这个人登山之后这所山的权值会被修改为 \r\n「Div1.D/Div2.F」思路简述\r\n显然是要贪心的去解，手玩分讨发现，当最值相等时我们让 \r\n小的先爬不会使答案变劣，所以我们直接进行一边排序即可。\r\n「Div1.D/Div2.F」Code\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define Heriko return#define Deltana 0#define Romanno 1#define S signed#define LL long long#define R register#define I inline#define CI const int#define mst(a, b) memset(a, b, sizeof(a))#define ON std::ios::sync_with_stdio(false);cin.tie(0)#define Files() freopen(\"RNMTQ.in\",\"r\",stdin);freopen(\"RNMTQ.out\",\"w\",stdout)using namespace std;template&lt;typename J&gt;I void fr(J &amp;x){    short f(1);x=0;char c=getchar();    while(c&lt;'0' or c&gt;'9')    {        if(c=='-') f=-1;                c=getchar();    }    while (c&gt;='0' and c&lt;='9')     {        x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^=48);        c=getchar();    }       x*=f;}template&lt;typename J&gt;I void fw(J x,bool k){    if(x&lt;0) x=-x,putchar('-');    static short stak[35];short top(0);    do    {        stak[top++]=x%10;        x/=10;    }    while(x);    while(top) putchar(stak[--top]+'0');    k?puts(\"\"):putchar(' ');}template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y) {Heriko x&gt;y?x:y;}CI MXX(500001);struct Rubbisher{    int a,s;    I bool operator &lt; (const Rubbisher &amp;co) const    {        int mx1(Hmax(a,s)),mx2(Hmax(co.a,co.s));        if(mx1!=mx2) Heriko mx1&lt;mx2;        else Heriko s==co.s?a&lt;co.a:s&lt;co.s;    }}a[MXX];int n,d,ans;S main(){    Files();    fr(n),fr(d);    for(int i(1);i&lt;=n;++i) fr(a[i].s),fr(a[i].a);    sort(a+1,a+1+n);    for(int i(1);i&lt;=n;++i)        if(a[i].s&gt;=d)            ++ans,d=Hmax(d,a[i].a);    fw(ans,1);    Heriko Deltana;}\r\n「终」\r\n水。\r\n","slug":"CF-1602-ABCF","date":"2021-10-30T09:26:59.000Z","categories_index":"OI-Solutions","tags_index":"OI","author_index":"Heriko Deltana"},{"id":"b58122a29595b463e3b3cdbfe8d3a623","title":"Start.","content":"「此博客启用于 2021.10.30」\r\n\r\n再进行了一些列调试之后，这个博客大约可以开始正常使用力ヽ(✿ﾟ▽ﾟ)ノ\r\n那么就开始啦，这个博客（\r\n\r\n这个博客目前好像和 Cnblogs 的那个博客没太有区分度呐（\r\n不过以后肯定会不太一样罢，这边会更新一些生活上的东西罢，而那边更偏向\r\nOI 的样子。\r\n目前是这样想的，其它以后再说吧，现在还不知道呐（\r\nε=ε=ε=(~￣▽￣)~\r\n\r\n大约是关于我的东西。\r\n","slug":"Start","date":"2021-10-30T01:49:18.000Z","categories_index":"MyBlog","tags_index":"About Blog","author_index":"Heriko Deltana"},{"id":"f648796dba6bb3303d2b1c7ee54c44cc","title":"ZROI NOIP21 冲刺汇总","content":"「正睿 NOIP20 天冲刺」\r\n\r\n\r\n\r\n同步发布于ZROI NOIP21\r\n冲刺汇总 (Cnblogs)\r\n\r\n「启」\r\n[TOC]\r\n实际上之前是单独发的，但是因为每天一测，不一定能够补完当天的题目，所以就将所有的未补完的考试中已经补过的题放在这里。\r\n四道题全部整完的会单独发出。\r\n\r\nUPD 2021.11.8\r\n\r\n「Day1」\r\n讲课，略。\r\n「Day2」\r\n✅ ZR-NOIP21-20D-D2\r\n已经整理完，博客为：总之就是 | ZROI\r\nNOIP21 冲刺 Day2。\r\n「Day3」\r\n⬜ ZR-NOIP21-20D-D3\r\n「启」\r\n今天在🐏的强码力支持下没有爆零（\r\n缺省源和「这一篇」一致；\r\n「A」\r\n\r\n一道搞一搞出奇迹的题。\r\n\r\n「A」题目简述\r\n给出一个 \r\n的矩阵，里面填入了  到 ，求问最少进行几次操作可以使得这个矩阵满足：每行三个数之和为\r\n，每列三个数之和为 ，且每条对角线三个数之和也为 \r\n操作即为交换相邻的两个数，题目为  组询问。\r\n「A」思路简述\r\n经过手玩/爆搜，发现如果我们把矩阵表述为一个长为  的序列，最终只有  种目标序列：\r\n\r\n于是我们考虑去双向 BFS.\r\n于是考虑一下这样做的复杂度：一共有  种操作，一个矩阵最多扩展出  种状态，也就是说复杂度为 \r\n但是这样是过不去的，于是考虑把这个 \r\n的常数干掉，于是乆有了对于目标矩阵的离散化，所以最终的时间复杂度为 \r\n在 BFS 的过程之中用到了 Hash 去判断重复状态（\r\n「A」Code\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149template&lt;typename J&gt;I J Hmin(const J &amp;x,const J &amp;y) {Heriko x&lt;y?x:y;}CI MOD(1000003),TXX(400000);int n,Tco[10],f[10][10],sum,Sco[9][10],co[10],a[10];int r[13][2];void Pre(){    for(int i(1);i&lt;=9;++i) Tco[i]=i;    do    {        if (Tco[1]+Tco[2]+Tco[3] != 15 or Tco[4]+Tco[5]+Tco[6] != 15 or         Tco[7]+Tco[8]+Tco[9] != 15 or Tco[1]+Tco[4]+Tco[7] != 15 or         Tco[2]+Tco[5]+Tco[8] != 15 or Tco[3]+Tco[6]+Tco[9] != 15 or        Tco[1]+Tco[5]+Tco[9] != 15 or Tco[3]+Tco[5]+Tco[7] != 15)            continue;                ++sum;        for (int i(1);i&lt;=9;++i) f[sum][i]=Tco[i],Sco[sum][Tco[i]]=i;        puts(\"\");    }     while(next_permutation(Tco+1,Tco+10));    r[1][0]=1,r[1][1]=2;    r[2][0]=2,r[2][1]=3;    r[3][0]=1,r[3][1]=4;    r[4][0]=2,r[4][1]=5;    r[5][0]=3,r[5][1]=6;    r[6][0]=4,r[6][1]=5;    r[7][0]=5,r[7][1]=6;    r[8][0]=4,r[8][1]=7;    r[9][0]=5,r[9][1]=8;    r[10][0]=6,r[10][1]=9;    r[11][0]=7,r[11][1]=8;    r[12][0]=8,r[12][1]=9;}struct Core{    int id,ans;};struct Node{    int nxt,key,cnt;}t[TXX];int head[MOD+10],tot;I void Add(int x,int k) {t[++tot]=(Node){(int)head[x%MOD],x,k};head[x%MOD]=tot;}I bool CheckBool(int x){    for (int i(head[x%MOD]);i;i=t[i].nxt)        if (t[i].key==x)            Heriko Romanno;    Heriko Deltana;}I int CheckInt(int x){    for (int i(head[x%MOD]);i;i=t[i].nxt)        if (t[i].key==x)            Heriko t[i].cnt;    Heriko Deltana;}int m[10];I int Modify(int x,int id){    int temp(0),now,pw(1);    for(int i(9);i;--i) m[i]=(x%10),x/=10;    for (int i(9);i;--i)    {        now=m[i];        if (now==r[id][1]) now=r[id][0];        else if (now==r[id][0]) now=r[id][1];        temp+=pw*now;pw*=10;    }    Heriko temp;}I void BFS(){    queue&lt;Core&gt; q;    q.push((Core){123456789,0});    while (!q.empty())    {        int x=q.front().id;        int k=q.front().ans;        q.pop();        if (CheckBool(x)) continue;        Add(x,k);        for (int i=1;i&lt;=12;++i)        {            int Ner(Modify(x,i));               q.push((Core){Ner,k+1});        }    }}int main(){    Files();    Pre();BFS();    int T;fr(T);    while (T--)    {        for(int i(1);i&lt;=9;++i) fr(a[i]);        int ans(100);        for(int i(1);i&lt;=8;++i)        {            for(int j(1);j&lt;=9;++j) co[j]=Sco[i][a[j]];            int temp(0),pw(1);            for(int j(9);j;--j) temp+=pw*co[j],pw*=10;            ans = min(CheckInt(temp),ans);        }        fw(ans,1);    }    Heriko Deltana;}\r\n「Day4」\r\n✅ ZR-NOIP-21-20D-D4\r\n已经整理完，博客为：总之就是 | ZROI\r\nNOIP21 冲刺 Day4。\r\n「Day5」\r\n⬜ ZR-NOIP21-20D-D5\r\n「启」\r\n昨天上大分，今天挂大分，就当是一场梦，醒来还是很感动\r\n\r\n缺省源使用「V5」.\r\n\r\n「A」\r\n\r\n这题我场上写假了两个之后，又交了个假的上去……\r\n\r\n「A」题目简述\r\n对于长度同为  的数  和 ，定义其距离为 \r\n现在你可以任意交换 \r\n的两个元素，求使得距离最短的最少交换次数。\r\n求距离，若 ，输出最少交换次数。\r\n数据范围：\r\n「A」思路简述\r\n对于最短距离，sort 一下即可。\r\n对于交换次数，我们用冰茶姬维护一下，再比较即可。\r\n「A」Code\r\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950CI MXX(3e5+1),MOD(998244353);struct Node{    int val,id;    I bool operator &lt; (const Node &amp;co) const {Heriko val&lt;co.val;}}a[MXX],b[MXX];int n,opt,fa[MXX];LL ans;LL Find(int x){    if(fa[x]!=x) fa[x]=Find(fa[x]);    Heriko fa[x];}S main(){    Files();    fr(n),fr(opt);    for(int i(1);i&lt;=n;++i) fr(a[i].val),a[i].id=i;    for(int i(1);i&lt;=n;++i) fr(b[i].val),b[i].id=i;    for(int i(1);i&lt;=n;++i) fa[i]=i;    sort(a+1,a+1+n);sort(b+1,b+1+n);    for(int i(1);i&lt;=n;++i) (ans+=1ll*(a[i].val-b[i].val)*(a[i].val-b[i].val)%MOD)%=MOD,fa[Find(a[i].id)]=Find(b[i].id);    fw((ans+MOD)%MOD,0);    if(opt)    {        ans=0;        for(int i(1);i&lt;=n;++i) ans+=(fa[i]!=i);        fw(ans,1);    }    Heriko Deltana;}\r\n「B」\r\n\r\n场上想的是正解，但是因为做 A 做的心态炸了所以场上就没写出来（\r\n\r\n「B」题目简述\r\n国际象棋中，主教这个棋子可以攻击所有与其在同一条斜线上的位置（自己所处位置也算在内），现在在\r\n 的棋盘中给出 \r\n个主教，问棋盘中还有几个不会被攻击到的位置。\r\n数据范围：\r\n「B」思路简述\r\n因为是 ，即使是三秒时限， 也铁定过不去，所以考虑  的做法。\r\n考虑到一个棋子带来的影响只在两条直线上，所以我们考虑这两条直线的解析式：\r\n于是我们只需要记录  和  来判断边出现过没有即可。\r\n因为所有的 \r\n都是平行的，所以我们只需要考虑其和所有 \r\n的交点即可，而这个可以前缀和优化。\r\n于是乆做到了复杂度 \r\n「B」Code\r\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849template&lt;typename J&gt;I J Habs(const J &amp;x) {Heriko x&lt;0?-x:x;}CI MXX(2e6+1);int n,m,sum[MXX];LL ans;bitset&lt;MXX&gt; co[2];S main(){    Files();    fr(n),fr(m);    for(int i(1),x,y;i&lt;=m;++i)    {        fr(x),fr(y);        int b1(x+y-1),b2(y-x+n);        co[0][b1]=co[1][b2]=1;    }        n&lt;&lt;=1;    for(int i(1);i&lt;n;++i)        if(co[0][i])        {            int temp(Habs((n&gt;&gt;1)-i));            --sum[temp+1],++sum[n-temp+1];        }\t            for(int i(3);i&lt;n;++i) sum[i]+=sum[i-2];        for(int i(1);i&lt;n;++i)        if(i&lt;=(n&gt;&gt;1)) sum[i]+=i;        else sum[i]+=n-i;        for(int i(1);i&lt;n;++i)        if(co[1][i])            sum[i]=0;                for(int i(1);i&lt;n;++i) ans+=sum[i];        fw(ans,1);    Heriko Deltana;}\r\n「Day6」\r\n⬜ 21-NOIP21-20D-D6\r\n「启」\r\n今天这题给我做离谱了……希望几天之后的 CSP 不要这样出题……\r\n各种毒瘤题，还卡常（\r\n\r\n缺省源使用「V5」\r\n\r\n「A」\r\n\r\n这题场上因为读错题耽误了一个半小时，结果最后写完暴力发现又读错了题……我真是服了（\r\n\r\n「A」题目复述\r\n\r\n因为读错 \r\n遍题，所以就不简述了吧（\r\n\r\n「A」思路简述\r\n因为第一页写在了第 \r\n页，根据题意，那么接下来的几天的页数会一天比一天小，然后会出现一个 。然后去掉写过的这几页，又会重复这样的情况。\r\n对于  中每一段连续的 ，相当于就是要在剩下的页数里，选出若干页给这一段连续的\r\n 使用（由于第  页一定会选，所以计算组合数时上下都要减\r\n），于是就在排列  中找到所有  的  构成一个长度为  的数列 ，那么答案为：\r\n\r\n用 set 维护 ，每次修改去修改前驱或后继即可。\r\n「A」Code\r\n\r\n我最一开始 ans 开了两个，一个全局，一个在\r\nmain 里面，就因为这个调了两个小时。\r\n\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169CI MXX(3e5+1),MOD(1e9+7);int n,m,a[MXX];LL fac[MXX],inv[MXX],val[MXX],ans(1);bitset&lt;MXX&gt; co;set&lt;LL&gt; s;I LL FstPow(LL x,LL y){    LL res(1);    while(y)    {        if(y&amp;1) (res*=x)%=MOD;        (x*=x)%=MOD,y&gt;&gt;=1;    }    Heriko res;}I void Pre(){    fac[0]=1;    for(int i(1);i&lt;=n;++i) fac[i]=fac[i-1]*i%MOD;     inv[n]=FstPow(fac[n],MOD-2);    for(int i(n-1);i&gt;=0;--i) inv[i]=inv[i+1]*(i+1)%MOD;}I LL C(int x,int y) {Heriko ((fac[x]*inv[y]%MOD)*inv[x-y])%MOD;}I void Add(int x){    auto i(s.lower_bound(x));    auto lst(i);    if(i==s.begin())    {        (ans*=C(n-1,x-1))%=MOD;        (ans*=FstPow(val[(*i)],MOD-2))%=MOD;        (ans*=C(n-x-1,(*i)-x-1))%=MOD;        val[x]=C(n-1,x-1);        val[(*i)]=C(n-x-1,(*i)-x-1);    }    else if(i==s.end())    {        --i;        (ans*=C(n-(*i)-1,x-(*i)-1))%=MOD;        val[x]=C(n-(*i)-1,x-(*i)-1);    }    else    {        --lst;        (ans*=C(n-(*lst)-1,x-(*lst)-1))%=MOD;        val[x]=C(n-(*lst)-1,x-(*lst)-1);        (ans*=FstPow(val[(*i)],MOD-2))%=MOD;        (ans*=C(n-x-1,(*i)-x-1))%=MOD;        val[(*i)]=C(n-x-1,(*i)-x-1);    }        s.insert(x);}I void Del(int x){    auto i(s.lower_bound(x));    auto lst(i);    auto org(i);    if(i==s.begin())    {        (ans*=FstPow(val[x],MOD-2))%=MOD;        ++i;        (ans*=FstPow(val[(*i)],MOD-2))%=MOD;        val[(*i)]=C(n-1,(*i)-1);        (ans*=val[(*i)])%=MOD;        val[x]=0;    }    else    {        --lst,++i;        (ans*=FstPow(val[x],MOD-2))%=MOD;        if(i!=s.end())        {            (ans*=FstPow(val[(*i)],MOD-2))%=MOD;            (ans*=C(n-(*lst)-1,(*i)-(*lst)-1))%=MOD;            val[(*i)]=C(n-(*lst)-1,(*i)-(*lst)-1);        }                val[x]=0;    }    s.erase(org);}S main(){    Files();    fr(n),fr(m);Pre();    for(int i(1);i&lt;=n;++i) fr(a[i]);    int lsti(0);    for(int i(1);i&lt;=n;++i)    {        co[i]=(a[i]&lt;a[i+1]);                if(co[i])        {            (ans*=C(n-lsti-1,i-lsti-1))%=MOD;            val[i]=C(n-lsti-1,i-lsti-1);            s.insert(i);lsti=i;        }    }        fw(ans,1);    while(m--)    {        int x,y;fr(x),fr(y);        swap(a[x],a[y]);        int lstq;                if(x!=1)        {              lstq=co[x-1];            co[x-1]=(a[x-1]&lt;a[x]);                        if(lstq != co[x-1]) co[x-1]?Add(x-1):Del(x-1);        }        if(x!=n)        {            lstq=co[x];            co[x]=(a[x]&lt;a[x+1]);            if(lstq != co[x]) co[x]?Add(x):Del(x);        }        if(y!=1)        {            lstq=co[y-1];            co[y-1]=(a[y-1]&lt;a[y]);                        if(lstq != co[y-1]) co[y-1]?Add(y-1):Del(y-1);        }        if(y!=n)        {            lstq=co[y];            co[y]=(a[y]&lt;a[y+1]);                        if(lstq != co[y]) co[y]?Add(y):Del(y);        }        fw(ans,1);    }    Heriko Deltana;}\r\n「Day7」\r\n⬜ 21-NOIP21-20D-D7\r\n「启」\r\n\r\n4h 做 A，结果多测清空不规范，爆零两行泪。\r\n可是就快要复赛了啊……还在爆零……\r\n\r\n缺省源使用「V5」.\r\n「A」\r\n\r\n4h，两个假算法，多测清空不规范，TLE，爆零。\r\n\r\n「A」题目简述\r\n你参加了一个为期 \r\n天的夏令营，在此  到  天内有  个活动，其中第  个活动对你的吸引力是  ，且将从第  天持续到第  天（包括  和 ）。\r\n每天你最多参加 kk\r\n个活动，你想知道在此期间，哪一天的活动对你的吸引力总和最大。\r\n数据范围：\r\n「A」思路简述\r\n枚举时间，将当前可选的活动加入时间序列，维护两个堆，一个小根堆表示现在选了哪些课程保持大小为\r\n，另一个堆维护剩下的随时准备补位。\r\n「A」Code\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y) {Heriko x&gt;y?x:y;}CI MXX(3e5+2);int d,n,k,h[MXX];LL ans;bitset&lt;MXX&gt; in,no;vector&lt; pair&lt;int,int&gt; &gt; v[MXX];priority_queue&lt; pair&lt;int,int&gt; &gt; hp,thp;I void Clear(){    for(int i(1);i&lt;=d+1;++i) v[i].clear();    while(hp.size()) hp.pop();    while(thp.size()) thp.pop();    in=no=0;}I void Solve(){    int opt(0),x(0),sz(0),val(0),num(0);    LL sum(0);ans=0;    for(int i(1);i&lt;=d;++i)    {        for(auto j:v[i])        {            opt=j.first,x=j.second;            if(opt)            {                if(sz&lt;k)                {                    sum+=h[x];++sz;in[x]=1;                    hp.push(make_pair(-h[x],x));                }                else                {                    while(no[hp.top().second]) hp.pop();                    val=-hp.top().first;num=hp.top().second;                    if(h[x]&gt;val)                    {                        in[x]=1;in[num]=0;                        sum+=(h[x]-val);                        hp.pop();                        hp.push(make_pair(-h[x],x));                        thp.push(make_pair(val,num));                    }                    else thp.push(make_pair(h[x],x));                }            }            else            {                no[x]=1;                if(in[x])                {                    sum-=h[x];--sz;                                        while (thp.size() &amp;&amp; no[thp.top().second]) thp.pop();                    if(thp.size())                    {                        val=thp.top().first,num=thp.top().second;thp.pop();                        if(!no[num])                        {                            sum+=val,in[num]=1,++sz;                            hp.push(make_pair(-val,num));                        }                    }                }            }        }        ans=Hmax(ans,sum);    }}S main(){    Files();    int T;fr(T);    for(int ct(1);ct&lt;=T;++ct)    {        Clear();fr(d),fr(n),fr(k);        for(int i(1),l,r;i&lt;=n;++i)         {            fr(h[i]),fr(l),fr(r);            v[l].push_back(make_pair(1,i));            v[r+1].push_back(make_pair(0,i));        }        Solve();printf(\"Case #%d: %lld\\n\",ct,ans);    }    Heriko Deltana;}\r\n「Day8」\r\n⬜ 21-NOIP21-20D-D8\r\n「Day9」\r\n⬜ 21-NOIP21-20D-D9\r\n「启」\r\n拉了。\r\n\r\n缺省源使用「V5」.\r\n\r\n「A」\r\n\r\n场上想了一堆拉掉的玩意。\r\n\r\n「A」题目简述\r\n给定整数 ，称它的一个分解为一组正整数 ，满足以下条件：\r\n\r\n\r\n对于任意 ，都有\r\n，这里  均为非负整数；\r\n对于任意 ， 都不是  的因子。\r\n\r\n现在要求输出一种  的分解。\r\n「A」思路简述\r\n先将  不断除掉 ，然后再不断减去最大的  的幂，答案最后要乘上那些 \r\n这个数据范围需要高精（\r\n「A」Code\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126CI MXX(105);struct Pic{    int num[MXX],sz;    Pic() {mst(num,0);sz=1;}    I void Clear() {mst(num,0);sz=1;}    I Pic operator * (const int &amp;co) const    {        Pic res;res.sz=sz;        for(int i(1);i&lt;=sz;++i) res.num[i]=num[i]*co;        for(int i(1);i&lt;=sz;++i) res.num[i+1]+=(res.num[i]/10),res.num[i]%=10;        while(res.num[res.sz+1])        {            ++res.sz;            res.num[res.sz+1]+=(res.num[res.sz]/10);            res.num[res.sz]%=10;        }        Heriko res;    }    I Pic operator * (const Pic &amp;co) const    {        Pic res;res.sz=co.sz+sz;        for(int i(1);i&lt;=sz;++i)            for(int j(1);j&lt;=co.sz;++j)            {                res.num[i+j-1]+=(num[i]*co.num[j]);                res.num[i+j]+=(res.num[i+j-1]/10);res.num[i+j-1]%=10;            }        while(!res.num[res.sz] and res.sz&gt;1) --res.sz;        Heriko res;    }    I Pic operator - (const Pic &amp;co) const    {        Pic res;res.sz=sz;        for(int i(1);i&lt;=sz;++i)        {            res.num[i]+=num[i]-co.num[i];            if(res.num[i]&lt;0) --res.num[i+1],res.num[i]+=10;        }        while(!res.num[res.sz] and res.sz&gt;1) --res.sz;        Heriko res;    }    I void RightShift()    {        for(int i(sz);i;--i)        {            if(num[i]&amp;1) num[i-1]+=10;            num[i]&gt;&gt;=1;        }        while(!num[sz] and sz&gt;1) --sz;    }    I bool operator &gt; (const Pic &amp;co) const    {        if(sz!=co.sz) Heriko sz&gt;co.sz;        for(int i(sz);i;--i)            if(num[i]!=co.num[i])                Heriko num[i]&gt;co.num[i];        Heriko Deltana;    }        I bool operator &lt;= (const Pic &amp;co) const {Heriko !((*this)&gt;co);}    I void Into(char s[])    {        sz=strlen(s+1);        for(int i(1);i&lt;=sz;++i) num[i]=s[sz-i+1]-'0';    }    I bool Zero() {Heriko (sz==1)&amp;(num[1]==0);}    I void fw() {for(int i(sz);i;--i) putchar(num[i]+'0'); putchar(' ');}}n,ans[1005];char s[105];int anslen;S main(){    Files();    scanf(\"%s\",s+1);n.Into(s);Pic pw;pw.num[1]=1;    while(!n.Zero())    {        while(!(n.num[1]&amp;1)) pw=pw*2,n.RightShift();        Pic res,nex;res.num[1]=1;nex=res*3;        while(nex&lt;=n) res=nex,nex=res*3;        n=n-res;res=res*pw;ans[++anslen]=res;    }    fw(anslen,1);    for(int i(1);i&lt;=anslen;++i) ans[i].fw();    Heriko Deltana;}\r\n「Day10」\r\n讲课，略。\r\n「Day11」\r\n⬜ 21-NOIP21-20D-D11\r\n「启」\r\nA 假了，B 场上以为假了但是其实没假，总结还是拉了。\r\n\r\n缺省源使用「V5」.\r\n\r\n「A」\r\nBad.\r\n「A」题目简述\r\n有一颗 \r\n个节点的树，每个节点可能是红色或者黑色，每次操作可以选择一个节点，把这个节点所连的同色的结点反色，求把整棵树变成同一种颜色的最小操作次数。\r\n「A」思路简述\r\n因为相邻同色的结点可以看作一块，所有缩为一个点，然后对新树找直径，答案即为直径除\r\n\r\n「A」Code\r\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y) {Heriko x&gt;y?x:y;}template&lt;typename J&gt;I J Hmin(const J &amp;x,const J &amp;y) {Heriko x&lt;y?x:y;}CI MXX(1e6+1);int n,f[MXX],ans;struct Node{    int nex,to;}r[MXX&lt;&lt;1];int cnt,head[MXX];I void Add(int x,int y){    r[++cnt]=(Node){head[x],y};head[x]=cnt;    r[++cnt]=(Node){head[y],x};head[y]=cnt;}bitset&lt;MXX&gt; co;void DFS(int x,int fa){    for(int i(head[x]);i;i=r[i].nex)    {        int y(r[i].to);        if(y==fa) continue;        DFS(y,x);        if(co[y]!=co[x])         {            ans=Hmax(ans,f[x]+f[y]+1);            f[x]=Hmax(f[x],f[y]+1);        }        else        {            ans=Hmax(ans,f[x]+f[y]);            f[x]=Hmax(f[x],f[y]);        }    }}I int GetCo(){    char c(getchar());    while(c!='R' and c!='B') c=getchar();    Heriko c=='R'?1:0;}S main(){    Files();    fr(n);    for(int i(1);i&lt;=n;++i) co[i]=GetCo();    for(int i(1),x,y;i&lt;n;++i) fr(x),fr(y),Add(x,y);    DFS(1,0);fw((ans+1)&gt;&gt;1,1);    Heriko Deltana;}\r\n「B」\r\n\r\n场上最后的贪心策略是对的，但是当时以为假了。\r\n\r\n「B」题目简述\r\n给出一个长度为 \r\n的数列，然后给出 \r\n个操作，操作分为三种：\r\n\r\n\r\n\r\n\r\n\r\n其中 \r\n是给定的，每个操作只能用一次，最多使用  个操作，让整个数列的乘积最大。\r\n「B」思路简述\r\n考虑将 Cover 操作转为 Add\r\n操作，然后贪心的选取贡献权值大的即可。\r\n「B」Code\r\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y) {Heriko x&gt;y?x:y;}template&lt;typename J&gt;I J Hmin(const J &amp;x,const J &amp;y) {Heriko x&lt;y?x:y;}CI MXX(1e5+1),MOD(1e9+7);int n,k,m,cnt;LL a[MXX],ans(1),cover[MXX];struct CoFuc{    int opt,pos;LL val;long double dlt;}co[MXX],ro[MXX];I bool CMP(const CoFuc &amp;x,const CoFuc &amp;y) {Heriko x.val&gt;y.val;}I bool RMP(const CoFuc &amp;x,const CoFuc &amp;y) {Heriko x.dlt&gt;y.dlt;}S main(){    Files();    fr(k),fr(n),fr(m);    for(int i(1);i&lt;=k;++i) fr(a[i]);    for(int i(1);i&lt;=n;++i)    {        fr(co[i].opt),fr(co[i].pos),fr(co[i].val);        if(co[i].opt==1) cover[co[i].pos]=Hmax(cover[co[i].pos],co[i].val);    }    for(int i(1);i&lt;=k;++i)        if(cover[i]&gt;a[i])            ro[++cnt]=(CoFuc){2,i,cover[i]-a[i],0.0};    for(int i(1);i&lt;=n;++i)        if(co[i].opt!=1)            ro[++cnt]=co[i];        sort(ro+1,ro+1+cnt,CMP);    for(int i(1);i&lt;=k;++i) cover[i]=a[i];    for(int i(1);i&lt;=cnt;++i)        if(ro[i].opt==2)        {            ro[i].dlt=1.0*(cover[ro[i].pos]+ro[i].val)/(1.0*cover[ro[i].pos]);            cover[ro[i].pos]+=ro[i].val;        }        else if(ro[i].opt==3) ro[i].dlt=ro[i].val*1.0;    sort(ro+1,ro+1+cnt,RMP);    for(int i(1);i&lt;=Hmin(m,cnt);++i)        if(ro[i].opt==2) a[ro[i].pos]+=ro[i].val;        else if(ro[i].opt==3) (ans*=ro[i].val)%=MOD;    for(int i(1);i&lt;=k;++i) (ans*=a[i])%=MOD;    fw((ans+MOD)%MOD,1);     Heriko Deltana;}\r\n「C」\r\n\r\n不是这怎么还出特判题呐？\r\n\r\n「C」题目简述\r\n小明有  到  共  包零食，同时他又有  到  共  个朋友。\r\n昨天，小明的 \r\n个朋友都到他家来玩了。他的 \r\n个朋友瓜分了他的 \r\n包零食，每个人都恰好吃了一包零食，没有两个人吃了同一包零食。\r\n小明发现，第  个朋友吃第  包零食能获得的愉悦值是 。\r\n今天，小明想回忆起每个朋友吃的是哪包零食，他想不起来了，但是他却记得了所有人的愉悦值之和\r\n。于是，小明找上了你，请你构造出一种可能的方案。\r\n由于小明记忆力不好，他有可能记错了 ，所以可能会存在无解的情况。\r\n「C」思路简述\r\n特判题（\r\n\r\n 的上界为 ，超过乆输出无解。\r\n 的时候详见代码， 时同理。\r\n剩余情况我们只需要构造出  的答案。\r\n\r\n「C」Code\r\n\r\n这里的 fw 函数不太一样，放一下。\r\n\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130template&lt;typename J&gt;I void fw(bool g,J x,bool k){    if(!g)    {        puts(\"SPFA is dead!\");        Heriko;    }    if(x&lt;0) x=-x,putchar('-');    static short stak[35];short top(0);    do    {        stak[top++]=x%10;        x/=10;    }    while(x);    while(top) putchar(stak[--top]+'0');    k?puts(\"\"):putchar(' ');}CI MXX(1e6+1);LL n,s,res,ans[MXX],flg;bitset&lt;MXX&gt; co;S main(){    Files();    fr(n),fr(s);    if(s&gt;((n*(n-1))&gt;&gt;1)) Heriko fw(0,114514,1919810),Deltana;        if(n==1)    {        if(!s) puts(\"1\");        else Heriko fw(0,114514,1919810),Deltana;        Heriko Deltana;    }    else if(n==2)    {        if(!s) puts(\"1\\n2\");        else if(s==1) puts(\"2\\n1\");        else Heriko fw(0,114514,1919810),Deltana;        Heriko Deltana;    }    else if(n==3)    {        if(!s) puts(\"1\\n2\\n3\");        else if(s==1) puts(\"2\\n1\\n3\");        else if(s==2) puts(\"3\\n1\\n2\");        else if(s==3) puts(\"1\\n3\\n2\");        else Heriko fw(0,114514,1919810),Deltana;        Heriko Deltana;    }        if(!s)    {        for(int i(1);i&lt;=n;++i) fw(1,i,1);        Heriko Deltana;    }    else if(s==1)    {        puts(\"2\\n1\");        for(int i(3);i&lt;=n;++i) fw(1,i,1);        Heriko Deltana;    }    else if(s==2)    {        puts(\"3\\n1\\n2\");        for(int i(4);i&lt;=n;++i) fw(1,i,1);        Heriko Deltana;    }    else if(s==((n*(n-1))&gt;&gt;1)-1)    {        if(n&amp;1)        {            ans[1]=3,ans[2]=1,ans[n]=2;            for(int i(3);i&lt;n;++i) ans[i]=i+1;        }        else        {            ans[1]=1;ans[n]=2;            for(int i(2);i&lt;n;++i) ans[i]=i+1;        }        for(int i(1);i&lt;=n;++i) fw(1,ans[i],1);        Heriko Deltana;    }    ans[n]=1;--s;    for(int i(n-1);i&gt;=2;--i)    {        if(s&gt;=i and s-i!=1) s-=i;        else ans[i]=i,co[i]=1;    }    int nw(n);    for(int i(n-1);i;--i)        if(!ans[i])         {            ans[i]=nw,co[nw]=1;            while(co[nw]) --nw;        }    for(int i(1);i&lt;=n;++i) fw(1,ans[i],1);    Heriko Deltana;}\r\n「Day12」\r\n✅ 21-NOIP21-20D-D12\r\n已经整理完，博客为：总之就是 | ZROI\r\nNOIP21 冲刺 Day12。\r\n「Day13」\r\n⬜ 21-NOIP21-20D-D13\r\n「启」\r\n今天倒是没挂 A，但是大家都切 A，所以我挂 B 了/cy\r\n\r\n缺省源使用「V5」.\r\n\r\n「A」\r\n切了好耶（\r\n\r\nTime:1s Memory:512MiB.\r\n\r\n「A」题目简述\r\n要求找出满足下列条件最小的数：\r\n\r\n这是一个正整数；\r\n这个数至少有四个不同的因子；\r\n这个数的任意两个因子之间的差不小于输入的 \r\n\r\n「A」思路简述\r\n因为要求两个任意两个因子之间的差不小于输入的 ，所以想到选取质数。\r\n而题目要求至少要有四个不同的因子，而一个数最小的因子是 ，最大的因子是自己，所以我们只需要找到大于\r\n\r\n的第一个质数和大于等于第一个选出来的质数  后的最小的质数即可。\r\n用一个欧拉筛解决质数问题即可。\r\n「A」Code\r\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859CI MXX(1e7+5);LL prime[MXX],cnt;bool nopr[MXX];I void Es(LL x){    nopr[1]=1;    for(LL i(2);i&lt;=x;++i)    {        if(!nopr[i]) prime[++cnt]=i;        for(int j(1);j&lt;=cnt and prime[j]*i&lt;=x;++j)        {            nopr[i*prime[j]]=1;            if(i%prime[j]==0) break;        }    }}LL n,T;S main(){    Files();    Es(MXX);    fr(T);    while(T--)    {        fr(n);LL fst(0),fstid(0),sed(0);        for(int i(1);i&lt;=cnt;++i)            if(prime[i]&gt;=n+1)                {                    fst=prime[i];                    fstid=i;                                        break;                }        for(int i(fstid);i&lt;=cnt;++i)            if(prime[i]&gt;=fst+n)            {                sed=prime[i];                break;            }        fw(sed*fst,1);    }    Heriko Deltana;}\r\n「B」\r\n挂了好耶（\r\n\r\nTime:1s Memory:512MiB.\r\n\r\n「B」题目简述\r\n给出一个有 \r\n个点的无向完全图，每次在图上去掉一个生成树中的所有边，问最多能进行多少次，并且输出每次要删掉哪些边。\r\n「B」思路简述\r\n首先能知道 \r\n个点的完全图的总边数为 ，而一个生成树的边数为\r\n，所以能得出最多能进行 \r\n次删除操作。\r\n那么下面考虑如何构造出每次删掉的生成树，场上是想的 DFS\r\n删除，但是没判环于是挂掉了。\r\n考完之后看题解发现可以反着来，考虑从  转移到  的时候，对于之前的每一个生成树  连上  和 、 和 ，然后如果是偶数就再建一个新的，连边同理。\r\n「B」Code\r\n123456789101112131415161718192021222324252627int n,m;S main(){    Files();    int T;fr(T);    for(int ct(1);ct&lt;=T;++ct)    {        fr(n);m=(n&gt;&gt;1);        printf(\"Case #%d: %d\\n\",ct,m);        for(int i(1);i&lt;=m;++i)        {            if(!(n&amp;1)) fw((i+m)%n+1,0),fw(i+m,1);            for(int j(1);j&lt;=(n-1)&gt;&gt;1;++j)            {                fw((i-j+n)%n+1,0),fw((i+j-1)%n+1,1);                fw((i+j-1)%n+1,0),fw((i-j+n-1)%n+1,1);            }        }    }    Heriko Deltana;}\r\n「C」\r\n写不出 Check 好耶（\r\n\r\nTime:3s Memory:512MiB.\r\n\r\n「C」题目简述\r\n现在要将一个 \r\n个结点的无向树分割成 \r\n个子树，使得这些子树中结点权值和最大的一颗最小。\r\n「C」思路简述\r\n这个题的答案求解……嗯是二分没错了，那么下面的问题就是如何去写\r\nCheck（\r\n然而场上没写出来 T_T\r\n所以这个的 Check 怎么写呢（\r\n考虑 DFS 去解决（\r\n设  表示当前结点 \r\n所在的联通块的点权和。对于每一个节点，将其所有孩子的  排序以后，从小到大依次往父亲里塞。\r\n塞不下的，就只能切断了，也就是形成单独的联通块，塞进父亲里的，更新到父亲的\r\n\r\n中，可以继续和上面的节点合并，然后就能求出最大值。\r\n排序和统计用个 vector 即可。\r\n「C」Code\r\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y) {Heriko x&gt;y?x:y;}CI MXX(1e5+1);struct Node{    int nex,to;}r[MXX&lt;&lt;1];int cnt,head[MXX];I void Add(int x,int y){    r[++cnt]=(Node){head[x],y};head[x]=cnt;    r[++cnt]=(Node){head[y],x};head[y]=cnt;}int n,k;LL val[MXX],ans,f[MXX],sz[MXX];vector&lt;LL&gt; sub[MXX];void DFS(LL lmt,int x,int fa){    f[x]=sz[x]=0;sub[x].clear();    int res(0);sz[x]=val[x];    for(int i(head[x]);i;i=r[i].nex)    {        int y(r[i].to);        if(y==fa) continue;        DFS(lmt,y,x);++res;sub[x].push_back(sz[y]);f[x]+=f[y];    }    sort(sub[x].begin(),sub[x].end());    for(auto i:sub[x])        if(sz[x]+i&lt;=lmt) sz[x]+=i,--res;        else break;    f[x]+=res;}I bool Check(LL x){    for(int i(1);i&lt;=n;++i)        if(x&lt;val[i])            Heriko Deltana;    DFS(x,1,0);    Heriko f[1]&lt;k;}S main(){    Files();    int T;fr(T);    for(int ct(1);ct&lt;=T;++ct)    {        fr(n),fr(k);cnt=0;mst(head,0);        for(int i(1),x,y;i&lt;n;++i) fr(x),fr(y),Add(x,y);        LL sm(0),mx(0);        for(int i(1);i&lt;=n;++i) fr(val[i]),sm+=val[i],mx=Hmax(mx,val[i]);        if(n==k)        {            printf(\"Case #%d: %lld\\n\",ct,mx);            continue;        }        LL l(0),r(sm);        while(l&lt;=r)        {            LL mid((l+r)&gt;&gt;1);            if(Check(mid)) r=mid-1,ans=mid;            else l=mid+1;        }        printf(\"Case #%d: %lld\\n\",ct,ans);    }    Heriko Deltana;}\r\n「Day14」\r\n⬜ 21-NOIP21-20D-D14\r\n「启」\r\n哈哈又啥都没有，还是使用惊艳骗分。\r\n\r\n缺省源使用「V5」.\r\n\r\n「A」\r\n不知道该说啥。\r\n\r\nTime:2s,Memory:512MiB.\r\n\r\n「A」题目简述\r\n求一颗 \r\n的树上有多少点集 \r\n内的任意两点的最短距离为 \r\n「A」思路简述\r\n先处理出深度，然后按照深度从浅到深跑\r\nDFS，每次选取之前已经选取过的点，然后计算子集大小  回答询问。\r\n「A」Code\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475CI MXX(2001),MOD(1e9+7);struct Node{    int nex,to;}r[MXX&lt;&lt;1];int cnt,head[MXX];I void Add(int x,int y){    r[++cnt]=(Node){head[x],y};head[x]=cnt;    r[++cnt]=(Node){head[y],x};head[y]=cnt;}int n,dep[MXX],id[MXX];LL pw2[MXX],tot[MXX],ans[MXX];void DFS1(int x){    for(int i(head[x]);i;i=r[i].nex)        if(!dep[r[i].to])            dep[r[i].to]=dep[x]+1,DFS1(r[i].to);}bitset&lt;MXX&gt; vis;void DFS2(int x,int fa,int stp){    if(vis[x]) ++tot[stp];    for(int i(head[x]);i;i=r[i].nex)        if(r[i].to!=fa)            DFS2(r[i].to,x,stp+1);}S main(){    Files();    fr(n);    for(int i(1);i&lt;=n;++i) id[i]=i;    pw2[0]=1;    for(int i(1);i&lt;=n;++i) pw2[i]=(pw2[i-1]&lt;&lt;1)%MOD;    for(int i(1),x,y;i&lt;n;++i) fr(x),fr(y),Add(x,y);    dep[1]=1;DFS1(1);sort(id+1,id+1+n,[](int x,int y){Heriko dep[x]&lt;dep[y];});    for(int i(1);i&lt;=n;++i)    {        vis[id[i]]=1;int tmp(1);        memset(tot,0,sizeof(LL)*(n+1));        DFS2(id[i],0,0);        for(int j(1);j&lt;=n;++j)        {            (ans[j]+=(pw2[tot[j]]-1)*(pw2[tmp-1]))%=MOD;            tmp+=tot[j];        }    }    int T;fr(T);    while(T--)    {        int x;fr(x);fw(ans[x],1);    }    Heriko Deltana;}\r\n「Day15」\r\n⬜ 21-NOIP21-20D-D15\r\n「启」\r\n哈哈又挂了 A，还是只有垃圾 \r\n分暴力。\r\n\r\n缺省源使用「V5.1」.\r\n\r\n「A」\r\n挂了。\r\n\r\nTime:1s,Memory:1GiB.\r\n\r\n「A」题目简述\r\n从 \r\n个数中选出一个非空子集，求满足异或和等于与和，每个数都满足 \r\n「A」思路简述\r\n我们设  表示选取前  个数，与和为 ，异或和为  的方案数，那么显然答案为 \r\n因为直接开会炸空间，所以我们滚掉第一维，状态就变成了 ，然后我们用一个栈来优化一下复杂度，要不然还是过不去（\r\n「A」Code\r\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253CI NXX(51),MXX(1&lt;&lt;13),SXX(1&lt;&lt;21);bitset&lt;MXX&gt; co[MXX]; int n,m,a[NXX],top[2];LL f[2][MXX][MXX];pair&lt; int,int &gt; stk[2][SXX];LL ans;S main(){    Files();    fr(n);    for(int i(1);i&lt;=n;++i) fr(a[i]),m|=a[i];    int nw(0);f[nw][m][0]=1;stk[nw][++top[nw]]=mkp(m,0);    for(int i(1),x,y;i&lt;=n;++i)    {        nw^=1;int lst(nw^1);        for(int j(1);j&lt;=top[nw];++j) x=stk[nw][j].first,y=stk[nw][j].second,f[nw][x][y]=0;        top[nw]=0;        for(int j(0);j&lt;=m;++j) co[j]=0;        for(int j(1);j&lt;=top[lst];++j)        {            x=stk[lst][j].first,y=stk[lst][j].second;            f[nw][x&amp;a[i]][y^a[i]]+=f[lst][x][y];            if((x&amp;a[i])==(y^a[i])) ans+=f[lst][x][y];            f[nw][x][y]+=f[lst][x][y];            if(!co[x][y]) co[x][y]=1,stk[nw][++top[nw]]=mkp(x,y);            x&amp;=a[i],y^=a[i];            if(!co[x][y]) co[x][y]=1,stk[nw][++top[nw]]=mkp(x,y);        }           }        fw(ans,1);    Heriko Deltana;}\r\n「Day16」\r\n⬜ 21-NOIP21-20D-D16\r\n因为某些原因未参加。\r\n「SC1」\r\n⬜ 21-NOIP21-20D-SC1\r\n同上。\r\n「SC2」\r\n⬜ 21-NOIP21-20D-SC2\r\n「启」\r\n因为某些事情，前几场考试没参加，这一场听说是信心场还\r\nunr，就打一打玩。\r\n\r\n缺省源使用「V5.2」.\r\n\r\n「A」\r\n诈骗题，但是场上写的结论少了点东西所以只有 \r\n「A」题目简述\r\n一个长度为 \r\n的字符串，字典集大小为 ，要求连续长度为  的子串都必须是回文串，求方案数。\r\n「A」思路简述\r\n看起来没啥东西所以就觉得很诈骗（\r\n分为以下几种情况：\r\n\r\n 或  时，答案为 \r\n 时，答案为 \r\n否则，当  为  的倍数的时候，答案为 ，若不是  的倍数，答案为 \r\n\r\n「A」Code\r\n12345678910111213141516171819202122232425262728293031323334353637CI MOD(1e9+7);int n,m,k;I int FstPow(int x,int y){    int res(1);    while(y)    {        if(y&amp;1)            (res*=1ll*x)%=MOD;                (x*=1ll*x)%=MOD;        y&gt;&gt;=1;    }    Heriko res;}S main(){    Files();    fr(n),fr(m),fr(k);    if(k&gt;n or k==1)        fw(FstPow(m,n)%MOD,1);    else if(k==n)        fw(FstPow(m,(n+1)&gt;&gt;1),1);    else if(k&amp;1)        fw((m*m)%MOD,1);    else if(!(k&amp;1))        fw((m+MOD)%MOD,1);        Heriko Deltana;}\r\n「B」\r\n考场写了个暴力，然后乆润了。\r\n「B」题目简述\r\n每次可以在矩阵中选择一行或一列加到答案中，然后把选择的这一列的每一项都减去\r\n\r\n「B」思路简述\r\n考虑把行和列的操作拆开先预处理，然后最后合并答案的时候减去互相的影响。\r\n「B」Code\r\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y){    Heriko x&gt;y?x:y;}CI MXX(1001),KXX(1e5+1);CL INF(1145141919810);int n,m,k,p,a[MXX][MXX];LL ans(-INF),f[KXX],coi[KXX],coj[KXX],g[KXX];priority_queue&lt;LL&gt; q;S main(){    Files();    fr(n),fr(m),fr(k),fr(p);    for(int i(1);i&lt;=n;++i)        for(int j(1);j&lt;=m;++j)            fr(a[i][j]);    for(int i(1);i&lt;=n;++i)        for(int j(1);j&lt;=m;++j)            coi[i]+=a[i][j],coj[j]+=a[i][j];    for(int i(1);i&lt;=n;++i)        q.push(coi[i]);    for(int i(1);i&lt;=k;++i)    {        LL x(q.top());        q.pop();        f[i]=f[i-1]+x,x-=p*m;        q.push(x);    }    while(q.size())        q.pop();    for(int i(1);i&lt;=m;++i)        q.push(coj[i]);    for(int i(1);i&lt;=k;++i)    {        LL x(q.top());        q.pop();        g[i]=g[i-1]+x,x-=p*n;        q.push(x);    }    for(int i(0);i&lt;=k;++i)        ans=Hmax(ans,f[i]+g[k-i]-(1ll*i*(k-i)*p));    fw(ans,1);    Heriko Deltana;}\r\n「C」\r\n是个大模拟，先不补。\r\n「Day17」\r\n⬜ 21-NOIP21-20D-D17\r\n\r\n缺省源使用「V5.2」.\r\n\r\n「启」\r\n没啥好说的。\r\n「A」\r\n场上做出来了。\r\n题目。\r\n「A」思路简述\r\n我们考虑对于每个点都用两个长度为  的二进制数来存储，分别记录第  位对应着第  次操作的时候的  或  归属状态，那么最终两个点  之间是否有连边就等同于  的  的个数是否为奇数加上  的  的个数再减去两者交集。\r\n「A」Code\r\n1234567891011121314151617181920212223242526272829303132333435CI NXX(2e4+1),MXX(64);bitset&lt;MXX&gt; X[NXX],Y[NXX];int n,m;LL ans;char s[NXX];S main(){    Files();    fr(n),fr(m);    for(int i(1);i&lt;=m;++i)    {        scanf(\"%s\",s+1);        for(int j(1);j&lt;=n;++j)        {            Y[j][i]=(s[j]^48)&amp;1;            X[j][i]=((s[j]^48)&gt;&gt;1)&amp;1;        }    }    for(int i(1);i&lt;n;++i)        for(int j(i+1);j&lt;=n;++j)            ans+=((X[i]&amp;Y[j]).count()+((Y[i]&amp;X[j])^((X[i]&amp;Y[j])&amp;(Y[i]&amp;X[j]))).count())&amp;1;    fw(ans,1);        Heriko Deltana;}\r\n「B」\r\n题目。\r\n「B」思路简述\r\n看到这个问题，就很自然地想到二分，于是设 ，然后去二分这个 \r\n然后把 \r\n的前缀和求出来，求长度为  的\r\nLIS.\r\n「B」Code\r\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y){    Heriko x&gt;y?x:y;}CI MXX(2e5+1);const double INF(1e9);int n,k,a[MXX],mx;double ans,b[MXX],f[MXX];I bool Check(double x){    for(int i(1);i&lt;=n;++i)        b[i]=b[i-1]+a[i]-x;    int hd(0);    f[hd]=INF;        for(int i(1);i&lt;=n;++i)    {        if(b[i]&lt;0.0 or b[i]&gt;b[n])            continue;                int pos(lower_bound(f,f+1+hd,b[i])-f);        f[pos]=b[i];        if(pos==hd)            f[++hd]=INF;    }    Heriko hd&gt;=k;}S main(){    Files();    fr(n),fr(k);    for(int i(1);i&lt;=n;++i)        fr(a[i]),mx=Hmax(mx,a[i]);    double l(0),r(mx*1.0);    while(l+(1e-4)&lt;r)    {        double mid((l+r)/2.0);        if(Check(mid))            l=mid,ans=mid;        else            r=mid;    }    printf(\"%.4lf\",ans);    Heriko Deltana;}\r\n「C」\r\n题目。\r\n「C」思路简述\r\n首先把每个无向边改为两个有向边，然后在每个结点上，可以任意匹配来自两条不同树边的边。\r\n总的方案数为 ，但是还有重复的方案，减去即可。\r\n「C」Code\r\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960CI MXX(1e6+1),MOD(1e9+7);LL f[MXX],n,inv[MXX],fac[MXX],r[MXX],sum[MXX],tot[MXX],ans(1);I LL FstPow(LL x,LL y){    LL res(1);    while(y)    {        if(y&amp;1)            (res*=x)%=MOD;                (x*=x)%=MOD;        y&gt;&gt;=1;    }    Heriko res;}S main(){    Files();    fr(n);    inv[0]=fac[0]=inv[1]=fac[1]=1;    for(int i(2);i&lt;=n;++i)    {        inv[i]=(MOD-MOD/i)*1ll*inv[MOD%i]%MOD;        fac[i]=(fac[i-1]*1ll*i)%MOD;    }            for(int i(1);i&lt;n;++i)    {        int x,y;        fr(x),fr(y);        ++r[x],++r[y];    }    f[0]=tot[0]=sum[0]=1;    for(int i(1);i&lt;=n;++i)    {        f[i]=(tot[i-1]+sum[i-1])%MOD;        f[i]=(f[i]-f[i-1]+MOD)%MOD;        f[i]=(1ll*f[i]*((MOD+1)&gt;&gt;1)%MOD*inv[i]%MOD);        sum[i]=(sum[i-1]+f[i])%MOD;        tot[i]=(tot[i-1]+sum[i])%MOD;    }    (ans*=FstPow(2,n-1))%=MOD;    for(int i=1;i&lt;=n;i++)        ans=1ll*ans*fac[r[i]]%MOD*f[r[i]]%MOD;    fw((ans+MOD)%MOD,1);    Heriko Deltana;}\r\n","slug":"ZRNOIP21-20D","date":"2021-10-29T12:23:59.000Z","categories_index":"OI-Solutions","tags_index":"OI","author_index":"Heriko Deltana"},{"id":"90411f8f3b7607c46d1ec6fda3f4a1b1","title":"Nothing : 20210926","content":"「2021.09.26，中午，梦。」\r\n\r\n\r\n「序」\r\n嗯……\r\n这里写的是我在 9.26\r\n中午的一个梦，因为记得很清楚，再加上那天下午因为这个梦变得很奇怪，所以就写出来。\r\n所以从做完这个梦到现在已经整整一个周了w\r\n简单描述一下就是，那天中午因为做这个梦，睡过了，于是下午少上了一节课（\r\n下面……就开始略详细描述。\r\n\r\n因为是很奇怪的零散的描述了所以我也不奢求各位能看懂。\r\n一看就是手画的图都是手画的（有数位板）\r\n有一些神必配图。\r\n\r\n「因」\r\n显然如果宿舍里不止我一个人的话是不会睡过的（\r\n9.25\r\n生物奥赛的同学们前往湖南尝鲨，于是我们班的男生宿舍就出现了很多空位（\r\n然而我们宿舍里只有我一个人不是生物奥赛，于是我们宿舍就剩下我一个人了w\r\n用 F1 里的 Starting Grid 来描述一下宿舍的位置就是：\r\n\r\n\r\n这里的 Pole Position 是距离宿管最近的宿舍（也就是 113\r\n\r\n本身这个宿舍楼只有一楼有高一，还只有两个班，于是一楼是相对空旷的（\r\n本来 113 是距离宿管宿舍最近的宿舍，但是由于 113\r\n是一个由生物奥赛的同学组成的宿舍，所以这个宿舍，它空了。\r\n也就是说仅有一个人的宿舍 112 来到了 Pole Postion（bushi\r\n然而宿舍的出口又在另一边，所以我就成了距离门口最远的人，也就是说没有人会在出宿舍的时候路过我宿舍，这是我睡了这么长时间的最主要原因（\r\n然鹅机智的我早就想到了这一点，于是我提前给 111\r\n宿舍的各位打好了招呼，让他们叫我起床……\r\n然而……他们忘了……而且是整个宿舍都没人想起来（\r\n~~嗯就是你们都没想起来才有的这个（ @Dfkuaid @hyl @禁止右转\r\n于是就有了整个梦。\r\n「梦」\r\n\r\n下面涉及的人物都是真实人类在我梦中的映像（？），认识的人看一点就明白了，不认识的人肯定不认识，不过就算不认识好像也不影响的样子（\r\n\r\n「一」\r\n中午，宿舍里只有我一个人，\r\n\r\n\r\nScreenshot_20211003_200952_com.miHoYo.bh3.huawei.jpg\r\n\r\n于是我就和昨天一样，提前上床睡觉了。\r\n\r\n\r\nScreenshot_20211003_201013_com.miHoYo.bh3.huawei.jpg\r\n\r\n于是梦就开始了。\r\n「二」\r\n最一开始，我在往楼下搬东西（估计是想国庆假期了）。\r\n然后我从五楼下到一楼的时候，发现\r\nwsr，然后他让我给他拿个东西（？为什么我会在五楼，不懂）\r\n然后我就跑上去又给他拿了一趟（？为什么我怎么听话)\r\n东西很显眼，就是 wsr\r\n他们宿舍里那个狗狗玩偶，我拿完之后就直接跑下去给了 wsr.\r\n当我给 wsr\r\n狗狗的时候，他给我指了指我后面（？）我发现是一个初中班里的孩子，下面称为\r\nJP.\r\n我正在迷惑为什么会有人会瞬移的时候，wsr 给我说 JP 快不行了（？）\r\n然后让我去拿什么纸（？大抵是什么公文之类的玩意，但是我觉着应该是需要医疗援助罢（bushi\r\n（还有为什么男生和女生会在一个宿舍楼啊？）\r\n然后我就跑上楼去拿，在宿舍里碰见了渣渣辉，然后我就问渣渣辉：那张纸放在哪里了？\r\n然后渣渣灰就指了指……天（？）然后我就非常理解的开始翻床单（？）\r\n大约翻了好长时间的样子，因为等我找到下去的时候，wsr 说 JP\r\n已经不行了已经被送走了（\r\n还给我看了张她被车接走的照片（？为什么怎么惨）\r\n「三」\r\n然后我就拎着包向着教学楼（大概是）的方向跑，但是宿舍楼和教学楼中间并不是露天的，而是室内环境。（难道这就\r\n是 114514 年之后的 lcez 吗）\r\n路上我就看见楼上满满的都是人再往下走，好像都大包小包准备回家。\r\n然而走在一楼的人只有我一个。（后来我觉得这里是伏笔（？），后面说）\r\n然后我就去挤电梯，然后好不容易进去，发现里面全是老师就我一个学生，剩下四学科奥赛教练、ysh、J、齐齐、尚尚（\r\nJ 就经典刷电梯卡姿势，（见过的请自行想象）然后就就上到了 8\r\n楼，但是只有我一个人下了电梯，然后就看见了泰山和小明（\r\n然后当时大约小明在看手机，泰山在干啥我不知道，然后我过去的时候泰山对我说小明也有那病（？所以说泰山是说的什么玩意病？）\r\n小明直接垂死病中惊坐起，扔了手机爆锤泰山（\r\n大约就是这样：\r\n\r\n于是泰山那句话就让我围观了一场战斗（？感谢）\r\n围观了一会之后，我右转进入教室，然后……打地铺睡觉（？）\r\n感觉在我梦里面一天就三个小时的感觉，最一开始我觉得是在上午，到这直接变成晚上了（\r\n于是我就在梦里睡觉（？）\r\n突然感觉被叫醒（在现实中可能是吹哨了，可惜这次吹哨只能叫醒第一层的我），于是睁开眼（在梦里），发现大家都正常的在教室的桌椅上，只有我一个人\r\n躺 在 地 上 穿 着 睡 衣 盖 着 被 子 睡 眼 朦 胧 一 脸 懵\r\n逼（\r\n然而好像并没有上课，于是我就开始看手机（？为什么我会有手机）\r\n然后打开了个神必的游戏（？上课玩游戏）\r\n123456789101112131415看起来像 ![Phigros](https://pic.imgdb.cn/item/615b0fa42ab3f51d9128a112.jpg)但是又有点像 ![Dancing Line](https://pic.imgdb.cn/item/615b06a72ab3f51d91194606.jpg)中间好像又有了玩蛇，于是加一点 ![Arcaea](https://pic.imgdb.cn/item/615b0fa42ab3f51d9128a0e1.jpg)然后，加一点 ![Cytoid](https://pic.imgdb.cn/item/615b0fa42ab3f51d9128a0f8.jpg) 和 ![Muse dash](https://pic.imgdb.cn/item/615b0ffd2ab3f51d91293461.jpg)（但是结算的界面又是 ![bh3](https://pic.imgdb.cn/item/615b0fa42ab3f51d9128a0ed.jpg) 的（可以自行想象一下薪炎旅但是是穿着类似于超级马里奥的背带裤（？）结算之后又是开放世界（加一点 ![ys](https://pic.imgdb.cn/item/615b0fa42ab3f51d9128a0d3.jpg)开放世界还能开车打雀（？？）（加一点 ![RR3](https://pic.imgdb.cn/item/615b0ffd2ab3f51d91293469.jpg) ![FH4](https://pic.imgdb.cn/item/615b104e2ab3f51d9129bcf8.jpg) ![雀](https://pic.imgdb.cn/item/615b103b2ab3f51d91299a87.jpg) ![AR](https://pic.imgdb.cn/item/615b0ffd2ab3f51d912933e8.jpg) ![A9](https://pic.imgdb.cn/item/615b0ffd2ab3f51d912933f1.jpg)甚至还有社交功能，画面类似于 ![](https://pic.imgdb.cn/item/615b0ef62ab3f51d9127800e.jpg)（？)\r\n我明白了我一定是在完那个游戏 6 罢！\r\n然后……\r\n\r\n剩下的明天补（\r\n谢谢各位整齐划一的催更，哦里面好像还有我（（（（（\r\n\r\n\r\nimage.png\r\n\r\n昨天补的最后一部分好像有点乱，今天上完课把他做成一张图罢。\r\n\r\n","slug":"Dream-2021926","date":"2021-09-27T13:48:00.000Z","categories_index":"Nothing","tags_index":"Me","author_index":"Heriko Deltana"},{"id":"05ae6cfb4f51d63958ca39d06c557ce9","title":"Dell5568","content":"「关于老物的一些字。」\r\n\r\n\r\n章零 · 序章\r\n实际上从这个在暑假的开端，就有写这篇的想法了，不过由于各种神必的原因一直没写就是了，也不知道什么时候能写完\r\n说实话网上应该也不会有人和我一样干啥都想写点东西，所以这篇文章大约就是你能看到的最详细的16\r\n年过气本 Dell Vostro 5568 体验。\r\n这篇文章和 OI 关系不大，可能同步到 Bilibili 专栏和酷安。\r\nBilibili 上虽然不支持手写 Markdown\r\n但是有基本的常用语法，所以排版和这里算是差不多罢。\r\n而酷安的话不支持 Markdown 所以大概率会重写一份罢。\r\n同时因为酷安和 Bilibili\r\n毕竟不是自己博客，所以里面的一些小东西也会不一样（\r\n但是这里应该就是最全了的罢，但是可能因为某些神必原因，我对 2018\r\n年之前的事情都记得比较模糊了，所以总体的文章长度也不长（\r\n章一 · 初见\r\n这个是 2016.12 发布的本子，而我是 2017.01 拿到的它。\r\n实际上也没有什么初见可爱单推的过程ww\r\n当时还是小学，现在来看觉得自己很幸运能够这么早的接触这些东西，这也可能是我走上\r\nOI 这条路的原因之一。\r\n当时比较天真，关于电脑就只能知道它能否正常的运行，各种毒瘤的软件也霸占了那个电脑的小硬盘。\r\n后来由于自己装了一大堆神必东西导致电脑很慢很卡，于是懒得去开电脑，后来逐渐变成多数时间都不碰它。它便逐渐吃灰，从我的生活淡出。当然有些必要的时候还是要用到它的\r\n那时候也不知道如何保护电池什么的，这也为后来埋下了伏笔（？）\r\n章二 · 重逢\r\n上面说的它从我这里逐渐消失了存在感（\r\n但是 2020 年的疫情让它重新回到了我的生活当中来，学校选择的网课平台对\r\niPad\r\n适配极差，在老家度过疫情最严重的前两个月之后，我实在是忍不住就回家拿了电脑。\r\n当时我一打开电脑扑面而来的是 Windows 安全中心 VS 迈克菲 VS\r\n360 VS 火绒 的壮观场面，考虑了一下最后先用 360\r\n把最毒瘤的软件干掉了之后只留下了火绒。当然如果要按照后面的事情来看根本不必如此（\r\n因为那个时候也是算是开始逐渐对数码之类的东西真正有点懂了，就开始对电脑进行各种神必的操作优化，上课划水无师自通。\r\n突然有一天我妈问我如果高中五大奥赛要选一个，我会选哪个。我当时可能是出于对信息方面的爱好（？）于是选了\r\nOI，从此踏上 OI 的不归路。后来好像听说家庭版的 C++\r\n库什么的好像不全（现在发现其实都是能自己装的），于是想着要不然就重装个系统罢，然后这就是梦开始的地方了。（这里指噩梦）\r\n当时我把找了个 熟 人 帮我重装系统。现在来回忆的话，他大概就是拿了个 U\r\n盘作启动盘到家里插电脑上 setup\r\n一下就完事了，但是当时天真浪漫不懂电脑的我就只会在旁边看着。当时他好像还用的是大白兔这个毒瘤玩意。\r\n因为只有 C 盘会受到影响，当时就没有备份（危）。\r\n本来用起来非常的舒适，所以也没有什么思想准备，下载 QQ\r\n的时候电脑卡了一小下，但是我认为是新系统的问题就没有注意。然后下载\r\nOffice 的时候，进度条卡在了 86%\r\n，然后……电脑黑屏了，那天就再也没开开过了（悲）\r\n后来拿去修发现是硬盘坏了.....咱也不知道为什么给我重装系统把硬盘搞坏了，里面数据也不给我取出来，到现在还没找他，气死我。\r\n所以从那以后是坚决不让所谓熟人来整电脑了，明明搞个系统自己不用花钱就能解决的事情最后还花了钱买了个不是很好\r\nSSD\r\n那人也挺有意思，中间给我拆机的时候忘了把风扇的一个盖板安回来......\r\n更有意思的是明明我要的是专业版，他给我装了个 L T S C\r\n!这谁顶得住啊，绝了。反正我是再也不让我爸的“熟人”碰我的设备了。\r\n然后一直到现在，它上面还是 LTSC，主要是懒得改了。\r\n章三 · 印象\r\n实际上这章的标题确实不知道该起什么了（\r\nDell\r\n的做工不错貌似是公认的样子，但是它的做工……让人一言难尽。基本这四年半的时间一直在和它的神必做工斗争。\r\n最一开始是直接掉了一个螺丝（？）导致屏幕转轴的地方开裂（\r\n然后换了个螺丝上去也没事了，再后来就是这货的风扇，可能是出于某些神必的原因开始打它和主板之间的挡板，但是风扇的位置是对的，这玩意到后来演化成了战\r\n略 级 移 动 拖 拉 机，我也把这玩意录了下来发到了B站（？）视频链接在这\r\n当然这也是换掉它的主要原因之一。\r\n最重要的应该是因为这货的电池......当然这个怪不得它罢，这个属于是小时候习惯不好一直插着电最后导致电池鼓包了罢（\r\n但是充电口也能坏是我没想到的，插着充电器，突然就有一瞬间供不上电，然后我未保存的东西成功没了……这两点加起来让人体验挺拉的，到后期因为风扇太吵甚至不想晚上打\r\nCodeforces 了（\r\n但是刨除这两点，它整体的实力还算是差强人意。\r\ni5-7200u\r\n虽然主频拉跨，而且我经常吐槽，不过放在今天还是足够作为一个办公的本子的\r\nu；Geforce 940MX\r\n算是这个电脑为数不多能拿出来说道的东西，这个显卡其实就是老 MX\r\n系列的最后的一代里面最高端的那块了，如果我没记错的话这玩意有 4GB\r\n的显存，算力在这台电脑上完全够用。\r\n在这两位的支持下，F1 2016 和 GTA5 都能窗口模式 +\r\n最低画质的情况下达到不错的帧数。（前者平均 40 帧，后者平均 52 帧）\r\n其实这个帧数能更进一步的，因为我发现帧数的瓶颈在于……内存。\r\n4GB DDR3 2300 的配置放在 2017 之前还算是不错的水平，不过现在可是 1202\r\n年啊，开个 Egde + VScode 内存就能暴毙（\r\n4GB 是真的拉，要不然这个体验显然能更进一步的（\r\n屏幕就不多说了，大果粒 + 低亮度 + 45%NTSC。\r\n但是这个电脑确实助力了我达成了很多事情，同时陪我经历了许多，我的第一个\r\nC++ 程序，Py 程序，第一份 3D 建模，第一个 FL Studio 工程文件……\r\n当然最重要的应该就是现在这段 OI 之路的前半段，由它陪我度过。\r\n章四 · 暂别\r\n不再听它的声音，已经是有三天时间了，当我写完代码时，兴奋地按下的已经不再是它身上的\r\nF5，深夜调代码的时候，面对的也不再是它，它现在只是一个旁观者，在一旁默默地感受我的喜怒。\r\n现在已经有新来的小弟接替了它的任务啦。虽然它主人的 OI\r\n前途还非常迷茫，但是它一定是问心无愧了，它完成了它的任务，可以安然的度过它的余生了。\r\n当然前提是假如我不再折腾它的话（\r\n章五 · 余声\r\n这一篇算是写了有一段时间了，基本上都是抽空写成的每个章节，整体的连贯性不强，也没有什么图片描述，这只是一个我对于一台刚退役的老电脑的感想而已。\r\n最初的章零和章一还是在老戴尔上完成的，后面的基本上都是在新电脑上写完的（\r\n说点题外话，我觉得如果我当时是在老电脑上全写完的话，可能篇幅会更长一些，因为能说能吐槽的更多。比如\r\n940MX 在其他硬件拉跨的情况下是让我相对最满意的一个硬件，但是现在用了\r\n3060 之后，感觉也夸不出来啥了ww\r\n那就这样吧，翻过上一页，开始新的篇章罢（\r\n","slug":"Dell5568","date":"2021-08-08T12:36:00.000Z","categories_index":"Other","tags_index":"Me","author_index":"Heriko Deltana"},{"id":"d10de1c24dfcd71e15a78ea7474a9266","title":"Number-theory-basic","content":"「数论函数初步」\r\n\r\n\r\n前言\r\n内容相关：数论相关。\r\n因为 OI\r\n里研究的数论相关芝士大多是正整数相关，于是下面呢，没有特殊声明的就都是正整数~\r\n\r\n2022.8.3 UPD：搬运到了 hriver2.github.io，修了一些 typo.\r\n\r\n基础知识\r\n唔......这个板块大概就是回顾一下数论的基本的东西，一些简单而基础的东西就光写个标题或简单一提表示这是个前备芝士🍕罢。\r\n整除\r\n对于正整数  ，如果存在整数\r\n 使得  ，则称  整除  ，记作  ,就称  是  的约数， 是  的倍数。\r\nGCD and LCM\r\n是什么东西大家都知道了，简单说一条性质，下面可能要用到~\r\n若 ，则 。\r\n互质\r\n即对于正整数 ，\r\n下取整\r\n对于实数  ，记  为不超过  的最大整数。\r\n也就是说 \r\n是满足如下关系的唯一整数：\r\n\r\n显然，对于一个整数  ，从 1 到\r\n 中  的倍数有  个。\r\n在数论问题的讨论中，我们常会考虑这些数，称这些数为特殊点。\r\n性质一\r\n对于任意的  和正整数  ，均有：\r\n\r\n性质二\r\n对于正整数  ，考虑当  时， \r\n的不同的的取值个数。\r\n\r\n我们在此分类讨论此问题。\r\n若 ，则能够得到的\r\n\r\n只有不超过 \r\n种，这是显然的。\r\n若 ，则显然  的结果小于 ，又因为  且前者为正整数，所以这种情况下能够得到的 \r\n也不超过  种。\r\n综上，\r\n的取值不超过  种。\r\n莉题\r\n求：\r\n\r\n其中 。\r\n\r\n首先来看这个取值范围，显然 \r\n递推的牙白的，然后我们考虑取整函数的性质。\r\n因为对于一定范围内的 ，其对应的\r\n 的取值是一个区间。\r\n于是我们可以在 \r\n时正常按照这个核柿进行计算，然后剩下的按照上面所说的直接乘上区间长度。\r\n而这个区间的范围应当是：\r\n\r\n于是这道莉题就这样解决力。\r\n调和数\r\n定义调和数为：\r\n性质\r\n\r\n由这个柿子可以煺出一个常见的复杂度：\r\n 这个复杂度在从  到  中找因数时常见。\r\n素数\r\n定义  表示不超过  的素数个数，有：\r\n\r\n推论\r\n\r\n\r\n附近的素数密度近似是 \r\n第  个素数 \r\n\r\n算数基本定理\r\n基本定理就不说了。\r\n欧拉筛\r\n这个我之前写过一次，应该都会罢......\r\n数论函数\r\n从这里正式开始第一部分力~\r\n积性函数\r\n设 \r\n是数论函数，若对于任意互质的正整数的 ，都有 ，则称  是积性函数。\r\n若去掉互质这个条件，则称 \r\n为完全积性函数。\r\n性质\r\n设  是积性函数，且  是  的标准分解，则有：\r\n\r\n于是我们在研究某个积性函数 \r\n时就可以转化为研究 \r\n的形式，也就是研究 \r\n在素数和素数的幂上的取值。\r\n（研究素数的 0 次幂就可以研究 1 上的取值力！）\r\n求值\r\n设  是积性函数，求  可以对  分解质因数然后计算所有的  乘起来。\r\n如果要对 1 到 \r\n之间的每一个数求出它的 ，可以使用欧拉筛线性求解。\r\n单位函数\r\n定义单位函数 \r\n为：\r\n\r\n这个 \r\n表示当内部的条件为真时取值为 1，否则为 0 的函数。\r\n注意：单位函数是完全积性函数。\r\n除数函数\r\n定义除数函数 \r\n为：\r\n\r\n也就是用来表示 \r\n的因子的  次方之和。\r\n我们根据这个定义可以求一些特殊的东西，比如：\r\n\r\n 的约数个数可以表示为 ，常记为 。\r\n 的约数和可以表示为 ，常记为 。\r\n\r\n注意：除数函数是积性函数。\r\n欧拉函数\r\n定义欧拉函数  为不超过\r\n 且与  互质的正整数的个数。\r\n有欧拉函数的显式表达式如下：\r\n\r\n这里的  就是  的质因子之一，其实这里也是将  标准分解了。\r\n因此显然欧拉函数是积性函数。\r\n性质\r\n对于任意的 ，欧拉函数具有如下的性质：\r\n\r\n而这个性质的证明需要我们从 1 到  中的所有整数按照与  的  来分类。\r\n证明：\r\n若 ，那么 。而又因为\r\n 且\r\n，故这样的  有  个。\r\n我们考虑所有的 \r\n时，也就同时考虑到了所有 1 到 \r\n之间的所有 \r\n，所以就有了下面这个柿子：\r\n\r\n证毕。\r\n常见函数补充\r\n\r\n常函数：用 1 表示，即值恒为一的常函数。\r\n幂函数：定义为 \r\n\r\nDirichlet 卷积\r\n设  是数论函数，若数论函数\r\n 满足：\r\n\r\n则称  为  和  的  卷积，记作  。\r\n性质\r\n\r\n单位元：单位函数  是\r\n\r\n卷积的单位元，即对于任意函数 ，有\r\n。\r\n\r\n卷积满足交换律和结合律。\r\n如果  都是积性函数，则\r\n 也是积性函数。\r\n基本上所有形如  的函数或性质都能用  卷积表示，如：\r\n\r\n除数函数：\r\n欧拉函数的性质：\r\n\r\n如果 ，则  有关于 卷积的逆元。\r\n\r\n计算 Dirichlet 卷积\r\n我们设  是数论函数，计算\r\n 和  的  卷积在  处的值需要枚举  的所以约数。\r\n如果要计算前  项的话，能够枚举\r\n1 到  中每个数的倍数。\r\n根据我们刚才调和数的相关结论，这样做的复杂度是 。\r\n然后有一道例题是 P2303 Longge 的问题\r\n[SDOI2012] ，这道题的具体解法我发在了总之就是一堆杂题的 [#\r\n84]。\r\nMobius 函数\r\n定义  函数  定义为：\r\n\r\n其中  是不同的质数，能看出\r\n 在  没有平方因子时非零，因此显然  是积性函数。\r\n\r\nPS：若  其中,\r\n，则称  有平方因子。\r\n\r\n性质\r\n\r\n用 \r\n卷积表示就是：\r\n\r\n证明\r\n 时，显然是成立的。\r\n如果 ，我们设  有  个不同的素因子，由于  当且仅当\r\n 无平方因子，\r\n故  中每个素因子的指数只能是 0\r\n或 1，这和我在最初的定义里面说的一样。\r\n因此就有：\r\n\r\n证毕。\r\nMobius 变换\r\n设  是某数论函数，定义函数\r\n 满足：\r\n\r\n就称  是  的 \r\n变换， 是  的 \r\n逆变换。\r\n上面我在 \r\n卷积的性质里面提到过这样的和式都能用它表示，这个也不例外，即：\r\n\r\nMobius 反演\r\n 反演定理中指出柿子\r\n\r\n的充要条件为：\r\n\r\n可以通过 \r\n卷积证明：\r\n\r\n常见卷积是  和\r\n\r\n然后有一道例题是 P2257 YY的GCD\r\n，这道题的具体解法我发在了总之就是一堆杂题的 [#\r\n88]。\r\n无平方因子数\r\n\r\nPS：这部分不大会，爬了。\r\n\r\n求 \r\n以内的无平方因子数的个数，也就是求：\r\n\r\n对于一个素数 ，那么  的倍数都会有平方因子，个数是 ，这些显然不符合要求，去掉。\r\n但是这样会去多了，比如对于两个不同的素数  时，它们的平方的乘积 \r\n的倍数就被多去掉了一次（也就是被去掉了两次），我们要把他们救回来QwQ，也就是容斥原理。\r\n而这个容斥的系数正好是  函数，因此答案就是： \r\nEnd\r\n有点水呐呐呐呐呐呐呐呐呐。\r\n","slug":"Number-theory-basic","date":"2021-06-20T02:03:00.000Z","categories_index":"OI-Theorem","tags_index":"OI","author_index":"Heriko Deltana"},{"id":"1f1f781c67d8285d88ba4d4df0df3590","title":"15 次回环之日","content":"「十五岁生日小记（bushi」\r\n\r\n\r\n3.14,是数学节.\r\n能在这样一个伟大的学科的节日过生日,我很荣幸\r\n所以求求您了数学对我好一点行吗,150能不能让我得一个90?\r\n关于14\r\n14,就这样过去了,算是我经历过的最不平常的一岁,\r\n疫情,疫情时期的成绩起飞,返校考试三科的起飞,暑假的颓废,初三的跳崖下滑\r\n再到兴趣社团(实验班)的压线险进,再到OI的重新起步.\r\n总的来说,这一年没什么明显的成就,但是经历的挫折和起伏却不少\r\n但是转念一想,我上了初中之后,也没太有平凡的一岁吧.\r\n13岁,在12岁的WMC止步国赛之后,开启了和WMC项目的鏖战,请假了50+天,也不平凡,也累\r\n再说15\r\n前两天,在宿舍里面说到,\r\n我们原来在初中是43级,现在都是58了,比他们都小了15岁\r\n我说,那我还差几天才出生呢\r\n虽然说是玩笑,但是仔细想来,今天的确又是一个新的节点,\r\n43-&gt;58 新的数字,新的开始,再加上3.14,这些都是巧合,又不是巧合\r\n15,将是有一次的出发,在这一岁的旅途上,OI与学习,初中到高中,中考与高考的迫近......\r\n不过细想来,好像也就这些,有什么好怕的呢,现在一无所有,所以,没什么可以钩住我的\r\n还是我两个周前开学说的那句,15,并不只是负重前行,也是轻装上阵\r\n愿15,美好的事情将要发生\r\n\r\n2021.3.13\r\n\r\n","slug":"15th","date":"2021-03-13T16:00:00.000Z","categories_index":"About Me","tags_index":"Me","author_index":"Heriko Deltana"}]