{"pages":[{"title":"Heriko Deltana&#39;s Social Behavior Note Insiders","text":"4005478c813fff6361b09f2325cfd7786d2fe363732d2fbb0a94114b771c191de7199406f0f2db666ef74ed5ac78b4848bde1da4773ecfd4830d8b532f38c2d95a371ca792e50911f2c528023a792660bbbddbd1f31e486e1372103ca42dab2bfa3febb48c8745b52fd3aec83656cb645a3ea2fff4686f031833c7d5a13f40bb42e13db253aa4759620f525fc943d06ed02a512511d562f9bd71a9d062e31af6e99e70deefcc60844a14da5a55c9706e96c66c25bcd05d64a5b45be27c2a6299fb78afc9bcafba3e087606608848aed47cb8c6ff2dbdd66becf5e6841f1ae37eb4999879b559852a121c4212dd241d1550bdeb88a45eb2d2c272c825de9820269625f8573cc6f7fe99cf6887eb6485172721a556d00dbe623415c9fd9b216ed178da12442946cb28dcd42eb2c2df31882e5de1ea54ab035aaf01d890547d9b33221c229ced974e9f1074fb5a73ec1f8ae7db2b8aeca3ca7db68bd9d1fabed57b58ce6455c482827d4afcc747d65183eefffb3a4b2e29f49c45f16e1e47790b1ac05887ccd1877f3fbf67319d9725e8fd9f47d19e3758c0bb0e2fb6b280b873206be9e3c1a9237b3e303332ff4f4c4d862ae2bb1ae53f784e881ad1e2624f9b0ab22f22b5e363ab9f4bad135d40f5505f528d8e0e0e93fcc6d6a84fe59464eca53d906b42490ead1e5aa1f61f357c9ceb2a1c1462ee1f4ddf449b9d1aeac95ffbd93daa885fe8c608ae9ed190935756500a6c6a135228d217294991ced18fa942083975c52f24395e97b4d2d312a605fdb0d3a3fd686d215fb30befe33ce74734cb8e098ba26a6a716f01bcf7be24688f7c7b41cbcd5bdb19d11014495a92fa0736360f5487c2576973e9acec05c8313d969bc6991166c88b3f599b70f73f352ef6f2282c90f867ae2edc20873ca3cfbb63c5b7b9f8b597ef0b7a4fa2ace6d344b65ea72bafeacf0e06a7afc8cc8d87eb418a48d12de3956fa4179d47f01ff9954d9b06f5712ff4c5584346bf390577f6f7ba16c4e82580217c9160446452ece04d7ea8a2a6adfa80e9f4ef3f7b20497ca1b7eba48d8b77722e1743451ad9e02cd204e3943031f28a8a81f9d7e6cfb320e4f74e1a85915705a0b3eeed54aefa49768ab0f2291487ecd024f4645592c31abe049ac5cc645662c604571cbf8dab3310b718e54c05deec1004249ece4f8401494ccb0d9d1b60100e6a04524a721303f5d1a48a0d2256acf31892cbf4f4adedd35a810363047c38f5af127dc92e499cd40ea8df632cde974e8b93b5ddc0e88fee7b2811a962d4492d631f6374d9f85457e63d17a682e613a79313cccda2ebee7a0630e5b4b60ddfe43a3d4f0539a37f75d8b39519e6399028d9903922bdff17bed3f6f62ce2ce9d5057322ffb8391d1b07147f51c34a7a6b87c511e0d1033de0d63b5fcef0bb7701208e5482dbb0104eac0a1b9e6fd843a9d5955fd6e6c56102b3866b5e8e7e7bb14f09c720af6257d67d7551a5c49ab448335da4860ea9f29318c2dcaf8da85c2ce680fc45b76f336b49180c59e83d4278eed568afbb9c2d1f4848aa19c0a978df7efd79c3eb2a70940efb5c1ded7d842fc00fe068884fecf7701758873aac789c6c9ffb9036445ddc0ce7a79f52d73ec96b839943aa0ad260b96b27f8c779a73cf2b043389ecdeddc86ccf59d43f9b2eeaf1f70120eb715d6d4d6c1926332f5951542bff87dd5f7800a93f7152c21f76bebc18d10ec341a0af0ee31fa55678663eb4d2590234767ba4be0a0fd46ce5ce70e818d8300c61a4c303fa83e152e9668ac42a959eca2121151390c0c3af3d99d5a4d0582df3d5b86dc009d55f63f3b6f9b2e57a0321f26e160c066af29a776ade50dbd6a083f11c09a38c730180bce6348c65680828739f434025279905b273d01c00db9c18047700ff03ea4281f664a9482cbbce8e1a438120dec0e9c940339f3c76795fa098d98c957b4fd574b5b4eaa9838fde9e6723961d4f6c1b4a11b4a7b8cb0798d42d2ec3237b0b0dfb6f011739ce4f350314a99552db65f0a7170d16b888347cfd06cfd19591435e6835b535401a631ea5e07abf72eb4363acdd6bf42a3e904154d4b36ded83c6c46e8f07e5f81290ad94657851d10e7073aaaef5ef3ef63c2a22daeefe1a36d12abffb54fcdcdc24f8ee73d41228795ec0663e6dd5a4665bc7fd2d19e4ba9d7a0068c3b6f59cced9bbac6fa2934f3bc6c52fd2c9cb32b082e197df51f9e43e0bd6c66e9359edb778fafc56af4e4889eb42e41bbd37bfd6ceb121c21858db47d17e7dc970aaf8bd8eb32003d5843893860692c97ed8203297c195615f54eca319ea7ada269d7556f160342320349325bf6e247892f12fb6234add72658bb15500d99b6e9ba82ebd73ffed635583ab78954ec74a599c7edc543610a9d740777d5c0566c6e99eded1b35d5919d1ae5fdf495cfb4d933f26a9889694d8d2de0d6cab5da730b51de1967b77410137319e4a73bfcfa7f760cd6059bbc18d9e0281494abffc113f8bd163f3f77d07693b52041a450fa4d545f7bac36f610cf35e28933041bcb54bed9af33a49c52411d9d2c115dd5b62533333b6b1b610f82899a9f9cc4c9d095f18be639e42a9552d1ef00f7c6b98da5e46c1b3e70011c52c93b138f4da228f523e7bdb13ce78dd5538022056155865783096e30fb1e423f30f86486b743f1972e031f5eec195c5cd46b3aaaac27db1107c5f045c053889fcc60bd993b7eabfd28fd783e52e06d8b69fd57dabb92ec255d5e3f8f604d0aaa181c54611bac92e8d0c6700e951f0fcf5b4739c604253bcad13e6dd03137d5107f29f84690c24ce7b5df0fabef89cc8caec4746f28b3000e2a6c0fd4ba76246435b4785a801362808cbbf2a1d3c1c7db8c25168fc6fe34c0313374fbb4339d943319940c07564bb2db3ba7677f93c83920056287ceff624bb97f528aab5eac4cd0d76a1e51b49b1435abc817ccd9b1982382b47ee4567a9b4abb64ff6aad9de00cdae78e602f5d54fc572e581ad191836d7948b7c4416da170a6b6f6bafaec81e2c98218f8921de7ddf69188343bc8969430f6b0cff0890f7fe372a6d66a6d7587b78a9957d89e6817c26c809d768b9ce978d7cdc7e4fce59078b653b4c1ffc324ab911cdf424482b96973c9c056ef6ff308fc10494b2f1243bba030c01c1a18966a66b63debddf4bd113e3b68feb0fc2494b20fbd41faf507b36d8da64d9cb238d2d1674fa5a6d1e6eb15a364980d6800474c8803747bbad3f8d348db74f586b0cb4f82ceffdd66b52edb58caa0f0deca9309bad22b5d25da91cabc61762ec84c553f0b6fe7e45333cd6cb7a900b3270cf38f2b0138c8f3bded0ba9d10eb585c8755d40dcc6b03ad51bdc3a59cb89f761d46aabde41da2c7337d59b006eeb74a81fc43eaae5ee348d9d0ed9fe795ff22cf0a122ac422b8f09ade8ba1aa1703aa563e78f3f39fd8518e5ec587632e7962559bb6df851270c1a46e98edbf3934c4c77b2cf48ba3d29a703c8761e2d99c854b09331d835c49cca6292b36020458ab2103dd80b736587b18c4f800ceecb49f066ae29ea4d7a51a9a9b887ba5c05a403c90e18aa82611bdc51233f782832c61ee8be9d45fdad7b27d16f9254f4d3d7352d2b3170946dd116ac49ec093ded640bcf323ee388d32419eb9908edea486dc3a8818066541bca37ca5cee0cf36d095b03f8f05a301c8ee4ae14b945b479a29835f768cbbbf1d60dc580a24d2d4da0460a68729363417be18d117d0dc2a66c08622bb187c7585cdeac0f7c3210b96c8edd384dd15662ded40dbe0deaf613f525e812c6f46602cd738f2a1d79c5dbea6c02c1b29c5404faf3f4dfeaac0fa50ae 你觉得为什么会有密码呢（","link":"/HD-Social-Behavior-Note/"},{"title":"My Friends","text":"留言互换友链 ヽ(✿ﾟ▽ﾟ)ノ .links-content{ margin-top:1rem; } .link-navigation::after { content: \" \"; display: block; clear: both; } .card-friend { width: 45%; font-size: 1rem; padding: 10px 20px; border-radius: 4px; transition-duration: 0.15s; margin-bottom: 1rem; display:flex; } .card-friend:nth-child(odd) { float: left; } .card-friend:nth-child(even) { float: right; } .card-friend:hover { transform: scale(1.1); box-shadow: 0 2px 6px 0 rgba(0, 0, 0, 0.12), 0 0 6px 0 rgba(0, 0, 0, 0.04); } .card-friend a { border:none; } .card-friend .ava { width: 3rem!important; height: 3rem!important; margin:0!important; margin-right: 1em!important; border-radius:4px; } .card-friend .card-friend-header { font-style: italic; overflow: hidden; width: 100%; } .card-friend .card-friend-header a { font-style: normal; color: #1e90ff; font-weight: bold; text-decoration: none; } .card-friend .card-friend-header a:hover { color: #d480aa; text-decoration: none; } .card-friend .card-friend-header .info { font-style:normal; color:#a3a3a3; font-size:14px; min-width: 0; overflow: hidden; white-space: nowrap; } Dfkuaid の 小窝 暖呼呼~ zythonc zyc 可爱w HYL 天梦 六变形战士，我们滴光！~ _ajthreac_ ご注文はブログですか？ Rolleylon 忽乘青玄，熙事备成 Suzt_ilymtics 嘿嘿……Suzt_ilymtics…… KEBrantily 呜呜……KEBrantily…… 友链格式 名称：$\\tt{Heriko Deltana}$ 网址：https://hriver2.github.io/ 头像：https://s2.loli.net/2022/03/13/sjBvi17npORAf2W.png 简介：ねぇねぇねぇ","link":"/friends/"},{"title":"About","text":"这里是 Heriko Deltana 的个人博客，相比于博客园的博客，这里会有更多非 OI 的东西（ 坐标 SD，算半个 V 家人（ 喜欢 F1，或许能在一些水群看见我说 F1 相关，目前没买 2021，穷人只能先玩 2020，欢迎一起来玩（ 其实博客更新文章频率不高，主要都是在 HDSBN 更新一些日常啥的，毕竟这个博客等退役之后会大概会一直作为个人博客用，而博客园作为学术向的博客可能就弃了（ 唔……不知道该写啥了，那就先这些吧：D","link":"/about/"}],"posts":[{"title":"15 次回环之日","text":"十五岁生日小记（bushi 3.14,是数学节. 能在这样一个伟大的学科的节日过生日,我很荣幸 所以求求您了数学对我好一点行吗,150能不能让我得一个90? 关于1414,就这样过去了,算是我经历过的最不平常的一岁, 疫情,疫情时期的成绩起飞,返校考试三科的起飞,暑假的颓废,初三的跳崖下滑 再到兴趣社团(实验班)的压线险进,再到OI的重新起步. 总的来说,这一年没什么明显的成就,但是经历的挫折和起伏却不少 但是转念一想,我上了初中之后,也没太有平凡的一岁吧. 13岁,在12岁的WMC止步国赛之后,开启了和WMC项目的鏖战,请假了50+天,也不平凡,也累 再说15前两天,在宿舍里面说到, 我们原来在初中是43级,现在都是58了,比他们都小了15岁 我说,那我还差几天才出生呢 虽然说是玩笑,但是仔细想来,今天的确又是一个新的节点, 43-&gt;58 新的数字,新的开始,再加上3.14,这些都是巧合,又不是巧合 15,将是有一次的出发,在这一岁的旅途上,OI与学习,初中到高中,中考与高考的迫近…… 不过细想来,好像也就这些,有什么好怕的呢,现在一无所有,所以,没什么可以钩住我的 还是我两个周前开学说的那句,15,并不只是负重前行,也是轻装上阵 愿15,美好的事情将要发生 2021.3.13","link":"/2021/03/14/15th/"},{"title":"16 次回环之日","text":"十六岁生日巨献（bushi 提前几天开这个罢，想要等到回环的当天能够准时发出，毕竟周五当天写肯定是写不完罢。 2022.02.27 感觉快写成年度总结了（不就是吗 2022.02.28 好像大约能写完，好 但是感觉内容没什么逻辑的样子，无所谓了（ 2022.03.01 咋越写越慢了，感觉甚至写不完了（ 2022.03.02 今天一定要写完（ 写完啦，完结撒花（并不 2022.03.03 今天在展望里加了一点东西，改掉了一些奇怪的语句（ 2022.03.11 回顾去年，怎么说呢…… 好复杂的一年，经历的事情也很多，自己的变化也很多…… 那就从上次回环之日前一点开始回忆罢。 2020.12 ~ 2020.1想起来也是一年前的事情了（废话） 升入初三之后的状态是真的不好，学习成绩总是不向上走，大有一滑到底之势。于是，12 月月考，就真的一滑到底了（ 当时大概是十二月中旬罢，当时的我在某种意义上算是日记本的地方上写下了： 在那一天之前，却知道那一天不会到来。 当时应该是对自己快绝望了，明明平常不比别人差，为什么实验班要参考的考试就炸成这样（ 所以这里写的“那一天”，就是实验班录取的那一天。不过那个时候的我心态还是调整得比较快的，毕竟去不了实验班那就考推荐生嘛，再不济中考也是可以的……罢。不过那个时候单调下降的成绩让我觉得中考希望也寄了的感觉（ 然后就换了一个比较离谱的位置（我咋想也想不到为啥我会和 jp 同桌去，班主任换位的时候是忘了初一的事情了么w），然后度过了一个比较快乐的圣诞节（指帮迪哥打掩护以便于迪哥可以给 jp 送礼物（草），以及第一次收到别人礼物（大约是，反正初中之前我也不记得了））。 当然这个时期还是在好好学习的，期末考试虽然还是低于预期（主要是语文拉跨），但是也算是回升了，大约是没有压力的原因。 一月的时候去参加了实验班选拔考试，放轻松考的，发挥啥样不知道，但是大约是除了信息炸了都算正常。（我的水平来说，毕竟本身不太适合其他科奥赛之类的，但是就信息写炸是我真的没想到的）想起来英语的作文格超级长，于是自己写了 500 词的作文进去（草） 考完期末考试和济南市抽测之后的一个周六的下午，因为是考完试了就放松了一点，去教室相对晚了一点，然后到了教室听见体育实心球可以补测，我其实非常想去，因为满分 9.6 米，我 9.5x（ 但是级部主任在广播里说先等等，然后宣布了实验班的名单，一个一个的念名字。因为这个时候期末考试肯定没批完，所以我才发现参考期末考试好像只是为了稳心，所以我突然觉得我还是有希望的，于是就很紧张，万一有我呐（ jp 也很紧张，于是我俩就互相紧张的拽着对方袖子（草） 很多熟悉的名字从广播里传来，班里也不断有被念到的同学，大家都为被念到的同学鼓掌（ 一百个了，应该没我了罢，应该…… 然后倒数第二个念到了我，我也就成了我们班最后一个进入实验班的同学（ 再往后就是比较常规的实验班生活了（ 2021.1 ~ 2021.6比较常规的实验班生活罢，也没啥而特别的好像，情绪波动趋向于月初沉月末高循环。 2021.6 推荐生考试过了，顺利正式进入高中（ 6.16 初中那边毕业典礼，参与了部分毕业 PPT 的制作啥的，挥手告别初中三年（ 然后就是全天奥赛，这也是我 OI 水平提升最快的一个时期，也整好了暑假的培训计划（ 2021.7 ~ 2021.8和🐏、🍑度过了一个欢快的暑假（ 虽然日照的 SDSC 宿舍非常 **，隔壁的小学生非常**，但是和🐏🍑过的挺快乐的（ 因为大约报班报低了，再加上那段时间的竞赛状态很好，所以每天下午模拟赛都挺顺畅的，Day 6 的时候甚至 AK（也是我唯一一次 AK 比赛，大嘘 在 SDSC 期间正式入坑了 Phigros 和 Arcaea，音游自此逐渐成为我手机上唯一玩的东西（ 因为 Arcaea 里有一首 IA 的 One Last Drive，于是第一次关注到 IA（伏笔x） 然后两次课都是在济南，除了 QBXT 第一天考试因为电脑电源被后面孩子碰掉心态炸裂而爆零之外，感觉都在一个 21 年我相对高的竞技状态上，最好成绩是 BCT 最后一天捡皮夹拿了 RK2（ 考完试之后一看睿站发现无意中转发的抽奖中奖了……草。 话说我都不知道那条是抽奖来着，单纯的评论并转发（ 于是大约那天就把今年所有 RP 全用完了，一天之内一个皮夹一个中奖（ 感谢大哈鱼的 648，给我 美好的日子总是短暂的，上完课就直接返校了。 2021.9 ~ 2021.11大约从十月的下半段开始就停课了，停课之前的班内生活好像没有啥记住的了。 好像影响比较大的是小明带着我入了术坑（ 九月中旬生物去湖南集训，因为宿舍里其他人都是生物的，于是有天中午就睡过了，那天因为教室里缺的人太多，甚至没人发现我没来（ 国庆假期前夕才想起来 9.29 是翔 B 和小明的生日（其实是他们在群里都开始发他们在湖南生日的照片了我才想起来，我对不起 国庆完了生物从湖南回来之后，我们就开始停课了，完美衔接生物，班里人总是不齐，不过班里少上六七个人也不是很影响（ 由于暑假的缘故，我和学长交际比较多。停课的日常就是上午做正睿的模拟赛，下午晚上补题。 额但是不知道为啥吧，竞赛状态比暑假下降很多，放张正睿 rating 在这里吧（ 其实 CSP 二轮之前的状态还是可以的，除了担心自己 T1 挂掉之外（毒奶实锤(╯▔皿▔)╯ 然后就去了日照，懒得再复述了，看游记吧（ 从日照回来的那天晚上，没睡着，真的睡不着，谁能想到自己的第一次正式比赛以这样的形式结束。 那天晚上真的是不知道该咋办了，虽然不断给自己说着 CSP 就是一个晋级 NOIP 的跳板，但是心里还是意难平。 放在四个多月后的今天，我感觉那可能是十一月的……一个预兆罢。 因为自己铁不是一等，心里有点虚，所以再返校之后还是先去班里上了几天晚自习装作自己没有完全停课（ 但是等 NOIP 名单出来之后就还是全天停课了，心态恢复的还挺好的。 然后就是被正睿的模拟赛连番血虐，低于百分成常态，不过本身我也不太有高分的预期，所以也觉得无所谓，于是就正常的补题 2021.11.04……这天不太好[1] 但是不好的事情还是不提了好，活着多好（ 于是就有了那天提前回家，然后就不想去学校了，直接去 BCT NOIP 的班了。 然后就是在自己学校的 NOIP，考场想出来正解但是因为打挂以为是想假了，又炸了了一次 T1，但是精神状态的原因就有了博客园和 Github 博客都没有写的 NOIP 游记。 我只能是对自己无语，也无助，于是第一年就以两个二等收尾了。 当时还感觉 11 月有 20 天停课很长，现在好多事情都可能都忘了就觉得 11 月消逝的非常快（ 2021.11 ~ 2022.2这段时间就是回归班学 whk 的日子了，中间夹了一个寒假（ 最一开始是觉得真的拉下好多课，但是由于级部里的进度我都学过了所以后期月考之前做了做期中的题感觉挺顺利的（ 但是期中和月考完全不是一个难度啊草，期中随随便便切掉，月考给我整不会了。不过作为高中第一次考试主要攒经验去了（ 然后就是一个快乐的元旦，Sociobiology Note 里有说，懒得再写一遍了（ 因为没拿省一，也没有任何 whk 优势，于是在这段期间思考明年的事情。已知的是上一级信息不受待见停课之后全都被扔到普通班，然而我经历过 11 月的低沉之后和其它一些原因是真的不想再去适应新的环境了，也不想离开这个环境（ 然而也不是没有解决方案，第一种是考回前 200；第二种是上一级有学长选择不停课，成为了上一级唯一留在实验班的信息人（ 于是我决定效法，拿省一就润的话，今年暑假如果我觉得应该可以稳有那个水平了，就不长时间停课了，保持留在实验班吧。 至于这段时间的心理状态的话，除了元旦的时候发烧、考完期末和寒假最后的时候，也没太有回到 11 月的迹象了（ 新年的目标是活着就行（ 期末考试完全低于预期，不符合自己的练习量啥的。一般来说放在往前就依然按照之前的方式学就是了，但是十一月之后因为没有过往的负担了还是啥，准备故意开学考砸一次，看看会不会有老师找我。[2] 然后寒假就没怎么学文化课，基本都在看奥赛或者不知道在干啥（感觉是在挣扎？），开学也故意考差，目标是班里倒数第一，试图摸班底。[Ex] 但是结果就是并不是班里倒数第一，甚至也没有老师找我（[3] 可能是因为现在内心世界即使重构，也是完全变形，和之前不一样了罢（[4] 感觉十一月之后心理受到的影响还是挺大的，所以尽量避免这种事情罢（ 开学之后给自己心理暗示还是比较积极的，趁着这段乐观的重构期好好做一些事罢（ 展望前面说到了，对自己未来一年的预期不再像是上次回环之时了。 这一岁目标就一个了，活着，活到 17. 十一月以及之后我想了很多，很多。对自己的否定、肯定；对内心世界的肯定、否定；对未来的希望、失望；对前途的坚定、迷茫；对生命的滥想…… 还是顺其自然罢，活着就好，就算有极端的想法…… 那我不存在了，上面的都没用。 所以活着罢，活到未来，这是我唯一的期许。[5] 以下内容更新于 2022.03.11 介于这几天发生的一些事情以及一些思考，对最后一段做一些简单的添加罢。 前面说的活过这一年还是有点重了，某种意义上（ 因为我胆小啊（笑），只要没人要把我干掉就没啥问题的罢。 之前写那些的时候主要是回想起太多不好的事情，所以就写的 down 了一点。 虽然还是比较难逃出来自己给自己压出来的阴影，但是不至于对自己干一些极端的事情罢（大概）[6] [1] 我不会忘记那一天了。 痛的，苦的，闷的，烦的，所有 downside 的东西，一起冲向脑海了，我真的承载不住了，出生十五年来所有积压的东西，把我死死的压在地上。 甚至快四个月过去了，那些东西到底从我身上离开了多少，我无法确定。那时的我那到底是谁呢，我吗？不知道，我真的不知道，不会描述，但是难受，不知道，真的不知道…… 世界崩塌的那一刻我不会描述。 于是十一月之后就在一点点的重构世界（ 十一月之后感觉在各种方面还是变化挺大的，某种意义上之前我线上线下还是比较统一的，但是从那之后就开始，线上线下逐渐“分裂”了。 我不知道哪个是真正的我，因为这好像都是我，但是好像有点偏向人格分裂了，不过和人格分裂的定义好像不太一样，人格分裂是完全的每个人格之前分裂开来不互通，而线下的我和线上的我之前好像还有一个独处的我连接着。 其他方面的话，好像极端的想法多了一些，之前不敢的事情敢去做了。（当然还是有很多不敢的） 情绪化更严重了，网络依赖更严重了（不如说是对“线上人格”的倾向更严重了） 不愿意说话的时候变多了，自己一个人沉默的不知道要干什么的时候变多了。 [2] 寒假最后不知道自己想干啥，真的，而且很虚弱，不知道为什么。 [Ex] 寒假最后玩了主播女孩重度依赖，感觉对我还是挺有影响的，主要是认识到好像自己还有救，假如积极一点。 说到重度依赖呢，今年在回归文化课之后逐渐发现了自己的一些精神支柱是别人的事实，而且这个支柱对我影响还挺大的。 [3] 看来已经学校没人在意我考成啥样了罢。 [4] 第一次有了想毁掉别人的想法，反正自己已经没有什么用了，无所谓了罢。 [5] 毕竟这个也失去真实世界的我的存在之后，一切都无法后悔了罢。 [6] 谁能想到一个周了我又想补充一些东西呐…… 首先是去掉了之前对于 11.04 的前缀描述，感觉有点多余了，虽然没有人看。 然后把这些字调成了真正的透明。 想改一部分描述的主要原因是有点写的 down 了。 其余原因就是生日之后每天都还过的挺好的（ 但是昨天开始微微感到架空世界的感觉了 换句话来说就是把世界架空到一个或者一两个人或事之上了 虽然这段时间挺好的，但是未来会怎么样呐？ 不是，我瞎想什么呢。。","link":"/2022/03/04/16th/"},{"title":"Blog Develop Log","text":"记录这个博客的更改 如果看过我 Cnblogs 博客的应当知道我很闲，在一个博皮上稍微改个颜色都要记录一下（ 然而我习惯难改所以这个新博客也有这个东西了呐。 UPD 2021.11.2 2022.1.7 开始加题图咯（ 2021.11.2 配置好了友链，欢迎来互换友链（ 2021.11.1 配置好了 gitalk，现在可以自由的评论力！ 2021.10.31 配置好了 Mathjex. 移除了对于我无用的捐赠等界面。 2021.10.30 正式启用这个博客。 2021.10.29 选用主题 icarus，并进行初步的设置。","link":"/2021/11/01/Blog-Develop-Log/"},{"title":"CF 1602 ABCF","text":"随便做点题。 同步发布于博客园 「启」实在是不想接着补前几天的 NOIP 冲刺了（尤其是遇到 Day11 D 这种毒瘤题），于是就上洛谷随便做点题。 发现今天的日推是 CF1602A，于是乆决定把这场比赛的 A,B,C 都做了，然后发现 F 也挺水的，就一起水掉了（ 「Div2.A」Two Subsequences「Div2.A」题目简述给出一个字符串 $S$，要求找到一个字典序最小的非空字串，然后输出这个字串和原字符串删掉这个字串后形成的串。 「Div2.A」思路简述还是一如既往的手速题（ 因为是找出一个字典序最小的非空字串，所以找到一个字典序最小的字母即可。 「Code」123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define Heriko return#define Deltana 0#define Romanno 1#define S signed#define LL long long#define R register#define I inline#define CI const int#define mst(a, b) memset(a, b, sizeof(a))#define ON std::ios::sync_with_stdio(false);cin.tie(0)#define Files() freopen(&quot;RNMTQ.in&quot;,&quot;r&quot;,stdin);freopen(&quot;RNMTQ.out&quot;,&quot;w&quot;,stdout)using namespace std;template&lt;typename J&gt;I void fr(J &amp;x){ short f(1);x=0;char c=getchar(); while(c&lt;'0' or c&gt;'9') { if(c=='-') f=-1; c=getchar(); } while (c&gt;='0' and c&lt;='9') { x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^=48); c=getchar(); } x*=f;}template&lt;typename J&gt;I void fw(J x,bool k){ if(x&lt;0) x=-x,putchar('-'); static short stak[35];short top(0); do { stak[top++]=x%10; x/=10; } while(x); while(top) putchar(stak[--top]+'0'); k?puts(&quot;&quot;):putchar(' ');}CI MXX(1005);char s[MXX];S main(){ Files(); int T;fr(T); while(T--) { scanf(&quot;%s&quot;,s+1); int a(1),n(strlen(s+1)); for(int i(2);i&lt;=n;++i) if(s[i]&lt;s[a]) a=i; putchar(s[a]);putchar(' '); for(int i(1);i&lt;=n;++i) if(i!=a) putchar(s[i]); puts(&quot;&quot;); } Heriko Deltana;} 「Div2.B」Divine Array「Div2.B」题目简述给出一个长度为 $n$ 的序列，求问在经过第 $k$ 次变换之后序列中的第 $x$ 个数。 第 $i$ 次变换为：对于所有的 $1 \\le j \\le n$，将 $a_j$ 变为 $a_j$ 在第 $i-1$ 次修改后出现的次数。 「Div2.B」思路简述时空限制还是挺宽的，而且我们可以简单的手玩一下发现一个序列进行最多 $n$ 操作之后就不会发生变化了，所以我们预处理出每次操作后的序列即可。 「Div2.B」Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define Heriko return#define Deltana 0#define Romanno 1#define S signed#define LL long long#define R register#define I inline#define CI const int#define mst(a, b) memset(a, b, sizeof(a))#define ON std::ios::sync_with_stdio(false);cin.tie(0)#define Files() freopen(&quot;RNMTQ.in&quot;,&quot;r&quot;,stdin);freopen(&quot;RNMTQ.out&quot;,&quot;w&quot;,stdout)using namespace std;template&lt;typename J&gt;I void fr(J &amp;x){ short f(1);x=0;char c=getchar(); while(c&lt;'0' or c&gt;'9') { if(c=='-') f=-1; c=getchar(); } while (c&gt;='0' and c&lt;='9') { x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^=48); c=getchar(); } x*=f;}template&lt;typename J&gt;I void fw(J x,bool k){ if(x&lt;0) x=-x,putchar('-'); static short stak[35];short top(0); do { stak[top++]=x%10; x/=10; } while(x); while(top) putchar(stak[--top]+'0'); k?puts(&quot;&quot;):putchar(' ');}CI MXX(2001);int a[MXX][MXX],co[MXX];S main(){ Files(); int T;fr(T); while(T--) { int n,q;fr(n); for(int i(1);i&lt;=n;++i) fr(a[i][0]),co[i]=0; fr(q); for(int i(1);i&lt;=n;++i) ++co[a[i][0]]; for(int i(1);i&lt;=n;++i) { for(int j(1);j&lt;=n;++j) a[j][i]=co[a[j][i-1]]; for(int j(1);j&lt;=n;++j) co[j]=0; for(int j(1);j&lt;=n;++j) ++co[a[j][i]]; } while(q--) { int x,k;fr(x),fr(k); if(k&gt;n) fw(a[x][n],1); else fw(a[x][k],1); } } Heriko Deltana;} 「Div2 C/Div1 A」Array Elimination「Div2 C/Div1 A」题目简述给出一个长度为 $n$ 的序列，定义操作 elimination(k) 为：从序列中选取 $k$ 个数，设 $x=a_{i_1} \\operatorname{and} a_{i_2} \\cdots \\operatorname{and} a_{i_k}$，然后让这 $k$ 个数都减去 $x$，直到所有的 $a_i$ 都变为 $0.$ 求问能选出多少个 $k$，输出它们。 「Div2 C/Div1 A」思路简述考虑到要让数变为全 $0$，于是我们选的数 and 起来必须要让每个数每一位上的 $1$ 都被消除，所以选定的 $k$ 必然是所有位上的 $1$ 出现次数的公因数。 总体的时间复杂度为 $O(Tn\\log^2n+n\\sqrt{n}).$ 「Div2 C/Div1 A」Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define Heriko return#define Deltana 0#define Romanno 1#define S signed#define LL long long#define R register#define I inline#define CI const int#define mst(a, b) memset(a, b, sizeof(a))#define ON std::ios::sync_with_stdio(false);cin.tie(0)#define Files() freopen(&quot;RNMTQ.in&quot;,&quot;r&quot;,stdin);freopen(&quot;RNMTQ.out&quot;,&quot;w&quot;,stdout)using namespace std;template&lt;typename J&gt;I void fr(J &amp;x){ short f(1);x=0;char c=getchar(); while(c&lt;'0' or c&gt;'9') { if(c=='-') f=-1; c=getchar(); } while (c&gt;='0' and c&lt;='9') { x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^=48); c=getchar(); } x*=f;}template&lt;typename J&gt;I void fw(J x,bool k){ if(x&lt;0) x=-x,putchar('-'); static short stak[35];short top(0); do { stak[top++]=x%10; x/=10; } while(x); while(top) putchar(stak[--top]+'0'); k?puts(&quot;&quot;):putchar(' ');}CI MXX(2e5+1);int GCD(int x,int y) {Heriko !y?x:GCD(y,x%y);}int a[MXX],n,co[31],ans[MXX],cnt;S main(){ Files(); int T;fr(T); while(T--) { fr(n);mst(co,0);cnt=0; for(int i(1);i&lt;=n;++i) fr(a[i]); for(int i(1);i&lt;=n;++i) for(int j(0);j&lt;=30;++j) co[j]+=((a[i]&gt;&gt;j)&amp;1); int g(0); for(int i(0);i&lt;=30;++i) g=GCD(g,co[i]); if(!g) { for(int i(1);i&lt;=n;++i) fw(i,0); puts(&quot;&quot;); continue; } for(int i(1);i*i&lt;=g;++i) if(!(g%i)) { ans[++cnt]=i; if(i*i!=g) ans[++cnt]=(g/i); } sort(ans+1,ans+1+cnt); for(int i(1);i&lt;=cnt;++i) fw(ans[i],0); puts(&quot;&quot;); } Heriko Deltana;} 「Div1.D/Div2.F」Difficult Mountain「Div1.D/Div2.F」题面简述有 $n$ 个人去爬难度为 $d$ 的山，每个人都有 $a,s$ 两个值。 $s$ 表示当且仅当一个人的 $s$ 大于 $d$ 的时候它才能登山，后者则表示这个人登山之后这所山的权值会被修改为 $\\max(d,s).$ 「Div1.D/Div2.F」思路简述显然是要贪心的去解，手玩分讨发现，当最值相等时我们让 $s$ 小的先爬不会使答案变劣，所以我们直接进行一边排序即可。 「Div1.D/Div2.F」Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define Heriko return#define Deltana 0#define Romanno 1#define S signed#define LL long long#define R register#define I inline#define CI const int#define mst(a, b) memset(a, b, sizeof(a))#define ON std::ios::sync_with_stdio(false);cin.tie(0)#define Files() freopen(&quot;RNMTQ.in&quot;,&quot;r&quot;,stdin);freopen(&quot;RNMTQ.out&quot;,&quot;w&quot;,stdout)using namespace std;template&lt;typename J&gt;I void fr(J &amp;x){ short f(1);x=0;char c=getchar(); while(c&lt;'0' or c&gt;'9') { if(c=='-') f=-1; c=getchar(); } while (c&gt;='0' and c&lt;='9') { x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^=48); c=getchar(); } x*=f;}template&lt;typename J&gt;I void fw(J x,bool k){ if(x&lt;0) x=-x,putchar('-'); static short stak[35];short top(0); do { stak[top++]=x%10; x/=10; } while(x); while(top) putchar(stak[--top]+'0'); k?puts(&quot;&quot;):putchar(' ');}template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y) {Heriko x&gt;y?x:y;}CI MXX(500001);struct Rubbisher{ int a,s; I bool operator &lt; (const Rubbisher &amp;co) const { int mx1(Hmax(a,s)),mx2(Hmax(co.a,co.s)); if(mx1!=mx2) Heriko mx1&lt;mx2; else Heriko s==co.s?a&lt;co.a:s&lt;co.s; }}a[MXX];int n,d,ans;S main(){ Files(); fr(n),fr(d); for(int i(1);i&lt;=n;++i) fr(a[i].s),fr(a[i].a); sort(a+1,a+1+n); for(int i(1);i&lt;=n;++i) if(a[i].s&gt;=d) ++ans,d=Hmax(d,a[i].a); fw(ans,1); Heriko Deltana;} 「终」水。","link":"/2021/10/30/CF-1602-ABCF/"},{"title":"CSP S2 2021 题解","text":"CSP S2 2021（部分）题解 「启」因为觉得场上很不甘心，所以就把自己场上看过的前三题写了出来。 T4 没有写，因为觉得不是我的能力范围之内的（ 但是总体上来说今年的题好像简单的比去年简单（？），难的也比去年简单（？），但是总体难度好像难一点，再加上暴力分比去年少，所以分数线低（？） 反正去年的贪吃蛇我是一点想法都没有，今年 T4 还是有点想法的（ 以下代码均使用缺省源 V5.2. 「A」廊桥分配总的来说这道题真的不难，自己场上的做法和正解只是一个循环的区别，但是场上光想着先把能打的暴力全打了就没把这道题继续往下想。 要写这个的时候，觉得应当测一下官方数据，没想到居然 $A$ 第一个点挂了，于是改的时候又重新修了一下码风。 「A」思路简述首先先是场上的 $O(n^2\\log n)$ 的暴力做法。 思路非常的简单，先排序，然后枚举分配的时间，然后里面枚举飞机，每次将应当飞走的飞机从堆中弹出，然后让当前的飞机到编号最小的廊桥停下。 考场代码太丑了，我也懒得修就不放了。 但是这样显然是过不了的，于是考虑优化。首先可以想到的是这样贪心绝对是没问题的，所以我们考虑如何让这个过程的复杂度降低。 仔细分析一下，其实我们可以把两种飞机分开预处理，最后再将对应的答案合并。于是我们就要对于每种飞机处理出分配 $0$ 到 $n$ 个廊桥的方案，为了优化复杂度我们肯定不能再傻傻的枚举。 根据刚才我们的贪心策略，我们每次放飞机的时候都是要找到编号最小的廊桥把放进去，所以我们可以把可用廊桥的编号扔到一个小根堆里面，然后每次被使用的时候和占用这个廊桥的飞机一起扔到另外一个堆里面，这样我们处理的复杂度就降为了 $O(n \\log n).$ 「A」Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y) { Heriko x&gt;y?x:y;}template&lt;typename J&gt;I J Hmin(const J &amp;x,const J &amp;y){ Heriko x&lt;y?x:y;}CI MXX(1e5+1);int n,m1,m2,coa[MXX],cob[MXX],ans;struct Plane{ int l,r; I bool operator &lt; (const Plane &amp;co) const { Heriko (l==co.l)?(r&lt;co.r):(l&lt;co.l); }}a1[MXX],a2[MXX];priority_queue&lt;int&gt; id;priority_queue&lt; pair&lt;int,int&gt; &gt; q;S main(){ Files(); fr(n),fr(m1),fr(m2); for(int i(1);i&lt;=m1;++i) fr(a1[i].l),fr(a1[i].r); for(int i(1);i&lt;=m2;++i) fr(a2[i].l),fr(a2[i].r); sort(a1+1,a1+1+m1); sort(a2+1,a2+1+m2); for(int i(1);i&lt;=n;++i) id.push(-i); for(int i(1);i&lt;=m1;++i) { while(q.size() and -q.top().first&lt;a1[i].l) id.push(-q.top().second),q.pop(); if(id.size()) { q.push(make_pair(-a1[i].r,-id.top())); ++coa[-id.top()];id.pop(); } } for(int i(1);i&lt;=n;++i) coa[i]+=coa[i-1]; while(id.size()) id.pop(); while(q.size()) q.pop(); for(int i(1);i&lt;=n;++i) id.push(-i); for(int i(1);i&lt;=m2;++i) { while(q.size() and -q.top().first&lt;a2[i].l) id.push(-q.top().second),q.pop(); if(id.size()) { q.push(make_pair(-a2[i].r,-id.top())); ++cob[-id.top()];id.pop(); } } for(int i(1);i&lt;=n;++i) cob[i]+=cob[i-1]; for(int i(0);i&lt;=n;++i) ans=Hmax(ans,coa[i]+cob[n-i]); fw(ans,1); Heriko Deltana;} 「B」括号序列感觉是一道恶心的题，然后场上写了三个小时挂了，最后写的暴力也挂了，然后提交样例还 CE 了，Bad. 「B」思路简述暴力就不说了，$O(3^n)$ 的暴搜，下面的内容主要参考了I_am_Accepted 的题解。 看到数据范围之后，我们心中大约有了一个比较常规的复杂度：$O(n^3)$，而这是一个比较正常的区间 DP 的复杂度，所以我们就先正常的设状态和转移。 设 $f(l,r)$ 表示 $[l,r]$ 为合法序列且 $l$ 和 $r$ 匹配的方案数，而 $g(l,r)$ 表示不匹配的数量，这样就能避免重复计算的情况，最终的答案显然为 $f(1,n)+g(1,n)$。同时因为我们最多有 $k$ 个 *，为了后面方便使用，可以在最初用 $O(n^2)$ 的时间预处理出来。 而在转移之前还需要特判一些状态： 当端点为符号未确定且不能成为括号的时候，跳过； 当当前区间的长度为 $2$ 的时候，$f(l,r)=1$，跳过。 然后就是转移，首先是 $f:$ $(S): f(l,r)+=[co(l+1,r)].$ $(A): f(l,r)+=f(l+1,r-1)+g(l+1,r-1).$ $(SA): f(l,r)+=\\sum_{i=1}^k(f(l+i+1,r-1)+g(l+i+1,r-1))\\times[co(l+1,l+i)].$ $(AS): f(l,r)+=\\sum_{i=1}^k(f(l+1,r-i-1)+g(l+1,r-i-1))\\times[co(r-i,r-1)].$ 然后是 $g:$ $ASB / AB: g(l,r)+=\\sum\\limits_{l&lt;i&lt;j&lt;r,j-i-1\\le k}(f(l,i)+g(l,i)\\times f(i,r))[co(i+1,j-1)].$ 然而这个转移是 $O(n^4)$ 的，所以考虑优化这个的复杂度，发现 $i$ 每次增减 $1$，$j$ 的变化是 $O(1)$ 的，可控，所以我们可以先预处理出来合法的下一个转移对象，然后就优化成了 $O(n^2+n^3)=O(n^3).$ 「B」Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y) { Heriko x&gt;y?x:y;}template&lt;typename J&gt;I J Hmin(const J &amp;x,const J &amp;y){ Heriko x&lt;y?x:y;}CI MXX(501),MOD(1e9+7);int n,k,nex[MXX];LL f[MXX][MXX],g[MXX][MXX];bitset&lt;MXX&gt; co[MXX];char s[MXX];S main(){ Files(); fr(n),fr(k); scanf(&quot;%s&quot;,s+1); for(int i(1);i&lt;=n;++i) { if(s[i]!='*' and s[i]!='?') continue; co[i][i]=1; for(int j(i+1);j&lt;=n;++j) if(s[j]=='*' or s[j]=='?') co[i][j]=1; else break; } for(int len(2);len&lt;=n;++len) { for(int l(1),r;l&lt;=n-len+1;++l) { r=len+l-1;f[l][r]=g[l][r]=0; if((s[l]!='(' and s[l]!='?') or (s[r]!=')' and s[r]!='?')) continue; if(l+1==r) { (f[l][r]+=1)%=MOD; continue; } /*----F----*/ if(r-l-1&lt;=k and co[l+1][r-1]) (f[l][r]+=1)%=MOD; (f[l][r]+=f[l+1][r-1]+g[l+1][r-1])%=MOD; for(int i(l+1);i&lt;=Hmin(l+k,r-2);++i) if(co[l+1][i]) (f[l][r]+=f[i+1][r-1]+g[i+1][r-1])%=MOD; for(int i(r-1);i&gt;=Hmax(l+2,r-k);--i) if(co[i][r-1]) (f[l][r]+=f[l+1][i-1]+g[l+1][i-1])%=MOD; /*----G----*/ LL tmp(0); for(int i(l+1);i&lt;r-1;++i) { if(tmp&lt;=i) tmp=i+1; while(tmp&lt;r-1 and (s[tmp]=='?' or s[tmp]=='*')) ++tmp; nex[i]=Hmin((LL)i+k+1,tmp); } tmp=0; for(int i(l+2);i&lt;=nex[l+1];++i) (tmp+=f[i][r])%=MOD; (g[l][r]+=((f[l][l+1]+g[l][l+1])%MOD*tmp))%=MOD; for(int i(l+2);i&lt;r-1;++i) { (tmp+=MOD-f[i][r])%=MOD; for(int j(nex[i-1]+1);j&lt;=nex[i];++j) (tmp+=f[j][r])%=MOD; (g[l][r]+=((f[l][i]+g[l][i])%MOD*tmp))%=MOD; } } } fw((f[1][n]+g[1][n]+MOD)%MOD,1); Heriko Deltana;} 「C」回文多测没清空的痛啊，暴力分都没了…… 「C」思路简述实际上，因为要构成回文串，所以当我们在进行第 $i$ 步操作的时候，就能知道 $2n-i+1$ 次操作取出的数应当和其相同。 然后又因为每次只能从两段取数，所以原来的序列就被分为了两个连续的部分，于是就考虑用两个 deque 去维护从左端取出的数和从右端取出的数。 然后就有以下四种情况（因为要最优的方案，所以已经按照字典序排序）: $L$ 的头尾相同，则第 $i$ 次操作为 $L$，第 $2n-i+1$ 次为 $L.$ $L$ 的头和 $R$ 的头相同，则第 $i$ 次操作为 $L$，第 $2n-i+1$ 次为 $R.$ $R$ 的尾和 $L$ 的尾相同，则第 $i$ 次操作为 $R$，第 $2n-i+1$ 次为 $L.$ $R$ 的头尾相同，则第 $i$ 次操作为 $R$，第 $2n-i+1$ 次为 $R.$ 按照最优的策略先从左端开始跑一边再从右端开始跑一边，如果两次都不能构成就说明无解。 「C」Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177CI MXX(1e6+4);int n,m,a[MXX];char ans[MXX];deque&lt;int&gt; l,r;I void Solve(){ /*----Start At L----*/ l.clear(); r.clear(); l.push_back(a[1]); l.push_back(a[2]); for(int i(3);i&lt;=m;++i) if(l.front()!=l.back()) l.push_back(a[i]); else r.push_back(a[i]); int flg(0),cnt(0); while(cnt&lt;n) { if(flg) break; flg=1; if(l.size()&gt;1 and l.front()==l.back()) { flg=0; ans[++cnt]='L',ans[m-cnt+1]='L'; l.pop_front(); l.pop_back(); continue; } if(l.size() and r.size() and l.front()==r.front()) { flg=0; ans[++cnt]='L',ans[m-cnt+1]='R'; l.pop_front(); r.pop_front(); continue; } if(l.size() and r.size() and l.back()==r.back()) { flg=0; ans[++cnt]='R',ans[m-cnt+1]='L'; l.pop_back(); r.pop_back(); continue; } if(r.size()&gt;1 and r.front()==r.back()) { flg=0; ans[++cnt]='R',ans[m-cnt+1]='R'; r.pop_front(); r.pop_back(); continue; } } if(!flg) { for(int i(1);i&lt;=m;++i) putchar(ans[i]); puts(&quot;&quot;); Heriko; } /*----Start At R----*/ l.clear(); r.clear(); r.push_front(a[m]); r.push_front(a[m-1]); for(int i(m-2);i;--i) if(r.front()!=r.back()) r.push_front(a[i]); else l.push_front(a[i]); l.push_back(r.front()); r.pop_front(); flg=cnt=0; while(cnt&lt;n) { if(flg) { puts(&quot;-1&quot;); Heriko; } flg=1; if(l.size()&gt;1 and l.front()==l.back()) { flg=0; ans[++cnt]='L',ans[m-cnt+1]='L'; l.pop_front(); l.pop_back(); continue; } if(l.size() and r.size() and l.front()==r.front()) { flg=0; ans[++cnt]='L',ans[m-cnt+1]='R'; l.pop_front(); r.pop_front(); continue; } if(l.size() and r.size() and l.back()==r.back()) { flg=0; ans[++cnt]='R',ans[m-cnt+1]='L'; l.pop_back(); r.pop_back(); continue; } if(r.size()&gt;1 and r.front()==r.back()) { flg=0; ans[++cnt]='R',ans[m-cnt+1]='R'; r.pop_front(); r.pop_back(); continue; } } for(int i(1);i&lt;=m;++i) putchar(ans[i]); puts(&quot;&quot;);}S main(){ Files(); int T;fr(T); while(T--) { fr(n);m=n*2; for(int i(1);i&lt;=m;++i) fr(a[i]); Solve(); } Heriko Deltana;} 「结」算是完成了自己的心愿吧（ $$NOIP2021 RP++.$$","link":"/2021/11/03/CSP-S2-2021-Solu/"},{"title":"CSP S2 2021 游记","text":"CSP S2 2021 游记 「在启之前」这个后面的内容和博客园上是一样的，但是这是更偏向我个人向的博客，所以我还是多说一点（ 今天晚上出成绩之后，和之前自己预测的差不多，应该是个能进 NOIP 但是省三/省二的分数。在博客园上写的标题是”退役记”，但是都明白实际上这一切才刚开始一年。 即使只剩下了高二一次机会， 即使 NOIP 省一要比 CSP-S2 难， 即使因为考场上有各种失误而不甘， 但是还是要打下去的，不然为什么要选 OI 呢。 所以应当摆大烂！ 所以应当接着努力（ 「启」孩子第一年打比赛，给孩子打傻了。 因为复赛就 10.23 一下午而已，所以就用日期当标题了。 「2021.9.X」发现自己过了初赛，按照 CCF 的标准来说，居然还是 《全 国 一 等》，笑傻。 「2021.10.1 ~ 10.7」报了 ZR 的线上课，在家听课。 最后一天考试感觉不错，体验很好。 「2021.10.8 ~ 10.21」ZR 的 NOIP 冲刺，每天都在考试，但是时好时坏……总体不好，题也补不完，就很蛋…… 「2021.10.21」提前一天从学校回到家，晚上进行了随便看了看模板，去 fys 的 CSP 2020 赛前总结那里看一些易错点，顺便扫墓。 晚上和初中班主任打了电话，虽然已经在高中上了 10 个月的课了，但是和初中班主任联系还是很多，好多事情都必须要感谢，人真的很好（ 主要说了点关于心态的东西，然后晚上大约就水过去了。 因为 Phigros 22 号要更新，所以我试图等更新，但是后来发现都说是 22 号下午，就没再等，然后乆睡了。 「2021.10.22」上午和昨天晚上差不多，中午吃完饭往日照走。晚上敲了个线段树板子，结果没调出来，懒得调乆睡觉了。 下午在车上更新了 phigros，2.0 属实好看，体验很好（ 新铺子除了狂喜的 IN 都觉得简单了好多，☁️女孩慢速彻底没了（ 因为 Win11 刚上了 WSA，整了一会，体验一般。 「2021.10.23」 比赛日。 「上午」上午先是试图调出来昨天晚上的线段树，但是发现 KnightL 他们建了一个 SD 面基群，然后就听 hyl 唱歌（？） 然后去找 Dfkuaid，ceh，hyl，在他们宾馆呆了一会。 然后就是正常的吃饭，实际上到了吃饭的时候才发现好像真的要比赛了呐，会宾馆睡了一会，我爸说睡得很香。 「下午」起床之后乆直接去山外了，时隔三个月又回到了这个破地方……SDSC 属实难受。 下车正好遇到 hyl，Dfkuaid，ceh 下车，我们四个乆一块去，然后就是非常正常的进行拍照，本来还要喊某口号来着。 口号则是去年 LCEZ 的 CSP 二轮典中典： $$ 人生在勤，志达天下\\\\ 亮剑精神，信息之光\\\\ 脚踏实地，勇争第一\\\\ $$ 然后就是进去考试试机（ 「13:50 ~ 14:27」说实话因为心里没想啥所以就只是单纯的打了我常用的缺省源，试了试 auto，bitset 等自 己 常 用的东西（埋 下 雷 了），然后测了测机子的速度，可以说是很慢。所以我还去确认了一下配置之类的。最后总结来看我考试用的机子的环境是： i3-4130 + 4G + Win10 + DevC++ 5.10 (gcc 4.8.1) 嗯没错这个环境 c++14 开不了，虽然好像部分符合 14 的标准来着（ 试了试 __int128 发现不能用，但是试机的时候没想出来为啥不能用，后来考试开始了我才发现是因为这个破东西的 DevC++ 默认的 gcc 是 32bit……当然最后也没用到 __int128 就是了。 发现输入法没有英语环境，乆从设置里整了一下，然后按照自己的使用习惯又开了两个桌面，这三个桌面分别负责 Coding，读题 and 审题，以及检查文件。 把 DevC++ 的时间戳自动保存开开了，防止出问题。 看 起 来 真 的 是 十 分 万 全 的 准 备 了 呐。 然后乆没测啥，等着发密码。去看了一眼文件的大小，发现有个样例好大的样子，略感震惊。 密码好像就是非常正常的随机生成的样子来着（ 「14:30 ~ 14:45」这个十五分钟先是过了一遍题，当时觉得 A 仿佛是最可做的，B 和 C 有一点 DP 的意思，以上三题都有暴力分，分别是 40 + 15 + 28，D 觉得不太可做，所以就最后开题的顺序是 A(BF)B(BF)C(BF)ABCD. 「14:45 ~ 15:00」这十五分钟主要是把 A 的暴力写了出来，然后测了测样例，发现三个都过了，就按照既定的顺序去写 B 的暴力了。 然后，一 个 人 类 的 噩 梦 来 了。 「15:01 ~ 17:47」前半段时间就一直在写 B 的暴力 DFS，我不知道为什么最后总是一会 RE 一会不 RE，很奇怪，于是就去开了 C 的暴力。 也是一个 DFS，难道是本场暴力都是 DFS 么（悲 然后……写了一段时间，也和刚才的 B 差不多，同一段代码一会 RE，一会不 RE，就给孩子整离谱了（？ 然后因为之前喝了两罐 RB，于是就决定去上个撤硕。 上撤硕的时候灵光乍现：它 RE 的时候总是说我 vector.h 这个头文件错了，不 会 是 哪 个 STL 锅 了 吧。 然后我就自然的想到了 string 身上。 「17:57 ~ 18:30」回去之后，想了一下发现其实 C 没必要用，用 char 数组就行，然后，果然不 RE 了（？ 然后发现答案的字典序不对，就又对着调了一下，后来发现是对比的时候下标对应错了，改完就对了，而这个时候已经来到了 18:11，终于是过了样例…… 然后去看了半天的 B，死活改不出，然后在 18:21 的时候终于放弃抵抗，把样例全都特判了上去，并把自己打的 DFS 注释掉，并在其中慰问了 CCF. 然后最后检查了一遍就把东西整好了交上去了，要交的时候问了一下旁边的老师是不是没有什么问题，然后老师看了看，说“都身经百战了，这点不会错的，不用紧张这些。” 第一年打的孩子大为震惊（ 临近考试结束了，旁边的孩子吃东西的表情越来越绝望，看来是打的也不好啊（ 考完了去看了看同场的 hyl，它还在交文件。 出了考场发现除了我都切了 A，然后算了算发现今年暴力打满还不如一个正解……突然感觉省一无了，省二勉强。（实际上是省三（ 「晚上」因为第二天要返校，所以当天晚上乆回去了，路上和爸妈，和初中班主任，进行了一堆聊天（ 最后觉得应当能进 NOIP 就考虑接下来如何权衡 whk 和奥赛，说实话因为 whk 不如其它的人好，所以确实很纠结。 晚上到家十点半，上床之后不知道为什么就是睡不着，虽然过去 CSP 感觉还是没啥两样，但是确实是睡不着（ 手机放在旁边充电，看了一会 QQ，然后就睡了。 「2021.10.24」今天早上起来发现： 晚上（也就是现在）发了程序，本来期望是 $40 + 0 + 28 + 0$ 或者 $40 + 0 + 40 + 0.$ 结果呢洛谷测一测……T2 注释多了 CE 了，T3 好像暴力假了爆零。 更正一下，T3 爆零是因为多测清空不完全，暴力部分内的答案是对的。 目前测试的结果：洛谷 $40 + 0 + 0 + 0 = 40$（10.24 测，期望最低，希望 CCF 数据能放亿点水qwq） InfOJ $50 + 0 + 16 + 0 = 66$（10.29自测，这个 T3 可能比较现实） LOJ $45 + 0 + 24 + 0 = 69.$（10.26自测，可能是这个的 T3 数据有 $T=1$ 的部分） HydroOJ $60 + 0 + 24 + 0 = 84$（批量，可能这个 T1 的数据水一点，不知道为啥 T3 的数据改的像 LOJ 一样有 $T=1$ 的东西了） 最后应该是 $40$ pts 滚粗，恭喜你 LCEZ 喜提一个省三。 「2021.10.30」出成绩了，和 LOJ 的一样，等 NOIP 吧。","link":"/2021/10/30/CSP-S2-2021/"},{"title":"Dell5568","text":"关于老物的一些字。 章零 · 序章实际上从这个在暑假的开端，就有写这篇的想法了，不过由于各种神必的原因一直没写就是了，也不知道什么时候能写完 说实话网上应该也不会有人和我一样干啥都想写点东西，所以这篇文章大约就是你能看到的最详细的16 年过气本 Dell Vostro 5568 体验。 这篇文章和 OI 关系不大，可能同步到 Bilibili 专栏和酷安。 Bilibili 上虽然不支持手写 Markdown 但是有基本的常用语法，所以排版和这里算是差不多罢。 而酷安的话不支持 Markdown 所以大概率会重写一份罢。 同时因为酷安和 Bilibili 毕竟不是自己博客，所以里面的一些小东西也会不一样（ 但是这里应该就是最全了的罢，但是可能因为某些神必原因，我对 2018 年之前的事情都记得比较模糊了，所以总体的文章长度也不长（ 章一 · 初见这个是 2016.12 发布的本子，而我是 2017.01 拿到的它。 实际上也没有什么初见可爱单推的过程ww 当时还是小学，现在来看觉得自己很幸运能够这么早的接触这些东西，这也可能是我走上 OI 这条路的原因之一。 当时比较天真，关于电脑就只能知道它能否正常的运行，各种毒瘤的软件也霸占了那个电脑的小硬盘。 后来由于自己装了一大堆神必东西导致电脑很慢很卡，于是懒得去开电脑，后来逐渐变成多数时间都不碰它。它便逐渐吃灰，从我的生活淡出。当然有些必要的时候还是要用到它的 那时候也不知道如何保护电池什么的，这也为后来埋下了伏笔（？） 章二 · 重逢上面说的它从我这里逐渐消失了存在感（ 但是 2020 年的疫情让它重新回到了我的生活当中来，学校选择的网课平台对 iPad 适配极差，在老家度过疫情最严重的前两个月之后，我实在是忍不住就回家拿了电脑。 当时我一打开电脑扑面而来的是 Windows 安全中心 VS 迈克菲 VS 360 VS 火绒 的壮观场面，考虑了一下最后先用 360 把最毒瘤的软件干掉了之后只留下了火绒。当然如果要按照后面的事情来看根本不必如此（ 因为那个时候也是算是开始逐渐对数码之类的东西真正有点懂了，就开始对电脑进行各种神必的操作优化，上课划水无师自通。 突然有一天我妈问我如果高中五大奥赛要选一个，我会选哪个。我当时可能是出于对信息方面的爱好（？）于是选了 OI，从此踏上 OI 的不归路。后来好像听说家庭版的 C++ 库什么的好像不全（现在发现其实都是能自己装的），于是想着要不然就重装个系统罢，然后这就是梦开始的地方了。（这里指噩梦） 当时我把找了个 熟 人 帮我重装系统。现在来回忆的话，他大概就是拿了个 U 盘作启动盘到家里插电脑上 setup 一下就完事了，但是当时天真浪漫不懂电脑的我就只会在旁边看着。当时他好像还用的是大白兔这个毒瘤玩意。 因为只有 C 盘会受到影响，当时就没有备份（危）。 本来用起来非常的舒适，所以也没有什么思想准备，下载 QQ 的时候电脑卡了一小下，但是我认为是新系统的问题就没有注意。然后下载 Office 的时候，进度条卡在了 86% ，然后……电脑黑屏了，那天就再也没开开过了（悲） 后来拿去修发现是硬盘坏了…..咱也不知道为什么给我重装系统把硬盘搞坏了，里面数据也不给我取出来，到现在还没找他，气死我。 所以从那以后是坚决不让所谓熟人来整电脑了，明明搞个系统自己不用花钱就能解决的事情最后还花了钱买了个不是很好 SSD 那人也挺有意思，中间给我拆机的时候忘了把风扇的一个盖板安回来…… 更有意思的是明明我要的是专业版，他给我装了个 L T S C !这谁顶得住啊，绝了。反正我是再也不让我爸的“熟人”碰我的设备了。 然后一直到现在，它上面还是 LTSC，主要是懒得改了。 章三 · 印象实际上这章的标题确实不知道该起什么了（ Dell 的做工不错貌似是公认的样子，但是它的做工……让人一言难尽。基本这四年半的时间一直在和它的神必做工斗争。 最一开始是直接掉了一个螺丝（？）导致屏幕转轴的地方开裂（ 然后换了个螺丝上去也没事了，再后来就是这货的风扇，可能是出于某些神必的原因开始打它和主板之间的挡板，但是风扇的位置是对的，这玩意到后来演化成了战 略 级 移 动 拖 拉 机，我也把这玩意录了下来发到了B站（？）视频链接在这 当然这也是换掉它的主要原因之一。 最重要的应该是因为这货的电池……当然这个怪不得它罢，这个属于是小时候习惯不好一直插着电最后导致电池鼓包了罢（ 但是充电口也能坏是我没想到的，插着充电器，突然就有一瞬间供不上电，然后我未保存的东西成功没了……这两点加起来让人体验挺拉的，到后期因为风扇太吵甚至不想晚上打 Codeforces 了（ 但是刨除这两点，它整体的实力还算是差强人意。 i5-7200u 虽然主频拉跨，而且我经常吐槽，不过放在今天还是足够作为一个办公的本子的 u；Geforce 940MX 算是这个电脑为数不多能拿出来说道的东西，这个显卡其实就是老 MX 系列的最后的一代里面最高端的那块了，如果我没记错的话这玩意有 4GB 的显存，算力在这台电脑上完全够用。 在这两位的支持下，F1 2016 和 GTA5 都能窗口模式 + 最低画质的情况下达到不错的帧数。（前者平均 40 帧，后者平均 52 帧） 其实这个帧数能更进一步的，因为我发现帧数的瓶颈在于……内存。 4GB DDR3 2300 的配置放在 2017 之前还算是不错的水平，不过现在可是 1202 年啊，开个 Egde + VScode 内存就能暴毙（ 4GB 是真的拉，要不然这个体验显然能更进一步的（ 屏幕就不多说了，大果粒 + 低亮度 + 45%NTSC。 但是这个电脑确实助力了我达成了很多事情，同时陪我经历了许多，我的第一个 C++ 程序，Py 程序，第一份 3D 建模，第一个 FL Studio 工程文件…… 当然最重要的应该就是现在这段 OI 之路的前半段，由它陪我度过。 章四 · 暂别不再听它的声音，已经是有三天时间了，当我写完代码时，兴奋地按下的已经不再是它身上的 F5，深夜调代码的时候，面对的也不再是它，它现在只是一个旁观者，在一旁默默地感受我的喜怒。 现在已经有新来的小弟接替了它的任务啦。虽然它主人的 OI 前途还非常迷茫，但是它一定是问心无愧了，它完成了它的任务，可以安然的度过它的余生了。 当然前提是假如我不再折腾它的话（ 章五 · 余声这一篇算是写了有一段时间了，基本上都是抽空写成的每个章节，整体的连贯性不强，也没有什么图片描述，这只是一个我对于一台刚退役的老电脑的感想而已。 最初的章零和章一还是在老戴尔上完成的，后面的基本上都是在新电脑上写完的（ 说点题外话，我觉得如果我当时是在老电脑上全写完的话，可能篇幅会更长一些，因为能说能吐槽的更多。比如 940MX 在其他硬件拉跨的情况下是让我相对最满意的一个硬件，但是现在用了 3060 之后，感觉也夸不出来啥了ww 那就这样吧，翻过上一页，开始新的篇章罢（","link":"/2021/08/08/Dell5568/"},{"title":"Dilworth","text":"Dilworth 定理浅谈。 主要参考：浅谈Dilworth定理 - cmwqf。 「启」想起来这个定理，是因为我在古远的时候（大约今年 $3$ 月？）遇到了但是没有进一步了解，今天突然又看到导弹拦截这道题，于是就想把它进一步里了解一下。 「定理内容」偏序集上最小链划分中链的数量等于其反链长度的最大值。 一看，偏序集，最小链划分，反链，都不会（ 于是下面开始逐一理解 看 定 义（ 「偏序集」定义一种比较关系使得两种元素进行比较，比如我们定义 $x \\operatorname{Aqua} y$ 当且仅当 $x,y\\in Z$ 且 $x \\le y.$ 显然 $x$ 和 $y$ 都满足 $\\in Z$ 的时候她们两个是可比的，否则若有一个不满足，我们则称这两个元素不可比。 那么偏序集 $S$ 就定义为满足以下性质的允许存在不可比元素的集合： 自反性：$\\forall x \\in S,x \\le x;$ 对称性：$\\forall x,y \\in S,x \\le y \\Rightarrow y \\ge x;$ 传递性：$\\forall x,y,z \\in S,x \\le y,y \\le z \\Rightarrow x \\le z.$ 「链划分」若我们把满足 $x,y \\in S,x \\le y$ 的 $x,y$ 之间建立一条 $x \\to y$ 的边，那么显然的是偏序集是一张 DAG. 把 $S$ 中的元素划分为若干条链，使得每个元素都在且仅在唯一的一条链中，叫做链划分。 「反链」链是 DAG 上的某条路径上的元素，而反链和链的定义恰好相反，对于一个集合，它是反链当且仅当这个集合里的元素两两都是不可比的，即这个集合中的元素两两不连通。 也就是说，我们将一个偏序集 $S$ 划分为若干个小集合，使得每个小集合里的元素构成一条链，这个最小的划分数量，等于这个偏序集最长的反链的长度。 然后就能利用这个来做一些看起来很难的题。 以下摘自我的杂题记录。 「例题」 洛谷 | P3974 组合数学 [TJOI2015] [省选+/NOI-] 好喵一题。 其实做这道题只是在看自己之前的博客的时候想起来之前有个 Dilworth 定理，然后就随着一个博客（浅谈Dilworth定理 - cmwqf）学习的时候，找到了这道题。 众所周知题目名字里有啥，这道题就不用啥做，所以这道题用不到组合数学（ 我们把这道题中的每个点 $(i,j)$ 拆成 $val(i,j)$ 个点，然后把能够到达的点之间连边，最后变成了一个 DAG，题目所求就是求这个图的最小链的划分，根据 Dilworth 定理，这个 DAG 的最小链划分就等于它的最长反链的长度。 按照我们建图的操作来说的话，这个反链就是说的最长的不能到达的链，也就是说要求每个点的右上和左下矩阵中点权值的最大值，于是直接 DP 即可。 123456for(int i(1);i&lt;=n;++i) for(int j(m);j;--j) { f[i][j]=f[i-1][j+1]+a[i][j]; f[i][j]=Hmax(Hmax(f[i][j],f[i-1][j]),f[i][j+1]); } 答案即为 f[n][1].","link":"/2021/12/10/Dilworth/"},{"title":"Dream:2021926","text":"03542c0fe6f2490b92a0271bf9c39db56357b1f24ee055e4e6b7ef5e48e7bd111688983e8541860469c0e6f6d551b43637141c1a3440d1a96571cd05531c1e38683d1dd487afd1ceb39ede45ae388fc1e2df64d28aff37ad6a1353c6e950544293ce338cb9b2cd33f663e9d17e2ea7c41c782d3b6d8262cd7da6cfbc8a22c67c08d841ec246854b709296009f90c0eca3c36695d397b918c5eaf0779b81a9734dd2760fa3ee85451a74f5ef58d323c3bdabe3fef46d4693b4b0c67389e35b301bcf2cfd548aeffb8e3cdf0a2712b2490b89762e8811d419ad0ec3f7251d9c0cd22cee079bf61a7b2c8c0ab4591ebdd99e791d75eae43c63585013c981829a854b8c14b006f153362d5cde2a864b89898eba949814c74d62379cc45e5fbbcc9a8863febe0d7cfc76cc14f756a3b6869d0ca2ec7e13a4c332811238bd3d75a92fe0a61795b4c72f5ce6aae86837251689d1b66f19f5e2d0f5d22ced1096b609f072d3ca87f93a5bdad9e992fa6b3a5b7c2d05945d258af3a741dcb8c9e6de58c866d4eb3bb6d39c4bc550a48f80e3686cb46349993356fdacb13456fd8883d735a364c06dfa70c227c1002a4f751ee12bb356f9a36b4782fa0d432ed8bda1baadb321a3f8da6cf90e32b499b2472a43fabb6b62e6d5bfdaf12fdfbaffd739b958b7cf3d5c82cf6e4cea77a903f194703638871cf392a3a162475a194e35694a3c995b85b9a3aa5828237f751b4b3963b007e645288e8f8de7719a91c73e25e8cca646fa050ddcc4c3ed77643ee1ade4d66657191b5494d645d74a3284a055c53b8979ae9794a9d446149ec782b1f9778cc0d95b19793a48bf2445c3ea138e369743b321f8420802bae107263544e165adaeafa7bf4e502571d062fba27fd1b9961caef21ce647858096ca34911ec82af8ba12f95350a66c78da92cc6e3ac06a432d9a775e740e4c2894ab06f0bb0b7ab8835c3673c283e591df107bd4df43f5a75a23ac66f6f0142c1db012b1954d5722ce5a4fa1ae36fc622ccb424e9566deac1db710e3dcf420cdab80435d77154fa641e8f80d6661804e48c863e51562490ebbfa839573ea29cfaf2c078351268ad7d1b55e74c549ea3e1fe268ba9f12ebea6efd3bdd46645d450fe67b4c5f06eee592198d0ea792f3cd2c5521dcbfc33aa3f8694b3ddc374b2e36e07f404f11fadba5873c2accc38923a8e7b91d68e62f10d95e9fd0077a148a749ce9f5c0962c00aa7160d36f1c2766533240887825a8da5ffeb848d49a3af16154adc0338649da91a388a1c5d4cf72d47877148c3377a1ef592e98500f93329f410caa5827de41902ad565a2e4657e0963d5d255a778d463e8bc2c563ba723f2df2f4031aeaea76b08a0e6438893607f1e9f7876fe708d237e5496eed27016bf8f698af17f6fd5480e465937450f9741df799cdd61ae33f592e497a1ceb606a5e5f8a856686f43031cd2cc9de5d06c91c3c8cfcf4100881e5368d4e7aff575e9f11067174a4860c9bc98ec137fbbfadd896087138cef172f44f525096c1013842d3461dee84fb50aca025873821b8384f5021dad606e86c1f498afb6f4ce8d5f8588c1e55c9f7f66f346e4d1de3c7db444360ac148f756edafb75ebc5cce5f670193e49a76f880a6481472a0a4051e09366f55d03fc0445e1699ac7eaf0b3f2720bfc33f3425d130bc4887a878a4a6fb8b44d37c2e75a35601ef2b4d0d5fa920d6f6534cc19caaee2f23ef60b9839f186c6a5dcf341def019751cc6ec2ea4a9cdb351fcb62881ff9cf756d7aaeff703db761e70fc5265d63f74b9663d15b0122b6be8fd60b2dee3077526cf6a7bb90c0a1eb25719deb6e11378389ca5916e0b1fcc478c77aad6072cd1104280d3fc6dba300a5f4e4accf9bf07034737b4cef8843f55143311fe90bf86134a128b1a29398f6841eb26ee395becf0071f69d7097d3ecfe3b90602f35d43ca1e7a8c85f7ca0bc0649e2146e0d24909e269904b782617f489b2c3866a43de1fda3a7305af3f05f2208900082ce1504c6e4d1bb242a4793a0ce79075753260783a94aca104ba0ce6dbd7aace6ba7387adfcce9c4b1dd2ce5e16cea5999d9f5b1c982ee187a3020100f9c3bb8c940693d4e0c2450df5a85a36c4d6859dd806fcb85769ed1121ace8e32d25c8feb636861f20ce241b4944d3cdb0fced5f147aadcfe1094d284cc6dac60248638f397b215ffe063914389948123f24e1db37aba40669b90052fab7ecc851111996f1101da40cf5f42e35b379594ef402e20411a701745d8514d4f2ee397a086344e28a2ce6577ba5f1d106466ab122dbb39eefc00b938fc48e1ed3b432c2d522e42a4b9a2e525556dc809f1af7e9ddbacf16200c95e7c76aa96feedb1b926f457a90ef4e7e6879e0d2d81b7c095f50ee4ac57410d324d0e29278dc80bf75f285ffce3bace1cd029ac8906e9f0cab1fbc5c1e4df86b20cc65c4701bf4372bd7e3ecc03cd4b51d2c01c5b036ccaecacdf005e3037c4241a96ae7f2f51aa891da5654c229fccbbf6156e2d40e0dfdd03e686fde47639b7276c891f02f56b480a7f809b95e3018a121790ebc0c03bd190b6163908cd87366e9cff0686f28a1a61a92a84b9456e1461524ebd2f823372649c6b2ff1f7a5122fd8de64cf33ba441fb78b79799b066dd26f1896db4ba3defcdbf33baed9e232bb8a5bdf08d069acf33278e41c3d600be11ed8fa7c327b8d2acc1a17a8acecaf6b648d7c8e6a67fe8899d67bc776498b03a522da12a7cd0a56c516aab545371b35fdedab2223555fab3fbdfbaea3bc034266e877c186feb627c067e5053b591472437714228a65d4056248c11b6a97c987a40e1f2bebf64b6fd7a70266680f005e8f357f23ab72bf7ae2b2e3cf17d1a11df60d47a84ffcb23ea9a4b5bc5865b6280296584af058be62d9954d3d9f7e2b19f8c6adc9cd63d8f7a629e9c87571fa396bfaab5feffa6a7878b38690ed096a040fa53638e4d40df62398f10d45ba7aeda23e01bb3d4309d84d20791e3ea5c88501dba4db395bcd91c4e00b364ea9ab7c1738242b7e9142f7ccf82e53cede8ffc1264c576be342bd49644cb9f6838e4da4385743fcbce4860bdf3b927d4fcfe9519e5c049883832f0880737f3a740d569a6ca8c562c11315820489f5b6902a7d8b6211088a5ed2c66f3d41919264e02b037cd7181e888d228414f1be7ec2291a490844796e1452af3ddd6cadb2c507300fd2a1317ffc844368cadb095a43028de55e42598fef468d0b4f65ffd1acb62923716dda5b0dd70b62643ba4b26f5bd7ce057c077da3887dee3557bac35e6a1ecb5d82a14f660829c2295cbbe39f452464d16a37c1f7fc0db2821795c069f1fe48502551caa1a67b466f548b2dd411b09a833594d42f82cf9540f5ff0b5d30520bded186942298e05cf9778f7ab6bc46fd9d74d8908217a076eee3ce5efc4b47a66eb1fcdee3f893f081ac4dc61ae3bf3103a693f9fc6fba64f094cf98e691144d95907fe53b26d7dc22361ed5369c694fa4267907d1348d8e493b7785efd309bce1f85a32c33a95dcfbe3605dd010f22dfbd38f845913b8d3a008002bbd90f007b021d57690e31420f7f14b2d2d341c3bf4ed9df4e14e61a9a91c1644344cd9c75a64210cfe46a9affc204f68ace4accf28309761465bca5aaef9433e23b45e40dfde080f9b63e5ea8509e82ad165e4b1acf7b5c5437b37c77c4535e92a1a46fa2436a9179a2bae0884858592abddae88dbbd96a55a06f0fa834b01af7d40afa59dd08f0a73ae854287c241fe2cb578d1d50f273265fa17c77ad814a1d5644b9ea2c5c73988908f8e08b4cfc3e2e199b2359b807157679f59a354c4860eb6af1f571b70e300d3b5ba88c7a27953af196e02cf9b45982129d1fbfadada3ba69a754fc00c44e691e6818d6d9f069e19bef32ae8b92eb61adbee9aed82b1c1d7e07876838031ec69258799b01071954f141b09e530a40ed1aed9853a09bd46ff10c322be6184d97913edcc85d4b806d7e4ae5106a14f4aaff7a48e163ca1c7dfc105ff4f812a4d66524c6f8428d1f44ad3a6684299dd88f4c4282639e18c8eb85d0510f650974e29d6b94e86861ead2efd59b5ac8c3e60b3d52352b1e91864b55b0e51ab63aee5dfb1ecf03dcef4ddbc0d2f5830c75dca58614c388bbcf968bc00bff3f9f2697cd895a4a693a4b788e69464f42ade388e7b6cfdb50a58f1180a1eb841dc11f9635b1d82b459532cf8a9f37135b35d241cddaa0f165d97fdab0efced0499edec50f5565f5a10decfdab7c7e45c11f90772f98cef5ee133c9692a22aaffd4baf93eeceec781470bc7bfe5fbe6c2a4cf22ced7a6c4075f62dee444b020a8c766d3ee843243ece4c21c54b225105890d3f502282f3b1248d869f3eae50a1401cf52e747aaf56c048e83be31bae23ebd79e3960cd861d11c766f493cd45871a8a08fe35c0fc09a426e5d54d6ff4808b6b55a68a419ef151ee8dd25f12e7bfece13762eb122e395a268c71e9d4c77a8e109677eb8ea9efeeb0bf1b0995ff37c342627c60f03c10ce8af7976f6108007af72995ac59e03f9f05b704f7198322560b157cabaf86699dac8df47f41774c075b0119ae9813423136a11a6f3b58bd38a2ffecbde278b684bf1d78376be06563cd3043ac10f615d19619b65e4c8bfb32b610dfd8ae14d615ac0f0c47821a568eb7bf6eb1ccaeaa2cbc6f2c201b8d07f768fbad69a67bae2081c886888744606b47acb5509403512ac8338aaf512c2fc5a46adbaa9c33bf96bd712abe0fc8d19fd0fc90ca93faac7791909f3238d97382a9b166701b6efd39445cd6d3c162d38c52aa91478ac67f5ac917afd176f9d1aaa8349ce044d4f5963dfb6c39aed41438ae80fd35a112279d5b5751a5743019f9d5862e3453e3e3badffbd133c2c3d568cfc1adadb748f03a0999d86de79ab3af6c260001f3869eaaf3dd0bf64603a2c0753654815eb6ecd9d0c349ddddf7576d8ee441d0a5e4a254bc92f8945a009e6327719d54d5ef25b04e46c7d55fff0d2cb83b26532a85b7b6a4863e5e061c947b0923af3d1e91aab73ac945dee442c9e3dcd1d18cf828de1c7c56648aafc081624f055b1c7c1d092c0bfee7773272325a2ffb558c875a9af51e8aaf964f1c26abf74b32f1f876c29591de61ef4f0326403148c23c9c0b4815a8d2367a14e27ac791dcc7d3260b84584b1f2bbfeab5fae08296b5b21e38dd86b04f3048d7e914ece513675a2ba0ad711439cf07a4d0df61dea08691b7b738aaaa277d448c5f5bbca42d49a2bad2acd54ff4235c08f92a1a6dbae5f2019480dd5fa2c37b51cfa4a03472c36970ce99e32a433546c46a225a042a64a9cffc0cf033b91f1a6a1e781323d90613ba0f5a86f67cf7ad5c591eb390abfdd53fcbd390f9fab7d48b555624737bd0764c9206e85a8a4ba747e5e9c7433720b7f51dcba7f6b134e709acbf23e0fd6bbc7bee255c4a9fb5d48e2064ff82aaf76b9f41e1f881ec80048c2e9795386b635b8eb819ee66a7dbd7c24b8f80ef450dcbb963ae5beda3ff297fa34e2d639797774740276b8ed9c7c068150a6f242edd8abba4ad3cf1661033149a93d00ed7d99327840bf40cd03458e7066ad1e125b10207fcb156a1981984679808064ebce359a7711197a44862300e07a2c0a8df3c852c897d16e35d841c38c83e448d58f9e20e174248c4734e9cdb04248580f138b0871982382279b92b31b497919f9a107ea9834542993d1f9b3b601b089440c55bffcf77178f92ceb476256c718f4892413f91c90016424e280229d842d9a74d3f72b579badd47583ef033152f6fda2980f24558ee65f227467e42fa4197698f40f9c49b61965a9ae185e48c7a4f5367beea41f5d5108134bdc8cee8c444b250cc680109ee0964d080e41f50f9270527e95731081f0989d86c47a1f43e44cb93d9ebe8f6af848624202f64e8e8bd9f50e0ad5e8b7e42b14e98882eeb63c117810a5295cfa7ba3a09d0e246322ab06b2e4b87ac4079a69719150905ce8098b95fb50bff775c918f015801fe835a3823eaca8081a49e359c00783a5bec41b7fa08ba673770bb25f89d74d9c9e4033186d2657ca3a66b87227fe47f2fb92f79c96f17113cec249ad24dfb571b716f7aae49891de0d2025a4a92084f0f395c7b42caa0da4ed01a10a3b7615453bb0af3d799e72f3ee26a7bfb60b204fc53cb8faba7dfc8c221d2133c0c53466dabd00093585f85682df3d8b09a60b5ff4635613a0b8643a51bcd514f94001aed37341cee9d0ad8c6bf1dfe268b625e7b196d013bd04dd7d550e56878fb3e37d02b8d655472dbc875e3109b0c3f3c820fafafc2b988d67e6e1af4116e6948460d3c98f74cfb044b3a46b47264b4378a8e7bb3bff71f3e68af4410a0e81d2ff6d275ce9ee6bccb0b344d0eb24985fdbee7a4c321647a10715138837b73155da11f982772959c286f1e87ac825d6d7f64072cf794f1084bd659c41a25ecd23b7f4060f644efc506b7e7f4a016d2385b1a17d9a8c5af613b78058b1aee408085fdbb4e0274b3b3c234e2dd8e5c3f2b8bf06a431c5fdde418317d6116c6a57208cfd657b166ccc0005b76a34808f038c58158e3d2b5fe7e090cd9080e0a8a301b39b1f9f413306bbb8a6f8dac4c2a2fcb85f5dc09f333b424df6c3674fbf5d162c967e6042b9efd97682fbcebad272c4a3b6e348af879c85bf510b77dfcd7413bdf13dc6963d4322ece4e0db3fcc42221e3e1cfb50bc9f00dcbeec8ee2202846dac575cfd914ff509bb4e86009149f6dbcb7aff4478c19b04e41810952b7e779fb9aa7bd34a569b877494e766122fa10baba6f38de1fa929df00a9d8e1ef5bc9aa8d0e702bbbf9cf05278716f64117f279b30bc1a4c05c9a832fea1967bc692883f3ac82bfa1e0fa4cd08d580b06a69cd22cf354f8218e790fe925587114eef59ee5291df858ff81b414c5b26b5b74c7542fe2289f9039487c917a3e693cdb70e84e41fe5d13ad1f0801dcd7fe28a81455bc79816b9a9c0cc8526f882e00b17d663aaafb7f2b9d86d5ec9644d4f7d2d828fb92e29cafc2271368efc7845e8629bd23a12f34aa0505ee91252d08f05716d0fb319e9f2b32a030f2451c3a0e433c141ce75602e8caea2dbeb30de56ffeee5fa50c10096ce1c01a209b0bfe90740a53d9a6b4cf053813adc241c87ec26055068b6b5e3592b348a363779586b76a6c60d07db53dded7a1599c9b0c56c3ecfff6c9e1c80c4e0cf41dcc8ae7cb73c57414f63fe69a1a9de6b628c58fe470bcd9c5c7767f7400691fc3db6c81aa0f56093aba02b7e159c25823247b36cd43c95970dda914b703e81ffc1c3f295b9fe16b03a6aec3514355714eef9ec59f9cb38679effa2593b544fb4748bddb15657e97a0c362837c19c4df23f4db99e498df8c7e41fb837e22ed914abd9164b2e66da870044bb683b5eb2e9ea285d3a42ea7d904078bd9e388f8bfd67e26b0ce95bc279b53ac9886f7a802293b867a60f710f25032e4f74ff6519e0fb2b81ea98768078b1b0363e326ff705dc3fe9c1e493b782cdd18be4cdbf890d8b953e5c60f5372a6de34316c9e9a5a92882e7b5a8fe71df598c190571fa62cf1f9f5b9830e94e4772c9e843c101464a8a17ac67909fbf1c54acbfece8d2b64ad414e9c5336e403953957f908c7d067d05d7ef9a99e6ba744271d9d8b79c080d66d555f278d19c4a2b385066dacaee2014c4e8d674b6d8a2213c9c0a153d9c41bd5cfa36efddcf1f2e7c9404d97708ff0096c7f9d166955f7fba8631a764a407f4299a3f6a529db36fea82e4fb222fd27256c59e472363a7d21d44baff2def3e6e384ae232fd1fd1843523a19e64b718d78761ca7e4fa5d90f20399072313d6113828243a6df6f16dbb9a75aea032baa968fc6b0439d88ba637dd01c8baebabcfb30ce4f869ecd3de557744d5ee6daf139b79789d784bbabc8da0ccdd7b11552d0bad102294f5f58328c4c63e7e1cdfe0499f33ff5e41af280e6f2f6fc493becf5ccaba11c6fb5d1cc254bfc77f170ae698ff202102c672cf3b265767e155b2199e2dae9d4e50161f0f84cb84cfb27d33631e2bc3eb9d47ecf91128b4fb156299c9a897649d65141e0aee74db113312238f4190bfc3f0904e3bea5cff1efce8cf8e1242d3f58f48f5d7f3c24ceb398819be535097fecbe4d8224ee8295e1cc1b3c29b755757df757a8865b4670e20b9f248e94fcd86cb637a622b3d05c2dc206dacc17d6c7fc7d725aab94c26a39da01b72c0e5970a85e7c5033c7540a8cfa5aebc767d72b1f4e27b0da0ea05b4bceefd9ee1ed9761349f447117b97e3a98b7c6d4bc04bcc66df739dd7adc9396e55e3452999390e965d286c102470861494e748a245d00f98530cacc4a7ac43a504309c8b43949bb380de6c10be76f1c86918f48ffdb5175d28f9d925e37c339c39c9682ab0be743ab7daec5ab3a15869db9cb60fff3bd033659454fa651e3fc1a9d4800789124689c037b9e61aee23401c25dde1d79be50acf62c1947d5c8cf8f49fd49bf1ad8c42fa709b899d6c9d1f391687c0e14f721e05481c35814d08c15fbabc5c62a8d60dce6518c598ee5c35e4d065214beb44158f215b345136ccbe49a181c0f503ba3a42add354911ab67f51fdf66a09f53c1d49ad2a841675f2448ad8e59f7c1b052f03a7250c869ca27db2208b94abfc303c45469579a31fff185d3d8a919829c6006a7d600a7a1903f851844abb7be380098657295c56f05d90660646a405b95aa87fbd2371c6d02eea9486e9e31aa8fcde8706eb73b2edb091532a75362025ba4b6b52805e41ce9e4edb01db89d54683d47dc520312517e5f092b1663c3aced158a97ec349884ac630c8e4e1f292f74013137585d3db2abc757140b158bce500fc4ccbdc62f7b4f04b981613a72ac24f87faa67b9a438f182b68b2ccb667ec7646cdf84bb8447bb07be3b4158a59b3330022266d6caf90611be428ad13fe3ecb89f10e1b7a94059afb081b71f1db65b770e81cf1e9fd76d33301f0c6af3a4ad989bb51c93484a1c653b31ffd3cd0ab326817abf089e5d98d4774d4b1725832a57ee8187591c76fe2519dd39ea92d457d12bedea6f488a9c59660a5471926012b2a90c0d2712983f5cbf6fd5e539440bc19ca1b81d35aa9616a5c9ed272ce689d21acf435460f2ffbe638c65e5a61a88a1982707ffc628a93c31afa535f323afad10e02c15393a0da43e3f4d3e67802bc5a8993e4d952b7a7897bd0bd37e38298be26eb30dc2e8db34cea3c21e5931733763d09e7831ea3d2751ebe538c50e3a4b34e43a5b618cb7c4697265595f16ea65eb1dcaca715062722b16d1c99d71342518586ff7d57bccf60a2759b89132698275fa2dbe68e3303886196afd05de57f086d2d3313e4b6202318e0820e47a9d470dac4181a044395956f796ac9bbd24f5a6f5795f167971c7989abcbf1b6738bae63baf0b2bdc9f1c1c9ef9ed73b3281f25064da6947523307786e15c7058973df6674f40f5d4b207fda14aeb3ec8b02a290f3341d71e4285afef35dc9b3a9640413133ee3c4dafaec1a35e5dd97db4556ff63643cd05bd69df8797e62d672207055544564fb368c4532ef06dd95575fbe86112c76231957df88b28c2569278b2effbe8ae8f193cf695c4c39b3e613b22488888a17cc533a37b7c3e531327d297227032f7cfc6ca077bfa709a1ebb95797c1518388ac9bd4ba4452a4b5c0d9af771828bc1febcbf2835094a1350bf6c6fac66c58c551d56d6f9145a42c09f07922303118ed1a4e62adf601c5346a3e664ef8583c69e4ef1f35697de4e9a17a18a6da6f76096f0799213df605e0b54370787f5faa9278ff1971abc79435ef27a7b1028e35aa330d74f71541a39f709ba5ccdf321645b15888ee89bfa1ed1c2e529295188589cf97c5cd5a46a650647a7f6ccec247eb1e9648fd114b17cab0c3daa14ad2395e765a6d3782520516ae39a169ce8ef5f6cbb5b9bfdec28e9e6e278077185b81e21ceacd0a0a4ddf0d50aabe3311ef5a0e7d86d7075f3cf850db845b786ec8a75fe28be083ccab699c7b4140e08f42e1ae52fd06014e308cfccf39e2572179928fd65429b9e7143e699ac021c37de85cc918bf2635e80907c56bb354b7444ff51e0f40354a9b72481154b2b135be78fd571ca4e0101933af95b8e4d95ac6ee3e9e9df11883675eb719cbb15d4b195d0a2f81a4b1ca5bd268b6ee22e3eec56974ca9996a1687c4749eec25efd2de5fdc88dfb4a31f2f831366910f268ceb48792bd22706cbeb508790c42348f6a7b163ee632898ca9edb9b7d226c7aa6f5c02c08fde41c949f8cbb7ca079891dcefb57a179a9ff2ba77ba4da3da9c2ad38671d3c2d409980a76686c30ad2be9068e0d82d5c9f5b1abeaf836a98da792a63bd70f4c26a62b17303e0725ced965977cf0fe893ca1318b6e47b097a9250448ddd5309b64b249d291c2bfb082972aff474aa5eb77a60bf9a5e07b3e0c008a6b834f8bfd60683f29b9c13ba07299866f8fa08cb528445057e12568347ecf58f81c117a265dd8d5a47ce82d336de04fce8cfa612bb88dbea09437782b54e478ac9e7763ed51ec1101cd387853d331b23dbc12df186998975d4fea94e10dcd0b0277d2ece7434913da357cfe924e83298ef31e852457a9c31bc3ea0251f60f78c99489c468666fee9ff80ea3988fc692228cb500a2d380e1552cda1966bbfae202b51e8194c38ab17a3ecd3a4732fd1682574201fbd83107a11d5fdaf589c66467b6d079699eb8061ff0a34b8882969a004a39faeb356f0263270f37d0ab5a194f9b634bf0a8b9f922003ce33e2bbaf0675dab3343bd4bb4faed5b1c2960776bcd759d374a9e751521e1cbe64c9c3c97b2ae6e20b26573d97d1d0ccffd51fd7dc6618a9c9483c8838bca1c0253388b0a49adf9f01aeb258e759697f4d14293f4b5a81ea3eadbea48a4b8a539fb236ab53bf37b295fe5f9a51224d15eb562ac9bc1825d58aba93946c37e5e48ee6b6121438e932322442f7645d1d7065afbaa9168ada07328b42027f3792667aa5df3b7be606d810ed7dcce1452847f849d21104d81907f7c76aed0df04ae2b92cb346b9e468e96ddf3067d50ac2c48eac934751d7baec2a8afa1281e455b62d6d139e39f000d0e79d4c360abb8ce68c44df56decf92466b3f4bfc5a46cb711d15b8b38bb111458f75f41ddea00c536935185f866da538f7a6461c2e70d0a6f39649685ecd1bb5446cb33292c3dd015b1657326b7921e4c9ee04d79b206e5297a2d8577f8743dbb5a90227fbee5e29cee206e0b65ee91c7827377f7d78a02f03fb6e03680722ab454a101ad7bdfdccc81844fd76ae4942dfdd8ad433f00020261641aef7d7e627b4b604ba2fb84fe336a4a1e7250524a84b3428fac8151052d5efb5058e33d648c73c946fbfc4a2f63fe4943eff67b64ae4fa8dcaebc8a8b8b6cf699d8b67995949fbda0156942c572f0e9230992709653a5016cbedfe47e613fc3d51e0396920cb579d987580dd48fdb563054d2378fba73bb9c2c570e306db4d3e7a80d282dbe0d68d31cefa7978ee44210e718eb9beb3b8aec4e5c2b8dfe55d19cf41e97f3a0177736a2188bb7fe170cfc7e76747625596b31b8055a91f18de65171bdaebd36fad94ffaad18923dacd024546de4118b96dbf2821d0720642623fe291aa8b6a05c39e86342092f8dbe1a45c8424d3d496fc2ef60f20ab7d051b5a1f1ce695595ee429899e77149f1519dae8cf8a0fa6a0298b3a33893f0c5373ff111117a8e0ed90122e4be1f2357b48063b5e1839ba447047620b854f08f3a30fd11857edace2c14698be17226608f5a6ae59faeec10625b13f8dfcd33e23db588f8e4bf1360af93b6c32d4685ecc90e71f4b7d2e6bc36ccb8affc9e7646d7ab537c7ff5cb164966a8f580010f56d90927c15c0793e72807e0e60fa95a4da62d80758ba3baa1bf568fcbbcbd96d09776f7f8015027c5b8fc0d1d14f6a06e86a2e3a095b7c2fb245e2858509dbf41d13ea1a30ff6929a62bd7f4a887446b4a907188c5ef5aec9a34d311f34571659e6cf211cc8e20aa55d70161c76087763b01d1c0e68b124ac5b9d3978f2d9b10f744dd51176415bed1111ba718429f1935c73314132c81720d4635c508bbe501fcbb1a5494117570f3368a91ddea5c97199e3849987c9720df56abba52189550044fd5f34a6d9e76fc13d279ba187b9356adfedd88170e04c2764d12ee85cae8dc553e20aba37d4ed01a014a642fde3abd37516349d8c88d4c836e69edc72e0006d3a28570f891e901a3c2720cce5f8c99a02c12402075c27fc7f1ddd49cd2e857a07b0832eafb59f757365f81729118c5aa2c39d8a8c207e1fe24f63f72d92247fa15145dc92e6397a0a83fc311e7638df49880f594fe27cab4898bbb5b8aa4e75dbe0d62978d04073dad79c1d245fd29622e6a9260d5508113050b07db5d09e427179b66c4290698995fd8d18934d1bac2ec68498a9134f268805b69448d49ed5864997188f3ae1d4e713d982132ede07a9f2a7339c91bcac44aaac2e84072fa8229db53f7109ad41e64b26dd1c1056d3952ed7d9a76ee545c468990dc453e64d00d912372ab1651c5301cd45361687c551a4f25015e65714e5e352b2fc1fe372cb438233f7f7b9c9b5339af53d500bcd565f1a764d2f95ef265cc52ecb3d5fde4b374a46e6e441d8bafac1e31d299c3490b518ee90b6402f55983045ee4b2d6fc8884e19c944f58df93dd146b69864f09a7695fe06c9d903de2f278b12d8aba440e0c2fb7430d830f90260a0bfb38793d78d1cc69174453f0df0a3a606851c8b6120a1d76297996677979a65bd655c22fcf094045e7d847e35a9b818cc1c2f59b87200371588c1f2432c197333798b164ad6cf55770402fdf263e3f6ff2254e9697770923bd0d2ae01aa22a51f00c49e8076e50ba2fac33af63b3ef41e399f1ab9a0acb36dee7362c99593f74af23c27038e901acea0a4c41fef99a56e2ff51ea1a20a3446e4a219b30bd826ab3c67d0a3e12066817df346fba9fd936a9d1c55396af92561ad8e830394e27c49d5901c27258e7428629bbd06d832276a5fe1641b4a724e2d4e1fdb90d06d4f1126a979af8c3458fc1b3556ed79c6c523f858daebe974f681a9e3281f3ec501a0d1a3c056ca52262c341c77986ab215362e971400a1a973ec5392305765dfef83b8e64bac17b6582f3ec614289bf9f29215b366a8152b529fec447a6825b5785dd51fa97f234e92594b83f8020539c465a27a7172e028217cd4fe0344ab7085f1db243b63598d31ac104ee154a08847ecdb3ffc3c3ce7c2594db78e529d8c95bf6398b187787c0effb9ffac05b5efce1bbc604095a03584d6d212ea7b1da562af577b1ffa54e84f0eca1409eb50c68813051e810a77b1dec64c80599d572ada0093bb00b13b4ecd0480af6dbd0ab46460bbd3eb65c2d01cd27d6c5965297a3542e5a578eadbd060a35de5f4c299cb7f34b214ec813b2862db83be026bcf52c2b5c46b4fba5bebadd2fdb42f547afd574642bd68eac783885f228d9368749f2801ab680ee1f10a480ce187712dde2d49310c5406194b2f8a96398fd2d58f56838a0669769038ce2e79c16d100563560186ab353df3c4ddb63f17343ad620442ff4ff2f125b30523d9727a1735fb6506b96b0c68ea9399ed63c9ea22bb5dfa0bf654aa261e7cff93497d93897f969e8a39c3a9d96906e8a432470ff0d31c8dc24ac467195842c0fb00a0fca6b111c698aeecf1e42e0c34406fb06ec4561ccd21c6ce9a36e052ec9c1375de3a5c93741d5c3bd34429dd631f57626e814b0c5e18d3175c857f9c12680c944b36a2e3e3c82285f88f1a0b0f5aca97cc278cbca2a6641d22da3a47660c494ced89ff95c9cbf51dd0be02040c151ee726c642b74c9cf0e77f5d72bee99d830dab36b158283a342fa47bda217e9b72cb415243f1ebbcba47005f8069d265bd03672a91de0e27b058ae6bd5fa5ce 我曾告诉一些人这个密码（","link":"/2021/09/27/Dream-2021926/"},{"title":"Heriko Deltana&#39;s Social Behavior Note","text":"社会行为实录。 Heriko Deltana’s Social Behavior Note，即 Heriko Deltana 的社会行为实录，其实大约就是一个日记之类的什么东西。 记忆最深的日记是 LSP 的焚燃指间の回忆和 SZT 的梦回还 名字看起来都很有文艺范的样子，所以我来整一个反其道而行之的东西：《社会行为记录》，以此来彰显 HD 同学是社会学天才。 2022.3.24学校这个网给我整无语了真的，你 LC** 吃枣药丸。 2022.3.23今天是世界小狗日好像（ 学校开始实名上网……无语 2022.3.22这玩意是真给我整无语了，最近 Github 难以访问可还行，push 不上去。。 整了好长时间终于整上去了。。。 我的评价是：抽象。 2022.3.21窝法一二带回，冠宇首秀拿分，红牛颗粒无收，老汉再度登台，法家阵营起飞，梅奔阵营提前备战 2023，好时代，来临了！ 我真的高兴坏了真的真的真的真的真的真的真的真的真的真的真的真的真的真的真的真的真的真的 法拉利阵营整体起飞！！ 本来我昨天晚上光看了起步，一看阿罗两位都晕厥（ 本来觉得能回到排位位置就好了，今天早上一起来就看到周冠宇是 P10！ 附，某两位铁佛寺： [保留]绝顶我为峰 2022/3/21 0:45:55窝法一二带回了啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊 [保留]绝顶我为峰 2022/3/21 0:46:00周冠宇拿积分了啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊 [保留]绝顶我为峰 2022/3/21 0:46:04过年了啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊 [保留]绝顶我为峰 2022/3/21 0:46:06【庆祝】 25時、コードを書く 2022/3/21 16:50:38好时代来临了！ 25時、コードを書く 2022/3/21 16:50:39窝法一二带回，冠宇首秀拿分，红牛颗粒无收，老汉再度登台，法家阵营起飞，梅奔阵营提前备战 2023，好时代，来临了（x） 25時、コードを書く 2022/3/21 16:50:49真的过年 [保留]绝顶我为峰 2022/3/21 16:50:57【庆祝】 25時、コードを書く 2022/3/21 16:51:07高兴坏了真的 25時、コードを書く 2022/3/21 16:51:31我因为今天要五点二十起床 25時、コードを書く 2022/3/21 16:51:34昨天晚上就没看 25時、コードを書く 2022/3/21 16:51:37光看了发车 25時、コードを書く 2022/3/21 16:51:50看着冠宇起步掉到20，觉得有点危 25時、コードを書く 2022/3/21 16:52:08但是就我过了一会发现冠宇超到 15 25時、コードを書く 2022/3/21 16:52:34然后我上床就祝愿冠宇和77能保持排位成绩 25時、コードを書く 2022/3/21 16:52:45法拉利双台 25時、コードを書く 2022/3/21 16:52:50今天早上起来一看 [保留]绝顶我为峰 2022/3/21 16:52:56【狂笑】 25時、コードを書く 2022/3/21 16:53:01爽飞了 以及，刚才有一架 737 失联了…… 希望能有奇迹🙏 2022.3.20早上起来看见 LEC 夺杆，真的，高兴坏了（ Forza Ferrari 然后把今天 QQ 空间的东西搬过来： 某个屑 B 因为不想现在开电脑所以就过会再扔博客里吧。简单来说，生日以来的这这两周是我 20.9 以来最开心的一段时间。希望能延续好心情（（顺便提一句日推真有你的。。我都忘了要找这首，你主动给我推了）因为比较菜听日语做不到听英语的水平，所以经常去翻歌词。逐渐的就喜欢上翻歌词，因为真的有许多术曲的歌词让我很有同感。（然而并不是专指什么厌弃自己淡漠世界的歌词，但是变故总是会让我和它们走近。嘛，不过，现在好多了嘛。）因为脑袋里记的东西一向比较奇怪，好多东西都是连在一起一串起来一堆的水准，所以会发生各种奇怪的遐想和梦境。（其实好像上了初三以来还没有没梦睡一次的。。）（等一个无梦之梦（x））哦好像某种意义上来讲，无梦之梦是我今年入坑之前最喜欢的一首术曲。（然而屑 B 网易云要 VIP）济南没有春秋所以随着气温升高是不是可以期待夏了。作为 IA 推（）然而感悟一通，随着脑袋瞎想瞎写，我发现我还有一个问题找不到答案。我啥时候能知道咋学习？（……毕竟学习好了才能完成生日愿望的某一条）好，我宣布某个谜语人又开始了。读自己之前写的东西，就很容易读不懂……因为写的实在是太迷离了。尤其是越对公众开放的东西越谜语。。某些在博客角落藏着的东西……他也很谜语。这就不是一个良性循环，因为我记东西比较连锁，可能就拽出来一堆之前的事情。不喜欢回顾初三之前的事情，因为现在就觉得人傻没做不出什么对的事。然而初三上学期，和高一上学期的回忆一个比一个寄，本身性格比较脆就可能直接手把手借之前的刀把自己再干碎一次（）不过某种意义上来讲，通过去年，我好像更知道我了。但是可能我的像太宽而淡了，就像是找到了自己在世界的哪个位置，但是找&gt; 不到自己在哪。不是……我是有病吧写这么一堆乱七八糟的东西。但是我是真的懒得开电脑（） 2022.3.19今天早上挺有意思，SKP 说我五点多一点开始在床上笑，然后就把全宿舍人整醒了（ 问题是我把他们笑醒了我没醒（（ 我起来之后怎么都想不起来为啥会笑，我梦里明明梦见 yym 拿着菜刀在宿舍追杀我和别人来着（？ 回家之后浅浅试了一下糖豆人和战舰世界（感觉还行 然后开着 20 年周冠宇的车挑战了一下 90 难度的 AI 跑河内，发现其实超车没啥难度（ 好奇怪我玩生涯的时候 AI 开 81 排位赛速度都不是很好（相对队友），但是 F2 正赛连着两次三段刷紫（ 好像我确实也是正赛节奏比较稳，排位纯靠天意（ 下回试试 95 AI，跑河内（不得不说这赛道是真恶心人，到底谁想出来的！） 2022.3.18我的想法是，要不然单独开一个写（ 但是今天还是先把之前博客里一些非学术的东西搬一搬。 2022.3.17终于有机会写一点东西了吗（ 笑死又没时间了，每天一个小时做个题都不够的（ 2022.3.16我是锅王，四道题的比赛锅三道，有两道是因为我，tnnd. HelloWorld2022 出假了，我对不起绊爱。。 2022.3.13昨天晚上把 HelloWorld2022 的三削版写完了，今天早上造了数据，于是乎给学弟学妹的题大约就剩下最后一道了。 但是这道我没啥想法（ 最后是把去年 Aik T1 搬来了，重设了一下题面。 但是不知道什么时候才能让他们做这道题呢……今天已经不够四个小时了（ 我发现我出题特点就是题目背景瞎糊一堆，然后题贼简单。 今天猫夸头像结束了长达九个月的服役，大概是我初中以来用过时间最长的头像了。 换掉的原因有两点，第一点是我个人逐渐不再看 VTB/VUP 了，第二点是即使 Aqua 虽然在最后的 Hololive 事件上并没有如哈卡哈卡吗和煌虫那么负面，但是毕竟还是有过各种事情吧，然后就换了。 （找理由） 可以看到的是现在换成了 knd，呜呜我的奏宝（ 2022.3.12今天去打 THUPC 初赛，当然是没想着晋级，因为菜。 目标是我们队能有题就好。 最后的结果就是做出来 K，A 和 D 差点，果真还是菜。 早上忘了买吃的，中午没吃东西（ 今天去萌娘百科看了 mzk 的经历啥的，发现你 sega 是真会写 25h，四个人各种戳我（ 虽然我是 knd 推，但是对 mzk 好像感悟更多欸（不是伪娘这一点 2022.3.11今天想了想，又改成了 Heriko Deltana’s Social Behavior Note（ 什么是架空世界啊（谜语人笑） 有道这个翻译我属实看不懂： 宵崎奏 → Night battery play 2022.3.10今天发现 16 岁以来每一天都挺……（ 有点担心之后。 2022.3.939日快乐（ 上午第三节课课间开始戴着 leo/need 的 miku 徽章，然后小明带着 leo/need 的 luka 徽章（ 然后我戴到下午实在社牛不了了（ [INFO] - 2022/03/09 17:00:35 - nmdlasd:我自己带逮捕证 [INFO] - 2022/03/09 17:00:40 - nmdlasd:*带不正 [INFO] - 2022/03/09 17:12:26 - nmdlasd:然后就带不上去了 [INFO] - 2022/03/09 17:12:38 - nmdlasd:主要是这玩意和校徽一样大 [INFO] - 2022/03/09 17:12:51 - nmdlasd:我就把它挂在领子上 [INFO] - 2022/03/09 17:12:56 - nmdlasd:结果感觉很奇怪 [INFO] - 2022/03/09 17:13:19 - nmdlasd:但是如果和校徽放在一起更加离谱的样子 [INFO] - 2022/03/09 17:13:30 - nmdlasd:所以最好的方式是盖住校徽/kx [INFO] - 2022/03/09 17:13:37 - nmdlasd:但是那样更会被干 后续：昨天一直戴到回家。 deco 新专辑 suki！ 2022.3.8发现随着某些事情越来越好，精神状态有很大恢复（ 我发现我就是巨大谜语人（ 2022.3.7没想到今天这么好（各种意义上 2022.3.5又要从昨天晚上说起了。 因为难得的大于一天的假期，小明说要周末一起出去打 mai（ 因为开学故意考砸，所以不是很敢和妈妈说来着（ 但是没想到同意了（ 然后今天上午就可以第二次去 mai 了，这次除了 mfj 和小明还有妈沫（ 最一开始是我和小明一个机子，mfj 和妈沫一个机子，但是因为是周六，来的人还是比上次去多的，因为太菜了不敢占机子就让了一个机子（ 最一开始找不太到感觉，后来就开始有感觉的糊（ mfj 最一开始形容我打 mai 宛若逛大街，后来我也学会了快乐糊（ 然后用着妈沫的号怒干用着 mfj 号的小明（中间 mfj 和妈沫打累了我俩就直接上了） 再加上后面 mfj 用妈沫的号怒干用着 mfj 号的小明，所以妈沫的记录上估计就有了五连干 mfj（ 话说我用自己号最一开始干不过小明来着，属于是不用别人号不会玩了（ 然后我和小明累了就带着小明去玩了一下湾岸（？ 然后因为下午要上课就提前走了，没能和生物的人去吃火锅（ 要不然我可能重现蛋饺事件（见 2021.1.20 Sec2 2022.3.4十六了，HD 生日快乐（ 班里各位是 真 会 送 东 西（ 怒提 45 包餐巾纸，虽然不知道送我这干啥（ 2022.3.3写了好多天的十六巨献终于写完了（ 因为明天不来机房了，不知道还碰不碰得电脑，于是把 3.4 的日记提前写上（ 2022.3.1今天阳历生日欸，虽然我不过就是了（ 青柠起始页的这个小细节suki 今天信息课被拉来拉去（草） 今天信息课和小明看了好多东西，毕竟在学校呆了两周多了她啥都没看（ 2022.2.28学弟学妹机房氛围真™好。 2022.2.26绊爱 HelloWorld2022 相关 18：08 开始倒计时。 18：11 开始。 18：13 老爱入场（） 我真的好想看视频，但是机房真的蛋疼。。 只能先听声了/ll 希望我能听懂一两句话吧，剩下的只能回家看了/ll 最一开始好像是英文 Hello My World，开场主题曲挺好（ 平常英语没少听，这次派上用场了终于呜呜，能听懂居然（ “米娜！” 老爱还是傻笑啊ww，呜呜 果然还是五岁小孩（x） 声音变了好像是黑爱出来了（ 草为什么会自己暂停/fn 现在纯靠我脑子想象呜呜。 没事，能听着也好（ 她在笑啊，在笑啊，呜呜 好高兴啊，但是…… 傻笑还是傻笑（） 呜呜好好听吧（ 无意之间居然听了一个小时了（） 可恶，zj 居然可以用手机看/fn AIAIAI！ -19：12 好多人都来了！ 都来给元老送别呐（） CEVIO AI!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 这是今天晚上最好的消息！！！！！！！！！！！！！！！！！！ 之前看见民间有人做绊爱音库，现在有官方了呜呜 另一种形式留下来了呐，这啥今天晚上最好的消息了！ 本来是要和小明一块看来着，但是发现学校条件不太允许，就我自己听了（ 她要是和我一块看，也会像是和我一样在机房直接喊出来一个“卧槽”吧应该（ 想买 CEVIO AI 了（ 草，我还以为结束了，刚才（ –19：32 呜呜，她哭了，她哭了，她哭了，她哭了…… 我也想哭啊…… “哦嗨呦，哦嗨呦，Good Moring，Hello，Hello，Hello” 我看见后面这么多人，真的想哭，真的…… \\ 说实话还是不能相信为什么绊爱真的要暂时停止活动了呜呜…… 她还在笑，但是明显带着哭腔啊呜呜 最后还是 AIAIAI 收尾，我真的哭了…… 呜呜啊啊呜呜…… 真的写不出来那种感觉，明明最后的 AIAIAI 的钢琴伴奏是轻快的，但是我听得好伤感，真的真的真的…… 写不出来，写不出来…… 我真的好伤心，真的…… 草，居然有 HONDA 和日清，幻视 F1 和 pjsk（ 哭了。 好像旁边要打 ABC，但是 Atcoder 炸了（ 八点，结束了，呜呜，呜呜…… 感谢绊爱，这些年的陪伴…… 感谢绊爱，每天早上的早安…… 希望总会有 First Live 到来…… 总会再见的，总会再见的…… 看完之后去操场跑了几圈，不知道为啥（ 单纯的有点伤心吧，毕竟…… 今天晚上天气晴朗，抬头能看到很多星星。 真好，不是吗。 我会等你回来，一定。 2022.2.24今天好几次呐，好开心。 上述内容和俄乌局势无关。 希望战争早日结束，没有人喜欢战争。 2022.2.23妈妈生日快乐！ 我服气了，我从我电脑上把系统安装到硬盘（这样的话会带着我电脑的驱动），然后去机房电脑升级内核，显示因为英伟达驱动版本过高不能合并所以不能更新版本。 但是我从机房电脑安装的话倒是可以更新内核，但是插到我电脑上因为没有屏幕驱动不能亮屏…… 那我就从我电脑上安装然后去机房电脑单独安驱动，但是整完之后插回我电脑还是没有网卡驱动。 服了。 2022.2.22试图装 Manjaro，结果发现 RTL8825AE 的网卡驱动还是没有（ 发现已经合并到 5.16 了，但是 Manjaro 虽然写了有 5.16，但是还是默认 5.15…… 2022.2.20学弟刚来就在机房看冬奥会了，很有精神。 2022.2.7返校。 2022.2.1新年快乐。 2022.1.31除夕快乐。 2022.1.22 - 2022.1.26因为这些天是 WC，所以主要写在游记里吧。 如发奇想，有没有一种可能，心理咨询师，自己也有心理问题，为了挽救别人向自己坠落的方向而努力。（2022.1.25） 2022.1.21延长了一晚上的假期，顺便把原神里的 4800 原石抽掉了，歪了刻师傅，草。 2022.1.20目前来说，初高中四年以来，最【无法描述】的一天，不恰当来说就是高开而低走（x） SecOne一切一切还要从前一天晚上开始，十九日十一点多，mfj 问曰：你明天去打 maimai 么。 作为一个从未和同学出去玩过人，欣然同意（x） 其实是好久之前小明问要不要出去打 maimai来消费她上次和 mfj 充的币，大约上次月考的之前一周的时候吧（ 但是显然就我这样学习成绩再加上刚停课回来的周末出去的可能性约为 0 吧，于是就觉得元旦出去。 然后元旦之前先是 mfj 发烧，然后我发烧，小明声带出问题，然后就（（ 然而这次 51.5h 的假期包含一整天，确实是非常好的选择的吧。 然后去问母，母问谁与同去，我曰 mfj ，母曰不知其人也，但终了母曰之可。（虽然莫名就又一次引起来了关于她对我们班人名的询问？） 因为下午要去社会实践，于是就顺便拉着这两位去。 当然还有 tsy，他和小明看电影去，于是最后打 maimai 的就剩下我和 mfj 了（ SecTwo早上五点半自己醒了……果然还是被学校的作息整怕了……然后回去睡到八点（ 起来之后进行一个饭的吃，然后一看手机发现一堆人找我，好久没看见这么多人找我了（） 原来是 wsr 的社会实践手册忘了拿，然后因为我离学校近就问我能不能去拿，然后因为我没回他就让小明问我，然后小明找不到我就让 mfj 找我，还有 yx 找我问下午的团员人数（？） 然后就是出发去打 mai 之前去给 wsr 拿了一趟（保安大爷居然也没问我干么去，难道是我没穿校服像是个老师，还是我天天通校认识我了，还是？） 总之在约定的十点到了，因为我第一次打，所以经常找不到键，不过逐渐好起来了（ 旁边貌似有大佬，怒 FC 13+（ 然后我们大约玩到最后就发现玩不了我们事先预计的 30 个币，就开始挥霍瞎搞，然后…… 然后我就莫名的往一个开 ce 的机子里扔了四个……然后……然后……它居然在维修把我币吞了！ 然后最后去玩湾岸 5，拿老 NSX 刷着玩，快跑完的时候小明带着 tsy 来了，然后就进行一个吃饭。 他们带着我去吃火锅，然后吃饭之前小明带着我打了一次 pjsk 的多人，虽然不知道有啥不同，但是我 pjsk 终于有好友了（（ 然后中间的时候上了个蛋饺，小明问曰能否直接吃，然后我就莫名的拿起来吃了（？） 然后路过的服务员哥哥看见我生吃非常惊恐，曰：哎！———————————— 然后就社死了，死在旁边的衣服里不敢抬头（（（ SecThree下午就是一个社会实践，去的新华书店，然后我和 mfj 和小明在二楼，大约就是干一些引路人和擦东西的事情。 然后偶遇一个翔 B（ 然后就快乐的站了两个小时没做下，然后活动结束后，就进行了【数据删除】的【数据删除】。 晚上知道了成绩，和我的期望差距很大，除了数学级部 99 还凑合，剩下的考的都是个么玩意。。 比我刚停课回来还低……比一个周前的模拟掉了 300 名。。 然后就很生气难过，反复观看乙女解剖。。。 至于为什么是乙女解剖呐？ 哈哈。 2022.1.19开启了长达 51.5h 的寒假。 前段时间因为准备期末考试所以没让来机房，但是，我觉得我还不如停课。。 复习了一周还不如一周之前考得好。。 生气.jpg 2022.1.8全天奥赛喜闻乐见。 今天挺高兴的，因为树剖复健非常成功（ 唯一一次调的时间长了点是读题锅了（ 上次全天奥赛好像也在这写了一堆东西，大约每次大考前十天就会全天奥赛一次的样子么（ 已经对期末考试考多少分不抱希望了，状态不行。 现在只希望着早点考完，上奥赛，放假，回家。 除了早上被某些奇怪的东西吓醒，今天挺好的。 2022.1.7发现了，增强新鲜感能显著增强的我的学习兴趣。 今天把 Fira Code 换成了 JetBrains Mono，于是兴趣巨大提升。 所以什么时候 whk 也能给我提升学习兴趣的东西？ 比如突然给我毕老师的脑子 明天早上要在宿舍打扫卫生，然而我今天晚上回家，所以就能多睡一个小时，这样好（ 今天下午来的时候发现 WTG 炸了，试图修了一下发现不行，危（ 不过现在用的比较少了先不修了吧（（ 发现机房网好快，于是就将买了好久没玩的战地 5 下到硬盘里（ 峰值速度 32Mb/s+，害怕，害怕，平均速度 26Mb/s，害怕，害怕。 二十分钟过去下载 50%，害怕，害怕（ 2022.1.6前几天吃药吃的总是困。。 2022.1.1新年，好（ 放一下空间发的什么鬼玩意吧。 2021.12.31很 好 的 一 天 呢。 2021.12.26 - 30在帮忙忙活元旦活动。 2021.12.25和小明、 mfj 在上午大课间进行了一个尝试安装 pgr，但是发现需要有密码才能安装，试图猜了一下 Hitevision 不对（ 于是就没装上，中午下课之后试图搜了一下没搜到（ 下午寻思是不是要搞个虚拟机或者模拟器什么的，然后，小明过来说好像要 32 33 一起搞于是就大概去报告厅，所以就不能在大家面前擦黑板了玩 pgr 了 下午下课之后和 mfj 去心灵港湾玩，第一次去，那里有个画板，上面好多画的样子（ 看到很多很好的元素，比如，居然，LCEZ 有这么多车万人，好多同学的画工真滴好，那个胡桃，warma （居然）还有 fufu …… 好多人玩原神啊，好多的原神相关（ 气抖冷，日 v 什么时候能站起来（不是说 vtb 看到了关注嘉然，顿顿解馋（（ 看到了石之海（ 车万相关居然能占据整个版面的 1/5 是我没想到的（ 然后原神大约又占了 1/5 的样子（ 其余的就是很多杂杂的东西（ 我拿笔写了个“卓爹 yyds”、“翔B yyds”和“我已经完全爱上 warma 啦”就溜了（ 本来想写个“我是 ___ 的狗”（然后 mfj 还说要写个 x2，（笑）），但是好像写全名不太好就没写（ 话说本来想更新里记来着，但是旁边人好多人好多人好多（ 2021.12.24下雪了，真·雪降り、メリクリ 有点冷，但是你卓爹还是穿短袖（ 小明说要元旦的时候在教室尝试让我们在大屏上搓 pgr，于是今天拿了个安装包（（ 2021.12.23rnm，月考没了！ 2021.12.19上午进行一些活动，下午他们在给新实验班出 NB 题。 2021.12.18据说幻塔隐私政策很垃圾，所以昨天决定的东西干掉了。 2021.12.17好像有个什么东西是幻塔来着，好像能捏人，捏个同学进去（x（？ 2021.12.12首先恭喜 MAX，然后就是 Fia 确实智障。 LAPPED CARS WILL NOT BE ALLOWED TO OVERTAKE. LAPPED CARS 4 (Norris) - 14 - 31 - 16 - 5 TO OVERTAKE SAFETY CAR. 2021.12.11之前的以后再说，今天的想到啥写啥。 突然想寒假的时候手画一下头像（？ 突然想把一些东西做成皮扔到地平线 4 里开着车玩（ 今天 ceh 的《Noi Linux To Go》因为硬盘炸了好多次，从六点到十点已经重启了 10 次了快？ 真的是离谱坏了，写题的话每隔 30 min 炸一次差不多，但是只要他不写代码就没事（ 下午就回去 whk 了，班主任过来发的一堆卷子让我深感危险（ 话说真的发现自己在机房的状态比在教室好多了，昨天居然中午听见了吹哨，起来还贼早。 莫名，莫名。","link":"/2021/12/10/HDSBN/"},{"title":"李超线段树","text":"李超线段树浅学浅记。 前言单纯的学了一下而已（ 因为尚未深入进行研究所以曰之浅学浅记。 本次浅记就主要根据洛谷 P4097 [HEOI2013]Segment 这道模板题来浅曰之，题目描述略。 思路从一个相对好切入的点开始，实际上李超线段树某种程度上可以自己发明（？ 首先看到这个题，会发现我们需要一个 DS 来维护这样一个线段的“容器”，它需要完成如题的各项操作。 比较显然的是我们在每个区间内维护一个在本区间每个值都取值最大的线段的编号，那么我们就需要线段树来维护这个东西。 那么考虑如何在每次插入线段的时候都能让每个区间保持最优，有两个步骤： 这个区间是线段的定义域的子集，即 $[L,R] \\in D.$ 将此线段和当前区间内最优线段进行比较以让该区间保持最优。 第一个步骤很好实现，那么考虑第二个，如何去比较呢？ 我们考虑让一个线段加入的影响通过不断二分区间来分化下传，下面来分类讨论之： 假设我们新加入的直线/线段为 $f$，原有最大值为 $g$，区间中点为 $mid.$ $f$ 斜率大于 $g:$ 如果 $f(mid)&gt;g(mid)$，那么 $f$ 在右子区间一定最优，而 $g$ 仍有可能在左子区间更优。 反之，$g$ 在左子区间一定最优，而 $f$ 仍有可能在右子区间更优。 $g$ 斜率大于 $f:$ 如果 $f(mid)&lt;g(mid)$，那么 $f$ 在左子区间一定最优，而 $g$ 仍有可能在右子区间更优。 反之，$g$ 在右区间一定最优，而 $f$ 仍有可能在左子区间更优。 还有一些特殊情况，比如说形如 $f(x) = d$（$d$ 为常数）的直线/线段，我们将其缩到每次的比较点来方便对比（ 当然，在比较的时候还需要考虑编号的大小，所以我们在比较的时候，将编号小的稍微加一点点（EPS）来保证我们每次得到的是编号更小的最优选择。 然后就可以上代码了，复杂度的话，瓶颈在于 Pushdown 为 $O(\\log n)$，于是查询和修改的操作都为 $O(\\log ^2n)$，总体复杂度就是 $O(n \\log ^2n).$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define Heriko return#define Deltana 0#define Romanno 1#define S signed#define LL long long#define DB double#define R register#define I inline#define CI const int#define CL const long long#define mkp(a,b) make_pair(a,b)#define mst(a,b) memset(a,b,sizeof(a))#define ON std::ios::sync_with_stdio(false);cin.tie(0)#define Files() freopen(&quot;RNMTQ.in&quot;,&quot;r&quot;,stdin);freopen(&quot;RNMTQ.out&quot;,&quot;w&quot;,stdout)using namespace std;template&lt;typename J&gt;I void fr(J &amp;x) { short f(1); x=0; char c(getchar()); while(c&lt;'0' or c&gt;'9') { if(c=='-') f=-1; c=getchar(); } while(c&gt;='0' and c&lt;='9') { x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^=48); c=getchar(); } x*=f;}template&lt;typename J&gt;I void fw(J x,bool k) { if(x&lt;0) x=-x,putchar('-'); static short stak[35]; short top(0); do { stak[top++]=x%10; x/=10; } while(x); while(top) putchar(stak[--top]+'0'); k?puts(&quot;&quot;):putchar(' ');}template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y) { Heriko x&gt;y?x:y;}template&lt;typename J&gt;I J Hmin(const J &amp;x,const J &amp;y) { Heriko x&lt;y?x:y;}CI MXX(1e5+1),MOD1(39989),MOD2(1e9);const DB EPS(1e-12);I void Hmod(int &amp;x,int y,int mod) { x=(x+y-1&gt;=mod)?x+y-mod:x+y;}#define lc(x) (x&lt;&lt;1)#define rc(x) (x&lt;&lt;1|1)struct Line { DB k,b; int id; Line(const DB &amp;k=0,const int &amp;x=0,const int &amp;y=0,const int &amp;id=0) : k(k),b(y-x*k),id(id){} I DB Calc(int x) { Heriko k*x+b; } I bool Empty() { Heriko !id; }}t[MXX&lt;&lt;2];I void Hswap(Line &amp;x,Line &amp;y) { Line z; z=x,x=y,y=z;}I Line Lmx(Line x,Line y,int v) { Heriko x.Calc(v)&gt;(y.Calc(v)+((x.id&gt;y.id)?EPS:-EPS))?x:y;}void Pushdown(int x,int l,int r,Line v) { int mid((l+r)&gt;&gt;1); if(t[x].Empty()) t[x]=v; else { if(v.Calc(mid)&gt;t[x].Calc(mid)+(v.id&gt;t[x].id?EPS:-EPS)) Hswap(v,t[x]); if(v.Calc(l)&gt;t[x].Calc(l)) Pushdown(lc(x),l,mid,v); else if(v.Calc(r)&gt;t[x].Calc(r)) Pushdown(rc(x),mid+1,r,v); }}void Modify(int x,int lx,int rx,Line v,int l=1,int r=MXX) { if(lx&lt;=l and r&lt;=rx) Heriko Pushdown(x,l,r,v); int mid((l+r)&gt;&gt;1); if(lx&lt;=mid) Modify(lc(x),lx,rx,v,l,mid); if(rx&gt;mid) Modify(rc(x),lx,rx,v,mid+1,r);}Line Query(int x,int pos,int l=1,int r=MXX) { if(l==r) Heriko t[x]; int mid((l+r)&gt;&gt;1); if(pos&lt;=mid) Heriko Lmx(t[x],Query(lc(x),pos,l,mid),pos); else Heriko Lmx(t[x],Query(rc(x),pos,mid+1,r),pos);}int n,lmd,lstans,cnt;S main() { Files(); fr(n); while(n--) { int opt; fr(opt); if(!opt) { int x1; fr(x1),Hmod(x1,lmd,MOD1); fw((lstans=Query(1,x1).id),1); lmd=lstans%MOD1; } else { int x1,x2,y1,y2; Line v; fr(x1),fr(y1),fr(x2),fr(y2); Hmod(x1,lmd,MOD1),Hmod(x2,lmd,MOD1); Hmod(y1,lstans,MOD2),Hmod(y2,lstans,MOD2); if(x1&gt;x2) x1^=x2^=x1^=x2,y1^=y2^=y1^=y2; if(x1==x2) v.b=Hmax(y1,y2),v.id=++cnt; else v=Line(1.0*(y2-y1)/(x2-x1),x1,y1,++cnt); Modify(1,x1,x2,v); } } Heriko Deltana;}","link":"/2022/01/23/Li-Chao-Tree/"},{"title":"线性基","text":"线性基简记。 主要参考了 Menci 的线性基学习笔记。 「前置知识」一些线性基能用到的。 下文中若未特殊说明，集合均为「无符号整数集」。 「异或和」对于集合 $S$，将其中所有元素异或起来的结果。 「张成」对于集合 $S$ 的所有子集的异或和组成的集合成为 $S$ 的张成，记作 $span(S).$ 换句话说就是在 $S$ 中选出任意多个数，其异或和的所有可能的结果组成的集合。 「线性相关」对于一个集合 $S$，如果存在一个元素 $i$，使得，$S$ 在去除这个元素后得到的集合 $S’$ 的张成 $span(S’)$ 中包含 $i$，即，$i\\in span(S’)$，则称集合 $S$ 线性相关。 换句话说就是 $S$ 中存在一个元素 $i$ 可以被 $S$ 中的其他的若干个元素异或得到。 如果不存在这样的 $i$，就说 $S$ 线性无关。 一个显然的结论是对于一个线性相关的集合 $S$，去掉符合条件的 $i$ 之后，$span(S)$ 不变。 「线性基」称集合 $LB$ 为集合 $S$ 的线性基，当且仅当： $S\\in span(LB).$ $LB$ 线性无关。 $LB$ 中的元素个数，称为线性基的长度。 线性基有以下的性质： $LB$ 是极小的满足线性基性质的集合，它的任何真子集都不可能是线性基； $S$ 中的任意元素都可以唯一表示为 $LB$ 中若干个元素异或起来的结果； 线性基里任意一个子集的异或和都不为$0.$ 「模板」下面是模板。 「构造」1234567891011121314151617I void Insert(int x){ for(int i(62);i&gt;=0;--i) { if(x&amp;(1&lt;&lt;i)) { if(!p[i]) { p[i]=x; Heriko; } else x^=p[i]; } }} 「查询元素是否存在」因为“$S$ 中的任意元素都可以唯一表示为 $LB$ 中若干个元素异或起来的结果”，所以如果一个数在不断异或的过程中，能变成 $0$，那就存在于集合中。 12345678I bool Query(int x){ for(int i(62);i&gt;=0;--i) if(x&amp;(1&lt;&lt;i)) x^=p[i]; Heriko !x;} 「查询异或最大值」贪心即可。 12345678910I int XorMax(int x){ int res(0); for(int i(62);i&gt;=0;--i) if((res^p[i])&gt;res) res^=p[i]; Heriko res;} 「查询异或最小值」贪心即可，但是要特判 $0$，即存在 $0$ 的时候最小值为 $0.$ 123456789I int XorMin(int x){ if(HaveZero) Heriko Deltana; for(int i(62);i&gt;=0;--i) if(p[i]) Heriko p[i];} 暂且就先这些，还有一个查询第 $k$ 大异或值的操作，因为我还没用过所以就先不写。","link":"/2021/12/09/Linear-basis/"},{"title":"Models","text":"模板库。 「Pre」临近 CSP-S2 2021 的时候，我决定把板子都打一遍，顺便就把这些板子整理成一个模板库罢。 然而 CSP-S2 2021 都爆了我还没整完（ 现在备战 NOIP2022 了（ 本模板库最新的内容为 2022.2.20 更新，最老内容为 2022.1.23 更新，最近的码风翻新日期为 2022.1.23. 以下代码若无特殊情况皆可使用的缺省源： UPD 2022.1.23 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;#define Heriko return#define Deltana 0#define Romanno 1#define S signed#define LL long long#define DB double#define R register#define I inline#define CI const int#define CL const long long#define mkp(a,b) make_pair(a,b)#define mst(a,b) memset(a,b,sizeof(a))#define ON std::ios::sync_with_stdio(false);cin.tie(0)#define Files() freopen(&quot;RNMTQ.in&quot;,&quot;r&quot;,stdin);freopen(&quot;RNMTQ.out&quot;,&quot;w&quot;,stdout)using namespace std;template&lt;typename J&gt;I void fr(J &amp;x) { short f(1); x=0; char c(getchar()); while(c&lt;'0' or c&gt;'9') { if(c=='-') f=-1; c=getchar(); } while(c&gt;='0' and c&lt;='9') { x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^=48); c=getchar(); } x*=f;}template&lt;typename J&gt;I void fw(J x,bool k) { if(x&lt;0) x=-x,putchar('-'); static short stak[35]; short top(0); do { stak[top++]=x%10; x/=10; } while(x); while(top) putchar(stak[--top]+'0'); k?puts(&quot;&quot;):putchar(' ');} 「快速排序」 UPD 2022.1.23 1234567891011121314151617181920212223242526272829303132333435363738394041CI MXX(1e5+1);int a[MXX];void Mysort(int l,int r) { int i(l),j(r),mid(a[(l+r)&gt;&gt;1]); do { while(a[i]&lt;mid) ++i; while(a[j]&gt;mid) --j; if(i&lt;=j) swap(a[i],a[j]),++i,--j; } while(i&lt;=j); if(l&lt;j) Mysort(l,j); if(i&lt;r) Mysort(i,r);}int n;S main() { fr(n); for(int i(1);i&lt;=n;++i) fr(a[i]); Mysort(1,n); for(int i(1);i&lt;=n;++i) fw(a[i],0); Heriko Deltana;} 「并查集」 仅使用了路径压缩。 UPD 2022.1.23 12345678910111213141516171819202122232425262728293031323334353637383940CI MXX(2e5+1),NXX(10001);int fa[NXX],n,m;int Find(int x) { if(fa[x]!=x) fa[x]=Find(fa[x]); Heriko fa[x];}I void Uni(int x,int y) { int fx(Find(x)),fy(Find(y)); if(fx!=fy) fa[fx]=fy;}S main() { fr(n),fr(m); for(int i(1);i&lt;=n;++i) fa[i]=i; for(int i(1);i&lt;=m;++i) { int x,y,z; fr(z),fr(x),fr(y); if(z==1) Uni(x,y); else { if(Find(x)==Find(y)) puts(&quot;Y&quot;); else puts(&quot;N&quot;); } } Heriko Deltana;} 「线性筛」 这里是按照洛谷模板来写的，不过平时用不着询问部分，主要是 Es 函数。 UPD 2022.1.23 12345678910111213141516171819202122232425262728293031323334CI MXX(1e8+1);int n,prime[MXX],cnt,q;bool nopr[MXX];I void Es() { nopr[1]=1; for(int i(2);i&lt;=n;++i) { if(!nopr[i]) prime[++cnt]=i; for(int j(1);j&lt;=cnt and prime[j]*i&lt;=n;++j) { nopr[i*prime[j]]=1; if(i%prime[j]==0) break; } }}S main() { fr(n),fr(q); Es(); while(q--) { int x; fr(x); fw(prime[x],1); } Heriko Deltana;} 「堆」 一般来说，都直接用 priority_queue. UPD 2022.1.23 123456789101112131415161718192021priority_queue&lt; int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q;int n;S main() { fr(n); while(n--) { int opt,x; fr(opt); if(opt==1) fr(x),q.push(x); else if(opt==2) fw(q.top(),1); else q.pop(); } Heriko Deltana;} 「单调栈」 UPD 2022.1.23 1234567891011121314151617181920212223CI MXX(3e6+1);int n,a[MXX],f[MXX],stak[MXX],top;S main() { fr(n); for(int i(1);i&lt;=n;++i) fr(a[i]); for(int i(n);i&gt;=1;--i) { while(top and a[stak[top]]&lt;=a[i]) --top; f[i]=top?stak[top]:0; stak[++top]=i; } for(int i(1);i&lt;=n;++i) fw(f[i],0); Heriko Deltana;} 「快速幂」 2021.12.25 更新了那行 x%=p，调了三天 ODT 居然是这里爆了……我从来没写过这，于是加上。 UPD 2022.1.23 1234567891011121314I LL FstPow(LL x,LL y,LL p) { LL res(1); x%=p; while(y) { if(y&amp;1) (res*=x)%=p; (x*=x)%=p; y&gt;&gt;=1; } Heriko res;} 「单调队列」 第一个循环是求区间最小值，后者则为最大值。 UPD 2022.1.23 1234567891011121314151617181920212223242526272829303132333435363738394041CI MXX(1e6+1);int n,k,a[MXX],qmin[MXX],qmax[MXX],hd(1),tl;S main() { fr(n),fr(k); for(int i(1);i&lt;=n;++i) fr(a[i]); for(int i(1);i&lt;=n;++i) { while(hd&lt;=tl and a[qmin[tl]]&gt;=a[i]) --tl; qmin[++tl]=i; while(qmin[hd]&lt;=i-k) ++hd; if(i&gt;=k) fw(a[qmin[hd]],0); } puts(&quot;&quot;); hd=1,tl=0; for(int i(1);i&lt;=n;++i) { while(hd&lt;=tl and a[qmax[tl]]&lt;=a[i]) --tl; qmax[++tl]=i; while(qmax[hd]&lt;=i-k) ++hd; if(i&gt;=k) fw(a[qmax[hd]],0); } Heriko Deltana;} 「最小生成树」 UPD 2022.1.23 「Prim」 因为没写挂了（？）暂时咕了 「Kruskal」1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556CI MXX(2e5+5),NXX(5001);struct Node { int x,y,z; I bool operator &lt; (const Node &amp;co) const { Heriko z&lt;co.z; }}r[MXX&lt;&lt;1];int fa[NXX],n,m,ans,k;int Find(int x) { if(fa[x]!=x) fa[x]=Find(fa[x]); Heriko fa[x];}I void Uni(int x,int y,int z) { int fx(Find(x)),fy(Find(y)); if(fx!=fy) { fa[fx]=fy; ++k; ans+=z; }}S main() { fr(n),fr(m); for(int i(1);i&lt;=n;++i) fa[i]=i; for(int i(1);i&lt;=m;++i) fr(r[i].x),fr(r[i].y),fr(r[i].z); std::sort(r+1,r+1+m); for(int i(1);i&lt;=m;++i) { Uni(r[i].x,r[i].y,r[i].z); if(k==n-1) break; } if(k==n-1) fw(ans,1); else puts(&quot;orz&quot;); Heriko Deltana;} 「字符串哈希」「单哈希+自然溢出」 UPD 2022.1.23 12345678910111213141516171819202122232425262728293031323334353637#define LL unsigned long longconst LL b(211),prime(19260817);LL h[10015];char s[10015];int n,ans=1;I LL hso(char x[]) { int lx=strlen(x); LL t=0; for(int i=0;i&lt;lx;i++) t=(t*b+(LL)x[i])+prime; Heriko t;}S main() { fr(n); for(int i=1;i&lt;=n;i++) { scanf(&quot;%s&quot;,s); h[i]=hso(s); } sort(h+1,h+1+n); for(int i=1;i&lt;n;i++) if(h[i]!=h[i+1]) ans++; fw(ans,1); Heriko Deltana;} 「双哈希」 UPD 2022.1.23 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374CI MXX(1501),NXX(10005),MOD1(19260817),MOD2(998244353);int n;char s[MXX];namespace Hash { #define ULL unsigned long long struct Node { ULL h1,h2; I bool operator &lt; (const Node &amp;co) const { Heriko (h1==co.h1)?(h2&lt;co.h2):(h1&lt;co.h1); } I bool operator != (const Node &amp;co) const { Heriko !((h1==co.h1)&amp;(h2==co.h2)); } } a[NXX]; I void GetHash1(int pos,char s[]) { int len(strlen(s)); ULL tmp(0); for(int i(0);i&lt;len;++i) tmp=(tmp*255+s[i])%MOD1; a[pos].h1=tmp; } I void GetHash2(int pos,char s[]) { int len(strlen(s)); ULL tmp(0); for(int i(0);i&lt;len;++i) tmp=(tmp*255+s[i])%MOD2; a[pos].h2=tmp; } I void GetHash(int pos,char s[]) { GetHash1(pos,s); GetHash2(pos,s); } I void Solve() { sort(a+1,a+1+n); int cnt(0); for(int i(1);i&lt;=n;++i) if(a[i]!=a[i-1] or i==1) a[++cnt]=a[i]; fw(cnt,1); exit(0); }}S main() { fr(n); for(int i(1);i&lt;=n;++i) { scanf(&quot;%s&quot;,s+1); Hash::GetHash(i,s+1); } Hash::Solve(); Heriko Deltana;} 「单端最短路」「Dijkstra」 UPD 2022.1.23 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374CI MXX(5e5+1),NXX(1e5+1);struct node { int nex,to,val;}r[MXX];int cnt,head[NXX];I void Add(int x,int y,int z) { r[++cnt]=(node){head[x],y,z}; head[x]=cnt;}struct co { int dis,id; I bool operator &lt; (const co &amp;x) const { Heriko x.dis&lt;dis; }};priority_queue&lt;co&gt; q;int dis[NXX],n,m,s;bool vis[MXX];I void Dijkstra() { dis[s]=0; q.push((co){0,s}); while(q.size()) { int x(q.top().id); q.pop(); if(vis[x]) continue; vis[x]=1; for(int i(head[x]);i;i=r[i].nex) { int y(r[i].to); if(dis[y]&gt;dis[x]+r[i].val) { dis[y]=dis[x]+r[i].val; if(!vis[y]) q.push((co){dis[y],y}); } } }}S main(){ fr(n),fr(m),fr(s); mst(dis,0x7f); dis[0]=0; for(int i(1);i&lt;=m;++i) { int x,y,z; fr(x),fr(y),fr(z); Add(x,y,z); } Dijkstra(); for(int i(1);i&lt;=n;++i) fw(dis[i],0); Heriko Deltana;} 「树状数组」「单点修改区间询问」 UPD 2022.1.23 1234567891011121314151617181920212223242526272829303132333435363738394041CI MXX(5e5+1);#define lowbit(x) (x&amp;(-x))LL n,t[MXX],a[MXX],m;I void Modify(int x,int v) { while(x&lt;=n) t[x]+=v,x+=lowbit(x);}I LL Query(int x) { int res(0); while(x) res+=t[x],x-=lowbit(x); Heriko res;}S main() { fr(n),fr(m); for(int i(1);i&lt;=n;++i) fr(a[i]); for(int i(1);i&lt;=n;++i) Modify(i,a[i]); while(m--) { int opt,l,r; fr(opt),fr(l),fr(r); if(opt==1) Modify(l,r); else fw(Query(r)-Query(l-1),1); } Heriko Deltana;} 「区间修改单点询问」 UPD 2022.1.23 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#define lowbit(x) ((x)&amp;(-x))CI MXX(5e5+1);int n,m,t[MXX],a[MXX];I void Add(int x,int val) { while(x&lt;=n) t[x]+=val,x+=lowbit(x);}I int Query(int x) { int res(0); while(x) res+=t[x],x-=lowbit(x); Heriko res;} S main() { fr(n),fr(m); for(int i(1);i&lt;=n;++i) fr(a[i]); for(int i(1);i&lt;=n;++i) Add(i,a[i]-a[i-1]); while(m--) { int opt,x,y,z; fr(opt); if(opt==1) { fr(x),fr(y),fr(z); Add(x,z); Add(y+1,-z); } else { fr(x); fw(Query(x),1); } } Heriko Deltana;} 「乘法逆元」 UPD 2022.1.23 12345678910111213141516CI MXX(3e6+1);LL inv[MXX],n,m;S main() { fr(n),fr(m); inv[1]=1; for(int i(2);i&lt;=n;++i) inv[i]=m-(m/i)*inv[m%i]%m; for(int i(1);i&lt;=n;++i) fw(inv[i],1); Heriko Deltana;} 「高精度」 UPD 2022.1.23 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176CI MXX(105);struct Pic { int num[MXX],sz; Pic() { mst(num,0); sz=1; } I void Clear() { mst(num,0); sz=1; } /*---- int * Pic ----*/ I Pic operator * (const int &amp;co) const { Pic res; res.sz=sz; for(int i(1);i&lt;=sz;++i) res.num[i]=num[i]*co; for(int i(1);i&lt;=sz;++i) res.num[i+1]+=(res.num[i]/10),res.num[i]%=10; while(res.num[res.sz+1]) { ++res.sz; res.num[res.sz+1]+=(res.num[res.sz]/10); res.num[res.sz]%=10; } Heriko res; } /*---- Pic * Pic ----*/ I Pic operator * (const Pic &amp;co) const { Pic res; res.sz=co.sz+sz; for(int i(1);i&lt;=sz;++i) for(int j(1);j&lt;=co.sz;++j) { res.num[i+j-1]+=(num[i]*co.num[j]); res.num[i+j]+=(res.num[i+j-1]/10);res.num[i+j-1]%=10; } while(!res.num[res.sz] and res.sz&gt;1) --res.sz; Heriko res; } /*---- Pic + Pic ----*/ I Pic operator + (const Pic &amp;co) const { Pic res; res.sz=sz+2; for(int i(1);i&lt;=sz;++i) { res.num[i]+=num[i]+co.num[i]; if(res.num[i]&gt;10) ++res.num[i+1],res.num[i]%=10; } while(!res.num[res.sz] and res.sz&gt;1) --res.sz; Heriko res; } /*---- Pic - Pic ----*/ /*Need to ensure *this &gt; co*/ I Pic operator - (const Pic &amp;co) const { Pic res; res.sz=sz; for(int i(1);i&lt;=sz;++i) { res.num[i]+=num[i]-co.num[i]; if(res.num[i]&lt;0) --res.num[i+1],res.num[i]+=10; } while(!res.num[res.sz] and res.sz&gt;1) --res.sz; Heriko res; } /*---- Pic&gt;&gt;1 ----*/ I void RightShift() { for(int i(sz);i;--i) { if(num[i]&amp;1) num[i-1]+=10; num[i]&gt;&gt;=1; } while(!num[sz] and sz&gt;1) --sz; } /*---- Pic &lt; Pic ----*/ I bool operator &lt; (const Pic &amp;co) const { if(sz!=co.sz) Heriko sz&lt;co.sz; for(int i(sz);i;--i) if(num[i]!=co.num[i]) Heriko num[i]&lt;co.num[i]; Heriko Deltana; } /*---- Pic &gt; Pic ----*/ I bool operator &gt; (const Pic &amp;co) const { if(sz!=co.sz) Heriko sz&gt;co.sz; for(int i(sz);i;--i) if(num[i]!=co.num[i]) Heriko num[i]&gt;co.num[i]; Heriko Deltana; } /*---- Pic &lt;= Pic ----*/ I bool operator &lt;= (const Pic &amp;co) const { Heriko !((*this)&gt;co); } /*---- Pic &gt;= Pic ----*/ I bool operator &gt;= (const Pic &amp;co) const { Heriko !((*this)&lt;co); } /*---- Pic == Pic ----*/ I bool operator == (const Pic &amp;co) const { Heriko (!((*this)&gt;co))&amp;(!((*this)&lt;co)); } /*---- Pic Input (char[] -&gt; Pic) ----*/ I void Into(char s[]) { sz=strlen(s+1); for(int i(1);i&lt;=sz;++i) num[i]=s[sz-i+1]-'0'; } /*---- Pic == 0 ? ----*/ I bool Zero() { Heriko (sz==1)&amp;(num[1]==0); } /*---- Pic Output ----*/ I void fw() { for(int i(sz);i;--i) putchar(num[i]+'0'); putchar(' '); }}n,m; 「线段树」 UPD 2022.1.23 这里只放了个区间加和区间改，其它东西改一改就有了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y) { Heriko x&gt;y?x:y;}const LL MXX(1e6+1),INF(1e12);int n,q;struct Node { int l,r;LL mx,tg1,tg2;}t[MXX&lt;&lt;2];I void Pushup(int x) { t[x].mx=Hmax(t[lc(x)].mx,t[rc(x)].mx);}I void Pushdown(int x) { if(t[x].tg2!=INF) { t[lc(x)].tg1=0; t[lc(x)].tg2=t[x].tg2; t[lc(x)].mx=t[x].tg2; t[rc(x)].tg1=0; t[rc(x)].tg2=t[x].tg2; t[rc(x)].mx=t[x].tg2; t[x].tg2=INF; } if(t[x].tg1) { t[lc(x)].tg1+=t[x].tg1; t[lc(x)].mx+=t[x].tg1; t[rc(x)].tg1+=t[x].tg1; t[rc(x)].mx+=t[x].tg1; t[x].tg1=0; }}void Build(int x,int l,int r) { t[x].l=l,t[x].r=r; t[x].mx=t[x].tg1=0; t[x].tg2=INF; if(l==r) { fr(t[x].mx); Heriko; } int mid((l+r)&gt;&gt;1); Build(lc(x),l,mid); Build(rc(x),mid+1,r); Pushup(x);}void ModifyAdd(int x,int lx,int rx,LL v) { if(lx&lt;=t[x].l and t[x].r&lt;=rx) { t[x].tg1+=v;t[x].mx+=v; Heriko; } Pushdown(x); int mid((t[x].l+t[x].r)&gt;&gt;1); if(lx&lt;=mid) ModifyAdd(lc(x),lx,rx,v); if(rx&gt;mid) ModifyAdd(rc(x),lx,rx,v); Pushup(x);}void ModifyChange(int x,int lx,int rx,LL v) { if(lx&lt;=t[x].l and t[x].r&lt;=rx) { t[x].tg1=0;t[x].tg2=v;t[x].mx=v; Heriko; } Pushdown(x); int mid((t[x].l+t[x].r)&gt;&gt;1); if(lx&lt;=mid) ModifyChange(lc(x),lx,rx,v); if(rx&gt;mid) ModifyChange(rc(x),lx,rx,v); Pushup(x);}LL Query(int x,int lx,int rx) { if(lx&lt;=t[x].l and t[x].r&lt;=rx) Heriko t[x].mx; LL res(-INF); int mid((t[x].l+t[x].r)&gt;&gt;1); Pushdown(x); if(lx&lt;=mid) res=Hmax(Query(lc(x),lx,rx),res); if(rx&gt;mid) res=Hmax(Query(rc(x),lx,rx),res); Heriko res;}S main() { fr(n),fr(q); Build(1,1,n); while(q--) { int opt,l,r;LL x; fr(opt),fr(l),fr(r); if(opt==1) fr(x),ModifyChange(1,l,r,x); else if(opt==2) fr(x),ModifyAdd(1,l,r,x); else fw(Query(1,l,r),1); } Heriko Deltana;} 「主席树」 UPD 2022.2.20 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667CI MXX(1e5+1);int n,q,lc[MXX&lt;&lt;5],rc[MXX&lt;&lt;5],sum[MXX&lt;&lt;5],t[MXX],a[MXX],b[MXX],id;int Build(int l,int r) { int x(++id),mid((l+r)&gt;&gt;1); if(l&lt;r) { lc[x]=Build(l,mid); rc[x]=Build(mid+1,r); } Heriko x;}int Insert(int pre,int l,int r,int v) { int x(++id),mid((l+r)&gt;&gt;1); lc[x]=lc[pre],rc[x]=rc[pre],sum[x]=sum[pre]+1; if(l&lt;r) { if(v&lt;=mid) lc[x]=Insert(lc[pre],l,mid,v); else rc[x]=Insert(rc[pre],mid+1,r,v); } Heriko x;}int Query(int x,int y,int l,int r,int v) { if(l&gt;=r) Heriko l; int nw(sum[lc[y]]-sum[lc[x]]),mid((l+r)&gt;&gt;1); if(nw&gt;=v) Heriko Query(lc[x],lc[y],l,mid,v); else Heriko Query(rc[x],rc[y],mid+1,r,v-nw);}S main() { fr(n),fr(q); for(int i(1);i&lt;=n;++i) fr(a[i]),b[i]=a[i]; sort(b+1,b+1+n); int nl(unique(b+1,b+1+n)-b-1); for(int i(1);i&lt;=n;++i) a[i]=lower_bound(b+1,b+1+nl,a[i])-b; t[0]=Build(1,nl); for(int i(1);i&lt;=n;++i) t[i]=Insert(t[i-1],1,nl,a[i]); while(q--) { int l,r,k; fr(l),fr(r),fr(k); fw(b[Query(t[l-1],t[r],1,nl,r-l+1-k+1)],1);//求区间第 K 大 fw(b[Query(t[l-1],t[r],1,nl,k)],1);//求区间第 K 小 } Heriko Deltana;} 「ST表」 UPD 2022.1.23 123456789101112131415161718192021222324252627282930313233343536template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y) { Heriko x&gt;y?x:y;}CI MXX(1e5+1);LL a[MXX][22];int n,m;I LL Query(int l,int r) { int tmp(std::log2(r-l+1)); Heriko Hmax(a[l][tmp],a[r-(1&lt;&lt;tmp)+1][tmp]);}S main() { fr(n),fr(m); for(int i(1);i&lt;=n;++i) fr(a[i][0]); for(int lg(1);lg&lt;=21;++lg) for(int i(1);i+(1&lt;&lt;lg)-1&lt;=n;++i) a[i][lg]=Hmax(a[i][lg-1],a[i+(1&lt;&lt;(lg-1))][lg-1]); for(int i(1);i&lt;=m;++i) { int l,r; fr(l),fr(r); fw(Query(l,r),1); } Heriko Deltana;} 「三分法」 UPD 2022.1.23 123456789101112131415161718192021222324252627282930313233343536373839404142template&lt;typename J&gt;I J Habs(const J &amp;x) { Heriko x&lt;0?-x:x;}const double EPS(1e-7);CI MXX(15);int n;double a[MXX],l,r;double Solve(double x) { double res(0); for(int i(n);i&gt;=0;--i) res*=x,res+=a[i]; Heriko res;}S main() { fr(n); scanf(&quot;%lf%lf&quot;,&amp;l,&amp;r); for(int i(n);i&gt;=0;--i) scanf(&quot;%lf&quot;,&amp;a[i]); while(Habs(r-l)&gt;=EPS) { double mid((l+r)/2); if(Solve(mid+EPS)&gt;Solve(mid-EPS)) l=mid; else r=mid; } printf(&quot;%.5lf\\n&quot;,r); Heriko Deltana;} 「KMP」 UPD 2022.1.23 123456789101112131415161718192021222324252627282930313233343536373839CI MXX(1e6+1);int lena,lenb,nex[MXX],kmp[MXX];char a[MXX],b[MXX];S main() { scanf(&quot;%s%s&quot;,a+1,b+1); lena=strlen(a+1),lenb=strlen(b+1); for(int i(2),j(0);i&lt;=lenb;++i) { while(j&gt;0 and b[i]!=b[j+1]) j=nex[j]; if(b[i]==b[j+1]) ++j; nex[i]=j; } for(int i(1),j(0);i&lt;=lena;++i) { while(j&gt;0 and a[i]!=b[j+1]) j=nex[j]; if(a[i]==b[j+1]) ++j; kmp[i]=j; } for(int i(1);i&lt;=lena;++i) if(kmp[i]==lenb) fw(i-lenb+1,1); for(int i(1);i&lt;=lenb;++i) fw(nex[i],0); Heriko Deltana;} 「LCA」「倍增」 UPD 2022.1.23 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273CI MXX(5e5+1);int n,m,rt;struct Node { int nex,to;}r[MXX&lt;&lt;1];int cnt,head[MXX];I void Add(int x,int y) { r[++cnt]=(Node){head[x],y};head[x]=cnt; r[++cnt]=(Node){head[y],x};head[y]=cnt;}int dep[MXX],f[MXX][35],lg[MXX];I void PreLog() { for(int i(1);i&lt;=n;++i) lg[i]=lg[i-1]+((1&lt;&lt;lg[i-1])==i);}void DFS(int x,int fa) { f[x][0]=fa; dep[x]=dep[fa]+1; for(int i(1);i&lt;=lg[dep[x]];++i) f[x][i]=f[f[x][i-1]][i-1]; for(int i(head[x]);i;i=r[i].nex) if(r[i].to!=fa) DFS(r[i].to,x);}I int LCA(int x,int y) { if(dep[x]&lt;dep[y]) swap(x,y); while(dep[x]&gt;dep[y]) x=f[x][lg[dep[x]-dep[y]]-1]; if(x==y) Heriko x; for(int i(lg[dep[x]]-1);i&gt;=0;--i) if(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i]; Heriko f[x][0];}S main() { fr(n),fr(m),fr(rt); for(int i(1);i&lt;n;++i) { int x,y; fr(x),fr(y); Add(x,y); } PreLog(); DFS(rt,0); for(int i(1);i&lt;=m;++i) { int x,y; fr(x),fr(y); fw(LCA(x,y),1); } Heriko Deltana;} 「树剖」 UPD 2022.1.23 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182CI MXX(500001);struct Node { int nex,to;}r[MXX&lt;&lt;1];int rcnt,head[MXX];I void Add(int x,int y) { r[++rcnt]=(Node){head[x],y},head[x]=rcnt; r[++rcnt]=(Node){head[y],x},head[y]=rcnt;}int sz[MXX],son[MXX],top[MXX],fa[MXX],dep[MXX];void DFS1(int x,int fath) { sz[x]=1,fa[x]=fath,dep[x]=dep[fath]+1; for(int i(head[x]);i;i=r[i].nex) { int y(r[i].to); if(y==fath) continue; DFS1(y,x); sz[x]+=sz[y]; if(!son[x] or sz[son[x]]&lt;sz[y]) son[x]=y; }}void DFS2(int x,int nw) { top[x]=nw; if(son[x]) DFS2(son[x],nw); for(int i(head[x]);i;i=r[i].nex) { int y(r[i].to); if(y==fa[x] or y==son[x]) continue; DFS2(y,y); }}int n,m,s;S main() { // Files(); fr(n),fr(m),fr(s); for(int i(1);i&lt;n;++i) { int x,y; fr(x),fr(y); Add(x,y); } DFS1(s,0); DFS2(s,s); for(int i(1);i&lt;=m;++i) { int x,y; fr(x),fr(y); while(top[x]!=top[y]) { if(dep[top[x]]&gt;=dep[top[y]]) x=fa[top[x]]; else y=fa[top[y]]; } fw((dep[x]&lt;dep[y])?x:y,1); } Heriko Deltana;} 「矩阵加速」 UPD 2022.1.23 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162CI MOD(1e9+7);int n,T;struct Matrix { LL a[5][5]; Matrix() { mst(a,0); } I void BuildB() { mst(a,0); a[1][1]=a[1][3]=a[2][1]=a[3][2]=1; } I void BuildA() { mst(a,0); a[1][1]=a[2][1]=a[3][1]=1; } I Matrix operator * (const Matrix &amp;co) const { Matrix res; for(int k(1);k&lt;=3;++k) for(int i(1);i&lt;=3;++i) for(int j(1);j&lt;=3;++j) (res.a[i][j]+=(a[i][k]*co.a[k][j])%MOD)%=MOD; Heriko res; }}A,B;I void MatrixFstPow(int x) { while(x) { if(x&amp;1) A=A*B; B=B*B; x&gt;&gt;=1; }}S main() { fr(T); while(T--) { fr(n); if(n&lt;=3) puts(&quot;1&quot;); else { A.BuildA(),B.BuildB(); MatrixFstPow(n-1); fw((A.a[1][1]+MOD)%MOD,1); } } Heriko Deltana;} 「SPFA判负环」 UPD 2022.1.23 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980CI MXX(3001),INF(0x3f3f3f3f);int n,m,T;struct Node { int nex,to,val;}r[MXX&lt;&lt;1];int cnt,head[MXX];I void Add(int x,int y,int z) { r[++cnt]=(Node){head[x],y,z}; head[x]=cnt;}int co[MXX],dis[MXX];bitset&lt;MXX&gt; vis;I bool SPFA(int s) { queue&lt;int&gt; q; q.push(s); dis[s]=0,vis[s]=1,++co[s]; while(q.size()) { int x(q.front()); q.pop(); vis[x]=0; for(int i(head[x]);i;i=r[i].nex) { int y(r[i].to); if(dis[y]&gt;dis[x]+r[i].val) { dis[y]=dis[x]+r[i].val; if(!vis[y]) { vis[y]=1; q.push(y); ++co[y]; if(co[y]&gt;n) Heriko Deltana; } } } } Heriko Romanno;}S main() { Files(); fr(T); while(T--) { fr(n),fr(m); cnt=0,vis=0; mst(dis,0x3f),mst(co,0),mst(head,0); for(int i(1);i&lt;=m;++i) { int x,y,z; fr(x),fr(y),fr(z); if(z&gt;=0) Add(x,y,z),Add(y,x,z); else Add(x,y,z); } if(!SPFA(1)) puts(&quot;YES&quot;); else puts(&quot;NO&quot;); } Heriko Deltana;} 「矩阵快速幂」 UPD 2022.1.23 12345678910111213141516171819202122232425262728293031323334353637383940414243444546CI NXX(101),MXX(21),MOD(1e9+7);struct Matrix { int n,m,a[MXX][MXX]; Matrix() { n=m=0,mst(a,0); } I void Build() { for(int i(1);i&lt;=m;++i) a[i][i]=1; } I Matrix operator * (const Matrix &amp;co) const { Matrix res; res.n=n,res.m=co.m; for(int i(1);i&lt;=n;++i) for(int k(1);k&lt;=m;++k) for(int j(1);j&lt;=co.m;++j) (res.a[i][j]+=(1ll*a[i][k]*co.a[k][j])%MOD)%=MOD; Heriko res; }}ans;int n,m;I Matrix MFP(Matrix x,int y) { Matrix res; res.n=res.m=m; res.Build(); while(y) { if(y&amp;1) res=res*x; x=x*x; y&gt;&gt;=1; } Heriko res;} 「AC自动机」 UPD 2022.1.23 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273CI MXX(1e6+5);struct ACAM { int c[MXX][26],val[MXX],fail[MXX],cnt; queue&lt;int&gt; q; I void Insert(char s[]) { int len(strlen(s)),nw(0); for(int i(0);i&lt;len;++i) { int v(s[i]-'a'); if(!c[nw][v]) c[nw][v]=++cnt; nw=c[nw][v]; } ++val[nw]; } I void Build() { for(int i(0);i&lt;26;++i) if(c[0][i]) fail[c[0][i]]=0,q.push(c[0][i]); while(q.size()) { int x(q.front()); q.pop(); for(int i(0);i&lt;26;++i) if(c[x][i]) fail[c[x][i]]=c[fail[x]][i],q.push(c[x][i]); else c[x][i]=c[fail[x]][i]; } } I int Query(char s[]) { int len(strlen(s)),nw(0),res(0); for(int i(0);i&lt;len;++i) { nw=c[nw][s[i]-'a']; for(int j(nw);j and ~val[j];j=fail[j]) res+=val[j],val[j]=-1; } Heriko res; }}AC;int n;char s[MXX];S main() { Files(); fr(n); for(int i(1);i&lt;=n;++i) scanf(&quot;%s&quot;,s),AC.Insert(s); AC.Build(); scanf(&quot;%s&quot;,s); fw(AC.Query(s),1); Heriko Deltana;} 「差分约束」 UPD 2022.1.23 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475CI MXX(5e3+5),INF(0x3f3f3f3f);int n,m,T;struct Node { int nex,to,val;}r[MXX&lt;&lt;1];int cnt,head[MXX];I void Add(int x,int y,int z) { r[++cnt]=(Node){head[x],y,z}; head[x]=cnt;}int co[MXX],dis[MXX];bitset&lt;MXX&gt; vis;I bool SPFA(int s) { queue&lt;int&gt; q; q.push(s); mst(dis,0x3f); dis[s]=0,vis[s]=1,++co[s]; while(q.size()) { int x(q.front()); q.pop(); vis[x]=0; for(int i(head[x]);i;i=r[i].nex) { int y(r[i].to); if(dis[y]&gt;dis[x]+r[i].val) { dis[y]=dis[x]+r[i].val; if(!vis[y]) { vis[y]=1; q.push(y); ++co[y]; if(co[y]&gt;=n+1) Heriko Deltana; } } } } Heriko Romanno;}S main() { Files(); fr(n),fr(m); for(int i(1);i&lt;=n;++i) Add(0,i,0); for(int i(1);i&lt;=m;++i) { int x,y,z; fr(x),fr(y),fr(z); Add(y,x,z); } if(!SPFA(0)) puts(&quot;NO&quot;); else for(int i(1);i&lt;=n;++i) fw(dis[i],0); Heriko Deltana;} 「欧拉路径」 UPD 2022.1.23 调了 $\\tt 114514$ 年，结果是答案栈开小了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y) { Heriko x&gt;y?x:y;}CI MXX(1e5+5);int n,m,into[MXX],outo[MXX],lst[MXX],ans[MXX&lt;&lt;1],s,t,cnt;vector&lt; pair&lt;int,int&gt; &gt; r[MXX];bitset&lt;(MXX&lt;&lt;1)&gt; vis;void DFS(int x) { for(int i(lst[x]);i&lt;(int)r[x].size();i=Hmax(i+1,lst[x])) { int y(r[x][i].first),id(r[x][i].second); if(!vis[id]) { vis[id]=1; lst[x]=i+1; DFS(y); } } ans[++cnt]=x;}S main() { Files(); fr(n),fr(m); for(int i(1);i&lt;=m;++i) { int x,y; fr(x),fr(y); ++outo[x],++into[y]; r[x].push_back(mkp(y,i)); } int tot(0); for(int i(1);i&lt;=n;++i) if(into[i]!=outo[i]) { ++tot; if(into[i]==outo[i]-1) s=i; if(into[i]==outo[i]+1) t=i; } if(tot!=0 and tot!=2) { puts(&quot;No&quot;); Heriko Deltana; } if(!tot) s=t=1; if(!s or !t) { puts(&quot;No&quot;); Heriko Deltana; } for(int i(1);i&lt;=n;++i) sort(r[i].begin(),r[i].end()); DFS(s); for(int i(cnt);i;--i) fw(ans[i],0); Heriko Deltana;} 「康托展开」 UPD 2022.1.23 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#define lowbit(x) ((x)&amp;(-x))CI MXX(1e6+1),MOD(998244353);int n;LL t[MXX];I void Add(int x,LL v) { while(x&lt;=n) t[x]+=v,x+=lowbit(x);}I LL Query(int x) { LL res(0); while(x) res+=t[x],x-=lowbit(x); Heriko res;}LL pw[MXX],ans;S main() { Files(); fr(n); for(int i(1);i&lt;=n;++i) Add(i,1); pw[0]=1; for(int i(1);i&lt;=n;++i) pw[i]=(pw[i-1]*i)%MOD; for(int i(1);i&lt;=n;++i) { int x; fr(x); (ans+=((Query(x)-1)*pw[n-i])%MOD)%=MOD; Add(x,-1); } fw(ans+1,1); Heriko Deltana;} 「威佐夫博弈」 UPD 2022.1.23 结论：若两堆物品的初始值为 $(n,m)$，且 $m&lt;n$，则使 $z=n-m.$ 记 x=(LL)(((sqrt(5.0)+1.0)/2.0)*w); 若 $m=x$，则先手必败，否则先手必胜。 1234567891011121314151617181920LL n,m,w,x;S main() { Files(); fr(n),fr(m); if(n&lt;m) swap(n,m); w=n-m; x=(LL)(((sqrt(5.0)+1.0)/2.0)*w); if(x==m) puts(&quot;0&quot;); else puts(&quot;1&quot;); Heriko Deltana;} 「莫队」 UPD 2022.1.23 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566CI MXX(5e4+1);int n,m,k,a[MXX],sqn;LL ans[MXX],co[MXX],cnt;struct Node { int l,r,id; I bool operator &lt; (const Node &amp;co) const { if(l/sqn!=co.l/sqn) Heriko l&lt;co.l; if((l/sqn)&amp;1) Heriko r&lt;co.r; Heriko r&gt;co.r; }}q[MXX];I void Add(int x) { }I void Del(int x) { }S main() { Files(); fr(n),fr(m),fr(k),sqn=sqrt(n); for(int i(1);i&lt;=n;++i) fr(a[i]); for(int i(1);i&lt;=m;++i) fr(q[i].l),fr(q[i].r),q[i].id=i; sort(q+1,q+1+m); int lx(1),rx(0); for(int i(1);i&lt;=m;++i) { while(lx&lt;q[i].l) Del(a[lx++]); while(lx&gt;q[i].l) Add(a[--lx]); while(rx&lt;q[i].r) Add(a[++rx]); while(rx&gt;q[i].r) Del(a[rx--]); ans[q[i].id]=cnt; } for(int i(1);i&lt;=m;++i) fw(ans[i],1); Heriko Deltana;} 「vector 存图遍历模板」 UPD 2022.1.23 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354CI MXX(1e6+1),NXX(1e5+1);bitset&lt;NXX&gt; vis;vector&lt;int&gt; r[NXX];int n,m;void DFS(int x) { fw(x,0); vis[x]=1; int sz(r[x].size()); for(int i(0);i&lt;sz;++i) if(!vis[r[x][i]]) DFS(r[x][i]);}I void BFS() { queue&lt;int&gt; q; q.push(1),vis[1]=1; while(q.size()) { int y(q.front()); q.pop(); fw(y,0); int sz(r[y].size()); for(int i(0);i&lt;sz;++i) if(!vis[r[y][i]]) q.push(r[y][i]),vis[r[y][i]]=1; }}S main() { Files(); fr(n),fr(m); for(int i(1);i&lt;=m;++i) { int x,y; fr(x),fr(y); r[x].push_back(y); } for(int i(1);i&lt;=n;++i) std::sort(r[i].begin(),r[i].end()); DFS(1),puts(&quot;&quot;); vis=0; BFS(),puts(&quot;&quot;); Heriko Deltana;} 「Dinic」 UPD 2022.1.23 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899template &lt;typename J&gt;I J Hmin(const J &amp;x,const J &amp;y) { Heriko x&lt;y?x:y;}CI MXX(5001),NXX(201),INF(998244353);struct Node { int nex,to; LL val;}r[MXX&lt;&lt;1];int cnt(1),head[NXX],now[NXX],n,m,s,t;I void Add(int x,int y,LL z) { r[++cnt]=(Node){head[x],y,z},head[x]=cnt; r[++cnt]=(Node){head[y],x,0},head[y]=cnt;}LL dis[NXX],ans;bitset&lt;NXX&gt; vis;I bool BFS() { mst(dis,0); queue&lt;int&gt; q; q.push(s); dis[s]=1,now[s]=head[s]; while(q.size()) { int x(q.front()); q.pop(); for(int i(head[x]);i;i=r[i].nex) { if(r[i].val and !dis[r[i].to]) { int y(r[i].to); q.push(y); now[y]=head[y],dis[y]=dis[x]+1; if(y==t) Heriko Romanno; } } } Heriko Deltana;}LL Dinic(int x,LL flow) { if(x==t) Heriko flow; LL rst(flow),k; for(int i(now[x]);i and rst;i=r[i].nex) { int y(r[i].to); if(r[i].val and dis[y]==dis[x]+1) { k=Dinic(y,Hmin(rst,r[i].val)); if(!rst) Heriko flow; if(!k) dis[y]=0; r[i].val-=k,r[i^1].val+=k,rst-=k; } now[x]=i; } Heriko flow-rst;}S main() { // Files(); fr(n),fr(m),fr(s),fr(t); for(int i(1);i&lt;=m;++i) { int x,y; LL z; fr(x),fr(y),fr(z); Add(x,y,z); } LL flow(0); while(BFS()) while((flow=Dinic(s,INF))) ans+=flow; fw(ans,1); Heriko Deltana;} 「Tarjan求强连通分量」 UPD 2022.1.23 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889template &lt;typename J&gt;I J Hmin(const J &amp;x,const J &amp;y) { Heriko x&lt;y?x:y;}CI MXX(100001),NXX(10001);struct Node { int nex,to; }r[MXX];int rcnt,head[NXX];I void Add(int x,int y) { r[++rcnt]=(Node){head[x],y}; head[x]=rcnt;}int dfn[NXX],low[NXX],cnt,stak[NXX],top,tot,c[NXX];bitset&lt;NXX&gt; vis;vector&lt;int&gt; v[NXX];void Tarjan(int x) { dfn[x]=low[x]=++cnt; stak[++top]=x,vis[x]=1; for(int i(head[x]);i;i=r[i].nex) { int y(r[i].to); if(!dfn[y]) Tarjan(y),low[x]=Hmin(low[x],low[y]); else if(vis[y]) low[x]=Hmin(low[x],dfn[y]); } if(dfn[x]==low[x]) { ++tot; int tmp(0); while(tmp!=x) { tmp=stak[top--]; vis[tmp]=0; c[tmp]=tot; v[tot].push_back(tmp); } }}int n,m;S main() { // Files(); fr(n),fr(m); for(int i(1);i&lt;=m;++i) { int x,y; fr(x),fr(y); Add(x,y); } for(int i(1);i&lt;=n;++i) if(!dfn[i]) Tarjan(i); fw(tot,1); for(int i(1);i&lt;=n;++i) { int x(c[i]); if(vis[x]) continue; vis[x]=1; std::sort(v[x].begin(),v[x].end()); int sz(v[x].size()); for(int j(0);j&lt;sz;++j) fw(v[x][j],0); puts(&quot;&quot;); } Heriko Deltana;} 「珂朵莉树」 直接把我 CF896C 的代码拿过来了。 UPD 2022.1.23 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798I LL FstPow(LL x,LL y,LL p) { LL res(1); x%=p; while(y) { if(y&amp;1) (res*=x)%=p; (x*=x)%=p; y&gt;&gt;=1; } Heriko res;}//其实这个快速幂没啥用，只是下面的 Query 的时候有用到，和 ODT 本身关系不大。struct Node { LL l,r; mutable LL v; Node(LL l,LL r=0,LL v=0) : l(l),r(r),v(v) {} I bool operator &lt; (const Node &amp;co) const { Heriko l&lt;co.l; }};set&lt;Node&gt; s;I auto Split(LL pos) { auto it(s.lower_bound(Node(pos))); if(it!=s.end() and it-&gt;l==pos) Heriko it; --it; if(it-&gt;r&lt;pos) Heriko s.end(); LL l(it-&gt;l),r(it-&gt;r),v(it-&gt;v); s.erase(it); s.insert(Node(l,pos-1,v)); Heriko s.insert(Node(pos,r,v)).first;}I void Assign(LL l,LL r,LL x) { auto itr(Split(r+1)),itl(Split(l)); s.erase(itl,itr); s.insert(Node(l,r,x));}I void Add(LL l,LL r,LL x) { auto itr(Split(r+1)),itl(Split(l)); for(auto it(itl);it!=itr;++it) it-&gt;v+=x;}struct Rank { LL val,cnt; Rank(LL val,LL cnt) : val(val),cnt(cnt) {} I bool operator &lt; (const Rank &amp;co) const { Heriko val&lt;co.val; }};I LL QueryRank(LL l,LL r,LL x) { auto itr(Split(r+1)),itl(Split(l)); vector&lt;Rank&gt; v; for(auto it(itl);it!=itr;++it) v.push_back(Rank(it-&gt;v,it-&gt;r-it-&gt;l+1)); sort(v.begin(),v.end()); LL i(0); for(;i&lt;(LL)v.size();++i) if(v[i].cnt&lt;x) x-=v[i].cnt; else Heriko v[i].val; Heriko v[i].val;}I LL QueryVal(LL l,LL r,LL x,LL y) { auto itr(Split(r+1)),itl(Split(l)); LL res(0); for(auto it(itl);it!=itr;++it) res=(res+FstPow(it-&gt;v,x,y)*(it-&gt;r-it-&gt;l+1)%y)%y; Heriko res;} 「平面最近点对」 $O(n \\log^2 n)$ 的做法。 UPD 2022.1.23 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960template&lt;typename J&gt;I J Hmin(const J &amp;x,const J &amp;y) { Heriko x&lt;y?x:y;}CI MXX(2e5+1);const double INF(1e12);I bool CMP(const pair&lt;double,double&gt; &amp;a,const pair&lt;double,double&gt; &amp;b) { Heriko a.second&lt;b.second;}I double Dist(const pair&lt;double,double&gt; &amp;a,const pair&lt;double,double&gt; &amp;b) { Heriko sqrt((long double)(a.first-b.first)*(a.first-b.first)+(long double)(a.second-b.second)*(a.second-b.second));}int n;pair&lt;double,double&gt; a[MXX],tmp[MXX];double Merge(int l,int r) { if(l==r) Heriko INF; int mid((l+r)&gt;&gt;1),top(0); double dis(INF); dis=Hmin(Merge(l,mid),Merge(mid+1,r)); for(int i(l);i&lt;=r;++i) if(fabs(a[mid].first-a[i].first)&lt;dis) tmp[++top]=a[i]; std::sort(tmp+1,tmp+1+top,CMP); for(int i(1);i&lt;=top;++i) for(int j(i+1);j&lt;=top;++j) { if(tmp[j].second-tmp[i].second&gt;=dis) break; dis=Hmin(dis,Dist(tmp[i],tmp[j])); } Heriko dis;}S main() { Files(); fr(n); for(int i(1);i&lt;=n;++i) scanf(&quot;%lf%lf&quot;,&amp;a[i].first,&amp;a[i].second); std::sort(a+1,a+1+n); double ans(Merge(1,n)); printf(&quot;%.4lf&quot;,ans); Heriko Deltana;}","link":"/2021/11/19/Models/"},{"title":"NOIP 2021 游记","text":"NOIP 2021 游记 不知道为什么，写不出什么积极的东西。 2021.11.17 「2021.11.9」离开学校去到 BCT，开始 8 天的集训。 「2021.11.16」听说考场有 sublime text 3，于是开始在 BCT 电脑上下一个开始用。 「2021.11.17」集训今天结束，算是很不错的体验，考试基本能正解一题，认识很多新朋友，见到了 UF 真人/se，手残删掉的 Phigros 的 rks 回到了原来的分，甚至现在到了 12.83. 今天老师说要欢乐赛，结果…… 这里说甚至 UF 还能发说说是因为 UF 只能用那里的电脑上 QQ. T1诈骗，然后就把T1切了。 最一开始用的 sublime 的自带编译，后来发现不能加其它编译选项，于是学会了写 makefile. 准备明天回学校。 「2021.11.18」回了学校，打板子，发现了 360 的优美特效：占用 .exe 文件运行时间 1s. 「2021.11.19」晚上不知道干啥，心情随着🐏删除东西，格盘逐渐down起来。 明天之后高二好多人就退役了。。。。 而我平时除了 Dfkuaid，就高二的人玩的多了吧。 孩子还小，接受不了。 昨天晚上辗转睡不着。。 去阳台打开窗户吹了一段时间风。 风。 初冬风。 但是有点冷。 我在干啥。 我不知道。 于是就迷迷糊糊回去睡了。 半夜， 梦见 NOIP 成绩出了，我卡线1=？ 不懂。 不知道是在梦里醒了， 还是现实醒了。 我发现我在床上反着躺着。 于是正了过来，继续睡。 不知道为啥我要写这个。 不知道。","link":"/2021/11/17/NOIP2021Days/"},{"title":"平面最近点对","text":"平面最近点对 闲来无事，学个新东西。 问题概述求有 $n$ 个点的平面上欧几里得距离最近的两个点。 算法考虑分治，将当前的点集经过按照 $x$ 坐标为关键字排序之后，不断的分为两段分别求解再合并。 分治是好想的，问题是如何合并。 假设我们要合并的两个区间的最近距离分别是 $h_1,h_2$，取较小值之后记作 $h$，区间中点为 $mid$。然后将所有满足 $| x_mid - x_i | &lt; h$ 的点放到一个新的集合中。 然后再将这个集合按照 $y$ 为关键字排序，然后每次枚举两个点，只用满足 $| y_j - y_i | &lt; h$ 的点更新答案。 而最后这个满足条件的点集的大小最大为 $7$，OI-wiki 上有其证明。 Code这个是洛谷模板题 P1429的代码，复杂度为 $O(n \\log^2 n)$，使用缺省源「V5.2」。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566template&lt;typename J&gt;I J Hmin(const J &amp;x,const J &amp;y){ Heriko x&lt;y?x:y;}CI MXX(2e5+1);const double INF(1e12);I bool CMP(const pair&lt;double,double&gt; &amp;a,const pair&lt;double,double&gt; &amp;b){ Heriko a.second&lt;b.second;}I double Dist(const pair&lt;double,double&gt; &amp;a,const pair&lt;double,double&gt; &amp;b){ Heriko sqrt((long double)(a.first-b.first)*(a.first-b.first)+(long double)(a.second-b.second)*(a.second-b.second));}int n;pair&lt;double,double&gt; a[MXX],tmp[MXX];double Merge(int l,int r){ if(l==r) Heriko INF; int mid((l+r)&gt;&gt;1),top(0); double dis(INF); dis=Hmin(Merge(l,mid),Merge(mid+1,r)); for(int i(l);i&lt;=r;++i) if(fabs(a[mid].first-a[i].first)&lt;dis) tmp[++top]=a[i]; std::sort(tmp+1,tmp+1+top,CMP); for(int i(1);i&lt;=top;++i) for(int j(i+1);j&lt;=top;++j) { if(tmp[j].second-tmp[i].second&gt;=dis) break; dis=Hmin(dis,Dist(tmp[i],tmp[j])); } Heriko dis;}S main(){ Files(); fr(n); for(int i(1);i&lt;=n;++i) scanf(&quot;%lf%lf&quot;,&amp;a[i].first,&amp;a[i].second); std::sort(a+1,a+1+n); double ans(Merge(1,n)); printf(&quot;%.4lf&quot;,ans); Heriko Deltana;}","link":"/2022/01/04/Narest-points/"},{"title":"珂朵莉树","text":"Chtholly Tree 简记 「启」 关于为啥我要学这个？ 闲的。 本篇中所有 Code 的缺省源使用 「V5.2」. 「关于 ODT」 ODT 用处？ （大多数是）在有区间赋值操作的 DS 题里面骗分，因为好像专门为 ODT 设计的题不多吧？反正我只知道 CF896C. 时间复杂度？ ODT 的复杂度正确建立在数据随机上，这点一定牢记。 对于所有的基础操作（如 $Assign$ 和 $Add$ 等），使用 set 实现的 ODT 的复杂度为 $O(n \\log\\log n)$，而链表实现的复杂度为 $O(n \\log n)$，不过我目前只会用 set 实现就是了（ 注意事项？ ODT 的复杂度正确建立在数据随机上，ODT 的复杂度正确建立在数据随机上，ODT 的复杂度正确建立在数据随机上。不然的话出题人很容易构造数据让你 T 掉。 别被没有区间赋值的部分分卡了。 「实现」先是核心思想：把值相同的区间合并成结点，存到 set 里面。 于是就有了以下的结构体来存结点： 「结点 Node」1234567891011121314struct Node{ LL l,r; mutable LL v; Node(LL l,LL r=0,LL v=0) : l(l),r(r),v(v) {} I bool operator &lt; (const Node &amp;co) const { Heriko l&lt;co.l; }};set&lt;Node&gt; s; 这里的 mutable 是为了突破 const 的限制，便于我们后面直接修改 set 中的值，而不是拿出来改完再扔进去。 「分裂 Split」$Split$ 算是 ODT 中最重要的操作了，简单来说就是把区间 $[l,r]$ 分成 $[l,pos-1]$ 和 $[pos,r]$ 两段，便于我们操作。 实现也很简单，我们先用 set 自带的 lower_bound 确定 $pos$ 对应位置，然后删除原区间分成两半插入。 123456789101112131415161718I auto Split(LL pos){ auto it(s.lower_bound(Node(pos))); if(it!=s.end() and it-&gt;l==pos) Heriko it; --it; if(it-&gt;r&lt;pos) Heriko s.end(); LL l(it-&gt;l),r(it-&gt;r),v(it-&gt;v); s.erase(it); s.insert(Node(l,pos-1,v)); Heriko s.insert(Node(pos,r,v)).first;} 这样的话所有的区间 $[l,r]$ 上的操作都可以转化为 $[Split(l),Split(r+1)].$ 「推平 Assign」$Assign$ 也是很重要操作，主要就是完成缩点的任务，实现起来也很简单，找到区间之后删除插入新的就行。 123456I void Assign(LL l,LL r,LL x){ auto itr(Split(r+1)),itl(Split(l)); s.erase(itl,itr); s.insert(Node(l,r,x));} 实际上最基本的操作也就上面这俩了，下面再扩展一点常用的操作。 「区间加 Add」如何区间加呐？暴力。 嗯，没错就是暴力，找到对应区间之后暴力加就是了（ 1234567I void Add(LL l,LL r,LL x){ auto itr(Split(r+1)),itl(Split(l)); for(auto it(itl);it!=itr;++it) it-&gt;v+=x;} 「排名 Rank」查询区间排名的话，我们先声明一个结构体或者 pair 便于对相同的数操作。 1234567891011struct Rank{ LL val,cnt; Rank(LL val,LL cnt) : val(val),cnt(cnt) {} I bool operator &lt; (const Rank &amp;co) const { Heriko val&lt;co.val; }}; 然后我们就用最好想的思路，先找到对应区间，然后把所有的数排序，直接去找要求排名即可。 12345678910111213141516171819I LL QueryRank(LL l,LL r,LL x){ auto itr(Split(r+1)),itl(Split(l)); vector&lt;Rank&gt; v; for(auto it(itl);it!=itr;++it) v.push_back(Rank(it-&gt;v,it-&gt;r-it-&gt;l+1)); sort(v.begin(),v.end()); LL i(0); for(;i&lt;(LL)v.size();++i) if(v[i].cnt&lt;x) x-=v[i].cnt; else Heriko v[i].val; Heriko v[i].val;} 「其它 Other」其实观察上面的也能发现在 ODT 上的操作，先找到对应区间之后就很好办了，所有大概的代码框架都是这个样子： 123456I auto Function(int l,int r,...){ auto itr(Split(r+1)),itl(Split(l)); ...} 然后知道了这些就可以去把 CF896C 干掉了。 「CF896C Code」123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158CI MXX(1e5+1),MOD(1e9+7);LL n,m,seed,vmax,a[MXX];I LL GetData(){ LL res(seed); seed=(seed*7+13)%MOD; Heriko res;}I LL FstPow(LL x,LL y,LL p){ LL res(1); x%=p; while(y) { if(y&amp;1) (res*=x)%=p; (x*=x)%=p; y&gt;&gt;=1; } Heriko res;}struct Node{ LL l,r; mutable LL v; Node(LL l,LL r=0,LL v=0) : l(l),r(r),v(v) {} I bool operator &lt; (const Node &amp;co) const { Heriko l&lt;co.l; }};set&lt;Node&gt; s;I auto Split(LL pos){ auto it(s.lower_bound(Node(pos))); if(it!=s.end() and it-&gt;l==pos) Heriko it; --it; if(it-&gt;r&lt;pos) Heriko s.end(); LL l(it-&gt;l),r(it-&gt;r),v(it-&gt;v); s.erase(it); s.insert(Node(l,pos-1,v)); Heriko s.insert(Node(pos,r,v)).first;}I void Assign(LL l,LL r,LL x){ auto itr(Split(r+1)),itl(Split(l)); s.erase(itl,itr); s.insert(Node(l,r,x));}I void Add(LL l,LL r,LL x){ auto itr(Split(r+1)),itl(Split(l)); for(auto it(itl);it!=itr;++it) it-&gt;v+=x;}struct Rank{ LL val,cnt; Rank(LL val,LL cnt) : val(val),cnt(cnt) {} I bool operator &lt; (const Rank &amp;co) const { Heriko val&lt;co.val; }};I LL QueryRank(LL l,LL r,LL x){ auto itr(Split(r+1)),itl(Split(l)); vector&lt;Rank&gt; v; for(auto it(itl);it!=itr;++it) v.push_back(Rank(it-&gt;v,it-&gt;r-it-&gt;l+1)); sort(v.begin(),v.end()); LL i(0); for(;i&lt;(LL)v.size();++i) if(v[i].cnt&lt;x) x-=v[i].cnt; else Heriko v[i].val; Heriko v[i].val;}I LL QueryVal(LL l,LL r,LL x,LL y){ auto itr(Split(r+1)),itl(Split(l)); LL res(0); for(auto it(itl);it!=itr;++it) res=(res+FstPow(it-&gt;v,x,y)*(it-&gt;r-it-&gt;l+1)%y)%y; Heriko res;}S main(){ Files(); fr(n),fr(m),fr(seed),fr(vmax); for(int i(1);i&lt;=n;++i) a[i]=(GetData()%vmax)+1,s.insert(Node(i,i,a[i])); while(m--) { LL opt((GetData()%4)+1),l((GetData()%n)+1),r((GetData()%n)+1),x,y; if(l&gt;r) swap(l,r); if(opt==3) x=(GetData()%(r-l+1))+1; else x=(GetData()%vmax)+1; if(opt==4) y=(GetData()%vmax)+1; if(opt==1) Add(l,r,x); else if(opt==2) Assign(l,r,x); else if(opt==3) fw(QueryRank(l,r,x),1); else fw(QueryVal(l,r,x,y),1); } Heriko Deltana;} 「其它例题」调了三天 CF896C 最后发现是快速幂少了 x%=p 之后就做了一点简单 ODT 板子题。 「HAOI2014 贴海报」 HAOI2014 贴海报 这个题巨大显然了吧，贼板子吧。 只需要区间推平，最后开个桶记录一下就行了，直接切了对吧。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465CI MXX(1001);struct Node{ int l,r; mutable int val; Node(int l,int r=0,int val=0) : l(l),r(r),val(val) {} I bool operator &lt; (const Node &amp;co) const { Heriko l&lt;co.l; }};set&lt;Node&gt; s;I auto Split(int pos){ auto it(s.lower_bound(Node(pos))); if(it!=s.end() and it-&gt;l==pos) Heriko it; --it; if(it-&gt;r&lt;pos) Heriko s.end(); int l(it-&gt;l),r(it-&gt;r),v(it-&gt;val); s.erase(it); s.insert(Node(l,pos-1,v)); Heriko s.insert(Node(pos,r,v)).first;}I void Assign(int l,int r,int v){ auto itr(Split(r+1)),itl(Split(l)); s.erase(itl,itr); s.insert(Node(l,r,v));}int n,m,x,y,tot,ans(-1);bitset&lt;MXX&gt; vis;S main(){ Files(); fr(n),fr(m); s.insert(Node(1,n+1)); while(m--) fr(x),fr(y),Assign(x,y,++tot); for(auto it(s.begin());it!=s.end();++it) if(!vis[it-&gt;val]) ++ans,vis[it-&gt;val]=1; fw(ans,1); Heriko Deltana;} 「CF343D Water Tree」这个题是个树上问题，比较板的树剖（ 不过我们不写线段树，我们直接上 ODT，在两边 DFS 处理出来 id 序之后按照普通的序列操作即可。 第二个操作就需要我们在 DFS 的时候记录一下 top，修改的时候不断跳 top 进行 $Assign$ 即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143CI MXX(5e5+5);struct ODT{ int l,r; mutable int v; ODT(int l,int r=0,int v=0) : l(l),r(r),v(v) {} I bool operator &lt; (const ODT &amp;co) const { Heriko l&lt;co.l; }};set&lt;ODT&gt; s;I auto Split(int pos){ auto it(s.lower_bound(ODT(pos))); if(it!=s.end() and it-&gt;l==pos) Heriko it; --it; if(it-&gt;r&lt;pos) Heriko s.end(); int l(it-&gt;l),r(it-&gt;r),val(it-&gt;v); s.erase(it); s.insert(ODT(l,pos-1,val)); Heriko s.insert(ODT(pos,r,val)).first;}I void Assign(int l,int r,int x){ auto itr(Split(r+1)),itl(Split(l)); s.erase(itl,itr); s.insert(ODT(l,r,x));}struct Node{ int nex,to;}r[MXX&lt;&lt;1];int rcnt,head[MXX];I void Add(int x,int y){ r[++rcnt]=(Node){head[x],y},head[x]=rcnt; r[++rcnt]=(Node){head[y],x},head[y]=rcnt;}int n,m,sz[MXX],dep[MXX],id[MXX],top[MXX],fa[MXX],son[MXX],tot;void DFS1(int x,int fath){ sz[x]=1,fa[x]=fath,dep[x]=dep[fath]+1; for(int i(head[x]);i;i=r[i].nex) { int y(r[i].to); if(y==fath) continue; DFS1(y,x); sz[x]+=sz[y]; if(sz[y]&gt;sz[son[x]]) son[x]=y; }}void DFS2(int x,int tp){ top[x]=tp,id[x]=++tot; if(son[x]) DFS2(son[x],tp); for(int i(head[x]);i;i=r[i].nex) { int y(r[i].to); if(y==fa[x] or y==son[x]) continue; DFS2(y,y); }}I void ModifyZero(int x){ int tp(top[x]); while(tp!=1) { Assign(id[tp],id[x],0); x=fa[tp],tp=top[x]; } Assign(id[1],id[x],0);}S main(){ Files(); fr(n); for(int i(1);i&lt;n;++i) { int x,y; fr(x),fr(y); Add(x,y); } DFS1(1,0); DFS2(1,1); s.insert(ODT(0,MXX)); fr(m); while(m--) { int opt,x; fr(opt),fr(x); if(opt==1) Assign(id[x],id[x]+sz[x]-1,1); else if(opt==2) ModifyZero(x); else fw(Split(id[x])-&gt;v,1); } Heriko Deltana;} 「终」那么就写这些吧。","link":"/2021/12/05/ODT/"},{"title":"Predict of F1 2022","text":"关于 F1 2022 赛季的预测（ 同步于知乎：2022年新规大改后，哪些F1车队变数会特别大？ 冬测时的瞎想首先窝法冬测表现仍然不错，希望正赛能好一点，起码给 LEC 和 SAI 争冠的机会吧（ 麦队整个冬测的表现也没有太多的问题，而且好像大家关注点都不太在麦队上（ 梅奔在巴塞罗那和巴林拿出了两版车，巴塞罗那的测试很稳定，但是巴林测试的这个表现…… 反正我是看着 W13B 的直道表现真的令人无语……有点不像是藏东西（当然马桶狼老奸巨猾也不是没有可能 红牛 RB18 设计思路很多地方都很有意思，测试也基本上很稳定，小红牛除了巴塞罗那 GAS 撞了好像也比较平淡。不过感觉小红牛在巴林的表现不是很好的样子（ 马丁这车……从巴林的表现来看……估计要寄。VET 那几圈真是可以说惨目忍睹，一条赛道所有的可能锁死的地方都锁死了，甚至转向过度转向不足兼而有之…… 威廉姆斯整个冬测都很稳定，没有太大的亮点也没有什么槽点，感觉是比哈斯和阿尔法罗密欧强得多。 然后就是难兄难弟，哈斯和阿尔法罗密欧。 先是巴塞罗那的时候，两家车都一直因为各种原因寄掉，总里程数完全不够。巴塞罗那最后一天俄对乌特别行动，导致哈斯和乌拉尔钾肥的赞助关系取消，马泽平的席位后来也就没了（虽然换来了马格努森 冬测之前的瞎想争冠行列前面有位老哥已经大体说过了，我的感觉也差不多（ 首先就研发实力来说的话，梅奔应该是比较确定的独一档。 红牛因为今年的研发投入，明年车搞成啥样目前还没太有定数，不过就算崩了也不会太逊。 上游然后就是法拉利和迈凯伦，感觉就上赛季来看，今年这两家还是会争一段时间。 从研发角度来说，法家实力强一点，从今年仅有两个研发 token 的 SF21 的改进，以及赛季末期引擎升级来看，我更看好法家，当然迈凯伦适应梅奔动力单元之后带来的提升也是个未知数。 从车手角度来说 LEC 和 NOR 都是天赋异禀，但是就目前来看 SAI 的稳定发挥拿分是要比 RIC 强不少的。（说实话 RIC 适应了一个赛季的车是我没想到的，虽然迈队的车适合带速度入弯，不符合 RIC 开红牛和雷诺时期早刹车入弯的习惯，，但是一个赛季都没配合好还是觉得有点……） （UPD 2022.2.5 ：感谢知乎上米兰米兰​的补充：RIC 的习惯并不是晚刹车，是迈凯轮的车低速晚需要晚刹慢抬带比较重的 Trail Brake 导致的 RIC 不适应） 我个人还是希望这两家都能有个好的表现的（ 中游雷诺在 2021 失去了所有的客户车队之后，就剩下自己家的 Alpine 了（ 就今年的表现来说，奥康的皮夹和头哥的领奖台算是非常惊喜了，剩下的表现也都符合中游厂队的表现，至于研发方面，希望明年新引擎和新底盘能有好的表现吧（ 小红牛今年表现算是出色了，研发方面我感觉可能要寄（莫名），但是拿分还是非常稳的，角田明年应该能体现出来实力了，加斯利现在状态在顶峰，冲击领奖台还是有可能的。 当然这个策略组我是真的看不懂了……今年小红牛策略真的无语…… 马丁今年拉还是比较能感觉出来的，去年的地球组第一（当然粉红梅奔也不是吹的）变成今年的……绿色拖拉机，心疼一波歪头……太会选队了，大有头哥之势（ 明年的研发估计不会太有起色，毕竟研发方式就比较被动，说好听了叫做逆向开发，说不好听了就是比着梅奔改……今年削底板、改后悬挂带来的后果也是非常明显了，据说本赛季还是保持之前的研发策略不变……我估计要寄。 中下游都说哈斯放弃 2021 备战 2022 所以 2022 的成绩可能会有大的提升。确实，但是提升估计大不了，而且两位公子爷的表现无法预测，2022 将是哈斯生死攸关一年了，如果还是今年这个寄样，吉恩估计要卖队了。 至于因为小周而备受关注的阿尔法，明年的主要提升，估计在窝法引擎上，其它估计没啥看头（ 威廉姆斯今年稍有起色，但是我个人觉得 RUS 是火星人占据小半部分，明年估计威队或许能和马丁一战（？ ALB 的水平还是不错的，LAT 水平也一直有小的进步，威队 2022 表现还是值得期待的。 补充以上纯属个人根据最近两三个赛季的车队表现得出，因为是新规，所以不确定性还是很大的（ 万一窝法起来了呢（","link":"/2022/01/30/PredictOfF12022/"},{"title":"回滚莫队浅记","text":"浅谈回滚莫队。 前置知识之前写的普通莫队笔记，在这里当个前置知识，其实大约知道莫队大概就是把询问离线下来，分块并排序之后用两个指针 $l,r$ 来更新信息统计答案即可。 有时在区间转移的时候，有些删除或添加的操作无法实现，那么当只有一种操作不能实现的时候，就可以用莫队来解决这个问题，然而普通莫队是很难解决（或者说是不能解决）这个问题的，所以我们要对普通莫队进行改造，也就是回滚莫队。 本文出现所有代码缺省源使用V5.3. 「例题一」洛谷模板原题链接：P5906 【模板】回滚莫队&amp;不删除莫队。 「例题一」题目简述给定一个序列，多次询问一段区间 $[l,r]$，求区间中相同的数的最远间隔距离。 序列中两个元素的间隔距离指的是两个元素下标差的绝对值。 「例题一」思路简述首先来说这个题有什么操作不能实现。显然增加是好实现的，只需要每次在增加时更新距离信息（记录第一次出现和最后一次出现）即可。但是删除操作不能这样实现，因为在删除的时候若要更新答案，需要知道次大值……肯定是不能这样维护的，所以我们要让 $l$ 和 $r$ 在移动的过程中尽量避免删除操作，也就是尽量让 $l$ 向左端移动，$r$ 向右端移动。 那么我们每次枚举块，把块内的询问解决的时候，每次把 $l$ 拉回当前块的右端，然后保证 $r$ 只向右端移动，$l$ 不断根据询问反复横跳，对于在一个块内的询问暴力更新（复杂度 $O(\\sqrt{n})$，不过可能实际略大），否则跳两个指针更新答案。因为块的是 $O(\\sqrt{n})$ 的，所以对于每个询问，$l$ 的移动是 $O(\\sqrt{n})$ 的，所以这样做的复杂度就是 $O(n\\sqrt{m}).$ 「例题一」Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y) { Heriko x&gt;y?x:y;}template&lt;typename J&gt;I J Hmin(const J &amp;x,const J &amp;y) { Heriko x&lt;y?x:y;}CI MXX(2e5+1);int ans[MXX],a[MXX],b[MXX],n,blo[MXX],len,blocnt,qn,appeared[MXX],fstpos[MXX],lstpos[MXX],apn;struct Query { int l,r,id; I bool operator &lt; (const Query &amp;co) const { Heriko (blo[l]==blo[co.l])?(r&lt;co.r):(blo[l]&lt;blo[co.l]); }}q[MXX];int lst[MXX];I int Clac_Faster_Than_SF1000(int l,int r) { int res(0); for(int i(l);i&lt;=r;++i) lst[a[i]]=0; for(int i(l);i&lt;=r;++i) if(!lst[a[i]]) lst[a[i]]=i; else res=Hmax(res,i-lst[a[i]]); Heriko res;}S main() { Files(); fr(n),len=sqrt(n); for(int i(1);i&lt;=n;++i) fr(a[i]),b[i]=a[i]; sort(b+1,b+1+n); int nl(unique(b+1,b+1+n)-b-1); for(int i(1);i&lt;=n;++i) a[i]=lower_bound(b+1,b+1+nl,a[i])-b; for(int i(1);i&lt;=n;++i) blo[i]=(i-1)/len+1; blocnt=blo[n]; fr(qn); for(int i(1);i&lt;=qn;++i) fr(q[i].l),fr(q[i].r),q[i].id=i; sort(q+1,q+1+qn); int l(0),r(0),nw(1),tmpans(0); for(int i(1);i&lt;=blocnt;++i) { int rx(Hmin(n,i*len)); l=rx+1,r=rx,tmpans=0,apn=0; for(;blo[q[nw].l]==i;++nw) { if(blo[q[nw].r]==i) ans[q[nw].id]=Clac_Faster_Than_SF1000(q[nw].l,q[nw].r); else { while(r&lt;q[nw].r) { ++r; lstpos[a[r]]=r; if(!fstpos[a[r]]) fstpos[a[r]]=r,appeared[++apn]=a[r]; tmpans=Hmax(tmpans,r-fstpos[a[r]]); } int lsttmp(tmpans); while(l&gt;q[nw].l) { --l; if(lstpos[a[l]]) tmpans=Hmax(tmpans,lstpos[a[l]]-l); else lstpos[a[l]]=l; } ans[q[nw].id]=tmpans; while(l&lt;=rx) { if(lstpos[a[l]]==l) lstpos[a[l]]=0; ++l; } tmpans=lsttmp; } } for(int i(1);i&lt;=apn;++i) fstpos[appeared[i]]=lstpos[appeared[i]]=0; } for(int i(1);i&lt;=qn;++i) fw(ans[i],1); Heriko Deltana;} 「例题二」AT1219 歴史の研究原题链接：AtCoder-JOI2014 歴史の研究； 洛谷链接：AT1219 歴史の研究。 「例题二」题目简述给出长度为 $N$ 的序列，$Q$ 次询问，每次询问区间 $[L,R]$ 中最大的重要度。 重要度的定义为当前事件的权值 $X_i$ 乘上事件在区间中出现次数 $T_i.$ 「例题二」思路简述和上个题一样，这个题添加操作也是很好实现的，维护一个桶即可，删除操作一样的不能实现，所以我们用同样的策略。 「例题二」Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y) { Heriko x&gt;y?x:y;}template&lt;typename J&gt;I J Hmin(const J &amp;x,const J &amp;y) { Heriko x&lt;y?x:y;}CI MXX(2e5+1);int a[MXX],b[MXX],lx[MXX],rx[MXX],blo[MXX],n,qn,len,blocnt,cnt[MXX],co[MXX];LL ans[MXX],tmpans;struct Query { int l,r,id; I bool operator &lt; (const Query &amp;co) const { Heriko blo[l]==blo[co.l]?r&lt;co.r:l&lt;co.l; }}q[MXX];I void Add(int x) { ++cnt[a[x]]; tmpans=Hmax(tmpans,(LL)cnt[a[x]]*b[a[x]]);}S main() { Files(); fr(n),fr(qn),len=sqrt(n),blocnt=n/len; for(int i(1);i&lt;=n;++i) fr(a[i]),b[i]=a[i]; for(int i(1);i&lt;=qn;++i) fr(q[i].l),fr(q[i].r),q[i].id=i; sort(b+1,b+1+n); int nl(unique(b+1,b+1+n)-b-1); for(int i(1);i&lt;=n;++i) a[i]=lower_bound(b+1,b+1+nl,a[i])-b; for(int i(1);i&lt;=n;++i) blo[i]=(i-1)/len+1; for(int i(1);i&lt;=blocnt;++i) lx[i]=rx[i-1]+1,rx[i]=lx[i]+len-1; if(rx[blocnt]&lt;n) ++blocnt,lx[blocnt]=rx[blocnt-1]+1,rx[blocnt]=n;//这里用了一种和前面不同的处理每个块端点的方法，都不难写 int l(0),r(0),nw(1); sort(q+1,q+1+qn); for(int i(1);i&lt;=blocnt;++i) { mst(cnt,0); r=rx[i],tmpans=0; while(blo[q[nw].l]==i) { l=rx[i]+1; if(q[nw].r-q[nw].l&lt;=len) { mst(co,0); LL anothertmpans(0); for(int i(q[nw].l);i&lt;=q[nw].r;++i) ++co[a[i]]; for(int i(q[nw].l);i&lt;=q[nw].r;++i) anothertmpans=Hmax(anothertmpans,(LL)co[a[i]]*b[a[i]]); for(int i(q[nw].l);i&lt;=q[nw].r;++i) --co[a[i]]; ans[q[nw].id]=anothertmpans; } else { while(q[nw].r&gt;r) Add(++r); LL lsttmp(tmpans); while(q[nw].l&lt;l) Add(--l); ans[q[nw].id]=tmpans; tmpans=lsttmp; while(l&lt;=rx[i]) --cnt[a[l++]]; } ++nw; } } for(int i(1);i&lt;=qn;++i) fw(ans[i],1); Heriko Deltana;} 终了终了。","link":"/2022/02/22/Rollback-Mo-s-Algorithm/"},{"title":"SEKAI R1 赛后认锅","text":"我是锅王。 前言首先呢，我是傻逼，昨天因为加字幕去了忘了二次验题。 得分情况总体正常，不再说，下面来一一说我的锅。 A 憧憬の翼 题目链接 题目背景歌曲链接 于是我们贪心的从和里面，答案即为 $\\left\\lfloor\\dfrac{sum}{x^y}\\right\\rfloor.$ STD 就不放了，反正签到题。 B HelloWorld2022 视频链接 这题本身是一个树上每次将结点修改为其子树中最大值，每次询问子树中最大值的题，但是我寻思学弟学妹应该还不是都会树链剖分，所以就削了一刀到序列上了。 但是我今天上课的时候突然想起来这玩意好像不太能 $O(n \\log n)$ 的做，但是不能及时过来说，所以真的很对不起。 C Identity 题目链接 歌曲链接 这个题本身是周末闲的没事想起来的一个东西，因为看起来问题好像也挺经典，所以拿来出应该也不会太难。 然后最后 STD 有个地方溢出了于是数据锅了，真的很对不起。 60 分做法设 $F(n,m)$ 表示考虑将 $n$ 个区域用 $m$ 种颜色分。 首先考虑边界，显然 $F(1,m)=n,F(2,m)=m(m-1),F(3,m)=m(m-1)(m-2).$ 然后，我们先把这个圆拆为一条链，即不考虑首尾互斥的情况，那么答案显然是 $m(m-1)(m-1)\\cdots(m-1)=m(m-1)^{n-1}$，然后我们考虑首尾冲突，可得多出来的方案数正好是 $n-1$ 块用 $m$ 种颜色填的情况，那么就有转移方程 $F(n,m)=m(m-1)^{n-1}-F(n-1,m).$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*60pts Solution By Dfkuaid*/#define LOCAL#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int N = 100010;const int INF = 0x3f3f3f3f;const ll MOD = 1e9 + 7;template &lt;typename T&gt; inline void read(T &amp;x) { x = 0; int f = 1; char c = getchar(); for (; !isdigit(c); c = getchar()) if (c == '-') f = -f; for (; isdigit(c); c = getchar()) x = x * 10 + c - '0'; x *= f;}ll n, m, ans, t;inline ll fpow(ll a, int b) { ll res = 1; while (b) { if (b &amp; 1) (res *= a) %= MOD; b &gt;&gt;= 1, a = a * a % MOD; } return res;}inline void MAIN() { read(n), read(m); if (n == 1) ans = m; else if (n == 2) ans = m * (m - 1) % MOD; else ans = m * (m - 1) % MOD * (m - 2) % MOD; for (int i = 4; i &lt;= n; ++ i) ans = (m * fpow(m - 1, i - 1) % MOD - ans + MOD) % MOD; printf(&quot;%lld\\n&quot;, ans);}int main() {#ifdef LOCAL freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);#endif read(t); while (t --) MAIN(); return 0;} 100 分做法首先，上面不考虑首尾矛盾的情况的柿子可以表示成这样： $$m(m-1)^{n-1} = a_n + a_{n-1}$$ 没错，这玩意最后能变成一个可以求通项的东西，下面写一下： $$\\begin{aligned}m(m-1)^{n-1} &amp;= a_n + a_{n-1} \\\\\\a_n &amp;= -a_{n-1}+m(m-1)^{n-1} \\\\\\\\\\\\a_n+x(m-1)^n &amp;= -[a_{n-1}+x(m-1)^{n-1}] \\\\\\a_n &amp;= -a_{n-1}-x(m-1)^{x-1}-x(m-1)^n \\\\\\ &amp;= -a_n-x(m-1)^{n-1}\\cdot(1+m-1)\\\\\\ &amp;= -a_n-x(m-1)^{n-1}m \\\\\\\\Rightarrow x&amp;=-1\\\\\\\\\\\\a_n-1(m-1)^n &amp;= -[a_{n-1}-1(m-1)^{n-1}]\\\\\\\\because a_3&amp;=m(m-1)(m-2)\\\\\\\\therefore a_n-1(m-1)^n &amp;= -[a_3-1(m-1)^3]\\cdot(-1)^{n-3}\\\\\\ &amp;= a_n=(m-1)^n+(m-1)\\cdot(-1)^{n-1}\\\\\\ &amp;= (m-1)^n+(-1)^n\\cdot(m-1)\\\\\\\\end{aligned}$$ 1234567891011121314151617181920212223242526272829303132333435363738CI MOD(1e9+7);I LL FstPow(LL x,LL y) { x%=MOD; LL res(1); while(y) { if(y&amp;1) (res*=x)%=MOD; (x*=x)%=MOD; y&gt;&gt;=1; } Heriko res;}LL T,n,m,ans;S main() { Files(); fr(T); while(T--) { fr(n),fr(m); ans=FstPow(m-1,n)%MOD; if(n&amp;1) ans-=(m-1); else ans+=(m-1); fw(ans%MOD,1); } Heriko Deltana;} D 世界寿命と最後の一日 题目链接 歌曲链接 题解","link":"/2022/03/16/SEKAI-R1/"},{"title":"Start.","text":"此博客启用于 2021.10.30 再进行了一些列调试之后，这个博客大约可以开始正常使用力ヽ(✿ﾟ▽ﾟ)ノ 那么就开始啦，这个博客（ 这个博客目前好像和 Cnblogs 的那个博客没太有区分度呐（ 不过以后肯定会不太一样罢，这边会更新一些生活上的东西罢，而那边更偏向 OI 的样子。 目前是这样想的，其它以后再说吧，现在还不知道呐（ ε=ε=ε=(~￣▽￣)~ 大约是关于我的东西。","link":"/2021/10/30/Start/"},{"title":"Tarjan","text":"铊金金。 「启」之前一直没空写，NOIP 考前重新学了一下，虽然考场上完全没用到就是了。 大概按照 OI-Wiki 来简单写一点。 同步发布于Cnblogs. 「Pre」首先是一些前置知识。 「强连通分量」在有向图 $G$ 中强连通是指 $G$ 中的任意两个节点联通，强连通分量则是极大的强连通子图。 强连通分量的英文是 Strongly Connected Components，简称 SCC. 「DFS 搜索树」 除了普通的树边之外，DFS 搜索树中还有可能出现以下三种类型的边： 回边（红），即指向祖先结点的边。 横叉边（蓝），即边的另一端是一个已经遍历过，但不是当前结点祖先的点。 前向边（绿），搜索时遇到一个子树中的结点生成的。 那么在这颗搜索树中求 SCC，有以下的性质： 设结点 $x$ 为某个 SCC 在搜索树中遇到的第一个结点，那么这个 SCC 的剩余结点一定是搜索树中以 $x$ 为根的子树中。 可以反证证明：设有一个结点 $y$ 在当前 SCC 中但是不在搜索树中以 $x$ 为根的子树中，那么 $x$ 到 $y$ 的路径上一定有一条离开子树的边，即存在一条横叉边或者回边，然而根据定义发现两条边要求指向的结点是被访问过的，这和 $x$ 的定义矛盾，得证。 「Tarjan」Tarjan 主要是为每个结点 $x$ 维护了两个变量：dfn[x] 和 low[x]. 前者表示在 DFS 时 $x$ 被遍历到的次序，后者表示 $x$ 能回溯到的 dfn 最小的栈中的结点。显然的是后者可以用未访问过的子树中的结点 $y$ 的 low[y] 来更新，否则用 dfn[y] 更新。 「Code」之前的模板库里放了个栈用 vector 的，这里再放一个手写栈的，缺省源使用 「V5.2」. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465template &lt;typename J&gt;I J Hmin(const J &amp;x,const J &amp;y){ Heriko x&lt;y?x:y;}CI MXX(5e4+1),NXX(1e4+1);int n,m;struct Node{ int nex,to;}r[MXX];int rcnt,head[NXX];I void Add(int x,int y){ r[++rcnt]=(Node){head[x],y}; head[x]=rcnt;}int dfn[NXX],low[NXX],dfsid,stak[NXX],top,sz[NXX],scc[NXX],scctot;bitset&lt;NXX&gt; instak;void Tarjan(int x){ low[x]=dfn[x]=++dfsid; stak[++top]=x,instak[x]=1; for(int i(head[x]);i;i=r[i].nex) { int y(r[i].to); if(!dfn[y]) { Tarjan(y); low[x]=Hmin(low[x],low[y]); } else if(instak[y]) low[x]=Hmin(low[x],dfn[y]); } if(dfn[x]==low[x]) { ++scctot; while(stak[top]!=x) { scc[stak[top]]=scctot; ++sz[scctot]; instak[stak[top]]=0; --top; } scc[stak[top]]=scctot; ++sz[scctot]; instak[stak[top]]=0; --top; }} 「终」还是，不知道啥时候写游记（","link":"/2021/12/05/Tarjan/"},{"title":"树链剖分中的边权变点权","text":"浅谈树链剖分中的边权变点权 前言因为我只会轻重链剖分，所以下面都是说的轻重链剖分。 发现自己会写这个也有很长时间了，所以来水丶东西。 最近写了好两个，稍微借题来搞一搞，估计篇幅会很短，因为主要是简单说一说思路啥的。 思路首先，都知道树链剖分是用来维护一棵树上的结点信息的一种思想，而对于一些题，我们需要维护树上的边权，于是我们就需要将边权等效替换到点权上。 貌似这样的题在洛谷上的评级都是紫，但是其实没那么难（话说你谷评级啥时候准过。。） 首先简单画棵树： 显然如果我们要把边权变为点权，需要把权值化到边的两端。 而因为一个结点会出现对应多条边的情况，所以我们将权值放到深度浅的结点是不合适的，于是我们把他放在深度深的那个点： 于是我们就可以进行快乐的操作了。 实现线段树部分显然是不用动了，因为我们不需要对线段树做出特定的要求，换句话说，如果写树状数组或者珂朵莉树的话也是可以用的。 于是就来看前置的两个 DFS 和后面的树链部分需要作何修改。 DFS首先，因为我们要重新划归权值到点上，所以我们需要建立一个映射到点上的权值数组，这个直接在遍历的时候建立即可。 1234567891011121314151617181920void DFS1(int x,int fath){ sz[x]=1,fa[x]=fath; for(int i(head[x]);i;i=r[i].nex) { int y(r[i].to),v(r[i].val); if(y==fath) continue; dep[y]=dep[x]+1; tmp[y]=v;//这里 tmp 就是。 DFS1(y,x); sz[x]+=sz[y]; if(sz[y]&gt;sz[son[x]]) son[x]=y; }} 然后，因为我们还需要建立原树结点到线段树上的结点的映射，所以方便起见把权值也映射过去（ 1234567891011121314151617void DFS2(int x,int tp){ top[x]=tp,id[x]=++cnt,antid[cnt]=x,a[cnt]=tmp[x];//这里的 a 就是。 if(son[x]) DFS2(son[x],tp); for(int i(head[x]);i;i=r[i].nex) { int y(r[i].to); if(y==fa[x] or y==son[x]) continue; DFS2(y,y); }} 树链部分需要注意到的是我们询问一段路径上的边权最大值的时候，由于我们把权值全部下方到深度深的结点，所以路径上最浅结点的权值是不能计算在内的： 于是我们把原本修改和查询中最后在一条链上的情况稍作修改，即从 Modify(1,id[x],id[y],v); 和 Query(1,id[x],id[y]); 变为 Modify(1,id[x]+1,id[y],v); 和 Query(1,id[x]+1,id[y]);. 全部代码即为： 12345678910111213141516171819202122232425262728293031323334353637I void MTree(int x,int y,int val){ while(top[x]!=top[y]) { if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); Modify(1,id[top[x]],id[x],val); x=fa[top[x]]; } if(dep[x]&gt;dep[y]) swap(x,y); Modify(1,id[x]+1,id[y],val);}I int QTree(int x,int y){ int res(0); while(top[x]!=top[y]) { if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); res+=Query(1,id[top[x]],id[x]); x=fa[top[x]]; } if(dep[x]&gt;dep[y]) swap(x,y); res+=Query(1,id[x]+1,id[y]); Heriko res;} 例题洛谷 | P1505 旅游 [国家集训队] Time: 1s | Memory: 256Mb 这道题就需要用到上面的操作把边权下放到点权。 当然，因为这个题的特殊性（需要维护最大值、最小值、区间和），所以代码会很长（（ 不过还是不难的，线段树多复制几个函数分别维护即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define Heriko return#define Deltana 0#define Romanno 1#define S signed#define LL long long#define R register#define I inline#define CI const int#define mkp(a,b) make_pair(a,b)#define mst(a,b) memset(a,b,sizeof(a))#define ON std::ios::sync_with_stdio(false);cin.tie(0)#define Files() freopen(&quot;RNMTQ.in&quot;,&quot;r&quot;,stdin);freopen(&quot;RNMTQ.out&quot;,&quot;w&quot;,stdout)using namespace std;template&lt;typename J&gt;I void fr(J &amp;x){ short f(1); x=0; char c(getchar()); while(c&lt;'0' or c&gt;'9') { if(c=='-') f=-1; c=getchar(); } while(c&gt;='0' and c&lt;='9') { x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^=48); c=getchar(); } x*=f;}template&lt;typename J&gt;I void fw(J x,bool k){ if(x&lt;0) x=-x,putchar('-'); static short stak[35]; short top(0); do { stak[top++]=x%10; x/=10; } while(x); while(top) putchar(stak[--top]+'0'); k?puts(&quot;&quot;):putchar(' ');}template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y){ Heriko x&gt;y?x:y;}template&lt;typename J&gt;I J Hmin(const J &amp;x,const J &amp;y){ Heriko x&lt;y?x:y;}CI MXX(2e5+1),INF(0x7fffffff);struct Edge{ int nex,to,val;}r[MXX&lt;&lt;1];int rcnt,head[MXX];I void Add(int x,int y,int z){ r[++rcnt]=(Edge){head[x],y,z},head[x]=rcnt; r[++rcnt]=(Edge){head[y],x,z},head[y]=rcnt;}int tmp[MXX],cnt,a[MXX],sz[MXX],fa[MXX],dep[MXX],son[MXX],top[MXX],id[MXX],antid[MXX];void DFS1(int x,int fath){ sz[x]=1,fa[x]=fath; for(int i(head[x]);i;i=r[i].nex) { int y(r[i].to),v(r[i].val); if(y==fath) continue; dep[y]=dep[x]+1; tmp[y]=v; DFS1(y,x); sz[x]+=sz[y]; if(sz[y]&gt;sz[son[x]]) son[x]=y; }}void DFS2(int x,int tp){ top[x]=tp,id[x]=++cnt,antid[cnt]=x,a[cnt]=tmp[x]; if(son[x]) DFS2(son[x],tp); for(int i(head[x]);i;i=r[i].nex) { int y(r[i].to); if(y==fa[x] or y==son[x]) continue; DFS2(y,y); }}#define lc(x) (x&lt;&lt;1)#define rc(x) (x&lt;&lt;1|1)struct Node{ int l,r,tg,mx,mi,v;}t[MXX&lt;&lt;2];I void Pushup(int x){ t[x].mi=Hmin(t[lc(x)].mi,t[rc(x)].mi); t[x].mx=Hmax(t[lc(x)].mx,t[rc(x)].mx); t[x].v=t[lc(x)].v+t[rc(x)].v;}I void Cover(int x){ t[x].tg^=1; t[x].v=-t[x].v; t[x].mi=-t[x].mi; t[x].mx=-t[x].mx; swap(t[x].mi,t[x].mx);}I void Pushdown(int x){ if(!t[x].tg) Heriko; Cover(lc(x)); Cover(rc(x)); t[x].tg=0;}void Build(int x,int l,int r){ t[x].l=l,t[x].r=r,t[x].tg=0; if(l==r) { t[x].v=t[x].mi=t[x].mx=a[l]; Heriko; } int mid((l+r)&gt;&gt;1); Build(lc(x),l,mid); Build(rc(x),mid+1,r); Pushup(x);}void ModifyOne(int x,int pos,int val){ if(t[x].l==t[x].r) { t[x].mx=t[x].mi=t[x].v=val; Heriko; } Pushdown(x); int mid((t[x].l+t[x].r)&gt;&gt;1); if(pos&lt;=mid) ModifyOne(lc(x),pos,val); if(pos&gt;mid) ModifyOne(rc(x),pos,val); Pushup(x);}void ModifyAll(int x,int lx,int rx){ if(lx&lt;=t[x].l and t[x].r&lt;=rx) { Cover(x); Heriko; } Pushdown(x); int mid((t[x].l+t[x].r)&gt;&gt;1); if(lx&lt;=mid) ModifyAll(lc(x),lx,rx); if(rx&gt;mid) ModifyAll(rc(x),lx,rx); Pushup(x);}int QueryMax(int x,int lx,int rx){ if(lx&lt;=t[x].l and t[x].r&lt;=rx) Heriko t[x].mx; Pushdown(x); int res(-INF),mid((t[x].l+t[x].r)&gt;&gt;1); if(lx&lt;=mid) res=Hmax(res,QueryMax(lc(x),lx,rx)); if(rx&gt;mid) res=Hmax(res,QueryMax(rc(x),lx,rx)); Heriko res;}int QueryMin(int x,int lx,int rx){ if(lx&lt;=t[x].l and t[x].r&lt;=rx) Heriko t[x].mi; Pushdown(x); int res(INF),mid((t[x].l+t[x].r)&gt;&gt;1); if(lx&lt;=mid) res=Hmin(res,QueryMin(lc(x),lx,rx)); if(rx&gt;mid) res=Hmin(res,QueryMin(rc(x),lx,rx)); Heriko res;}int QuerySum(int x,int lx,int rx){ if(lx&lt;=t[x].l and t[x].r&lt;=rx) Heriko t[x].v; Pushdown(x); int res(0),mid((t[x].l+t[x].r)&gt;&gt;1); if(lx&lt;=mid) res+=QuerySum(lc(x),lx,rx); if(rx&gt;mid) res+=QuerySum(rc(x),lx,rx); Heriko res;}I void MTree(int x,int y){ while(top[x]!=top[y]) { if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); ModifyAll(1,id[top[x]],id[x]); x=fa[top[x]]; } if(dep[x]&gt;dep[y]) swap(x,y); if(x!=y) ModifyAll(1,id[x]+1,id[y]);}I int QTreeMax(int x,int y){ int res(-INF); while(top[x]!=top[y]) { if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); res=Hmax(res,QueryMax(1,id[top[x]],id[x])); x=fa[top[x]]; } if(dep[x]&gt;dep[y]) swap(x,y); if(x!=y) res=Hmax(res,QueryMax(1,id[x]+1,id[y])); Heriko res;}I int QTreeMin(int x,int y){ int res(INF); while(top[x]!=top[y]) { if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); res=Hmin(res,QueryMin(1,id[top[x]],id[x])); x=fa[top[x]]; } if(dep[x]&gt;dep[y]) swap(x,y); if(x!=y) res=Hmin(res,QueryMin(1,id[x]+1,id[y])); Heriko res;}I int QTreeSum(int x,int y){ int res(0); while(top[x]!=top[y]) { if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); res+=QuerySum(1,id[top[x]],id[x]); x=fa[top[x]]; } if(dep[x]&gt;dep[y]) swap(x,y); if(x!=y) res+=QuerySum(1,id[x]+1,id[y]); Heriko res;}int n,m;pair&lt;int,int&gt; E[MXX];S main(){ Files(); fr(n); for(int i(1);i&lt;n;++i) { int x,y,z; fr(x),fr(y),fr(z); Add(x+1,y+1,z); E[i].first=x+1,E[i].second=y+1; } fr(m); DFS1(1,0); DFS2(1,1); Build(1,1,n); while(m--) { char opt[10]; int x,y; scanf(&quot;%s&quot;,opt+1),fr(x),fr(y); if(opt[1]=='C') { if(dep[E[x].first]&gt;dep[E[x].second]) ModifyOne(1,id[E[x].first],y); else ModifyOne(1,id[E[x].second],y); } else if(opt[1]=='N') MTree(x+1,y+1); else if(opt[1]=='S') fw(QTreeSum(x+1,y+1),1); else if(opt[1]=='M' and opt[2]=='A') fw(QTreeMax(x+1,y+1),1); else if(opt[1]=='M' and opt[2]=='I') fw(QTreeMin(x+1,y+1),1); } Heriko Deltana;} 关于这道题做完之后在杂题记录里的感想： 我在上个题的时候曾经说过： 不得不说虽然长是长了点，树剖还是好玩的，对于我这种没有脑子的人来说，不用想就能打的东西太好了。 确实，于是这个题的代码长度就成为了我目前为止通过代码中最长的，415 行，7Kb。（当然，和我码风有空行有关系） 树剖部分基本是一遍写对的，最后错了半天是因为题目说的边的编号要是 $0 \\sim n-1$，但是我读入的时候忘了 +1，害的我把前面的重新看了一遍。。 但是还好这是 7Kb 的树剖而不是其它别的什么鬼东西。 终声水完力（","link":"/2022/01/08/Tree-chain-splitting/"},{"title":"WC 2022 线上游记","text":"WC 2022 线上游记。 Day -?WC 又一次因为疫情改到了线上，于是我也有了机会进行一个报名（ Day 0下午开幕式，体验很莫名，但是居然有人跳舞是我没想到的。 Day 1早上直接来机房，好事（虽然不如放假，但是也比上 whk 好得多了），进行一个语文课文的背（ 上午上午是刘汝佳老师和曹钦翔讲的信息学竞赛中的直觉与证明。 首先是一个证明一些贪心和 DP 决策正确性的常见证明思路，就是要证明在任何时刻换一个决策都不会有更好的结果，因为我们会有很多的直觉（我没有），所以证明这些直觉是否正确是一个很重要的东西（ 讲了一种方法： Exchange Argument：假设存在一个更优的算法和我们的决策相接近，然后通过交换两个算法里的一个步骤（或元素），得到一个新的更优的算法，同时这个算法比前一个最优算法更接近于我们的贪心算法，从而得到矛盾，原命题成立。过程就是交换元素后比较，不算难理解。 决策规范化是个好东西，有时可以同时简化思路、证明和代码。 找反例也是一个好习惯，可以精准的知道一个错误算法的缺陷到底在哪，当然若找不到，也是一种证明的过程，在时间有限的情况下，如果找了很多看起来能推倒当前结论的“反例”，那么也算是一种相对可信的证明过程（当然前提是你的“反例”有足够的强度）。 当然把东西抽象出来也是好事，便于我们分析东西。 还有一个 rewrite，即改写，常用来证明等价性，常见的例子就是多项式展开、微积分（我不会）、手玩过程展开等 第一段的时候讨论区无人发言，课间就变得活跃了起来，然后上课就一直很活跃了（ 草，第二节突然开始提速，SPEEEEEED UP. 第三节持续 SPEEEEEED UP（坏 两分钟一道题，害怕，害怕。 下午下午的第一课堂是：网站可靠性工程中的算法，老师是钟诚。 第二课堂是链表相关，但是我看了一遍课件只有跳跃表我不会，但是前段时间 tyy 画的不用学的东西里就有这个（ 所以就去第一课堂听，然后顺便整理一下上午的内容。 中间老师为了铺垫放了一段某电影的预告片，结果班主任进入机房问我为什么看电影。。 然后中间因为打错个字被管理员踢出去了（？ 不能理解哦。 然后因为疫情我不能通校了，但是……为什么学弟学妹今天就直接放假了（？ 不懂哦（ 前面那个事情，是因为管理员说要把说*脏话*的人踢出去，起因是老师一不小心说了个：wc，非常符合主题（bushi 然后截止到五点，已经出现了 3*wc了（ 但是我寻思我也没发脏字啊（？ 不理解哦（ 晚上晚上是集训队大佬们的交流分享，先是”浅谈一类哈希表的复杂度分析“。 说是和 OI 里学的关系不算很大，当作科普（ 那么就听吧，顺便把刚才选的树剖 + 李超线段树写一写（ 飞速讲完，居然是多人讲么，我还以为是就一个人（ 然后是“双射在划分计数上的应用”，有例题（ 然后是“模拟费用流”，这个时候正好我那题写完了，但是……略离谱，样例都不对。 然后是……额这位大佬比较特别，ppt 名字就叫营员交流（ 然后晚上就一直在调 [SDOI2016]游戏……死活找不到错……日。 Day2上午第一课堂看起来像是给集训队爷颓废指点前方道路的课，于是来第二课堂听网络瘤（ 讲课老师是李健欸（ 这些边我不加，这些边我不加，暴力怎么做？ 加边加边加边，冰茶姬查询（ 然鹅他今天讲的网络瘤（ 下午钱易佬讲 DS 杂题，这不得听之。 但是发现越来越写不出来笔记了（呆 前面能跟上，后面直接掉线（呆 下课之后有位同学放出来了自己的灵梦fumo（好 Day3上午dmy 讲杂题ww “我不会啊我就是个憨憨” ”不要急优势在我“ “有一个憨憨故事……啊三国演义，就锦囊” “怎么这么多评论区，哦说我现写，没有关系我和大家同场竞技” 《我是椰树牌椰汁的粉丝，我很会排版》 神峰：金 句 频 出 神虎：我宣布，这里就是金句广场 “有些同学说没听懂，没听懂还加个问号，那就是听懂了”（确信 “初三开始给北京队讲，讲到现在” 《没问题》 《大家都很有智慧，谢谢大家》 “恍然大雾我也不知道是恍然还是大雾，这可能是个偏义复词” 《连 根 拔 起》 《掀起波兰》 神虎：《dmy 掀起波兰》 “大家都是成熟的 OI 人了都会很熟练的使用 $\\LaTeX$ 拉泰科了大家自己渲染一下” “给大家表演一下找代码，给大家表现一下我的技术（计数？）实力，我是纯憨憨，一个野蛮人” “哇我粘一下” “我给大家放大，很大很大“（指超出屏幕 “return (0-0);//&lt;3” “这个题目很好，好就好在它什么是地方都很好，就都很好” “我认为这个题很好，你们都应该看看，因为这个题很好，就大家多看看非常好” “不是说这个题怎么，他就是非常好” “这个题很好，真的很好，非常有教育意义，就是对于刚学 DP” “有人会 $O(n^4)$，有人会 $O(n^3)$，有人会 $(2^n)$，有人会 $O(n^2 \\log n)$，这个题就是好在这个地方“ ”有的人读不懂题，确实” “啊对对对对，苹果输入法她很憨” “哎呀不想共享桌面，这样的话其他同学给我编做法就会被看见了” “优势在我，在不在，好像不太在” “我跟几个老哥交流做法，然后他们过来我没过就有点难过”（看起来是物理难过（ “腾讯会议设计的人是个鬼才，大家以后设计东西一定不要设计成这样，我登录一下输验证码 10 几次” “这题当时只有三个人过” “这个题（指上面那个三个人过的题）还是挺简单的” “很奇怪的就是做出来的好像都赢过 IOI” “后面还有好多道题，没有关系，优势（逐渐小声）……优势在谁（声音渐无）” 《benq写了一年，dmy写了十分钟》 《benq怎么做到的 很难理解》 《很难理解》 《benq的不会的题 我会 都是好题》 “不要慌，优势在我，给大家表演一下光速讲课，我超会讲的啦，给大家共享一下，做大共享家” “这题我 20 分钟就过了，下个题我用了 114514 分钟” “这和我最近写的论文差不多，但是我写的论文的方法吊打他，这个不需要我论文的做法” “剩下还有六道题，四十分钟够了，不要急，优势在我” 《luogu上能有加强版？》 《luogu这么有实力的吗》 “我题解进步很大，自从我用了太婆rua” “现在快晚上一点了，明天还有考试，上个大学怎么这么多事嘛” 《构造主要就是图一乐》 《T姓选手》 “我电脑怎么卡了” 《冷静一下，不要寄》 《人工智能觉醒》 《裹上鸡蛋面包糠》 《苹果就这？》 《有人在用他挖矿》 《苹 果 就 是 垃 圾》 《卡老师，不卡》 神虎：#【】老师 SSH 侵入 MIT 网络并给 dmy 电脑下病毒# 《是因为苹果太好了，所以永不重启》 一上午的金句（ 发现同样的记录人：邓老师2022冬令营讲课简介 下午鱼大讲构造，不过莫名 rap（ 我构造不能，冬眠营（ 草，完全掉线，写题去了（ Day4上午大约只有第一课堂能听了吧（ 那就听彭老师讲 IOI2022 题目预测吧（ 虽然我这辈子估计都看不到IOI、NOI（ 说到动态电阻是 CTSC 标准题目（ #物理被四大学科夺舍 ¯\\\\_(ツ)_/¯ 这表情好好笑（ IOI: Host didn’t want a 600 dmy: 优势在我 冬令营梗蜂以及梗鼠： 椰树：dmy：《我是椰树牌椰汁的粉丝，我很会排版》 fumo：上面说到了。 土拨鼠：今天老师喜欢使用土拨鼠来表示惊讶（ 仓鼠：…… 离谱题： 下午DCX 讲杂题（ 之前在 zr 听他讲题就觉得他声音特别像张京华，现在越听越像（ 就是声音像张京华，说话方式像 Tim（影视飓风） 观看了评论区的 dmy 名言之后，发出感叹：《邓老师好有水平》 草，综合版 晚上测试平台，额……和 NOI ONLINE/NOI 同步赛是一样的平台，给的测试题是 NOIO 2020 #3 入门组题目 幸好不是那个 T2 紫题的 NOIO 入门。 T1 读错题了（ 然后做的还挺快的，没多久就全交上了，洛谷测了应该都对。 今天晚上回家，希望明天考试 RP++. Day5 因为今天考试而我又非常菜啥都不会，所以没有什么东西可以记的 上午昨天晚上定了早上六点半的铃，铃响，我醒了，非常冷静的关掉了铃，然后接着睡（ 最后是七点起的床（ 八点二十多的时候把东西大约都准备好了（指本地的文件夹 然后就开始做。 上来看 T1，怎么又是括号序列，我谢谢你，大约分析了十分钟左右发现可以将题目中给的操作转化为括号树上的旋转操作，然后能转化成一个链…… 然后我就不知道怎么搞了于是去看 T2. T2 的十分暴力非常显然，于是开始思考正解。 因为是个排列所以思考如何利用排列性质……想了快一个小时没分析出来（ 然后因为一看就是 DS 题，所以考虑我曾经学过的 DS，经过了筛选之后 $n \\log n$ 我都觉得不太行，于是最后剩下了分块和莫队。 但是这题需要回滚莫队，我不会，爬了。 T3 简而言之就是《我读不懂题但是写了纯随机但是觉得没用就没交》 然后就寄了，10 分，可能就？ 那么这个 WC，就这样画上句号吧，哦对了下午还有讲评。 下午T1：《小清新构造题》 T2：《lxl DS 题》，说实话我看到成员列表出现 lxl 就觉得事情不妙（ T3：《游戏改编但是随机化好多分 std 甚至写了 20k》 那么这个 WC，就这样画上句号吧，哦对了明天还有闭幕式，不过我个打铁的有啥好期待的。 Day6啊哈哈哈，出分啦，差五分 Cu，菜，那么这个 WC，就这样画上句号吧。","link":"/2022/01/23/WC2022Notes/"},{"title":"ZR NOIP21 D9 简记","text":"雪降り、メリクリ 圣诞，圣诞，圣诞节！ 「启」立冬就下暴雪，好。 随便写一下，因为 C 和 D 都不想写代码了，所以就快快口胡一下吧。 缺省源使用：「V5.2」。 「A」按照 %m 来统计方案数，每次用矩阵来转移。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778CI NXX(101),MXX(21),MOD(1e9+7);struct Matrix{ int n,m,a[MXX][MXX]; Matrix() { n=m=0,mst(a,0); } I void Build() { for(int i(1);i&lt;=m;++i) a[i][i]=1; } I Matrix operator * (const Matrix &amp;co) const { Matrix res; res.n=n,res.m=co.m; for(int i(1);i&lt;=n;++i) for(int k(1);k&lt;=m;++k) for(int j(1);j&lt;=co.m;++j) (res.a[i][j]+=(1ll*a[i][k]*co.a[k][j])%MOD)%=MOD; Heriko res; }}ans;int n,m;I Matrix MFP(Matrix x,int y){ Matrix res; res.n=res.m=m; res.Build(); while(y) { if(y&amp;1) res=res*x; x=x*x; y&gt;&gt;=1; } Heriko res;}S main(){ Files(); fr(n),fr(m); ans.n=1,ans.m=m; ans.a[1][m]=1; for(int i(1);i&lt;=n;++i) { int x,y; fr(x),fr(y); Matrix tmp; tmp.n=tmp.m=m; for(int j(1);j&lt;=m;++j) ++tmp.a[j][j],++tmp.a[j][(j+y-1)%m+1]; ans=MFP(tmp,x)*ans; } fw((ans.a[1][m]+MOD-1)%MOD,1); Heriko Deltana;} 「B」结论题，好像有很多人是直接上了平衡树（ 但是其实玩一玩就能发现，假如我们给 $[1,a_1],[a_1+1,a_2] \\cdots [a_{n-1}+1,a_n]$ 这些段编上编号：$1,2,\\cdots,k$，就会发现，这些段在最后的顺序只和 $k$ 的奇偶性相关，即偶数的时候先倒序输出偶数编号的段再顺序输出奇数段，反之先倒叙输出奇数段，再正序输出偶数段。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354CI MXX(5e5+1);int n,k,q[MXX],cnt1,cnt2;pair&lt;int,int&gt; co1[MXX],co2[MXX];char s[MXX];S main(){ Files(); fr(n),fr(k); scanf(&quot;%s&quot;,s+1); int lst(1); for(int i(1);i&lt;=k;++i) { fr(q[i]); if(i&amp;1) co1[++cnt1]=mkp(lst,q[i]); else co2[++cnt2]=mkp(lst,q[i]); lst=q[i]+1; } if(k&amp;1) { for(int i(cnt1);i;--i) for(int j(co1[i].second);j&gt;=co1[i].first;--j) putchar(s[j]); for(int i(1);i&lt;=cnt2;++i) for(int j(co2[i].first);j&lt;=co2[i].second;++j) putchar(s[j]); } else { for(int i(cnt2);i;--i) for(int j(co2[i].second);j&gt;=co2[i].first;--j) putchar(s[j]); for(int i(1);i&lt;=cnt1;++i) for(int j(co1[i].first);j&lt;=co1[i].second;++j) putchar(s[j]); } for(int i(lst);i&lt;=n;++i) putchar(s[i]); Heriko Deltana;} 「C」分讨，先把奇数的情况全加上一个 $1$，再把 $20$ 的情况转化为其他数组合的方案，于是就只剩下了 $1,2,5,10$ 需要考虑。 然后考虑如何把 $10$ 转化为其他的数字。考虑模 $10$ 的余数，发现除了余 $1,3,6,8$ 的时候都能有唯一的方案，然后这四种之间通过加减 $2$ 可以最后转化为两类，然后就看要多少的 $5,2,2,2$ 和 $5,1.$ 没写代码，爬。 「D」好像设涉及泰勒展开和多项式求和，这比我技能树高的不知道到哪去了（ 🎨：写完了ヽ(✿ﾟ▽ﾟ)ノ 我去发到博客里。 🐟: $ヽ(✿ﾟ▽ﾟ)ノ$ 「保留内容」🐏：非抄袭，非代表性，个人印象。 🐏：我现在都不会A我靠都 都很厉害AZ很 厉害🤩 🎨：AB 都 A 了，但是我场上没 A 掉 A。嗯😩我胡诌。好多人都是什么伸臂方法啥的，我™硬理解理解出来这个，但是我不会实现。。。。然后看王亦木，发现差不多，然后乆写，最后调了半天发现乘法的地方爆int了（ 🐟: 都在学习, 只有🐟在颓废😭 🎨：呜呜呜 🐏：我写A去了👋🏻草好我要学矩阵 🎨：祝你拿最优解，主要是前面的复杂度和我都不一样。那个我理解不出来，你看 xuruiyang 那个 🐏：我看看去 (【🐟：空格好评玉喜为你点赞】)我哦也不会 🎨：卧槽我用 ☁️ 这个键盘的错字率太高了，平均每个字都能错。 🎨：多 人 混 战","link":"/2021/11/07/ZR-NOIP21-D9-Solu/"},{"title":"ZROI NOIP21 冲刺汇总","text":"正睿 NOIP20 天冲刺 同步发布于ZROI NOIP21 冲刺汇总 (Cnblogs) 「启」[TOC] 实际上之前是单独发的，但是因为每天一测，不一定能够补完当天的题目，所以就将所有的未补完的考试中已经补过的题放在这里。 四道题全部整完的会单独发出。 UPD 2021.11.8 「Day1」讲课，略。 「Day2」✅ ZR-NOIP21-20D-D2 已经整理完，博客为：总之就是 | ZROI NOIP21 冲刺 Day2。 「Day3」⬜ ZR-NOIP21-20D-D3 「启」今天在🐏的强码力支持下没有爆零（ 缺省源和「这一篇」一致； 「A」 一道搞一搞出奇迹的题。 「A」题目简述给出一个 $3 \\times 3$ 的矩阵，里面填入了 $1$ 到 $9$，求问最少进行几次操作可以使得这个矩阵满足：每行三个数之和为 $15$，每列三个数之和为 $15$，且每条对角线三个数之和也为 $15.$ 操作即为交换相邻的两个数，题目为 $T,(T \\le 50)$ 组询问。 「A」思路简述经过手玩/爆搜，发现如果我们把矩阵表述为一个长为 $9$ 的序列，最终只有 $8$ 种目标序列： $$2 7 6 9 5 1 4 3 8 \\2 9 4 7 5 3 6 1 8 \\4 3 8 9 5 1 2 7 6 \\4 9 2 3 5 7 8 1 6 \\6 1 8 7 5 3 2 9 4 \\6 7 2 1 5 9 8 3 4 \\8 1 6 3 5 7 4 9 2 \\8 3 4 1 5 9 6 7 2 \\$$ 于是我们考虑去双向 BFS. 于是考虑一下这样做的复杂度：一共有 $12$ 种操作，一个矩阵最多扩展出 $9!$ 种状态，也就是说复杂度为 $O(8 \\times 9!T).$ 但是这样是过不去的，于是考虑把这个 $8$ 的常数干掉，于是乆有了对于目标矩阵的离散化，所以最终的时间复杂度为 $O(9!T).$ 在 BFS 的过程之中用到了 Hash 去判断重复状态（ 「A」Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149template&lt;typename J&gt;I J Hmin(const J &amp;x,const J &amp;y) {Heriko x&lt;y?x:y;}CI MOD(1000003),TXX(400000);int n,Tco[10],f[10][10],sum,Sco[9][10],co[10],a[10];int r[13][2];void Pre(){ for(int i(1);i&lt;=9;++i) Tco[i]=i; do { if (Tco[1]+Tco[2]+Tco[3] != 15 or Tco[4]+Tco[5]+Tco[6] != 15 or Tco[7]+Tco[8]+Tco[9] != 15 or Tco[1]+Tco[4]+Tco[7] != 15 or Tco[2]+Tco[5]+Tco[8] != 15 or Tco[3]+Tco[6]+Tco[9] != 15 or Tco[1]+Tco[5]+Tco[9] != 15 or Tco[3]+Tco[5]+Tco[7] != 15) continue; ++sum; for (int i(1);i&lt;=9;++i) f[sum][i]=Tco[i],Sco[sum][Tco[i]]=i; puts(&quot;&quot;); } while(next_permutation(Tco+1,Tco+10)); r[1][0]=1,r[1][1]=2; r[2][0]=2,r[2][1]=3; r[3][0]=1,r[3][1]=4; r[4][0]=2,r[4][1]=5; r[5][0]=3,r[5][1]=6; r[6][0]=4,r[6][1]=5; r[7][0]=5,r[7][1]=6; r[8][0]=4,r[8][1]=7; r[9][0]=5,r[9][1]=8; r[10][0]=6,r[10][1]=9; r[11][0]=7,r[11][1]=8; r[12][0]=8,r[12][1]=9;}struct Core{ int id,ans;};struct Node{ int nxt,key,cnt;}t[TXX];int head[MOD+10],tot;I void Add(int x,int k) {t[++tot]=(Node){(int)head[x%MOD],x,k};head[x%MOD]=tot;}I bool CheckBool(int x){ for (int i(head[x%MOD]);i;i=t[i].nxt) if (t[i].key==x) Heriko Romanno; Heriko Deltana;}I int CheckInt(int x){ for (int i(head[x%MOD]);i;i=t[i].nxt) if (t[i].key==x) Heriko t[i].cnt; Heriko Deltana;}int m[10];I int Modify(int x,int id){ int temp(0),now,pw(1); for(int i(9);i;--i) m[i]=(x%10),x/=10; for (int i(9);i;--i) { now=m[i]; if (now==r[id][1]) now=r[id][0]; else if (now==r[id][0]) now=r[id][1]; temp+=pw*now;pw*=10; } Heriko temp;}I void BFS(){ queue&lt;Core&gt; q; q.push((Core){123456789,0}); while (!q.empty()) { int x=q.front().id; int k=q.front().ans; q.pop(); if (CheckBool(x)) continue; Add(x,k); for (int i=1;i&lt;=12;++i) { int Ner(Modify(x,i)); q.push((Core){Ner,k+1}); } }}int main(){ Files(); Pre();BFS(); int T;fr(T); while (T--) { for(int i(1);i&lt;=9;++i) fr(a[i]); int ans(100); for(int i(1);i&lt;=8;++i) { for(int j(1);j&lt;=9;++j) co[j]=Sco[i][a[j]]; int temp(0),pw(1); for(int j(9);j;--j) temp+=pw*co[j],pw*=10; ans = min(CheckInt(temp),ans); } fw(ans,1); } Heriko Deltana;} 「Day4」✅ ZR-NOIP-21-20D-D4 已经整理完，博客为：总之就是 | ZROI NOIP21 冲刺 Day4。 「Day5」⬜ ZR-NOIP21-20D-D5 「启」昨天上大分，今天挂大分，就当是一场梦，醒来还是很感动 缺省源使用「V5」. 「A」 这题我场上写假了两个之后，又交了个假的上去…… 「A」题目简述对于长度同为 $n$ 的数 $a$ 和 $b$，定义其距离为 $d(a,b) = \\sum_{i=1}^n(a_i-b_i)^2.$ 现在你可以任意交换 $a$ 的两个元素，求使得距离最短的最少交换次数。 求距离，若 $opt=1$，输出最少交换次数。 数据范围：$n \\le 300000.$ 「A」思路简述对于最短距离，sort 一下即可。 对于交换次数，我们用冰茶姬维护一下，再比较即可。 「A」Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950CI MXX(3e5+1),MOD(998244353);struct Node{ int val,id; I bool operator &lt; (const Node &amp;co) const {Heriko val&lt;co.val;}}a[MXX],b[MXX];int n,opt,fa[MXX];LL ans;LL Find(int x){ if(fa[x]!=x) fa[x]=Find(fa[x]); Heriko fa[x];}S main(){ Files(); fr(n),fr(opt); for(int i(1);i&lt;=n;++i) fr(a[i].val),a[i].id=i; for(int i(1);i&lt;=n;++i) fr(b[i].val),b[i].id=i; for(int i(1);i&lt;=n;++i) fa[i]=i; sort(a+1,a+1+n);sort(b+1,b+1+n); for(int i(1);i&lt;=n;++i) (ans+=1ll*(a[i].val-b[i].val)*(a[i].val-b[i].val)%MOD)%=MOD,fa[Find(a[i].id)]=Find(b[i].id); fw((ans+MOD)%MOD,0); if(opt) { ans=0; for(int i(1);i&lt;=n;++i) ans+=(fa[i]!=i); fw(ans,1); } Heriko Deltana;} 「B」 场上想的是正解，但是因为做 A 做的心态炸了所以场上就没写出来（ 「B」题目简述国际象棋中，主教这个棋子可以攻击所有与其在同一条斜线上的位置（自己所处位置也算在内），现在在 $n \\times n$ 的棋盘中给出 $m$ 个主教，问棋盘中还有几个不会被攻击到的位置。 数据范围：$1 \\le n,m \\le 10^6.$ 「B」思路简述因为是 $10^6$，即使是三秒时限，$O(n^2)$ 也铁定过不去，所以考虑 $O(n)$ 的做法。 考虑到一个棋子带来的影响只在两条直线上，所以我们考虑这两条直线的解析式：$y_1=x+b_1,y_2=-x+b_2.$ 于是我们只需要记录 $b_1$ 和 $b_2$ 来判断边出现过没有即可。 因为所有的 $y_1$ 都是平行的，所以我们只需要考虑其和所有 $y_2$ 的交点即可，而这个可以前缀和优化。 于是乆做到了复杂度 $O(n).$ 「B」Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849template&lt;typename J&gt;I J Habs(const J &amp;x) {Heriko x&lt;0?-x:x;}CI MXX(2e6+1);int n,m,sum[MXX];LL ans;bitset&lt;MXX&gt; co[2];S main(){ Files(); fr(n),fr(m); for(int i(1),x,y;i&lt;=m;++i) { fr(x),fr(y); int b1(x+y-1),b2(y-x+n); co[0][b1]=co[1][b2]=1; } n&lt;&lt;=1; for(int i(1);i&lt;n;++i) if(co[0][i]) { int temp(Habs((n&gt;&gt;1)-i)); --sum[temp+1],++sum[n-temp+1]; } for(int i(3);i&lt;n;++i) sum[i]+=sum[i-2]; for(int i(1);i&lt;n;++i) if(i&lt;=(n&gt;&gt;1)) sum[i]+=i; else sum[i]+=n-i; for(int i(1);i&lt;n;++i) if(co[1][i]) sum[i]=0; for(int i(1);i&lt;n;++i) ans+=sum[i]; fw(ans,1); Heriko Deltana;} 「Day6」⬜ 21-NOIP21-20D-D6 「启」今天这题给我做离谱了……希望几天之后的 CSP 不要这样出题…… 各种毒瘤题，还卡常（ 缺省源使用「V5」 「A」 这题场上因为读错题耽误了一个半小时，结果最后写完暴力发现又读错了题……我真是服了（ 「A」题目复述 因为读错 $114514$ 遍题，所以就不简述了吧（ 「A」思路简述因为第一页写在了第 $t$ 页，根据题意，那么接下来的几天的页数会一天比一天小，然后会出现一个 $p_i &lt; p_{i+1}$。然后去掉写过的这几页，又会重复这样的情况。 对于 $q$ 中每一段连续的 $q_i&gt;q_{i+1}$，相当于就是要在剩下的页数里，选出若干页给这一段连续的 $q_i&gt;q_{i+1}$ 使用（由于第 $1$ 页一定会选，所以计算组合数时上下都要减 $1$），于是就在排列 $q$ 中找到所有 $q_i&lt;q_{i+1}$ 的 $i$ 构成一个长度为 $len$ 的数列 $w$，那么答案为： $$\\prod\\limits_{i=2}^{len} \\binom{n-w_{i-1}-1}{w_i-w_{i-1}-1} = (n-1)!\\prod\\limits_{i=2}^{len}\\dfrac{1}{n-a_i}\\cdot\\dfrac{1}{(a_i-a_{i-1}-1)}$$ 用 set 维护 $w$，每次修改去修改前驱或后继即可。 「A」Code 我最一开始 ans 开了两个，一个全局，一个在 main 里面，就因为这个调了两个小时。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169CI MXX(3e5+1),MOD(1e9+7);int n,m,a[MXX];LL fac[MXX],inv[MXX],val[MXX],ans(1);bitset&lt;MXX&gt; co;set&lt;LL&gt; s;I LL FstPow(LL x,LL y){ LL res(1); while(y) { if(y&amp;1) (res*=x)%=MOD; (x*=x)%=MOD,y&gt;&gt;=1; } Heriko res;}I void Pre(){ fac[0]=1; for(int i(1);i&lt;=n;++i) fac[i]=fac[i-1]*i%MOD; inv[n]=FstPow(fac[n],MOD-2); for(int i(n-1);i&gt;=0;--i) inv[i]=inv[i+1]*(i+1)%MOD;}I LL C(int x,int y) {Heriko ((fac[x]*inv[y]%MOD)*inv[x-y])%MOD;}I void Add(int x){ auto i(s.lower_bound(x)); auto lst(i); if(i==s.begin()) { (ans*=C(n-1,x-1))%=MOD; (ans*=FstPow(val[(*i)],MOD-2))%=MOD; (ans*=C(n-x-1,(*i)-x-1))%=MOD; val[x]=C(n-1,x-1); val[(*i)]=C(n-x-1,(*i)-x-1); } else if(i==s.end()) { --i; (ans*=C(n-(*i)-1,x-(*i)-1))%=MOD; val[x]=C(n-(*i)-1,x-(*i)-1); } else { --lst; (ans*=C(n-(*lst)-1,x-(*lst)-1))%=MOD; val[x]=C(n-(*lst)-1,x-(*lst)-1); (ans*=FstPow(val[(*i)],MOD-2))%=MOD; (ans*=C(n-x-1,(*i)-x-1))%=MOD; val[(*i)]=C(n-x-1,(*i)-x-1); } s.insert(x);}I void Del(int x){ auto i(s.lower_bound(x)); auto lst(i); auto org(i); if(i==s.begin()) { (ans*=FstPow(val[x],MOD-2))%=MOD; ++i; (ans*=FstPow(val[(*i)],MOD-2))%=MOD; val[(*i)]=C(n-1,(*i)-1); (ans*=val[(*i)])%=MOD; val[x]=0; } else { --lst,++i; (ans*=FstPow(val[x],MOD-2))%=MOD; if(i!=s.end()) { (ans*=FstPow(val[(*i)],MOD-2))%=MOD; (ans*=C(n-(*lst)-1,(*i)-(*lst)-1))%=MOD; val[(*i)]=C(n-(*lst)-1,(*i)-(*lst)-1); } val[x]=0; } s.erase(org);}S main(){ Files(); fr(n),fr(m);Pre(); for(int i(1);i&lt;=n;++i) fr(a[i]); int lsti(0); for(int i(1);i&lt;=n;++i) { co[i]=(a[i]&lt;a[i+1]); if(co[i]) { (ans*=C(n-lsti-1,i-lsti-1))%=MOD; val[i]=C(n-lsti-1,i-lsti-1); s.insert(i);lsti=i; } } fw(ans,1); while(m--) { int x,y;fr(x),fr(y); swap(a[x],a[y]); int lstq; if(x!=1) { lstq=co[x-1]; co[x-1]=(a[x-1]&lt;a[x]); if(lstq != co[x-1]) co[x-1]?Add(x-1):Del(x-1); } if(x!=n) { lstq=co[x]; co[x]=(a[x]&lt;a[x+1]); if(lstq != co[x]) co[x]?Add(x):Del(x); } if(y!=1) { lstq=co[y-1]; co[y-1]=(a[y-1]&lt;a[y]); if(lstq != co[y-1]) co[y-1]?Add(y-1):Del(y-1); } if(y!=n) { lstq=co[y]; co[y]=(a[y]&lt;a[y+1]); if(lstq != co[y]) co[y]?Add(y):Del(y); } fw(ans,1); } Heriko Deltana;} 「Day7」⬜ 21-NOIP21-20D-D7 「启」 4h 做 A，结果多测清空不规范，爆零两行泪。 可是就快要复赛了啊……还在爆零…… 缺省源使用「V5」. 「A」 4h，两个假算法，多测清空不规范，TLE，爆零。 「A」题目简述你参加了一个为期 $D$ 天的夏令营，在此 $1$ 到 $D$ 天内有 $N$ 个活动，其中第 $i$ 个活动对你的吸引力是 $h_i$ ，且将从第 $s_i$ 天持续到第 $e_i$ 天（包括 $s_i$ 和 $e_i$）。 每天你最多参加 kk 个活动，你想知道在此期间，哪一天的活动对你的吸引力总和最大。 数据范围：$1 \\le N,D \\le 3\\times 10^5.$ 「A」思路简述枚举时间，将当前可选的活动加入时间序列，维护两个堆，一个小根堆表示现在选了哪些课程保持大小为 $k$，另一个堆维护剩下的随时准备补位。 「A」Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y) {Heriko x&gt;y?x:y;}CI MXX(3e5+2);int d,n,k,h[MXX];LL ans;bitset&lt;MXX&gt; in,no;vector&lt; pair&lt;int,int&gt; &gt; v[MXX];priority_queue&lt; pair&lt;int,int&gt; &gt; hp,thp;I void Clear(){ for(int i(1);i&lt;=d+1;++i) v[i].clear(); while(hp.size()) hp.pop(); while(thp.size()) thp.pop(); in=no=0;}I void Solve(){ int opt(0),x(0),sz(0),val(0),num(0); LL sum(0);ans=0; for(int i(1);i&lt;=d;++i) { for(auto j:v[i]) { opt=j.first,x=j.second; if(opt) { if(sz&lt;k) { sum+=h[x];++sz;in[x]=1; hp.push(make_pair(-h[x],x)); } else { while(no[hp.top().second]) hp.pop(); val=-hp.top().first;num=hp.top().second; if(h[x]&gt;val) { in[x]=1;in[num]=0; sum+=(h[x]-val); hp.pop(); hp.push(make_pair(-h[x],x)); thp.push(make_pair(val,num)); } else thp.push(make_pair(h[x],x)); } } else { no[x]=1; if(in[x]) { sum-=h[x];--sz; while (thp.size() &amp;&amp; no[thp.top().second]) thp.pop(); if(thp.size()) { val=thp.top().first,num=thp.top().second;thp.pop(); if(!no[num]) { sum+=val,in[num]=1,++sz; hp.push(make_pair(-val,num)); } } } } } ans=Hmax(ans,sum); }}S main(){ Files(); int T;fr(T); for(int ct(1);ct&lt;=T;++ct) { Clear();fr(d),fr(n),fr(k); for(int i(1),l,r;i&lt;=n;++i) { fr(h[i]),fr(l),fr(r); v[l].push_back(make_pair(1,i)); v[r+1].push_back(make_pair(0,i)); } Solve();printf(&quot;Case #%d: %lld\\n&quot;,ct,ans); } Heriko Deltana;} 「Day8」⬜ 21-NOIP21-20D-D8 「Day9」⬜ 21-NOIP21-20D-D9 「启」拉了。 缺省源使用「V5」. 「A」 场上想了一堆拉掉的玩意。 「A」题目简述给定整数 $N$，称它的一个分解为一组正整数 $x_1,x_2,…,x_k$，满足以下条件： $\\sum_{i = 1}^k x_i = N;$ 对于任意 $1 \\le i \\le k$，都有 $x_i=2^a3^b$，这里 $a,b$ 均为非负整数； 对于任意 $1 \\le i,j \\le k,i≠j$，$x_i$ 都不是 $x_j$ 的因子。 现在要求输出一种 $N(N \\le 10^{100})$ 的分解。 「A」思路简述先将 $N$ 不断除掉 $2$，然后再不断减去最大的 $3$ 的幂，答案最后要乘上那些 $2.$ 这个数据范围需要高精（ 「A」Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126CI MXX(105);struct Pic{ int num[MXX],sz; Pic() {mst(num,0);sz=1;} I void Clear() {mst(num,0);sz=1;} I Pic operator * (const int &amp;co) const { Pic res;res.sz=sz; for(int i(1);i&lt;=sz;++i) res.num[i]=num[i]*co; for(int i(1);i&lt;=sz;++i) res.num[i+1]+=(res.num[i]/10),res.num[i]%=10; while(res.num[res.sz+1]) { ++res.sz; res.num[res.sz+1]+=(res.num[res.sz]/10); res.num[res.sz]%=10; } Heriko res; } I Pic operator * (const Pic &amp;co) const { Pic res;res.sz=co.sz+sz; for(int i(1);i&lt;=sz;++i) for(int j(1);j&lt;=co.sz;++j) { res.num[i+j-1]+=(num[i]*co.num[j]); res.num[i+j]+=(res.num[i+j-1]/10);res.num[i+j-1]%=10; } while(!res.num[res.sz] and res.sz&gt;1) --res.sz; Heriko res; } I Pic operator - (const Pic &amp;co) const { Pic res;res.sz=sz; for(int i(1);i&lt;=sz;++i) { res.num[i]+=num[i]-co.num[i]; if(res.num[i]&lt;0) --res.num[i+1],res.num[i]+=10; } while(!res.num[res.sz] and res.sz&gt;1) --res.sz; Heriko res; } I void RightShift() { for(int i(sz);i;--i) { if(num[i]&amp;1) num[i-1]+=10; num[i]&gt;&gt;=1; } while(!num[sz] and sz&gt;1) --sz; } I bool operator &gt; (const Pic &amp;co) const { if(sz!=co.sz) Heriko sz&gt;co.sz; for(int i(sz);i;--i) if(num[i]!=co.num[i]) Heriko num[i]&gt;co.num[i]; Heriko Deltana; } I bool operator &lt;= (const Pic &amp;co) const {Heriko !((*this)&gt;co);} I void Into(char s[]) { sz=strlen(s+1); for(int i(1);i&lt;=sz;++i) num[i]=s[sz-i+1]-'0'; } I bool Zero() {Heriko (sz==1)&amp;(num[1]==0);} I void fw() {for(int i(sz);i;--i) putchar(num[i]+'0'); putchar(' ');}}n,ans[1005];char s[105];int anslen;S main(){ Files(); scanf(&quot;%s&quot;,s+1);n.Into(s);Pic pw;pw.num[1]=1; while(!n.Zero()) { while(!(n.num[1]&amp;1)) pw=pw*2,n.RightShift(); Pic res,nex;res.num[1]=1;nex=res*3; while(nex&lt;=n) res=nex,nex=res*3; n=n-res;res=res*pw;ans[++anslen]=res; } fw(anslen,1); for(int i(1);i&lt;=anslen;++i) ans[i].fw(); Heriko Deltana;} 「Day10」讲课，略。 「Day11」⬜ 21-NOIP21-20D-D11 「启」A 假了，B 场上以为假了但是其实没假，总结还是拉了。 缺省源使用「V5」. 「A」Bad. 「A」题目简述有一颗 $n(n \\le 10^6)$ 个节点的树，每个节点可能是红色或者黑色，每次操作可以选择一个节点，把这个节点所连的同色的结点反色，求把整棵树变成同一种颜色的最小操作次数。 「A」思路简述因为相邻同色的结点可以看作一块，所有缩为一个点，然后对新树找直径，答案即为直径除 $2.$ 「A」Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y) {Heriko x&gt;y?x:y;}template&lt;typename J&gt;I J Hmin(const J &amp;x,const J &amp;y) {Heriko x&lt;y?x:y;}CI MXX(1e6+1);int n,f[MXX],ans;struct Node{ int nex,to;}r[MXX&lt;&lt;1];int cnt,head[MXX];I void Add(int x,int y){ r[++cnt]=(Node){head[x],y};head[x]=cnt; r[++cnt]=(Node){head[y],x};head[y]=cnt;}bitset&lt;MXX&gt; co;void DFS(int x,int fa){ for(int i(head[x]);i;i=r[i].nex) { int y(r[i].to); if(y==fa) continue; DFS(y,x); if(co[y]!=co[x]) { ans=Hmax(ans,f[x]+f[y]+1); f[x]=Hmax(f[x],f[y]+1); } else { ans=Hmax(ans,f[x]+f[y]); f[x]=Hmax(f[x],f[y]); } }}I int GetCo(){ char c(getchar()); while(c!='R' and c!='B') c=getchar(); Heriko c=='R'?1:0;}S main(){ Files(); fr(n); for(int i(1);i&lt;=n;++i) co[i]=GetCo(); for(int i(1),x,y;i&lt;n;++i) fr(x),fr(y),Add(x,y); DFS(1,0);fw((ans+1)&gt;&gt;1,1); Heriko Deltana;} 「B」 场上最后的贪心策略是对的，但是当时以为假了。 「B」题目简述给出一个长度为 $k$ 的数列，然后给出 $n$ 个操作，操作分为三种： $a_i=b$ $a_i=a_i+b$ $a_i=a_i \\times b$ 其中 $i,b$ 是给定的，每个操作只能用一次，最多使用 $m$ 个操作，让整个数列的乘积最大。 「B」思路简述考虑将 Cover 操作转为 Add 操作，然后贪心的选取贡献权值大的即可。 「B」Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y) {Heriko x&gt;y?x:y;}template&lt;typename J&gt;I J Hmin(const J &amp;x,const J &amp;y) {Heriko x&lt;y?x:y;}CI MXX(1e5+1),MOD(1e9+7);int n,k,m,cnt;LL a[MXX],ans(1),cover[MXX];struct CoFuc{ int opt,pos;LL val;long double dlt;}co[MXX],ro[MXX];I bool CMP(const CoFuc &amp;x,const CoFuc &amp;y) {Heriko x.val&gt;y.val;}I bool RMP(const CoFuc &amp;x,const CoFuc &amp;y) {Heriko x.dlt&gt;y.dlt;}S main(){ Files(); fr(k),fr(n),fr(m); for(int i(1);i&lt;=k;++i) fr(a[i]); for(int i(1);i&lt;=n;++i) { fr(co[i].opt),fr(co[i].pos),fr(co[i].val); if(co[i].opt==1) cover[co[i].pos]=Hmax(cover[co[i].pos],co[i].val); } for(int i(1);i&lt;=k;++i) if(cover[i]&gt;a[i]) ro[++cnt]=(CoFuc){2,i,cover[i]-a[i],0.0}; for(int i(1);i&lt;=n;++i) if(co[i].opt!=1) ro[++cnt]=co[i]; sort(ro+1,ro+1+cnt,CMP); for(int i(1);i&lt;=k;++i) cover[i]=a[i]; for(int i(1);i&lt;=cnt;++i) if(ro[i].opt==2) { ro[i].dlt=1.0*(cover[ro[i].pos]+ro[i].val)/(1.0*cover[ro[i].pos]); cover[ro[i].pos]+=ro[i].val; } else if(ro[i].opt==3) ro[i].dlt=ro[i].val*1.0; sort(ro+1,ro+1+cnt,RMP); for(int i(1);i&lt;=Hmin(m,cnt);++i) if(ro[i].opt==2) a[ro[i].pos]+=ro[i].val; else if(ro[i].opt==3) (ans*=ro[i].val)%=MOD; for(int i(1);i&lt;=k;++i) (ans*=a[i])%=MOD; fw((ans+MOD)%MOD,1); Heriko Deltana;} 「C」 不是这怎么还出特判题呐？ 「C」题目简述小明有 $1$ 到 $n$ 共 $n$ 包零食，同时他又有 $1$ 到 $n$ 共 $n$ 个朋友。 昨天，小明的 $n$ 个朋友都到他家来玩了。他的 $n$ 个朋友瓜分了他的 $n$ 包零食，每个人都恰好吃了一包零食，没有两个人吃了同一包零食。 小明发现，第 $i$ 个朋友吃第 $j$ 包零食能获得的愉悦值是 $i\\bmod j$。 今天，小明想回忆起每个朋友吃的是哪包零食，他想不起来了，但是他却记得了所有人的愉悦值之和 $s$。于是，小明找上了你，请你构造出一种可能的方案。 由于小明记忆力不好，他有可能记错了 $s$，所以可能会存在无解的情况。 「C」思路简述特判题（ $s$ 的上界为 $\\dfrac{n \\times (n+1)}{2}$，超过乆输出无解。 $s=0,1,2,\\dfrac{n \\times (n+1)}{2}-1$ 的时候详见代码，$n\\le 3$ 时同理。 剩余情况我们只需要构造出 $2 \\to n-1$ 的答案。 「C」Code 这里的 fw 函数不太一样，放一下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130template&lt;typename J&gt;I void fw(bool g,J x,bool k){ if(!g) { puts(&quot;SPFA is dead!&quot;); Heriko; } if(x&lt;0) x=-x,putchar('-'); static short stak[35];short top(0); do { stak[top++]=x%10; x/=10; } while(x); while(top) putchar(stak[--top]+'0'); k?puts(&quot;&quot;):putchar(' ');}CI MXX(1e6+1);LL n,s,res,ans[MXX],flg;bitset&lt;MXX&gt; co;S main(){ Files(); fr(n),fr(s); if(s&gt;((n*(n-1))&gt;&gt;1)) Heriko fw(0,114514,1919810),Deltana; if(n==1) { if(!s) puts(&quot;1&quot;); else Heriko fw(0,114514,1919810),Deltana; Heriko Deltana; } else if(n==2) { if(!s) puts(&quot;1\\n2&quot;); else if(s==1) puts(&quot;2\\n1&quot;); else Heriko fw(0,114514,1919810),Deltana; Heriko Deltana; } else if(n==3) { if(!s) puts(&quot;1\\n2\\n3&quot;); else if(s==1) puts(&quot;2\\n1\\n3&quot;); else if(s==2) puts(&quot;3\\n1\\n2&quot;); else if(s==3) puts(&quot;1\\n3\\n2&quot;); else Heriko fw(0,114514,1919810),Deltana; Heriko Deltana; } if(!s) { for(int i(1);i&lt;=n;++i) fw(1,i,1); Heriko Deltana; } else if(s==1) { puts(&quot;2\\n1&quot;); for(int i(3);i&lt;=n;++i) fw(1,i,1); Heriko Deltana; } else if(s==2) { puts(&quot;3\\n1\\n2&quot;); for(int i(4);i&lt;=n;++i) fw(1,i,1); Heriko Deltana; } else if(s==((n*(n-1))&gt;&gt;1)-1) { if(n&amp;1) { ans[1]=3,ans[2]=1,ans[n]=2; for(int i(3);i&lt;n;++i) ans[i]=i+1; } else { ans[1]=1;ans[n]=2; for(int i(2);i&lt;n;++i) ans[i]=i+1; } for(int i(1);i&lt;=n;++i) fw(1,ans[i],1); Heriko Deltana; } ans[n]=1;--s; for(int i(n-1);i&gt;=2;--i) { if(s&gt;=i and s-i!=1) s-=i; else ans[i]=i,co[i]=1; } int nw(n); for(int i(n-1);i;--i) if(!ans[i]) { ans[i]=nw,co[nw]=1; while(co[nw]) --nw; } for(int i(1);i&lt;=n;++i) fw(1,ans[i],1); Heriko Deltana;} 「Day12」✅ 21-NOIP21-20D-D12 已经整理完，博客为：总之就是 | ZROI NOIP21 冲刺 Day12。 「Day13」⬜ 21-NOIP21-20D-D13 「启」今天倒是没挂 A，但是大家都切 A，所以我挂 B 了/cy 缺省源使用「V5」. 「A」切了好耶（ Time:1s Memory:512MiB. 「A」题目简述要求找出满足下列条件最小的数： 这是一个正整数； 这个数至少有四个不同的因子； 这个数的任意两个因子之间的差不小于输入的 $n(n \\le 10^5)$ 「A」思路简述因为要求两个任意两个因子之间的差不小于输入的 $n$，所以想到选取质数。 而题目要求至少要有四个不同的因子，而一个数最小的因子是 $1$，最大的因子是自己，所以我们只需要找到大于 $n+1$ 的第一个质数和大于等于第一个选出来的质数 $+n$ 后的最小的质数即可。 用一个欧拉筛解决质数问题即可。 「A」Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859CI MXX(1e7+5);LL prime[MXX],cnt;bool nopr[MXX];I void Es(LL x){ nopr[1]=1; for(LL i(2);i&lt;=x;++i) { if(!nopr[i]) prime[++cnt]=i; for(int j(1);j&lt;=cnt and prime[j]*i&lt;=x;++j) { nopr[i*prime[j]]=1; if(i%prime[j]==0) break; } }}LL n,T;S main(){ Files(); Es(MXX); fr(T); while(T--) { fr(n);LL fst(0),fstid(0),sed(0); for(int i(1);i&lt;=cnt;++i) if(prime[i]&gt;=n+1) { fst=prime[i]; fstid=i; break; } for(int i(fstid);i&lt;=cnt;++i) if(prime[i]&gt;=fst+n) { sed=prime[i]; break; } fw(sed*fst,1); } Heriko Deltana;} 「B」挂了好耶（ Time:1s Memory:512MiB. 「B」题目简述给出一个有 $n(n\\le 1000)$ 个点的无向完全图，每次在图上去掉一个生成树中的所有边，问最多能进行多少次，并且输出每次要删掉哪些边。 「B」思路简述首先能知道 $n$ 个点的完全图的总边数为 $\\dfrac{n(n-1)}{2}$，而一个生成树的边数为 $n-1$，所以能得出最多能进行 $\\left\\lfloor\\frac{n}{2}\\right\\rfloor$ 次删除操作。 那么下面考虑如何构造出每次删掉的生成树，场上是想的 DFS 删除，但是没判环于是挂掉了。 考完之后看题解发现可以反着来，考虑从 $n-2$ 转移到 $n$ 的时候，对于之前的每一个生成树 $i$ 连上 $2i-1$ 和 $n-1$、$2i$ 和 $n$，然后如果是偶数就再建一个新的，连边同理。 「B」Code123456789101112131415161718192021222324252627int n,m;S main(){ Files(); int T;fr(T); for(int ct(1);ct&lt;=T;++ct) { fr(n);m=(n&gt;&gt;1); printf(&quot;Case #%d: %d\\n&quot;,ct,m); for(int i(1);i&lt;=m;++i) { if(!(n&amp;1)) fw((i+m)%n+1,0),fw(i+m,1); for(int j(1);j&lt;=(n-1)&gt;&gt;1;++j) { fw((i-j+n)%n+1,0),fw((i+j-1)%n+1,1); fw((i+j-1)%n+1,0),fw((i-j+n-1)%n+1,1); } } } Heriko Deltana;} 「C」写不出 Check 好耶（ Time:3s Memory:512MiB. 「C」题目简述现在要将一个 $n(n\\le10^5)$ 个结点的无向树分割成 $k$ 个子树，使得这些子树中结点权值和最大的一颗最小。 「C」思路简述这个题的答案求解……嗯是二分没错了，那么下面的问题就是如何去写 Check（ 然而场上没写出来 T_T 所以这个的 Check 怎么写呢（ 考虑 DFS 去解决（ 设 $f(i)$ 表示当前结点 $i$ 所在的联通块的点权和。对于每一个节点，将其所有孩子的 $f$ 排序以后，从小到大依次往父亲里塞。 塞不下的，就只能切断了，也就是形成单独的联通块，塞进父亲里的，更新到父亲的 $f$ 中，可以继续和上面的节点合并，然后就能求出最大值。 排序和统计用个 vector 即可。 「C」Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y) {Heriko x&gt;y?x:y;}CI MXX(1e5+1);struct Node{ int nex,to;}r[MXX&lt;&lt;1];int cnt,head[MXX];I void Add(int x,int y){ r[++cnt]=(Node){head[x],y};head[x]=cnt; r[++cnt]=(Node){head[y],x};head[y]=cnt;}int n,k;LL val[MXX],ans,f[MXX],sz[MXX];vector&lt;LL&gt; sub[MXX];void DFS(LL lmt,int x,int fa){ f[x]=sz[x]=0;sub[x].clear(); int res(0);sz[x]=val[x]; for(int i(head[x]);i;i=r[i].nex) { int y(r[i].to); if(y==fa) continue; DFS(lmt,y,x);++res;sub[x].push_back(sz[y]);f[x]+=f[y]; } sort(sub[x].begin(),sub[x].end()); for(auto i:sub[x]) if(sz[x]+i&lt;=lmt) sz[x]+=i,--res; else break; f[x]+=res;}I bool Check(LL x){ for(int i(1);i&lt;=n;++i) if(x&lt;val[i]) Heriko Deltana; DFS(x,1,0); Heriko f[1]&lt;k;}S main(){ Files(); int T;fr(T); for(int ct(1);ct&lt;=T;++ct) { fr(n),fr(k);cnt=0;mst(head,0); for(int i(1),x,y;i&lt;n;++i) fr(x),fr(y),Add(x,y); LL sm(0),mx(0); for(int i(1);i&lt;=n;++i) fr(val[i]),sm+=val[i],mx=Hmax(mx,val[i]); if(n==k) { printf(&quot;Case #%d: %lld\\n&quot;,ct,mx); continue; } LL l(0),r(sm); while(l&lt;=r) { LL mid((l+r)&gt;&gt;1); if(Check(mid)) r=mid-1,ans=mid; else l=mid+1; } printf(&quot;Case #%d: %lld\\n&quot;,ct,ans); } Heriko Deltana;} 「Day14」⬜ 21-NOIP21-20D-D14 「启」哈哈又啥都没有，还是使用惊艳骗分。 缺省源使用「V5」. 「A」不知道该说啥。 Time:2s,Memory:512MiB. 「A」题目简述求一颗 $n(n \\le 2000)$ 的树上有多少点集 $S$ 内的任意两点的最短距离为 $d.$ 「A」思路简述先处理出深度，然后按照深度从浅到深跑 DFS，每次选取之前已经选取过的点，然后计算子集大小 $O(1)$ 回答询问。 「A」Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475CI MXX(2001),MOD(1e9+7);struct Node{ int nex,to;}r[MXX&lt;&lt;1];int cnt,head[MXX];I void Add(int x,int y){ r[++cnt]=(Node){head[x],y};head[x]=cnt; r[++cnt]=(Node){head[y],x};head[y]=cnt;}int n,dep[MXX],id[MXX];LL pw2[MXX],tot[MXX],ans[MXX];void DFS1(int x){ for(int i(head[x]);i;i=r[i].nex) if(!dep[r[i].to]) dep[r[i].to]=dep[x]+1,DFS1(r[i].to);}bitset&lt;MXX&gt; vis;void DFS2(int x,int fa,int stp){ if(vis[x]) ++tot[stp]; for(int i(head[x]);i;i=r[i].nex) if(r[i].to!=fa) DFS2(r[i].to,x,stp+1);}S main(){ Files(); fr(n); for(int i(1);i&lt;=n;++i) id[i]=i; pw2[0]=1; for(int i(1);i&lt;=n;++i) pw2[i]=(pw2[i-1]&lt;&lt;1)%MOD; for(int i(1),x,y;i&lt;n;++i) fr(x),fr(y),Add(x,y); dep[1]=1;DFS1(1);sort(id+1,id+1+n,[](int x,int y){Heriko dep[x]&lt;dep[y];}); for(int i(1);i&lt;=n;++i) { vis[id[i]]=1;int tmp(1); memset(tot,0,sizeof(LL)*(n+1)); DFS2(id[i],0,0); for(int j(1);j&lt;=n;++j) { (ans[j]+=(pw2[tot[j]]-1)*(pw2[tmp-1]))%=MOD; tmp+=tot[j]; } } int T;fr(T); while(T--) { int x;fr(x);fw(ans[x],1); } Heriko Deltana;} 「Day15」⬜ 21-NOIP21-20D-D15 「启」哈哈又挂了 A，还是只有垃圾 $10$ 分暴力。 缺省源使用「V5.1」. 「A」挂了。 Time:1s,Memory:1GiB. 「A」题目简述从 $n(n \\le 50)$ 个数中选出一个非空子集，求满足异或和等于与和，每个数都满足 $\\le 2^13.$ 「A」思路简述我们设 $f(i,j,k)$ 表示选取前 $i$ 个数，与和为 $j$，异或和为 $k$ 的方案数，那么显然答案为 $\\sum\\limits_{i=1}^{2^{n}}f(i,j,k)\\times[j=k].$ 因为直接开会炸空间，所以我们滚掉第一维，状态就变成了 $f(0/1,j,k)$，然后我们用一个栈来优化一下复杂度，要不然还是过不去（ 「A」Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253CI NXX(51),MXX(1&lt;&lt;13),SXX(1&lt;&lt;21);bitset&lt;MXX&gt; co[MXX]; int n,m,a[NXX],top[2];LL f[2][MXX][MXX];pair&lt; int,int &gt; stk[2][SXX];LL ans;S main(){ Files(); fr(n); for(int i(1);i&lt;=n;++i) fr(a[i]),m|=a[i]; int nw(0);f[nw][m][0]=1;stk[nw][++top[nw]]=mkp(m,0); for(int i(1),x,y;i&lt;=n;++i) { nw^=1;int lst(nw^1); for(int j(1);j&lt;=top[nw];++j) x=stk[nw][j].first,y=stk[nw][j].second,f[nw][x][y]=0; top[nw]=0; for(int j(0);j&lt;=m;++j) co[j]=0; for(int j(1);j&lt;=top[lst];++j) { x=stk[lst][j].first,y=stk[lst][j].second; f[nw][x&amp;a[i]][y^a[i]]+=f[lst][x][y]; if((x&amp;a[i])==(y^a[i])) ans+=f[lst][x][y]; f[nw][x][y]+=f[lst][x][y]; if(!co[x][y]) co[x][y]=1,stk[nw][++top[nw]]=mkp(x,y); x&amp;=a[i],y^=a[i]; if(!co[x][y]) co[x][y]=1,stk[nw][++top[nw]]=mkp(x,y); } } fw(ans,1); Heriko Deltana;} 「Day16」⬜ 21-NOIP21-20D-D16 因为某些原因未参加。 「SC1」⬜ 21-NOIP21-20D-SC1 同上。 「SC2」⬜ 21-NOIP21-20D-SC2 「启」因为某些事情，前几场考试没参加，这一场听说是信心场还 unr，就打一打玩。 缺省源使用「V5.2」. 「A」诈骗题，但是场上写的结论少了点东西所以只有 $80.$ 「A」题目简述一个长度为 $N$ 的字符串，字典集大小为 $M$，要求连续长度为 $K$ 的子串都必须是回文串，求方案数。 「A」思路简述看起来没啥东西所以就觉得很诈骗（ 分为以下几种情况： $k&gt;n$ 或 $k=1$ 时，答案为 $m^n.$ $k=n$ 时，答案为 $m^{\\frac{n-1}{2}}.$ 否则，当 $k$ 为 $2$ 的倍数的时候，答案为 $m^2$，若不是 $2$ 的倍数，答案为 $m.$ 「A」Code12345678910111213141516171819202122232425262728293031323334353637CI MOD(1e9+7);int n,m,k;I int FstPow(int x,int y){ int res(1); while(y) { if(y&amp;1) (res*=1ll*x)%=MOD; (x*=1ll*x)%=MOD; y&gt;&gt;=1; } Heriko res;}S main(){ Files(); fr(n),fr(m),fr(k); if(k&gt;n or k==1) fw(FstPow(m,n)%MOD,1); else if(k==n) fw(FstPow(m,(n+1)&gt;&gt;1),1); else if(k&amp;1) fw((m*m)%MOD,1); else if(!(k&amp;1)) fw((m+MOD)%MOD,1); Heriko Deltana;} 「B」考场写了个暴力，然后乆润了。 「B」题目简述每次可以在矩阵中选择一行或一列加到答案中，然后把选择的这一列的每一项都减去 $p.$ 「B」思路简述考虑把行和列的操作拆开先预处理，然后最后合并答案的时候减去互相的影响。 「B」Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y){ Heriko x&gt;y?x:y;}CI MXX(1001),KXX(1e5+1);CL INF(1145141919810);int n,m,k,p,a[MXX][MXX];LL ans(-INF),f[KXX],coi[KXX],coj[KXX],g[KXX];priority_queue&lt;LL&gt; q;S main(){ Files(); fr(n),fr(m),fr(k),fr(p); for(int i(1);i&lt;=n;++i) for(int j(1);j&lt;=m;++j) fr(a[i][j]); for(int i(1);i&lt;=n;++i) for(int j(1);j&lt;=m;++j) coi[i]+=a[i][j],coj[j]+=a[i][j]; for(int i(1);i&lt;=n;++i) q.push(coi[i]); for(int i(1);i&lt;=k;++i) { LL x(q.top()); q.pop(); f[i]=f[i-1]+x,x-=p*m; q.push(x); } while(q.size()) q.pop(); for(int i(1);i&lt;=m;++i) q.push(coj[i]); for(int i(1);i&lt;=k;++i) { LL x(q.top()); q.pop(); g[i]=g[i-1]+x,x-=p*n; q.push(x); } for(int i(0);i&lt;=k;++i) ans=Hmax(ans,f[i]+g[k-i]-(1ll*i*(k-i)*p)); fw(ans,1); Heriko Deltana;} 「C」是个大模拟，先不补。 「Day17」⬜ 21-NOIP21-20D-D17 缺省源使用「V5.2」. 「启」没啥好说的。 「A」场上做出来了。 题目。 「A」思路简述我们考虑对于每个点都用两个长度为 $m$ 的二进制数来存储，分别记录第 $i$ 位对应着第 $i$ 次操作的时候的 $X$ 或 $Y$ 归属状态，那么最终两个点 $i,j$ 之间是否有连边就等同于 $X_i \\operatorname{and} Y_j$ 的 $1$ 的个数是否为奇数加上 $X_j \\operatorname{and} Y_i$ 的 $1$ 的个数再减去两者交集。 「A」Code1234567891011121314151617181920212223242526272829303132333435CI NXX(2e4+1),MXX(64);bitset&lt;MXX&gt; X[NXX],Y[NXX];int n,m;LL ans;char s[NXX];S main(){ Files(); fr(n),fr(m); for(int i(1);i&lt;=m;++i) { scanf(&quot;%s&quot;,s+1); for(int j(1);j&lt;=n;++j) { Y[j][i]=(s[j]^48)&amp;1; X[j][i]=((s[j]^48)&gt;&gt;1)&amp;1; } } for(int i(1);i&lt;n;++i) for(int j(i+1);j&lt;=n;++j) ans+=((X[i]&amp;Y[j]).count()+((Y[i]&amp;X[j])^((X[i]&amp;Y[j])&amp;(Y[i]&amp;X[j]))).count())&amp;1; fw(ans,1); Heriko Deltana;} 「B」题目。 「B」思路简述看到这个问题，就很自然地想到二分，于是设 $b_i = a_i - x$，然后去二分这个 $x.$ 然后把 $b$ 的前缀和求出来，求长度为 $k$ 的 LIS. 「B」Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y){ Heriko x&gt;y?x:y;}CI MXX(2e5+1);const double INF(1e9);int n,k,a[MXX],mx;double ans,b[MXX],f[MXX];I bool Check(double x){ for(int i(1);i&lt;=n;++i) b[i]=b[i-1]+a[i]-x; int hd(0); f[hd]=INF; for(int i(1);i&lt;=n;++i) { if(b[i]&lt;0.0 or b[i]&gt;b[n]) continue; int pos(lower_bound(f,f+1+hd,b[i])-f); f[pos]=b[i]; if(pos==hd) f[++hd]=INF; } Heriko hd&gt;=k;}S main(){ Files(); fr(n),fr(k); for(int i(1);i&lt;=n;++i) fr(a[i]),mx=Hmax(mx,a[i]); double l(0),r(mx*1.0); while(l+(1e-4)&lt;r) { double mid((l+r)/2.0); if(Check(mid)) l=mid,ans=mid; else r=mid; } printf(&quot;%.4lf&quot;,ans); Heriko Deltana;} 「C」题目。 「C」思路简述首先把每个无向边改为两个有向边，然后在每个结点上，可以任意匹配来自两条不同树边的边。 总的方案数为 $2^{n-1}$，但是还有重复的方案，减去即可。 「C」Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960CI MXX(1e6+1),MOD(1e9+7);LL f[MXX],n,inv[MXX],fac[MXX],r[MXX],sum[MXX],tot[MXX],ans(1);I LL FstPow(LL x,LL y){ LL res(1); while(y) { if(y&amp;1) (res*=x)%=MOD; (x*=x)%=MOD; y&gt;&gt;=1; } Heriko res;}S main(){ Files(); fr(n); inv[0]=fac[0]=inv[1]=fac[1]=1; for(int i(2);i&lt;=n;++i) { inv[i]=(MOD-MOD/i)*1ll*inv[MOD%i]%MOD; fac[i]=(fac[i-1]*1ll*i)%MOD; } for(int i(1);i&lt;n;++i) { int x,y; fr(x),fr(y); ++r[x],++r[y]; } f[0]=tot[0]=sum[0]=1; for(int i(1);i&lt;=n;++i) { f[i]=(tot[i-1]+sum[i-1])%MOD; f[i]=(f[i]-f[i-1]+MOD)%MOD; f[i]=(1ll*f[i]*((MOD+1)&gt;&gt;1)%MOD*inv[i]%MOD); sum[i]=(sum[i-1]+f[i])%MOD; tot[i]=(tot[i-1]+sum[i])%MOD; } (ans*=FstPow(2,n-1))%=MOD; for(int i=1;i&lt;=n;i++) ans=1ll*ans*fac[r[i]]%MOD*f[r[i]]%MOD; fw((ans+MOD)%MOD,1); Heriko Deltana;}","link":"/2021/10/29/ZRNOIP21-20D/"},{"title":"引越しできるかな？","text":"藉以此篇，纪念刚学 OI 的我。 当我今天看我未 AC 的题面时，看到了这道题，想起我当时的样子，看到这个题没有人做，题面还有锅，于是决定提供翻译，以及修复样例，来纪念十一个月前啥都不会的我。 引越しできるかな？你 会 搬 家 吗？ 原题链接。 题目翻译现在有 $C$ 件长方体物品，给出其长，宽，高，求能够单独放得下每个物体所需最小的长方体盒子的体积。 物品不会倾斜放置。 输入格式输入共 $C+1$ 行，第一行为一个整数 $C.$ 第二行到第 $C+1$ 行，每行三个整数 $N,M,L$ 表示第 $i$ 个物体的长宽高。 输出格式一行一个整数表示所需的最小长方体盒子的体积。 输入输出样例输入#1 123210 20 3020 20 20 输出#1 112000 输入#2 1234310 20 3020 20 2030 20 10 输出#2 112000 输入#3 12345410 20 3020 20 2030 20 1010 40 10 输出#3 116000 输入#4 123210 10 1011 1 1 输出#4 11100 数据范围对于 $40\\%$ 的数据，满足 $1 \\le C \\le 10.$ 对于 $100\\%$ 的数据，满足 $1 \\le C,N,M,L \\le 100.$ 思路简述题面意思很明了，所以直接说做法。 因为我们只需要保证能有一种姿势能放进去就行，所以每次读入的时候按照大小顺序去更新盒子的三维即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define Heriko return#define Deltana 0#define Romanno 1#define S signed#define LL long long#define R register#define I inline#define CI const int#define mkp(a,b) make_pair(a,b)#define mst(a,b) memset(a,b,sizeof(a))#define ON std::ios::sync_with_stdio(false);cin.tie(0)#define Files() freopen(&quot;RNMTQ.in&quot;,&quot;r&quot;,stdin);freopen(&quot;RNMTQ.out&quot;,&quot;w&quot;,stdout)using namespace std;template&lt;typename J&gt;I void fr(J &amp;x){ short f(1); x=0; char c(getchar()); while(c&lt;'0' or c&gt;'9') { if(c=='-') f=-1; c=getchar(); } while(c&gt;='0' and c&lt;='9') { x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^=48); c=getchar(); } x*=f;}template&lt;typename J&gt;I void fw(J x,bool k){ if(x&lt;0) x=-x,putchar('-'); static short stak[35]; short top(0); do { stak[top++]=x%10; x/=10; } while(x); while(top) putchar(stak[--top]+'0'); k?puts(&quot;&quot;):putchar(' ');}template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y){ Heriko x&gt;y?x:y;}CI MXX(101);int n,ans[3],tmp[3];S main(){ Files(); fr(n); for(int i(1);i&lt;=n;++i) { fr(tmp[0]),fr(tmp[1]),fr(tmp[2]); sort(tmp,tmp+3); sort(ans,ans+3); ans[0]=Hmax(ans[0],tmp[0]); ans[1]=Hmax(ans[1],tmp[1]); ans[2]=Hmax(ans[2],tmp[2]); } fw(ans[0]*ans[1]*ans[2],1); Heriko Deltana;}","link":"/2021/12/10/%E5%BC%95%E8%B6%8A%E3%81%97%E3%81%A7%E3%81%8D%E3%82%8B%E3%81%8B%E3%81%AA%EF%BC%9F/"}],"tags":[{"name":"Me","slug":"Me","link":"/tags/Me/"},{"name":"About Blog","slug":"About-Blog","link":"/tags/About-Blog/"},{"name":"OI","slug":"OI","link":"/tags/OI/"},{"name":"F1","slug":"F1","link":"/tags/F1/"}],"categories":[{"name":"About Me","slug":"About-Me","link":"/categories/About-Me/"},{"name":"MyBlog","slug":"MyBlog","link":"/categories/MyBlog/"},{"name":"OI-Solutions","slug":"OI-Solutions","link":"/categories/OI-Solutions/"},{"name":"OI-TravelNotes","slug":"OI-TravelNotes","link":"/categories/OI-TravelNotes/"},{"name":"Other","slug":"Other","link":"/categories/Other/"},{"name":"OI-Theorem","slug":"OI-Theorem","link":"/categories/OI-Theorem/"},{"name":"Dreams","slug":"Dreams","link":"/categories/Dreams/"},{"name":"OI-Algorithm","slug":"OI-Algorithm","link":"/categories/OI-Algorithm/"}]}