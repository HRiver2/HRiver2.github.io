{"pages":[{"title":"About","text":"这里是 Heriko Deltana 的个人博客，相比于博客园的博客，这里会有更多非 OI 的东西（ 坐标 SD JN 或 LC，算半个 V 家人（ 喜欢 F1，或许能在一些水群看见我说 F1 相关，目前没买 2021，穷人只能先玩 2020，欢迎一起来玩（ 其实博客更新文章频率不高，主要都是在 HDSBN 更新一些日常啥的，毕竟这个博客等退役之后会大概会一直作为个人博客用，而博客园作为学术向的博客可能就弃了（ 个人向的内容主要是在观察人类，语文不行所以写的稀碎。 ENFP-T 略偏 INFP，不过咱也不知道咱是个嚒玩意（ 唔……不知道该写啥了，那就先这些吧：D","link":"/about/"},{"title":"My Friends","text":"留言互换友链 ヽ(✿ﾟ▽ﾟ)ノ .links-content{ margin-top:1rem; } .link-navigation::after { content: \" \"; display: block; clear: both; } .card-friend { width: 45%; font-size: 1rem; padding: 10px 20px; border-radius: 4px; transition-duration: 0.15s; margin-bottom: 1rem; display:flex; } .card-friend:nth-child(odd) { float: left; } .card-friend:nth-child(even) { float: right; } .card-friend:hover { transform: scale(1.1); box-shadow: 0 2px 6px 0 rgba(0, 0, 0, 0.12), 0 0 6px 0 rgba(0, 0, 0, 0.04); } .card-friend a { border:none; } .card-friend .ava { width: 3rem!important; height: 3rem!important; margin:0!important; margin-right: 1em!important; border-radius:4px; } .card-friend .card-friend-header { font-style: italic; overflow: hidden; width: 100%; } .card-friend .card-friend-header a { font-style: normal; color: #1e90ff; font-weight: bold; text-decoration: none; } .card-friend .card-friend-header a:hover { color: #d480aa; text-decoration: none; } .card-friend .card-friend-header .info { font-style:normal; color:#a3a3a3; font-size:14px; min-width: 0; overflow: hidden; white-space: nowrap; } Dfkuaid の 小窝 暖呼呼~ zythonc zyc 可爱w HYL 天梦 六变形战士，我们滴光！~ _ajthreac_ ご注文はブログですか？ Rolleylon 忽乘青玄，熙事备成 Suzt_ilymtics 嘿嘿……Suzt_ilymtics…… KEBrantily 呜呜……KEBrantily…… 友链格式 名称：$\\tt{Heriko Deltana}$ 网址：https://hriver2.github.io/ 头像：https://s2.loli.net/2022/05/21/WniEcsqYdjoTlg4.png 简介：ねぇねぇねぇ","link":"/friends/"},{"title":"Heriko Deltana&#39;s Social Behavior Note Insiders","text":"Heriko Deltana’s Social Behavior Note，即 Heriko Deltana 的社会行为记录，其实大约就是一个日记之类的什么东西。 记忆最深的日记是 LSP 的焚燃指间の回忆和 SZT 的梦回还 里记来写 HD 同学对于自己深刻理解刨析。里记，Insiders，嗯没有问题（ 外记写的东西这里就不写了吧（？反正是给自己看的。 2022.5.21果然如我所料，我这周一解决不了这个问题我就会寄，于是周一终于说话了。 然后就恢复了正常的状态欸，现在想想我之前的担心好离谱，但是只能说是想得太多了吧（ 姑且留下上周末的文字展现我的心理吧，不知如何的心理（ 2022.5.155.11 返校，今天是返校后的第四天。 我，到底想要的是什么呢…… 因为不再想写出来任何名或人称代词了，所以用「」代替吧，把之前的也改了 今天打开这里的时候，看到了上次写的。上次是在什么情况下写的呢……是看见了「」和别人聊天的截图……嗯 因为刚回家上网课的时候，也就是 4.8 之前吧，聊的其实很多……那几天我是真的觉得很好 后来因为「」有奥赛的安排，所以说的话就渐渐的少了吧。 然后说的话好像越来越少了，不过确实「」很忙就是了，所以其实交流少了也无所谓毕竟不能总是打扰。 然后因为找了别的可以转移注意力的东西，所以其实在家感觉还好。 但是返校，会把我在家里找的一切转移注意力的东西失效，因为在学校只有学习能转移注意力了，但是惭愧的讲这个转移注意力效果真的不如在家。 在学校就很矛盾，我在家可以有时间来整理情绪但是在学校真的除了晚上上床之后的时间没有一点时间来干这种事情，全天被学习赶着跑。然而上床之后整理情绪就很容易睡不着，睡不着就会影响第二天的学习，这是我更不想看到的。 于是杂乱的想法，不明所以的情绪就会在我脑海中不时的跳出来，但是我又没有条件去把他们写下来（指没人看见），就一直堆积让我很难受，但是难受又不能说，我能给谁说呢，谁能理解呢，谁能理解一个人在努力的和过去的复杂的消极切断的时候，他重构世界的几个重要的人和他甚至站一块面对面都没有话的心情呢…… 我猜不到，我不到啊，下次有空了再写吧。 2022.4.26事隔近两个月的更新呢……先把外记的搬过来吧： 我不去想的时候，不会让我有任何感受，所以就不要想了。 可是就像现在一样，其实是无意去想的，但是我看到就会让我感到难受。但是这难受没有理由啊，这不是我能管到的事情，我不能也不应该让事情都向着我想要的地步去发展，更何况，我也不知道到底我想要的是什么。。 所以我真的…… 所以，我真的好想……能回到前段时间的……不知道怎么形容，姑且叫做交流频率罢。 好奇怪啊我明明知道我什么都做不到，可是为什么会看到截图就难受。。。。 我从未有过这种感觉…… 但我觉得这不是吃醋之类的东西……吧。 我……唉……算了，玩游戏去吧。 2022.3.8外记当谜语人，里记还要当谜语人！ 其实大约就算感觉和「」说话变多了这样（ 但是这能带来这么大的精神状态提升我也没想到（ 某种程度上印证了对于我的依赖原则罢（ 2022.2.24今天好，好几次. 突然想起来这里那天 JJK 看了欸。 草了我元旦到底写的啥写的啥 完全没有那个意思吧，但是为什么写的这么像有那么个意思（？ 没有吧，应该大概完全没有吧 2022.1.26日我发烧都写的什么玩意！ 2022.1.1slf 好好……真的会有人……主动安慰我……谢谢，谢谢。 zyw 情理之中，谢谢啦（ mmg 没把我忘了，谢谢（（ 「」，谢谢你。。谢谢你 发烧真的是太好了，完全虚幻，到底什么是真的？ 不知道呐（狂笑 「」 居然也想唱 ROKI 来着。。 早知道早问问了。。。 但是本来这个里面就是写一些奇怪的东西的，不是么。 2021.12.11之前的，好像有构思这个 HDSBN 好长时间了，但是回家之后一直懒得写，所以之前的就等等再写吧（ 今天好像还没什么要说的，大约周天回家，看看到那个时候能不能写一点。","link":"/HD-Social-Behavior-Note/"}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/05/28/hello-world/"},{"title":"15 次回环之日","text":"十五岁生日小记（bushi 3.14,是数学节. 能在这样一个伟大的学科的节日过生日,我很荣幸 所以求求您了数学对我好一点行吗,150能不能让我得一个90? 关于1414,就这样过去了,算是我经历过的最不平常的一岁, 疫情,疫情时期的成绩起飞,返校考试三科的起飞,暑假的颓废,初三的跳崖下滑 再到兴趣社团(实验班)的压线险进,再到OI的重新起步. 总的来说,这一年没什么明显的成就,但是经历的挫折和起伏却不少 但是转念一想,我上了初中之后,也没太有平凡的一岁吧. 13岁,在12岁的WMC止步国赛之后,开启了和WMC项目的鏖战,请假了50+天,也不平凡,也累 再说15前两天,在宿舍里面说到, 我们原来在初中是43级,现在都是58了,比他们都小了15岁 我说,那我还差几天才出生呢 虽然说是玩笑,但是仔细想来,今天的确又是一个新的节点, 43-&gt;58 新的数字,新的开始,再加上3.14,这些都是巧合,又不是巧合 15,将是有一次的出发,在这一岁的旅途上,OI与学习,初中到高中,中考与高考的迫近…… 不过细想来,好像也就这些,有什么好怕的呢,现在一无所有,所以,没什么可以钩住我的 还是我两个周前开学说的那句,15,并不只是负重前行,也是轻装上阵 愿15,美好的事情将要发生 2021.3.13","link":"/2021/03/14/15th/"},{"title":"Nothing : Asymmetry","text":"琉球 ≠ 画画 主要是觉得「不对等、不对称」很有意思所以就想把想的写一下。 但是显然没空写所以就先放一个坑在这里。","link":"/2022/05/27/Asymmetry/"},{"title":"APIO2022 线上游记","text":"如题。 笑死了 APIO 周五到周天，周一周二 whk 联考。 Day1上午是 OI 中的计数，感觉高级而我不会，寄。 好吧没想到 hyl 比我摆的还快（ hyl 太厉害了！ 昨天的时候他说发现自己邮箱把 icloud 填成了 iicloud 于是就没有收到 APIO 的账号和密码。 于是今天上午去给人家发邮件申请办理，然后中午起床来了之后发现人家说他提供的身份证号不能被确认身份。 我就很震惊啊，他总不能把身份证号和邮箱地址都填错了吧。 然后一看，嘿嘿，还真是（ 因为感觉上午的课件不可补所以就直接放弃了（ 下午讲的 FWT 前半段好歹跟着听懂了一部分，所以晚上就开始搞 FWT，hyl 因为之前会 FWT 于是就研究今天老师课件上很妙的定义方式，而我把 xht 的题解整会了好歹是过了板子。 算是没白学吧（安慰自己 hyl 的账号在下午终于回来了（ Day2早上买了一个面包和一瓶咖啡。 虽然我一直觉得学校里卖的雀巢瓶装的咖啡和喝奶一样，所以我几倍呢都是把他当奶喝（ 五个小时三道题，参考去年的话是三黑难度，尽量把暴力打满吧（ 把昨天晚上没写完的 FWT 的初学博客写完了，但是为啥我的浏览器还是摆烂不给我加载 LATEX 啊。。","link":"/2022/05/27/APIO2022/"},{"title":"CF 1602 ABCF","text":"随便做点题。 同步发布于博客园 「启」实在是不想接着补前几天的 NOIP 冲刺了（尤其是遇到 Day11 D 这种毒瘤题），于是就上洛谷随便做点题。 发现今天的日推是 CF1602A，于是乆决定把这场比赛的 A,B,C 都做了，然后发现 F 也挺水的，就一起水掉了（ 「Div2.A」Two Subsequences「Div2.A」题目简述给出一个字符串 $S$，要求找到一个字典序最小的非空字串，然后输出这个字串和原字符串删掉这个字串后形成的串。 「Div2.A」思路简述还是一如既往的手速题（ 因为是找出一个字典序最小的非空字串，所以找到一个字典序最小的字母即可。 「Code」123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define Heriko return#define Deltana 0#define Romanno 1#define S signed#define LL long long#define R register#define I inline#define CI const int#define mst(a, b) memset(a, b, sizeof(a))#define ON std::ios::sync_with_stdio(false);cin.tie(0)#define Files() freopen(&quot;RNMTQ.in&quot;,&quot;r&quot;,stdin);freopen(&quot;RNMTQ.out&quot;,&quot;w&quot;,stdout)using namespace std;template&lt;typename J&gt;I void fr(J &amp;x){ short f(1);x=0;char c=getchar(); while(c&lt;'0' or c&gt;'9') { if(c=='-') f=-1; c=getchar(); } while (c&gt;='0' and c&lt;='9') { x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^=48); c=getchar(); } x*=f;}template&lt;typename J&gt;I void fw(J x,bool k){ if(x&lt;0) x=-x,putchar('-'); static short stak[35];short top(0); do { stak[top++]=x%10; x/=10; } while(x); while(top) putchar(stak[--top]+'0'); k?puts(&quot;&quot;):putchar(' ');}CI MXX(1005);char s[MXX];S main(){ Files(); int T;fr(T); while(T--) { scanf(&quot;%s&quot;,s+1); int a(1),n(strlen(s+1)); for(int i(2);i&lt;=n;++i) if(s[i]&lt;s[a]) a=i; putchar(s[a]);putchar(' '); for(int i(1);i&lt;=n;++i) if(i!=a) putchar(s[i]); puts(&quot;&quot;); } Heriko Deltana;} 「Div2.B」Divine Array「Div2.B」题目简述给出一个长度为 $n$ 的序列，求问在经过第 $k$ 次变换之后序列中的第 $x$ 个数。 第 $i$ 次变换为：对于所有的 $1 \\le j \\le n$，将 $a_j$ 变为 $a_j$ 在第 $i-1$ 次修改后出现的次数。 「Div2.B」思路简述时空限制还是挺宽的，而且我们可以简单的手玩一下发现一个序列进行最多 $n$ 操作之后就不会发生变化了，所以我们预处理出每次操作后的序列即可。 「Div2.B」Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define Heriko return#define Deltana 0#define Romanno 1#define S signed#define LL long long#define R register#define I inline#define CI const int#define mst(a, b) memset(a, b, sizeof(a))#define ON std::ios::sync_with_stdio(false);cin.tie(0)#define Files() freopen(&quot;RNMTQ.in&quot;,&quot;r&quot;,stdin);freopen(&quot;RNMTQ.out&quot;,&quot;w&quot;,stdout)using namespace std;template&lt;typename J&gt;I void fr(J &amp;x){ short f(1);x=0;char c=getchar(); while(c&lt;'0' or c&gt;'9') { if(c=='-') f=-1; c=getchar(); } while (c&gt;='0' and c&lt;='9') { x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^=48); c=getchar(); } x*=f;}template&lt;typename J&gt;I void fw(J x,bool k){ if(x&lt;0) x=-x,putchar('-'); static short stak[35];short top(0); do { stak[top++]=x%10; x/=10; } while(x); while(top) putchar(stak[--top]+'0'); k?puts(&quot;&quot;):putchar(' ');}CI MXX(2001);int a[MXX][MXX],co[MXX];S main(){ Files(); int T;fr(T); while(T--) { int n,q;fr(n); for(int i(1);i&lt;=n;++i) fr(a[i][0]),co[i]=0; fr(q); for(int i(1);i&lt;=n;++i) ++co[a[i][0]]; for(int i(1);i&lt;=n;++i) { for(int j(1);j&lt;=n;++j) a[j][i]=co[a[j][i-1]]; for(int j(1);j&lt;=n;++j) co[j]=0; for(int j(1);j&lt;=n;++j) ++co[a[j][i]]; } while(q--) { int x,k;fr(x),fr(k); if(k&gt;n) fw(a[x][n],1); else fw(a[x][k],1); } } Heriko Deltana;} 「Div2 C/Div1 A」Array Elimination「Div2 C/Div1 A」题目简述给出一个长度为 $n$ 的序列，定义操作 elimination(k) 为：从序列中选取 $k$ 个数，设 $x=a_{i_1} \\operatorname{and} a_{i_2} \\cdots \\operatorname{and} a_{i_k}$，然后让这 $k$ 个数都减去 $x$，直到所有的 $a_i$ 都变为 $0.$ 求问能选出多少个 $k$，输出它们。 「Div2 C/Div1 A」思路简述考虑到要让数变为全 $0$，于是我们选的数 and 起来必须要让每个数每一位上的 $1$ 都被消除，所以选定的 $k$ 必然是所有位上的 $1$ 出现次数的公因数。 总体的时间复杂度为 $O(Tn\\log^2n+n\\sqrt{n}).$ 「Div2 C/Div1 A」Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define Heriko return#define Deltana 0#define Romanno 1#define S signed#define LL long long#define R register#define I inline#define CI const int#define mst(a, b) memset(a, b, sizeof(a))#define ON std::ios::sync_with_stdio(false);cin.tie(0)#define Files() freopen(&quot;RNMTQ.in&quot;,&quot;r&quot;,stdin);freopen(&quot;RNMTQ.out&quot;,&quot;w&quot;,stdout)using namespace std;template&lt;typename J&gt;I void fr(J &amp;x){ short f(1);x=0;char c=getchar(); while(c&lt;'0' or c&gt;'9') { if(c=='-') f=-1; c=getchar(); } while (c&gt;='0' and c&lt;='9') { x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^=48); c=getchar(); } x*=f;}template&lt;typename J&gt;I void fw(J x,bool k){ if(x&lt;0) x=-x,putchar('-'); static short stak[35];short top(0); do { stak[top++]=x%10; x/=10; } while(x); while(top) putchar(stak[--top]+'0'); k?puts(&quot;&quot;):putchar(' ');}CI MXX(2e5+1);int GCD(int x,int y) {Heriko !y?x:GCD(y,x%y);}int a[MXX],n,co[31],ans[MXX],cnt;S main(){ Files(); int T;fr(T); while(T--) { fr(n);mst(co,0);cnt=0; for(int i(1);i&lt;=n;++i) fr(a[i]); for(int i(1);i&lt;=n;++i) for(int j(0);j&lt;=30;++j) co[j]+=((a[i]&gt;&gt;j)&amp;1); int g(0); for(int i(0);i&lt;=30;++i) g=GCD(g,co[i]); if(!g) { for(int i(1);i&lt;=n;++i) fw(i,0); puts(&quot;&quot;); continue; } for(int i(1);i*i&lt;=g;++i) if(!(g%i)) { ans[++cnt]=i; if(i*i!=g) ans[++cnt]=(g/i); } sort(ans+1,ans+1+cnt); for(int i(1);i&lt;=cnt;++i) fw(ans[i],0); puts(&quot;&quot;); } Heriko Deltana;} 「Div1.D/Div2.F」Difficult Mountain「Div1.D/Div2.F」题面简述有 $n$ 个人去爬难度为 $d$ 的山，每个人都有 $a,s$ 两个值。 $s$ 表示当且仅当一个人的 $s$ 大于 $d$ 的时候它才能登山，后者则表示这个人登山之后这所山的权值会被修改为 $\\max(d,s).$ 「Div1.D/Div2.F」思路简述显然是要贪心的去解，手玩分讨发现，当最值相等时我们让 $s$ 小的先爬不会使答案变劣，所以我们直接进行一边排序即可。 「Div1.D/Div2.F」Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define Heriko return#define Deltana 0#define Romanno 1#define S signed#define LL long long#define R register#define I inline#define CI const int#define mst(a, b) memset(a, b, sizeof(a))#define ON std::ios::sync_with_stdio(false);cin.tie(0)#define Files() freopen(&quot;RNMTQ.in&quot;,&quot;r&quot;,stdin);freopen(&quot;RNMTQ.out&quot;,&quot;w&quot;,stdout)using namespace std;template&lt;typename J&gt;I void fr(J &amp;x){ short f(1);x=0;char c=getchar(); while(c&lt;'0' or c&gt;'9') { if(c=='-') f=-1; c=getchar(); } while (c&gt;='0' and c&lt;='9') { x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^=48); c=getchar(); } x*=f;}template&lt;typename J&gt;I void fw(J x,bool k){ if(x&lt;0) x=-x,putchar('-'); static short stak[35];short top(0); do { stak[top++]=x%10; x/=10; } while(x); while(top) putchar(stak[--top]+'0'); k?puts(&quot;&quot;):putchar(' ');}template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y) {Heriko x&gt;y?x:y;}CI MXX(500001);struct Rubbisher{ int a,s; I bool operator &lt; (const Rubbisher &amp;co) const { int mx1(Hmax(a,s)),mx2(Hmax(co.a,co.s)); if(mx1!=mx2) Heriko mx1&lt;mx2; else Heriko s==co.s?a&lt;co.a:s&lt;co.s; }}a[MXX];int n,d,ans;S main(){ Files(); fr(n),fr(d); for(int i(1);i&lt;=n;++i) fr(a[i].s),fr(a[i].a); sort(a+1,a+1+n); for(int i(1);i&lt;=n;++i) if(a[i].s&gt;=d) ++ans,d=Hmax(d,a[i].a); fw(ans,1); Heriko Deltana;} 「终」水。","link":"/2021/10/30/CF-1602-ABCF/"},{"title":"16 次回环之日","text":"十六岁生日巨献（bushi 提前几天开这个罢，想要等到回环的当天能够准时发出，毕竟周五当天写肯定是写不完罢。 2022.02.27 感觉快写成年度总结了（不就是吗 2022.02.28 好像大约能写完，好 但是感觉内容没什么逻辑的样子，无所谓了（ 2022.03.01 咋越写越慢了，感觉甚至写不完了（ 2022.03.02 今天一定要写完（ 写完啦，完结撒花（并不 2022.03.03 今天在展望里加了一点东西，改掉了一些奇怪的语句（ 2022.03.11 回顾去年，怎么说呢…… 好复杂的一年，经历的事情也很多，自己的变化也很多…… 那就从上次回环之日前一点开始回忆罢。 2020.12 ~ 2020.1想起来也是一年前的事情了（废话） 升入初三之后的状态是真的不好，学习成绩总是不向上走，大有一滑到底之势。于是，12 月月考，就真的一滑到底了（ 当时大概是十二月中旬罢，当时的我在某种意义上算是日记本的地方上写下了： 在那一天之前，却知道那一天不会到来。 当时应该是对自己快绝望了，明明平常不比别人差，为什么实验班要参考的考试就炸成这样（ 所以这里写的“那一天”，就是实验班录取的那一天。不过那个时候的我心态还是调整得比较快的，毕竟去不了实验班那就考推荐生嘛，再不济中考也是可以的……罢。不过那个时候单调下降的成绩让我觉得中考希望也寄了的感觉（ 然后就换了一个比较离谱的位置（我咋想也想不到为啥我会和 jp 同桌去，班主任换位的时候是忘了初一的事情了么w），然后度过了一个比较快乐的圣诞节（指帮迪哥打掩护以便于迪哥可以给 jp 送礼物（草），以及第一次收到别人礼物（大约是，反正初中之前我也不记得了））。 当然这个时期还是在好好学习的，期末考试虽然还是低于预期（主要是语文拉跨），但是也算是回升了，大约是没有压力的原因。 一月的时候去参加了实验班选拔考试，放轻松考的，发挥啥样不知道，但是大约是除了信息炸了都算正常。（我的水平来说，毕竟本身不太适合其他科奥赛之类的，但是就信息写炸是我真的没想到的）想起来英语的作文格超级长，于是自己写了 500 词的作文进去（草） 考完期末考试和济南市抽测之后的一个周六的下午，因为是考完试了就放松了一点，去教室相对晚了一点，然后到了教室听见体育实心球可以补测，我其实非常想去，因为满分 9.6 米，我 9.5x（ 但是级部主任在广播里说先等等，然后宣布了实验班的名单，一个一个的念名字。因为这个时候期末考试肯定没批完，所以我才发现参考期末考试好像只是为了稳心，所以我突然觉得我还是有希望的，于是就很紧张，万一有我呐（ jp 也很紧张，于是我俩就互相紧张的拽着对方袖子（草） 很多熟悉的名字从广播里传来，班里也不断有被念到的同学，大家都为被念到的同学鼓掌（ 一百个了，应该没我了罢，应该…… 然后倒数第二个念到了我，我也就成了我们班最后一个进入实验班的同学（ 再往后就是比较常规的实验班生活了（ 2021.1 ~ 2021.6比较常规的实验班生活罢，也没啥而特别的好像，情绪波动趋向于月初沉月末高循环。 2021.6 推荐生考试过了，顺利正式进入高中（ 6.16 初中那边毕业典礼，参与了部分毕业 PPT 的制作啥的，挥手告别初中三年（ 然后就是全天奥赛，这也是我 OI 水平提升最快的一个时期，也整好了暑假的培训计划（ 2021.7 ~ 2021.8和🐏、🍑度过了一个欢快的暑假（ 虽然日照的 SDSC 宿舍非常 **，隔壁的小学生非常**，但是和🐏🍑过的挺快乐的（ 因为大约报班报低了，再加上那段时间的竞赛状态很好，所以每天下午模拟赛都挺顺畅的，Day 6 的时候甚至 AK（也是我唯一一次 AK 比赛，大嘘 在 SDSC 期间正式入坑了 Phigros 和 Arcaea，音游自此逐渐成为我手机上唯一玩的东西（ 因为 Arcaea 里有一首 IA 的 One Last Drive，于是第一次关注到 IA（伏笔x） 然后两次课都是在济南，除了 QBXT 第一天考试因为电脑电源被后面孩子碰掉心态炸裂而爆零之外，感觉都在一个 21 年我相对高的竞技状态上，最好成绩是 BCT 最后一天捡皮夹拿了 RK2（ 考完试之后一看睿站发现无意中转发的抽奖中奖了……草。 话说我都不知道那条是抽奖来着，单纯的评论并转发（ 于是大约那天就把今年所有 RP 全用完了，一天之内一个皮夹一个中奖（ 感谢大哈鱼的 648，给我 美好的日子总是短暂的，上完课就直接返校了。 2021.9 ~ 2021.11大约从十月的下半段开始就停课了，停课之前的班内生活好像没有啥记住的了。 好像影响比较大的是小明带着我入了术坑（ 九月中旬生物去湖南集训，因为宿舍里其他人都是生物的，于是有天中午就睡过了，那天因为教室里缺的人太多，甚至没人发现我没来（ 国庆假期前夕才想起来 9.29 是翔 B 和小明的生日（其实是他们在群里都开始发他们在湖南生日的照片了我才想起来，我对不起 国庆完了生物从湖南回来之后，我们就开始停课了，完美衔接生物，班里人总是不齐，不过班里少上六七个人也不是很影响（ 由于暑假的缘故，我和学长交际比较多。停课的日常就是上午做正睿的模拟赛，下午晚上补题。 额但是不知道为啥吧，竞赛状态比暑假下降很多，放张正睿 rating 在这里吧（ 其实 CSP 二轮之前的状态还是可以的，除了担心自己 T1 挂掉之外（毒奶实锤(╯▔皿▔)╯ 然后就去了日照，懒得再复述了，看游记吧（ 从日照回来的那天晚上，没睡着，真的睡不着，谁能想到自己的第一次正式比赛以这样的形式结束。 那天晚上真的是不知道该咋办了，虽然不断给自己说着 CSP 就是一个晋级 NOIP 的跳板，但是心里还是意难平。 放在四个多月后的今天，我感觉那可能是十一月的……一个预兆罢。 因为自己铁不是一等，心里有点虚，所以再返校之后还是先去班里上了几天晚自习装作自己没有完全停课（ 但是等 NOIP 名单出来之后就还是全天停课了，心态恢复的还挺好的。 然后就是被正睿的模拟赛连番血虐，低于百分成常态，不过本身我也不太有高分的预期，所以也觉得无所谓，于是就正常的补题 2021.11.04……这天不太好[1] 但是不好的事情还是不提了好，活着多好（ 于是就有了那天提前回家，然后就不想去学校了，直接去 BCT NOIP 的班了。 然后就是在自己学校的 NOIP，考场想出来正解但是因为打挂以为是想假了，又炸了了一次 T1，但是精神状态的原因就有了博客园和 Github 博客都没有写的 NOIP 游记。 我只能是对自己无语，也无助，于是第一年就以两个二等收尾了。 当时还感觉 11 月有 20 天停课很长，现在好多事情都可能都忘了就觉得 11 月消逝的非常快（ 2021.11 ~ 2022.2这段时间就是回归班学 whk 的日子了，中间夹了一个寒假（ 最一开始是觉得真的拉下好多课，但是由于级部里的进度我都学过了所以后期月考之前做了做期中的题感觉挺顺利的（ 但是期中和月考完全不是一个难度啊草，期中随随便便切掉，月考给我整不会了。不过作为高中第一次考试主要攒经验去了（ 然后就是一个快乐的元旦，Sociobiology Note 里有说，懒得再写一遍了（ 因为没拿省一，也没有任何 whk 优势，于是在这段期间思考明年的事情。已知的是上一级信息不受待见停课之后全都被扔到普通班，然而我经历过 11 月的低沉之后和其它一些原因是真的不想再去适应新的环境了，也不想离开这个环境（ 然而也不是没有解决方案，第一种是考回前 200；第二种是上一级有学长选择不停课，成为了上一级唯一留在实验班的信息人（ 于是我决定效法，拿省一就润的话，今年暑假如果我觉得应该可以稳有那个水平了，就不长时间停课了，保持留在实验班吧。 至于这段时间的心理状态的话，除了元旦的时候发烧、考完期末和寒假最后的时候，也没太有回到 11 月的迹象了（ 新年的目标是活着就行（ 期末考试完全低于预期，不符合自己的练习量啥的。一般来说放在往前就依然按照之前的方式学就是了，但是十一月之后因为没有过往的负担了还是啥，准备故意开学考砸一次，看看会不会有老师找我。[2] 然后寒假就没怎么学文化课，基本都在看奥赛或者不知道在干啥（感觉是在挣扎？），开学也故意考差，目标是班里倒数第一，试图摸班底。[Ex] 但是结果就是并不是班里倒数第一，甚至也没有老师找我（[3] 可能是因为现在内心世界即使重构，也是完全变形，和之前不一样了罢（[4] 感觉十一月之后心理受到的影响还是挺大的，所以尽量避免这种事情罢（ 开学之后给自己心理暗示还是比较积极的，趁着这段乐观的重构期好好做一些事罢（ 展望前面说到了，对自己未来一年的预期不再像是上次回环之时了。 这一岁目标就一个了，活着，活到 17. 十一月以及之后我想了很多，很多。对自己的否定、肯定；对内心世界的肯定、否定；对未来的希望、失望；对前途的坚定、迷茫；对生命的滥想…… 还是顺其自然罢，活着就好，就算有极端的想法…… 那我不存在了，上面的都没用。 所以活着罢，活到未来，这是我唯一的期许。[5] 以下内容更新于 2022.03.11 介于这几天发生的一些事情以及一些思考，对最后一段做一些简单的添加罢。 前面说的活过这一年还是有点重了，某种意义上（ 因为我胆小啊（笑），只要没人要把我干掉就没啥问题的罢。 之前写那些的时候主要是回想起太多不好的事情，所以就写的 down 了一点。 虽然还是比较难逃出来自己给自己压出来的阴影，但是不至于对自己干一些极端的事情罢（大概）[6] [1] 我不会忘记那一天了。 痛的，苦的，闷的，烦的，所有 downside 的东西，一起冲向脑海了，我真的承载不住了，出生十五年来所有积压的东西，把我死死的压在地上。 甚至快四个月过去了，那些东西到底从我身上离开了多少，我无法确定。那时的我那到底是谁呢，我吗？不知道，我真的不知道，不会描述，但是难受，不知道，真的不知道…… 世界崩塌的那一刻我不会描述。 于是十一月之后就在一点点的重构世界（ 十一月之后感觉在各种方面还是变化挺大的，某种意义上之前我线上线下还是比较统一的，但是从那之后就开始，线上线下逐渐“分裂”了。 我不知道哪个是真正的我，因为这好像都是我，但是好像有点偏向人格分裂了，不过和人格分裂的定义好像不太一样，人格分裂是完全的每个人格之前分裂开来不互通，而线下的我和线上的我之前好像还有一个独处的我连接着。 其他方面的话，好像极端的想法多了一些，之前不敢的事情敢去做了。（当然还是有很多不敢的） 情绪化更严重了，网络依赖更严重了（不如说是对“线上人格”的倾向更严重了） 不愿意说话的时候变多了，自己一个人沉默的不知道要干什么的时候变多了。 [2] 寒假最后不知道自己想干啥，真的，而且很虚弱，不知道为什么。 [Ex] 寒假最后玩了主播女孩重度依赖，感觉对我还是挺有影响的，主要是认识到好像自己还有救，假如积极一点。 说到重度依赖呢，今年在回归文化课之后逐渐发现了自己的一些精神支柱是别人的事实，而且这个支柱对我影响还挺大的。 [3] 看来已经学校没人在意我考成啥样了罢。 [4] 第一次有了想毁掉别人的想法，反正自己已经没有什么用了，无所谓了罢。 [5] 毕竟这个也失去真实世界的我的存在之后，一切都无法后悔了罢。 [6] 谁能想到一个周了我又想补充一些东西呐…… 首先是去掉了之前对于 11.04 的前缀描述，感觉有点多余了，虽然没有人看。 然后把这些字调成了真正的透明。 想改一部分描述的主要原因是有点写的 down 了。 其余原因就是生日之后每天都还过的挺好的（ 但是昨天开始微微感到架空世界的感觉了 换句话来说就是把世界架空到一个或者一两个人或事之上了 虽然这段时间挺好的，但是未来会怎么样呐？ 不是，我瞎想什么呢。。","link":"/2022/03/04/16th/"},{"title":"Blog Develop Log","text":"记录这个博客的更改 如果看过我 Cnblogs 博客的应当知道我很闲，在一个博皮上稍微改个颜色都要记录一下（ 然而我习惯难改所以这个新博客也有这个东西了呐。 2022.4.19 修改默认字体为 Formula1 Display. 2022.1.7 开始加题图咯（ 2021.11.2 配置好了友链，欢迎来互换友链（ 2021.11.1 配置好了 gitalk，现在可以自由的评论力！ 2021.10.31 配置好了 Mathjex. 移除了对于我无用的捐赠等界面。 2021.10.30 正式启用这个博客。 2021.10.29 选用主题 icarus，并进行初步的设置。","link":"/2021/11/01/Blog-Develop-Log/"},{"title":"CF 1671","text":"随便做点题。 不想写前言的最好方法，就是不写（ 因为这些题很简单所以简单一提。 A String Building找出最小的串长，如果小于 $2$ 就不能拼出来。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566template&lt;typename J&gt;I J Hmin(const J &amp;x,const J &amp;y) { Heriko x&lt;y?x:y;}CI MXX(55);char s[MXX];S main() { Files(); int T; fr(T); while(T--) { scanf(&quot;%s&quot;,s+1); int n(strlen(s+1)),mina(MXX),nw(0),minb(MXX); for(int i(1);i&lt;=n;++i) if(s[i]=='a') ++nw; else { if(nw) mina=Hmin(mina,nw); nw=0; } if(nw) mina=Hmin(mina,nw); nw=0; if(mina==1) { puts(&quot;NO&quot;); continue; } for(int i(1);i&lt;=n;++i) if(s[i]=='b') ++nw; else { if(nw) minb=Hmin(minb,nw); nw=0; } if(nw) minb=Hmin(minb,nw); nw=0; if(minb==1) { puts(&quot;NO&quot;); continue; } puts(&quot;YES&quot;); } Heriko Deltana;} B Consecutive Points Segment序列中只有一个数的时候显然怎么改都能保证连续；当序列中有多个数的时候，因为一个序列若满足连续，那么这个序列的首项和末项之差为 $n-1$，而且给我们能填入的数字都他相近的两个数，也就是说在这里我们只能让这个差值更小，所以我们只能在原序列差值小于等于 $n-1$ 的时候才能修改得到一个满足连续的序列。 1234567891011121314151617181920212223242526CI MXX(2e5+5);int n,a[MXX];S main() { Files(); int T; fr(T); while(T--) { fr(n); for(int i(1);i&lt;=n;++i) fr(a[i]); if(n==1) puts(&quot;YES&quot;); else if(a[n]-a[1]&gt;n+1) puts(&quot;NO&quot;); else puts(&quot;YES&quot;); } Heriko Deltana;} C Dolce Vita首先肯定会有一天是临界状态，即我们能在这一天买最多的，从这一天往后买的越来越少，所以我们可以直接去找这一天，因为要贪心排序所以时间复杂度 $O(n \\log n).$ 1234567891011121314151617181920212223242526272829303132333435CI MXX(2e5+5);LL n,x,a[MXX];S main() { Files(); int T; fr(T); while(T--) { fr(n),fr(x); LL sum(0),lst(-1),ans(0); for(int i(1);i&lt;=n;++i) fr(a[i]),sum+=a[i]; sort(a+1,a+1+n); for(int i(n);i;--i) { LL now(-1); if(x-sum&gt;=0) now=(x-sum)/i; ans+=i*(now-lst); lst=now; sum-=a[i]; } fw(ans,1); } Heriko Deltana;} D Insert a Progression先拿出来一个样例进行观察，可以发现如果在两个数之间填入一个数，那么这个序列的分数会不变或增大，那么我们就要尽可能的让这个序列的分数不变，即填入的数的大小在这两个数之间。 这样的话只有 $1$ 和 $x$ 有可能会对分数造成影响，即最小值大于 $1$ 和 最大值小于 $x$ 的时候，所以我们枚举找到最小值即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y) { Heriko x&gt;y?x:y;}template&lt;typename J&gt;I J Hmin(const J &amp;x,const J &amp;y) { Heriko x&lt;y?x:y;}CI MXX(2e5+5),INF(INT32_MAX);LL n,x,a[MXX];S main() { Files(); int T; fr(T); while(T--) { fr(n),fr(x); LL mi(INF),mx(-INF),ans(0); for(int i(1);i&lt;=n;++i) fr(a[i]),mi=Hmin(mi,a[i]),mx=Hmax(mx,a[i]); for(int i(2);i&lt;=n;++i) ans+=abs(a[i]-a[i-1]); if(mi&gt;1) { LL tmpans(Hmin(a[1]-1,a[n]-1)); for(int i(2);i&lt;=n;++i) tmpans=Hmin(tmpans,a[i]-2-abs(a[i]-a[i-1])+a[i-1]); ans+=tmpans; } if(mx&lt;x) { LL tmpans(Hmin(x-a[1],x-a[n])); for(int i(2);i&lt;=n;++i) tmpans=Hmin(tmpans,2*x-abs(a[i]-a[i-1])-a[i]-a[i-1]); ans+=tmpans; } fw(ans,1); } Heriko Deltana;} 嗯，就四道简单题，终。","link":"/2022/05/03/CF-1671/"},{"title":"CSP S2 2021 游记","text":"CSP S2 2021 游记 「在启之前」这个后面的内容和博客园上是一样的，但是这是更偏向我个人向的博客，所以我还是多说一点（ 今天晚上出成绩之后，和之前自己预测的差不多，应该是个能进 NOIP 但是省三/省二的分数。在博客园上写的标题是”退役记”，但是都明白实际上这一切才刚开始一年。 即使只剩下了高二一次机会， 即使 NOIP 省一要比 CSP-S2 难， 即使因为考场上有各种失误而不甘， 但是还是要打下去的，不然为什么要选 OI 呢。 所以应当摆大烂！ 所以应当接着努力（ 「启」孩子第一年打比赛，给孩子打傻了。 因为复赛就 10.23 一下午而已，所以就用日期当标题了。 「2021.9.X」发现自己过了初赛，按照 CCF 的标准来说，居然还是 《全 国 一 等》，笑傻。 「2021.10.1 ~ 10.7」报了 ZR 的线上课，在家听课。 最后一天考试感觉不错，体验很好。 「2021.10.8 ~ 10.21」ZR 的 NOIP 冲刺，每天都在考试，但是时好时坏……总体不好，题也补不完，就很蛋…… 「2021.10.21」提前一天从学校回到家，晚上进行了随便看了看模板，去 fys 的 CSP 2020 赛前总结那里看一些易错点，顺便扫墓。 晚上和初中班主任打了电话，虽然已经在高中上了 10 个月的课了，但是和初中班主任联系还是很多，好多事情都必须要感谢，人真的很好（ 主要说了点关于心态的东西，然后晚上大约就水过去了。 因为 Phigros 22 号要更新，所以我试图等更新，但是后来发现都说是 22 号下午，就没再等，然后乆睡了。 「2021.10.22」上午和昨天晚上差不多，中午吃完饭往日照走。晚上敲了个线段树板子，结果没调出来，懒得调乆睡觉了。 下午在车上更新了 phigros，2.0 属实好看，体验很好（ 新铺子除了狂喜的 IN 都觉得简单了好多，☁️女孩慢速彻底没了（ 因为 Win11 刚上了 WSA，整了一会，体验一般。 「2021.10.23」 比赛日。 「上午」上午先是试图调出来昨天晚上的线段树，但是发现 KnightL 他们建了一个 SD 面基群，然后就听 hyl 唱歌（？） 然后去找 Dfkuaid，ceh，hyl，在他们宾馆呆了一会。 然后就是正常的吃饭，实际上到了吃饭的时候才发现好像真的要比赛了呐，会宾馆睡了一会，我爸说睡得很香。 「下午」起床之后乆直接去山外了，时隔三个月又回到了这个破地方……SDSC 属实难受。 下车正好遇到 hyl，Dfkuaid，ceh 下车，我们四个乆一块去，然后就是非常正常的进行拍照，本来还要喊某口号来着。 口号则是去年 LCEZ 的 CSP 二轮典中典： $$ 人生在勤，志达天下\\ 亮剑精神，信息之光\\ 脚踏实地，勇争第一\\ $$ 然后就是进去考试试机（ 「13:50 ~ 14:27」说实话因为心里没想啥所以就只是单纯的打了我常用的缺省源，试了试 auto，bitset 等自 己 常 用的东西（埋 下 雷 了），然后测了测机子的速度，可以说是很慢。所以我还去确认了一下配置之类的。最后总结来看我考试用的机子的环境是： i3-4130 + 4G + Win10 + DevC++ 5.10 (gcc 4.8.1) 嗯没错这个环境 c++14 开不了，虽然好像部分符合 14 的标准来着（ 试了试 __int128 发现不能用，但是试机的时候没想出来为啥不能用，后来考试开始了我才发现是因为这个破东西的 DevC++ 默认的 gcc 是 32bit……当然最后也没用到 __int128 就是了。 发现输入法没有英语环境，乆从设置里整了一下，然后按照自己的使用习惯又开了两个桌面，这三个桌面分别负责 Coding，读题 and 审题，以及检查文件。 把 DevC++ 的时间戳自动保存开开了，防止出问题。 看 起 来 真 的 是 十 分 万 全 的 准 备 了 呐。 然后乆没测啥，等着发密码。去看了一眼文件的大小，发现有个样例好大的样子，略感震惊。 密码好像就是非常正常的随机生成的样子来着（ 「14:30 ~ 14:45」这个十五分钟先是过了一遍题，当时觉得 A 仿佛是最可做的，B 和 C 有一点 DP 的意思，以上三题都有暴力分，分别是 40 + 15 + 28，D 觉得不太可做，所以就最后开题的顺序是 A(BF)B(BF)C(BF)ABCD. 「14:45 ~ 15:00」这十五分钟主要是把 A 的暴力写了出来，然后测了测样例，发现三个都过了，就按照既定的顺序去写 B 的暴力了。 然后，一 个 人 类 的 噩 梦 来 了。 「15:01 ~ 17:47」前半段时间就一直在写 B 的暴力 DFS，我不知道为什么最后总是一会 RE 一会不 RE，很奇怪，于是就去开了 C 的暴力。 也是一个 DFS，难道是本场暴力都是 DFS 么（悲 然后……写了一段时间，也和刚才的 B 差不多，同一段代码一会 RE，一会不 RE，就给孩子整离谱了（？ 然后因为之前喝了两罐 RB，于是就决定去上个撤硕。 上撤硕的时候灵光乍现：它 RE 的时候总是说我 vector.h 这个头文件错了，不 会 是 哪 个 STL 锅 了 吧。 然后我就自然的想到了 string 身上。 「17:57 ~ 18:30」回去之后，想了一下发现其实 C 没必要用，用 char 数组就行，然后，果然不 RE 了（？ 然后发现答案的字典序不对，就又对着调了一下，后来发现是对比的时候下标对应错了，改完就对了，而这个时候已经来到了 18:11，终于是过了样例…… 然后去看了半天的 B，死活改不出，然后在 18:21 的时候终于放弃抵抗，把样例全都特判了上去，并把自己打的 DFS 注释掉，并在其中慰问了 CCF. 然后最后检查了一遍就把东西整好了交上去了，要交的时候问了一下旁边的老师是不是没有什么问题，然后老师看了看，说“都身经百战了，这点不会错的，不用紧张这些。” 第一年打的孩子大为震惊（ 临近考试结束了，旁边的孩子吃东西的表情越来越绝望，看来是打的也不好啊（ 考完了去看了看同场的 hyl，它还在交文件。 出了考场发现除了我都切了 A，然后算了算发现今年暴力打满还不如一个正解……突然感觉省一无了，省二勉强。（实际上是省三（ 「晚上」因为第二天要返校，所以当天晚上乆回去了，路上和爸妈，和初中班主任，进行了一堆聊天（ 最后觉得应当能进 NOIP 就考虑接下来如何权衡 whk 和奥赛，说实话因为 whk 不如其它的人好，所以确实很纠结。 晚上到家十点半，上床之后不知道为什么就是睡不着，虽然过去 CSP 感觉还是没啥两样，但是确实是睡不着（ 手机放在旁边充电，看了一会 QQ，然后就睡了。 「2021.10.24」今天早上起来发现： 晚上（也就是现在）发了程序，本来期望是 $40 + 0 + 28 + 0$ 或者 $40 + 0 + 40 + 0.$ 结果呢洛谷测一测……T2 注释多了 CE 了，T3 好像暴力假了爆零。 更正一下，T3 爆零是因为多测清空不完全，暴力部分内的答案是对的。 目前测试的结果：洛谷 $40 + 0 + 0 + 0 = 40$（10.24 测，期望最低，希望 CCF 数据能放亿点水qwq） InfOJ $50 + 0 + 16 + 0 = 66$（10.29自测，这个 T3 可能比较现实） LOJ $45 + 0 + 24 + 0 = 69.$（10.26自测，可能是这个的 T3 数据有 $T=1$ 的部分） HydroOJ $60 + 0 + 24 + 0 = 84$（批量，可能这个 T1 的数据水一点，不知道为啥 T3 的数据改的像 LOJ 一样有 $T=1$ 的东西了） 最后应该是 $40$ pts 滚粗，恭喜你 LCEZ 喜提一个省三。 「2021.10.30」出成绩了，和 LOJ 的一样，等 NOIP 吧。","link":"/2021/10/30/CSP-S2-2021/"},{"title":"Dell5568","text":"关于老物的一些字。 章零 · 序章实际上从这个在暑假的开端，就有写这篇的想法了，不过由于各种神必的原因一直没写就是了，也不知道什么时候能写完 说实话网上应该也不会有人和我一样干啥都想写点东西，所以这篇文章大约就是你能看到的最详细的16 年过气本 Dell Vostro 5568 体验。 这篇文章和 OI 关系不大，可能同步到 Bilibili 专栏和酷安。 Bilibili 上虽然不支持手写 Markdown 但是有基本的常用语法，所以排版和这里算是差不多罢。 而酷安的话不支持 Markdown 所以大概率会重写一份罢。 同时因为酷安和 Bilibili 毕竟不是自己博客，所以里面的一些小东西也会不一样（ 但是这里应该就是最全了的罢，但是可能因为某些神必原因，我对 2018 年之前的事情都记得比较模糊了，所以总体的文章长度也不长（ 章一 · 初见这个是 2016.12 发布的本子，而我是 2017.01 拿到的它。 实际上也没有什么初见可爱单推的过程ww 当时还是小学，现在来看觉得自己很幸运能够这么早的接触这些东西，这也可能是我走上 OI 这条路的原因之一。 当时比较天真，关于电脑就只能知道它能否正常的运行，各种毒瘤的软件也霸占了那个电脑的小硬盘。 后来由于自己装了一大堆神必东西导致电脑很慢很卡，于是懒得去开电脑，后来逐渐变成多数时间都不碰它。它便逐渐吃灰，从我的生活淡出。当然有些必要的时候还是要用到它的 那时候也不知道如何保护电池什么的，这也为后来埋下了伏笔（？） 章二 · 重逢上面说的它从我这里逐渐消失了存在感（ 但是 2020 年的疫情让它重新回到了我的生活当中来，学校选择的网课平台对 iPad 适配极差，在老家度过疫情最严重的前两个月之后，我实在是忍不住就回家拿了电脑。 当时我一打开电脑扑面而来的是 Windows 安全中心 VS 迈克菲 VS 360 VS 火绒 的壮观场面，考虑了一下最后先用 360 把最毒瘤的软件干掉了之后只留下了火绒。当然如果要按照后面的事情来看根本不必如此（ 因为那个时候也是算是开始逐渐对数码之类的东西真正有点懂了，就开始对电脑进行各种神必的操作优化，上课划水无师自通。 突然有一天我妈问我如果高中五大奥赛要选一个，我会选哪个。我当时可能是出于对信息方面的爱好（？）于是选了 OI，从此踏上 OI 的不归路。后来好像听说家庭版的 C++ 库什么的好像不全（现在发现其实都是能自己装的），于是想着要不然就重装个系统罢，然后这就是梦开始的地方了。（这里指噩梦） 当时我把找了个 熟 人 帮我重装系统。现在来回忆的话，他大概就是拿了个 U 盘作启动盘到家里插电脑上 setup 一下就完事了，但是当时天真浪漫不懂电脑的我就只会在旁边看着。当时他好像还用的是大白兔这个毒瘤玩意。 因为只有 C 盘会受到影响，当时就没有备份（危）。 本来用起来非常的舒适，所以也没有什么思想准备，下载 QQ 的时候电脑卡了一小下，但是我认为是新系统的问题就没有注意。然后下载 Office 的时候，进度条卡在了 86% ，然后……电脑黑屏了，那天就再也没开开过了（悲） 后来拿去修发现是硬盘坏了…..咱也不知道为什么给我重装系统把硬盘搞坏了，里面数据也不给我取出来，到现在还没找他，气死我。 所以从那以后是坚决不让所谓熟人来整电脑了，明明搞个系统自己不用花钱就能解决的事情最后还花了钱买了个不是很好 SSD 那人也挺有意思，中间给我拆机的时候忘了把风扇的一个盖板安回来…… 更有意思的是明明我要的是专业版，**他给我装了个 L T S C !**这谁顶得住啊，绝了。反正我是再也不让我爸的“熟人”碰我的设备了。 然后一直到现在，它上面还是 LTSC，主要是懒得改了。 章三 · 印象实际上这章的标题确实不知道该起什么了（ Dell 的做工不错貌似是公认的样子，但是它的做工……让人一言难尽。基本这四年半的时间一直在和它的神必做工斗争。 最一开始是直接掉了一个螺丝（？）导致屏幕转轴的地方开裂（ 然后换了个螺丝上去也没事了，再后来就是这货的风扇，可能是出于某些神必的原因开始打它和主板之间的挡板，但是风扇的位置是对的，这玩意到后来演化成了战 略 级 移 动 拖 拉 机，我也把这玩意录了下来发到了B站（？）视频链接在这 当然这也是换掉它的主要原因之一。 最重要的应该是因为这货的电池……当然这个怪不得它罢，这个属于是小时候习惯不好一直插着电最后导致电池鼓包了罢（ 但是充电口也能坏是我没想到的，插着充电器，突然就有一瞬间供不上电，然后我未保存的东西成功没了……这两点加起来让人体验挺拉的，到后期因为风扇太吵甚至不想晚上打 Codeforces 了（ 但是刨除这两点，它整体的实力还算是差强人意。 i5-7200u 虽然主频拉跨，而且我经常吐槽，不过放在今天还是足够作为一个办公的本子的 u；Geforce 940MX 算是这个电脑为数不多能拿出来说道的东西，这个显卡其实就是老 MX 系列的最后的一代里面最高端的那块了，如果我没记错的话这玩意有 4GB 的显存，算力在这台电脑上完全够用。 在这两位的支持下，F1 2016 和 GTA5 都能窗口模式 + 最低画质的情况下达到不错的帧数。（前者平均 40 帧，后者平均 52 帧） 其实这个帧数能更进一步的，因为我发现帧数的瓶颈在于……内存。 4GB DDR3 2300 的配置放在 2017 之前还算是不错的水平，不过现在可是 1202 年啊，开个 Egde + VScode 内存就能暴毙（ 4GB 是真的拉，要不然这个体验显然能更进一步的（ 屏幕就不多说了，大果粒 + 低亮度 + 45%NTSC。 但是这个电脑确实助力了我达成了很多事情，同时陪我经历了许多，我的第一个 C++ 程序，Py 程序，第一份 3D 建模，第一个 FL Studio 工程文件…… 当然最重要的应该就是现在这段 OI 之路的前半段，由它陪我度过。 章四 · 暂别不再听它的声音，已经是有三天时间了，当我写完代码时，兴奋地按下的已经不再是它身上的 F5，深夜调代码的时候，面对的也不再是它，它现在只是一个旁观者，在一旁默默地感受我的喜怒。 现在已经有新来的小弟接替了它的任务啦。虽然它主人的 OI 前途还非常迷茫，但是它一定是问心无愧了，它完成了它的任务，可以安然的度过它的余生了。 当然前提是假如我不再折腾它的话（ 章五 · 余声这一篇算是写了有一段时间了，基本上都是抽空写成的每个章节，整体的连贯性不强，也没有什么图片描述，这只是一个我对于一台刚退役的老电脑的感想而已。 最初的章零和章一还是在老戴尔上完成的，后面的基本上都是在新电脑上写完的（ 说点题外话，我觉得如果我当时是在老电脑上全写完的话，可能篇幅会更长一些，因为能说能吐槽的更多。比如 940MX 在其他硬件拉跨的情况下是让我相对最满意的一个硬件，但是现在用了 3060 之后，感觉也夸不出来啥了ww 那就这样吧，翻过上一页，开始新的篇章罢（","link":"/2021/08/08/Dell5568/"},{"title":"CSP S2 2021 题解","text":"CSP S2 2021（部分）题解 「启」因为觉得场上很不甘心，所以就把自己场上看过的前三题写了出来。 T4 没有写，因为觉得不是我的能力范围之内的（ 但是总体上来说今年的题好像简单的比去年简单（？），难的也比去年简单（？），但是总体难度好像难一点，再加上暴力分比去年少，所以分数线低（？） 反正去年的贪吃蛇我是一点想法都没有，今年 T4 还是有点想法的（ 以下代码均使用缺省源 V5.2. 「A」廊桥分配总的来说这道题真的不难，自己场上的做法和正解只是一个循环的区别，但是场上光想着先把能打的暴力全打了就没把这道题继续往下想。 要写这个的时候，觉得应当测一下官方数据，没想到居然 $A$ 第一个点挂了，于是改的时候又重新修了一下码风。 「A」思路简述首先先是场上的 $O(n^2\\log n)$ 的暴力做法。 思路非常的简单，先排序，然后枚举分配的时间，然后里面枚举飞机，每次将应当飞走的飞机从堆中弹出，然后让当前的飞机到编号最小的廊桥停下。 考场代码太丑了，我也懒得修就不放了。 但是这样显然是过不了的，于是考虑优化。首先可以想到的是这样贪心绝对是没问题的，所以我们考虑如何让这个过程的复杂度降低。 仔细分析一下，其实我们可以把两种飞机分开预处理，最后再将对应的答案合并。于是我们就要对于每种飞机处理出分配 $0$ 到 $n$ 个廊桥的方案，为了优化复杂度我们肯定不能再傻傻的枚举。 根据刚才我们的贪心策略，我们每次放飞机的时候都是要找到编号最小的廊桥把放进去，所以我们可以把可用廊桥的编号扔到一个小根堆里面，然后每次被使用的时候和占用这个廊桥的飞机一起扔到另外一个堆里面，这样我们处理的复杂度就降为了 $O(n \\log n).$ 「A」Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y) { Heriko x&gt;y?x:y;}template&lt;typename J&gt;I J Hmin(const J &amp;x,const J &amp;y){ Heriko x&lt;y?x:y;}CI MXX(1e5+1);int n,m1,m2,coa[MXX],cob[MXX],ans;struct Plane{ int l,r; I bool operator &lt; (const Plane &amp;co) const { Heriko (l==co.l)?(r&lt;co.r):(l&lt;co.l); }}a1[MXX],a2[MXX];priority_queue&lt;int&gt; id;priority_queue&lt; pair&lt;int,int&gt; &gt; q;S main(){ Files(); fr(n),fr(m1),fr(m2); for(int i(1);i&lt;=m1;++i) fr(a1[i].l),fr(a1[i].r); for(int i(1);i&lt;=m2;++i) fr(a2[i].l),fr(a2[i].r); sort(a1+1,a1+1+m1); sort(a2+1,a2+1+m2); for(int i(1);i&lt;=n;++i) id.push(-i); for(int i(1);i&lt;=m1;++i) { while(q.size() and -q.top().first&lt;a1[i].l) id.push(-q.top().second),q.pop(); if(id.size()) { q.push(make_pair(-a1[i].r,-id.top())); ++coa[-id.top()];id.pop(); } } for(int i(1);i&lt;=n;++i) coa[i]+=coa[i-1]; while(id.size()) id.pop(); while(q.size()) q.pop(); for(int i(1);i&lt;=n;++i) id.push(-i); for(int i(1);i&lt;=m2;++i) { while(q.size() and -q.top().first&lt;a2[i].l) id.push(-q.top().second),q.pop(); if(id.size()) { q.push(make_pair(-a2[i].r,-id.top())); ++cob[-id.top()];id.pop(); } } for(int i(1);i&lt;=n;++i) cob[i]+=cob[i-1]; for(int i(0);i&lt;=n;++i) ans=Hmax(ans,coa[i]+cob[n-i]); fw(ans,1); Heriko Deltana;} 「B」括号序列感觉是一道恶心的题，然后场上写了三个小时挂了，最后写的暴力也挂了，然后提交样例还 CE 了，Bad. 「B」思路简述暴力就不说了，$O(3^n)$ 的暴搜，下面的内容主要参考了I_am_Accepted 的题解。 看到数据范围之后，我们心中大约有了一个比较常规的复杂度：$O(n^3)$，而这是一个比较正常的区间 DP 的复杂度，所以我们就先正常的设状态和转移。 设 $f(l,r)$ 表示 $[l,r]$ 为合法序列且 $l$ 和 $r$ 匹配的方案数，而 $g(l,r)$ 表示不匹配的数量，这样就能避免重复计算的情况，最终的答案显然为 $f(1,n)+g(1,n)$。同时因为我们最多有 $k$ 个 *，为了后面方便使用，可以在最初用 $O(n^2)$ 的时间预处理出来。 而在转移之前还需要特判一些状态： 当端点为符号未确定且不能成为括号的时候，跳过； 当当前区间的长度为 $2$ 的时候，$f(l,r)=1$，跳过。 然后就是转移，首先是 $f:$ $(S): f(l,r)+=[co(l+1,r)].$ $(A): f(l,r)+=f(l+1,r-1)+g(l+1,r-1).$ $(SA): f(l,r)+=\\sum_{i=1}^k(f(l+i+1,r-1)+g(l+i+1,r-1))\\times[co(l+1,l+i)].$ $(AS): f(l,r)+=\\sum_{i=1}^k(f(l+1,r-i-1)+g(l+1,r-i-1))\\times[co(r-i,r-1)].$ 然后是 $g:$ $ASB / AB: g(l,r)+=\\sum\\limits_{l&lt;i&lt;j&lt;r,j-i-1\\le k}(f(l,i)+g(l,i)\\times f(i,r))[co(i+1,j-1)].$ 然而这个转移是 $O(n^4)$ 的，所以考虑优化这个的复杂度，发现 $i$ 每次增减 $1$，$j$ 的变化是 $O(1)$ 的，可控，所以我们可以先预处理出来合法的下一个转移对象，然后就优化成了 $O(n^2+n^3)=O(n^3).$ 「B」Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y) { Heriko x&gt;y?x:y;}template&lt;typename J&gt;I J Hmin(const J &amp;x,const J &amp;y){ Heriko x&lt;y?x:y;}CI MXX(501),MOD(1e9+7);int n,k,nex[MXX];LL f[MXX][MXX],g[MXX][MXX];bitset&lt;MXX&gt; co[MXX];char s[MXX];S main(){ Files(); fr(n),fr(k); scanf(&quot;%s&quot;,s+1); for(int i(1);i&lt;=n;++i) { if(s[i]!='*' and s[i]!='?') continue; co[i][i]=1; for(int j(i+1);j&lt;=n;++j) if(s[j]=='*' or s[j]=='?') co[i][j]=1; else break; } for(int len(2);len&lt;=n;++len) { for(int l(1),r;l&lt;=n-len+1;++l) { r=len+l-1;f[l][r]=g[l][r]=0; if((s[l]!='(' and s[l]!='?') or (s[r]!=')' and s[r]!='?')) continue; if(l+1==r) { (f[l][r]+=1)%=MOD; continue; } /*----F----*/ if(r-l-1&lt;=k and co[l+1][r-1]) (f[l][r]+=1)%=MOD; (f[l][r]+=f[l+1][r-1]+g[l+1][r-1])%=MOD; for(int i(l+1);i&lt;=Hmin(l+k,r-2);++i) if(co[l+1][i]) (f[l][r]+=f[i+1][r-1]+g[i+1][r-1])%=MOD; for(int i(r-1);i&gt;=Hmax(l+2,r-k);--i) if(co[i][r-1]) (f[l][r]+=f[l+1][i-1]+g[l+1][i-1])%=MOD; /*----G----*/ LL tmp(0); for(int i(l+1);i&lt;r-1;++i) { if(tmp&lt;=i) tmp=i+1; while(tmp&lt;r-1 and (s[tmp]=='?' or s[tmp]=='*')) ++tmp; nex[i]=Hmin((LL)i+k+1,tmp); } tmp=0; for(int i(l+2);i&lt;=nex[l+1];++i) (tmp+=f[i][r])%=MOD; (g[l][r]+=((f[l][l+1]+g[l][l+1])%MOD*tmp))%=MOD; for(int i(l+2);i&lt;r-1;++i) { (tmp+=MOD-f[i][r])%=MOD; for(int j(nex[i-1]+1);j&lt;=nex[i];++j) (tmp+=f[j][r])%=MOD; (g[l][r]+=((f[l][i]+g[l][i])%MOD*tmp))%=MOD; } } } fw((f[1][n]+g[1][n]+MOD)%MOD,1); Heriko Deltana;} 「C」回文多测没清空的痛啊，暴力分都没了…… 「C」思路简述实际上，因为要构成回文串，所以当我们在进行第 $i$ 步操作的时候，就能知道 $2n-i+1$ 次操作取出的数应当和其相同。 然后又因为每次只能从两段取数，所以原来的序列就被分为了两个连续的部分，于是就考虑用两个 deque 去维护从左端取出的数和从右端取出的数。 然后就有以下四种情况（因为要最优的方案，所以已经按照字典序排序）: $L$ 的头尾相同，则第 $i$ 次操作为 $L$，第 $2n-i+1$ 次为 $L.$ $L$ 的头和 $R$ 的头相同，则第 $i$ 次操作为 $L$，第 $2n-i+1$ 次为 $R.$ $R$ 的尾和 $L$ 的尾相同，则第 $i$ 次操作为 $R$，第 $2n-i+1$ 次为 $L.$ $R$ 的头尾相同，则第 $i$ 次操作为 $R$，第 $2n-i+1$ 次为 $R.$ 按照最优的策略先从左端开始跑一边再从右端开始跑一边，如果两次都不能构成就说明无解。 「C」Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177CI MXX(1e6+4);int n,m,a[MXX];char ans[MXX];deque&lt;int&gt; l,r;I void Solve(){ /*----Start At L----*/ l.clear(); r.clear(); l.push_back(a[1]); l.push_back(a[2]); for(int i(3);i&lt;=m;++i) if(l.front()!=l.back()) l.push_back(a[i]); else r.push_back(a[i]); int flg(0),cnt(0); while(cnt&lt;n) { if(flg) break; flg=1; if(l.size()&gt;1 and l.front()==l.back()) { flg=0; ans[++cnt]='L',ans[m-cnt+1]='L'; l.pop_front(); l.pop_back(); continue; } if(l.size() and r.size() and l.front()==r.front()) { flg=0; ans[++cnt]='L',ans[m-cnt+1]='R'; l.pop_front(); r.pop_front(); continue; } if(l.size() and r.size() and l.back()==r.back()) { flg=0; ans[++cnt]='R',ans[m-cnt+1]='L'; l.pop_back(); r.pop_back(); continue; } if(r.size()&gt;1 and r.front()==r.back()) { flg=0; ans[++cnt]='R',ans[m-cnt+1]='R'; r.pop_front(); r.pop_back(); continue; } } if(!flg) { for(int i(1);i&lt;=m;++i) putchar(ans[i]); puts(&quot;&quot;); Heriko; } /*----Start At R----*/ l.clear(); r.clear(); r.push_front(a[m]); r.push_front(a[m-1]); for(int i(m-2);i;--i) if(r.front()!=r.back()) r.push_front(a[i]); else l.push_front(a[i]); l.push_back(r.front()); r.pop_front(); flg=cnt=0; while(cnt&lt;n) { if(flg) { puts(&quot;-1&quot;); Heriko; } flg=1; if(l.size()&gt;1 and l.front()==l.back()) { flg=0; ans[++cnt]='L',ans[m-cnt+1]='L'; l.pop_front(); l.pop_back(); continue; } if(l.size() and r.size() and l.front()==r.front()) { flg=0; ans[++cnt]='L',ans[m-cnt+1]='R'; l.pop_front(); r.pop_front(); continue; } if(l.size() and r.size() and l.back()==r.back()) { flg=0; ans[++cnt]='R',ans[m-cnt+1]='L'; l.pop_back(); r.pop_back(); continue; } if(r.size()&gt;1 and r.front()==r.back()) { flg=0; ans[++cnt]='R',ans[m-cnt+1]='R'; r.pop_front(); r.pop_back(); continue; } } for(int i(1);i&lt;=m;++i) putchar(ans[i]); puts(&quot;&quot;);}S main(){ Files(); int T;fr(T); while(T--) { fr(n);m=n*2; for(int i(1);i&lt;=m;++i) fr(a[i]); Solve(); } Heriko Deltana;} 「结」算是完成了自己的心愿吧（ $$NOIP2021 RP++.$$","link":"/2021/11/03/CSP-S2-2021-Solu/"},{"title":"Dilworth","text":"Dilworth 定理浅谈。 主要参考：浅谈Dilworth定理 - cmwqf。 「启」想起来这个定理，是因为我在古远的时候（大约今年 $3$ 月？）遇到了但是没有进一步了解，今天突然又看到导弹拦截这道题，于是就想把它进一步里了解一下。 「定理内容」偏序集上最小链划分中链的数量等于其反链长度的最大值。 一看，偏序集，最小链划分，反链，都不会（ 于是下面开始逐一理解 看 定 义（ 「偏序集」定义一种比较关系使得两种元素进行比较，比如我们定义 $x \\operatorname{Aqua} y$ 当且仅当 $x,y\\in Z$ 且 $x \\le y.$ 显然 $x$ 和 $y$ 都满足 $\\in Z$ 的时候她们两个是可比的，否则若有一个不满足，我们则称这两个元素不可比。 那么偏序集 $S$ 就定义为满足以下性质的允许存在不可比元素的集合： 自反性：$\\forall x \\in S,x \\le x;$ 对称性：$\\forall x,y \\in S,x \\le y \\Rightarrow y \\ge x;$ 传递性：$\\forall x,y,z \\in S,x \\le y,y \\le z \\Rightarrow x \\le z.$ 「链划分」若我们把满足 $x,y \\in S,x \\le y$ 的 $x,y$ 之间建立一条 $x \\to y$ 的边，那么显然的是偏序集是一张 DAG. 把 $S$ 中的元素划分为若干条链，使得每个元素都在且仅在唯一的一条链中，叫做链划分。 「反链」链是 DAG 上的某条路径上的元素，而反链和链的定义恰好相反，对于一个集合，它是反链当且仅当这个集合里的元素两两都是不可比的，即这个集合中的元素两两不连通。 也就是说，我们将一个偏序集 $S$ 划分为若干个小集合，使得每个小集合里的元素构成一条链，这个最小的划分数量，等于这个偏序集最长的反链的长度。 然后就能利用这个来做一些看起来很难的题。 以下摘自我的杂题记录。 「例题」 洛谷 | P3974 组合数学 [TJOI2015] [省选+/NOI-] 好喵一题。 其实做这道题只是在看自己之前的博客的时候想起来之前有个 Dilworth 定理，然后就随着一个博客（浅谈Dilworth定理 - cmwqf）学习的时候，找到了这道题。 众所周知题目名字里有啥，这道题就不用啥做，所以这道题用不到组合数学（ 我们把这道题中的每个点 $(i,j)$ 拆成 $val(i,j)$ 个点，然后把能够到达的点之间连边，最后变成了一个 DAG，题目所求就是求这个图的最小链的划分，根据 Dilworth 定理，这个 DAG 的最小链划分就等于它的最长反链的长度。 按照我们建图的操作来说的话，这个反链就是说的最长的不能到达的链，也就是说要求每个点的右上和左下矩阵中点权值的最大值，于是直接 DP 即可。 123456for(int i(1);i&lt;=n;++i) for(int j(m);j;--j) { f[i][j]=f[i-1][j+1]+a[i][j]; f[i][j]=Hmax(Hmax(f[i][j],f[i-1][j]),f[i][j+1]); } 答案即为 f[n][1].","link":"/2021/12/10/Dilworth/"},{"title":"Nothing : 20210926","text":"2021.09.26，中午，梦。 「序」嗯…… 这里写的是我在 9.26 中午的一个梦，因为记得很清楚，再加上那天下午因为这个梦变得很奇怪，所以就写出来。 所以从做完这个梦到现在已经整整一个周了w 简单描述一下就是，那天中午因为做这个梦，睡过了，于是下午少上了一节课（ 下面……就开始略详细描述。 因为是很奇怪的零散的描述了所以我也不奢求各位能看懂。 一看就是手画的图都是手画的（有数位板） 有一些神必配图。 「因」显然如果宿舍里不止我一个人的话是不会睡过的（ 9.25 生物奥赛的同学们前往湖南尝鲨，于是我们班的男生宿舍就出现了很多空位（ 然而我们宿舍里只有我一个人不是生物奥赛，于是我们宿舍就剩下我一个人了w 用 F1 里的 Starting Grid 来描述一下宿舍的位置就是： 这里的 Pole Position 是距离宿管最近的宿舍（也就是 113 本身这个宿舍楼只有一楼有高一，还只有两个班，于是一楼是相对空旷的（ 本来 113 是距离宿管宿舍最近的宿舍，但是由于 113 是一个由生物奥赛的同学组成的宿舍，所以这个宿舍，它空了。 也就是说仅有一个人的宿舍 112 来到了 Pole Postion（bushi 然而宿舍的出口又在另一边，所以我就成了距离门口最远的人，也就是说没有人会在出宿舍的时候路过我宿舍，这是我睡了这么长时间的最主要原因（ 然鹅机智的我早就想到了这一点，于是我提前给 111 宿舍的各位打好了招呼，让他们叫我起床…… 然而……他们忘了……而且是整个宿舍都没人想起来（ ~~嗯就是你们都没想起来才有的这个（ @Dfkuaid @hyl @禁止右转 于是就有了整个梦。 「梦」 下面涉及的人物都是真实人类在我梦中的映像（？），认识的人看一点就明白了，不认识的人肯定不认识，不过就算不认识好像也不影响的样子（ 「一」中午，宿舍里只有我一个人， 于是我就和昨天一样，提前上床睡觉了。 于是梦就开始了。 「二」最一开始，我在往楼下搬东西（估计是想国庆假期了）。 然后我从五楼下到一楼的时候，发现 wsr，然后他让我给他拿个东西（？为什么我会在五楼，不懂） 然后我就跑上去又给他拿了一趟（？为什么我怎么听话) 东西很显眼，就是 wsr 他们宿舍里那个狗狗玩偶，我拿完之后就直接跑下去给了 wsr. 当我给 wsr 狗狗的时候，他给我指了指我后面（？）我发现是一个初中班里的孩子，下面称为 JP. 我正在迷惑为什么会有人会瞬移的时候，wsr 给我说 JP 快不行了（？） 然后让我去拿什么纸（？大抵是什么公文之类的玩意，但是我觉着应该是需要医疗援助罢（bushi （还有为什么男生和女生会在一个宿舍楼啊？） 然后我就跑上楼去拿，在宿舍里碰见了渣渣辉，然后我就问渣渣辉：那张纸放在哪里了？ 然后渣渣灰就指了指……天（？）然后我就非常理解的开始翻床单（？） 大约翻了好长时间的样子，因为等我找到下去的时候，wsr 说 JP 已经不行了已经被送走了（ 还给我看了张她被车接走的照片（？为什么怎么惨） 「三」然后我就拎着包向着教学楼（大概是）的方向跑，但是宿舍楼和教学楼中间并不是露天的，而是室内环境。（难道这就 是 114514 年之后的 lcez 吗） 路上我就看见楼上满满的都是人再往下走，好像都大包小包准备回家。 然而走在一楼的人只有我一个。（后来我觉得这里是伏笔（？），后面说） 然后我就去挤电梯，然后好不容易进去，发现里面全是老师就我一个学生，剩下四学科奥赛教练、ysh、J、齐齐、尚尚（ J 就经典刷电梯卡姿势，（见过的请自行想象）然后就就上到了 8 楼，但是只有我一个人下了电梯，然后就看见了泰山和小明（ 然后当时大约小明在看手机，泰山在干啥我不知道，然后我过去的时候泰山对我说小明也有那病（？所以说泰山是说的什么玩意病？） 小明直接垂死病中惊坐起，扔了手机爆锤泰山（ 大约就是这样： 于是泰山那句话就让我围观了一场战斗（？感谢） 围观了一会之后，我右转进入教室，然后……打地铺睡觉（？） 感觉在我梦里面一天就三个小时的感觉，最一开始我觉得是在上午，到这直接变成晚上了（ 于是我就在梦里睡觉（？） 突然感觉被叫醒（在现实中可能是吹哨了，可惜这次吹哨只能叫醒第一层的我），于是睁开眼（在梦里），发现大家都正常的在教室的桌椅上，只有我一个人 躺 在 地 上 穿 着 睡 衣 盖 着 被 子 睡 眼 朦 胧 一 脸 懵 逼（ 然而好像并没有上课，于是我就开始看手机（？为什么我会有手机） 然后打开了个神必的游戏（？上课玩游戏） 123456789101112131415看起来像 ![Phigros](https://pic.imgdb.cn/item/615b0fa42ab3f51d9128a112.jpg)但是又有点像 ![Dancing Line](https://pic.imgdb.cn/item/615b06a72ab3f51d91194606.jpg)中间好像又有了玩蛇，于是加一点 ![Arcaea](https://pic.imgdb.cn/item/615b0fa42ab3f51d9128a0e1.jpg)然后，加一点 ![Cytoid](https://pic.imgdb.cn/item/615b0fa42ab3f51d9128a0f8.jpg) 和 ![Muse dash](https://pic.imgdb.cn/item/615b0ffd2ab3f51d91293461.jpg)（但是结算的界面又是 ![bh3](https://pic.imgdb.cn/item/615b0fa42ab3f51d9128a0ed.jpg) 的（可以自行想象一下薪炎旅但是是穿着类似于超级马里奥的背带裤（？）结算之后又是开放世界（加一点 ![ys](https://pic.imgdb.cn/item/615b0fa42ab3f51d9128a0d3.jpg)开放世界还能开车打雀（？？）（加一点 ![RR3](https://pic.imgdb.cn/item/615b0ffd2ab3f51d91293469.jpg) ![FH4](https://pic.imgdb.cn/item/615b104e2ab3f51d9129bcf8.jpg) ![雀](https://pic.imgdb.cn/item/615b103b2ab3f51d91299a87.jpg) ![AR](https://pic.imgdb.cn/item/615b0ffd2ab3f51d912933e8.jpg) ![A9](https://pic.imgdb.cn/item/615b0ffd2ab3f51d912933f1.jpg)甚至还有社交功能，画面类似于 ![](https://pic.imgdb.cn/item/615b0ef62ab3f51d9127800e.jpg)（？) 我明白了我一定是在完那个游戏 6 罢！ 然后…… 剩下的明天补（ 谢谢各位整齐划一的催更，哦里面好像还有我（（（（（ 昨天补的最后一部分好像有点乱，今天上完课把他做成一张图罢。","link":"/2021/09/27/Dream-2021926/"},{"title":"FWT","text":"初学 FWT. 主要从 xht37 的洛谷模板题解学习。 启摘自 APIO2022 游记 下午讲的 FWT 前半段好歹跟着听懂了一部分，所以晚上就开始搞 FWT，hyl 因为之前会 FWT 于是就研究今天老师课件上很妙的定义方式，而我把 xht 的题解整会了好歹是过了板子。 前置知识 记对序列 $a$ 进行快速沃尔什变换为 $\\operatorname{FWT}[a].$ 显然对于已知的序列 $a$ 和 $b$，直接计算 $c=a \\cdot b$ 复杂度为 $O(n^2).$ 若对序列进行快速沃尔什变换都为 $O(n \\log n)$ 的，而 $\\operatorname{FWT}[c]=\\operatorname{FWT}[a] \\cdot \\operatorname{FWT}[b]$ 是 $O(n)$ 的，那么我们就可以 $O(n \\log n)$ 的求解出 $c.$ 在 OI 中，FWT 是用于解决对下标进行位运算卷积问题的方法，即如下的形式： $$c_i=\\sum\\limits_{i=j \\oplus k}a_j b_k$$ 其中 $\\oplus$ 是一种二元位运算，下面就来分别分析 or、and 和 xor 三种运算如何利用 FWT 解决这类问题。 或 or即： $$c_i=\\sum\\limits_{i=j|k}a_j b_k$$ 若有 $j|i=i$，$k|i=i$，则有 $(j|k)|i=i$，于是可以构造 $\\operatorname{FWT}[a]=\\sum_{j|i=i}a_j.$ 故有 $$\\begin{aligned}\\operatorname{FWT}[a] \\times \\operatorname{FWT}[b] &amp;= \\left(\\sum\\limits_{j|i=i}a_j\\right)\\left(\\sum\\limits_{k|i=i}b_k\\right) \\&amp;= \\sum\\limits_{j|i=i}\\sum\\limits_{k|i=i}a_j b_k \\&amp;= \\sum\\limits_{(j|k)|i=i} \\&amp;= \\operatorname{FWT}[c]\\end{aligned}$$ $\\operatorname{FWT}[a] \\to a$ 即： $$\\operatorname{FWT}[a]i=\\sum\\limits{j|i=i}a_j$$ 考虑将这个分治解决，方法是按照二进制下最高位分类，设 $a_0$ 为最高位为 $0$ 的那一段序列，$a_1$ 反之，于是就有： $$\\operatorname{FWT}[a]=\\operatorname{Merge}{\\operatorname{FWT}[a_0],\\operatorname{FWT}[a_0]+\\operatorname{FWT}[a_1]}$$ Merge 即拼接两端序列，序列之前的加法即对应位置相加。 故有代码： 123456I void FWTOr(LL f[]) { for(int nw(2),k(1);nw&lt;=n;nw&lt;&lt;=1,k&lt;&lt;=1) for(int i(0);i&lt;n;i+=nw) for(int j(0);j&lt;k;++j) (f[i+j+k]+=f[i+j])%=MOD;} 同理 $\\operatorname{FWT}[a] \\to a$ 时， $$\\operatorname{FWT}[a]=\\operatorname{Merge}{\\operatorname{FWT}[a_0],\\operatorname{FWT}[a_0]+\\operatorname{FWT}[a_1]} \\ \\Rightarrow a=\\operatorname{Merge}(a_0,a_1-a_0)$$ 即： 123456I void FWTOr(LL f[]) { for(int nw(2),k(1);nw&lt;=n;nw&lt;&lt;=1,k&lt;&lt;=1) for(int i(0);i&lt;n;i+=nw) for(int j(0);j&lt;k;++j) (f[i+j+k]-=f[i+j]+MOD)%=MOD;} 所以可以综合为： 123456I void FWTOr(LL f[],LL x) { for(int nw(2),k(1);nw&lt;=n;nw&lt;&lt;=1,k&lt;&lt;=1) for(int i(0);i&lt;n;i+=nw) for(int j(0);j&lt;k;++j) (f[i+j+k]+=f[i+j]*x%MOD)%=MOD;} 与 and和 or 同理： 123456I void FWTAnd(LL f[],LL x) { for(int nw(2),k(1);nw&lt;=n;nw&lt;&lt;=1,k&lt;&lt;=1) for(int i(0);i&lt;n;i+=nw) for(int j(0);j&lt;k;++j) (f[i+j]+=f[i+j+k]*x%MOD)%=MOD;} 异或 xor我们考虑用类似的方式来拆解和式下标计算过程来构造 FWT. 定义 $x \\oplus y = \\operatorname{popcount}(x&amp;y) \\pmod 2$，于是可以发现满足 $(i \\oplus j) \\operatorname{xor} (i \\oplus k) = i \\oplus (j \\operatorname{xor} k).$ 于是可以构造 $\\operatorname{FWT}[a]=\\sum_{i \\oplus j=0}a_j-\\sum_{i \\oplus j=1}a_j$ 则有： $$\\begin{aligned}\\operatorname{FWT}[a] \\times \\operatorname{FWT}[b] &amp;= \\left(\\sum_{i \\oplus j=0}a_j-\\sum_{i \\oplus j=1}a_j\\right)\\left(\\sum_{i \\oplus k=0}b_k-\\sum_{i \\oplus k=1}b_k\\right) \\&amp;= \\sum\\limits_{i \\oplus (j \\operatorname{xor} k)=0}a_j b_k-\\sum\\limits_{i \\oplus (j \\operatorname{xor} k)=1}a_j b_k \\&amp;= \\operatorname{FWT}[c]\\end{aligned}$$ 因此有： $$\\operatorname{FWT}[a]=\\operatorname{Merge}(\\operatorname{FWT}[a_0]+\\operatorname{FWT}[a_1],\\operatorname{FWT}[a_0]-\\operatorname{FWT}[a_1]) \\ \\Rightarrow a=\\operatorname{Merge}(\\frac{a_0+a_1}{2},\\frac{a_1-a_0}{2})$$ 代码实现即为： 123456789I void FWTXor(LL f[],LL x) { for(int nw(2),k(1);nw&lt;=n;nw&lt;&lt;=1,k&lt;&lt;=1) for(int i(0);i&lt;n;i+=nw) for(int j(0);j&lt;k;++j) { (f[i+j]+=f[i+j+k]+MOD)%=MOD; f[i+j+k]=(f[i+j]-f[i+j+k]+MOD-f[i+j+k]+MOD)%MOD; (f[i+j]*=x)%=MOD,(f[i+j+k]*=x)%=MOD; }} Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687CI MXX((1&lt;&lt;17)+5),MOD(998244353);LL n,a[MXX],b[MXX],c[MXX],A[MXX],B[MXX];I void Into() { for(int i(0);i&lt;n;++i) a[i]=A[i],b[i]=B[i];}I void GetVal() { for(int i(0);i&lt;n;++i) c[i]=a[i]*b[i]%MOD;}I void FWTOr(LL f[],LL x) { for(int nw(2),k(1);nw&lt;=n;nw&lt;&lt;=1,k&lt;&lt;=1) for(int i(0);i&lt;n;i+=nw) for(int j(0);j&lt;k;++j) (f[i+j+k]+=f[i+j]*x%MOD)%=MOD;}I void FWTAnd(LL f[],LL x) { for(int nw(2),k(1);nw&lt;=n;nw&lt;&lt;=1,k&lt;&lt;=1) for(int i(0);i&lt;n;i+=nw) for(int j(0);j&lt;k;++j) (f[i+j]+=f[i+j+k]*x%MOD)%=MOD;}I void FWTXor(LL f[],LL x) { for(int nw(2),k(1);nw&lt;=n;nw&lt;&lt;=1,k&lt;&lt;=1) for(int i(0);i&lt;n;i+=nw) for(int j(0);j&lt;k;++j) { (f[i+j]+=f[i+j+k]+MOD)%=MOD; f[i+j+k]=(f[i+j]-f[i+j+k]+MOD-f[i+j+k]+MOD)%MOD; (f[i+j]*=x)%=MOD,(f[i+j+k]*=x)%=MOD; }}I LL Inv(LL x,LL y=MOD-2) { LL res(1); while(y) { if(y&amp;1) (res*=x)%=MOD; (x*=x)%=MOD; y&gt;&gt;=1; } Heriko res%MOD;}S main() { Files(); fr(n); n=(1&lt;&lt;n); for(int i(0);i&lt;n;++i) fr(A[i]); for(int i(0);i&lt;n;++i) fr(B[i]); Into(),FWTOr(a,1),FWTOr(b,1),GetVal(),FWTOr(c,MOD-1); for(int i(0);i&lt;n;++i) fw(c[i],0); puts(&quot;&quot;); Into(),FWTAnd(a,1),FWTAnd(b,1),GetVal(),FWTAnd(c,MOD-1); for(int i(0);i&lt;n;++i) fw(c[i],0); puts(&quot;&quot;); Into(),FWTXor(a,1),FWTXor(b,1),GetVal(),FWTXor(c,Inv(2)); for(int i(0);i&lt;n;++i) fw(c[i],0); puts(&quot;&quot;); Heriko Deltana;} 另一种定义等我学会了就填坑（","link":"/2022/05/27/FWT/"},{"title":"李超线段树","text":"李超线段树浅学浅记。 前言单纯的学了一下而已（ 因为尚未深入进行研究所以曰之浅学浅记。 本次浅记就主要根据洛谷 P4097 [HEOI2013]Segment 这道模板题来浅曰之，题目描述略。 思路从一个相对好切入的点开始，实际上李超线段树某种程度上可以自己发明（？ 首先看到这个题，会发现我们需要一个 DS 来维护这样一个线段的“容器”，它需要完成如题的各项操作。 比较显然的是我们在每个区间内维护一个在本区间每个值都取值最大的线段的编号，那么我们就需要线段树来维护这个东西。 那么考虑如何在每次插入线段的时候都能让每个区间保持最优，有两个步骤： 这个区间是线段的定义域的子集，即 $[L,R] \\in D.$ 将此线段和当前区间内最优线段进行比较以让该区间保持最优。 第一个步骤很好实现，那么考虑第二个，如何去比较呢？ 我们考虑让一个线段加入的影响通过不断二分区间来分化下传，下面来分类讨论之： 假设我们新加入的直线/线段为 $f$，原有最大值为 $g$，区间中点为 $mid.$ $f$ 斜率大于 $g:$ 如果 $f(mid)&gt;g(mid)$，那么 $f$ 在右子区间一定最优，而 $g$ 仍有可能在左子区间更优。 反之，$g$ 在左子区间一定最优，而 $f$ 仍有可能在右子区间更优。 $g$ 斜率大于 $f:$ 如果 $f(mid)&lt;g(mid)$，那么 $f$ 在左子区间一定最优，而 $g$ 仍有可能在右子区间更优。 反之，$g$ 在右区间一定最优，而 $f$ 仍有可能在左子区间更优。 还有一些特殊情况，比如说形如 $f(x) = d$（$d$ 为常数）的直线/线段，我们将其缩到每次的比较点来方便对比（ 当然，在比较的时候还需要考虑编号的大小，所以我们在比较的时候，将编号小的稍微加一点点（EPS）来保证我们每次得到的是编号更小的最优选择。 然后就可以上代码了，复杂度的话，瓶颈在于 Pushdown 为 $O(\\log n)$，于是查询和修改的操作都为 $O(\\log ^2n)$，总体复杂度就是 $O(n \\log ^2n).$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define Heriko return#define Deltana 0#define Romanno 1#define S signed#define LL long long#define DB double#define R register#define I inline#define CI const int#define CL const long long#define mkp(a,b) make_pair(a,b)#define mst(a,b) memset(a,b,sizeof(a))#define ON std::ios::sync_with_stdio(false);cin.tie(0)#define Files() freopen(&quot;RNMTQ.in&quot;,&quot;r&quot;,stdin);freopen(&quot;RNMTQ.out&quot;,&quot;w&quot;,stdout)using namespace std;template&lt;typename J&gt;I void fr(J &amp;x) { short f(1); x=0; char c(getchar()); while(c&lt;'0' or c&gt;'9') { if(c=='-') f=-1; c=getchar(); } while(c&gt;='0' and c&lt;='9') { x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^=48); c=getchar(); } x*=f;}template&lt;typename J&gt;I void fw(J x,bool k) { if(x&lt;0) x=-x,putchar('-'); static short stak[35]; short top(0); do { stak[top++]=x%10; x/=10; } while(x); while(top) putchar(stak[--top]+'0'); k?puts(&quot;&quot;):putchar(' ');}template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y) { Heriko x&gt;y?x:y;}template&lt;typename J&gt;I J Hmin(const J &amp;x,const J &amp;y) { Heriko x&lt;y?x:y;}CI MXX(1e5+1),MOD1(39989),MOD2(1e9);const DB EPS(1e-12);I void Hmod(int &amp;x,int y,int mod) { x=(x+y-1&gt;=mod)?x+y-mod:x+y;}#define lc(x) (x&lt;&lt;1)#define rc(x) (x&lt;&lt;1|1)struct Line { DB k,b; int id; Line(const DB &amp;k=0,const int &amp;x=0,const int &amp;y=0,const int &amp;id=0) : k(k),b(y-x*k),id(id){} I DB Calc(int x) { Heriko k*x+b; } I bool Empty() { Heriko !id; }}t[MXX&lt;&lt;2];I void Hswap(Line &amp;x,Line &amp;y) { Line z; z=x,x=y,y=z;}I Line Lmx(Line x,Line y,int v) { Heriko x.Calc(v)&gt;(y.Calc(v)+((x.id&gt;y.id)?EPS:-EPS))?x:y;}void Pushdown(int x,int l,int r,Line v) { int mid((l+r)&gt;&gt;1); if(t[x].Empty()) t[x]=v; else { if(v.Calc(mid)&gt;t[x].Calc(mid)+(v.id&gt;t[x].id?EPS:-EPS)) Hswap(v,t[x]); if(v.Calc(l)&gt;t[x].Calc(l)) Pushdown(lc(x),l,mid,v); else if(v.Calc(r)&gt;t[x].Calc(r)) Pushdown(rc(x),mid+1,r,v); }}void Modify(int x,int lx,int rx,Line v,int l=1,int r=MXX) { if(lx&lt;=l and r&lt;=rx) Heriko Pushdown(x,l,r,v); int mid((l+r)&gt;&gt;1); if(lx&lt;=mid) Modify(lc(x),lx,rx,v,l,mid); if(rx&gt;mid) Modify(rc(x),lx,rx,v,mid+1,r);}Line Query(int x,int pos,int l=1,int r=MXX) { if(l==r) Heriko t[x]; int mid((l+r)&gt;&gt;1); if(pos&lt;=mid) Heriko Lmx(t[x],Query(lc(x),pos,l,mid),pos); else Heriko Lmx(t[x],Query(rc(x),pos,mid+1,r),pos);}int n,lmd,lstans,cnt;S main() { Files(); fr(n); while(n--) { int opt; fr(opt); if(!opt) { int x1; fr(x1),Hmod(x1,lmd,MOD1); fw((lstans=Query(1,x1).id),1); lmd=lstans%MOD1; } else { int x1,x2,y1,y2; Line v; fr(x1),fr(y1),fr(x2),fr(y2); Hmod(x1,lmd,MOD1),Hmod(x2,lmd,MOD1); Hmod(y1,lstans,MOD2),Hmod(y2,lstans,MOD2); if(x1&gt;x2) x1^=x2^=x1^=x2,y1^=y2^=y1^=y2; if(x1==x2) v.b=Hmax(y1,y2),v.id=++cnt; else v=Line(1.0*(y2-y1)/(x2-x1),x1,y1,++cnt); Modify(1,x1,x2,v); } } Heriko Deltana;}","link":"/2022/01/23/Li-Chao-Tree/"},{"title":"线性基","text":"线性基简记。 主要参考了 Menci 的线性基学习笔记。 「前置知识」一些线性基能用到的。 下文中若未特殊说明，集合均为「无符号整数集」。 「异或和」对于集合 $S$，将其中所有元素异或起来的结果。 「张成」对于集合 $S$ 的所有子集的异或和组成的集合成为 $S$ 的张成，记作 $span(S).$ 换句话说就是在 $S$ 中选出任意多个数，其异或和的所有可能的结果组成的集合。 「线性相关」对于一个集合 $S$，如果存在一个元素 $i$，使得，$S$ 在去除这个元素后得到的集合 $S’$ 的张成 $span(S’)$ 中包含 $i$，即，$i\\in span(S’)$，则称集合 $S$ 线性相关。 换句话说就是 $S$ 中存在一个元素 $i$ 可以被 $S$ 中的其他的若干个元素异或得到。 如果不存在这样的 $i$，就说 $S$ 线性无关。 一个显然的结论是对于一个线性相关的集合 $S$，去掉符合条件的 $i$ 之后，$span(S)$ 不变。 「线性基」称集合 $LB$ 为集合 $S$ 的线性基，当且仅当： $S\\in span(LB).$ $LB$ 线性无关。 $LB$ 中的元素个数，称为线性基的长度。 线性基有以下的性质： $LB$ 是极小的满足线性基性质的集合，它的任何真子集都不可能是线性基； $S$ 中的任意元素都可以唯一表示为 $LB$ 中若干个元素异或起来的结果； 线性基里任意一个子集的异或和都不为$0.$ 「模板」下面是模板。 「构造」1234567891011121314151617I void Insert(int x){ for(int i(62);i&gt;=0;--i) { if(x&amp;(1&lt;&lt;i)) { if(!p[i]) { p[i]=x; Heriko; } else x^=p[i]; } }} 「查询元素是否存在」因为“$S$ 中的任意元素都可以唯一表示为 $LB$ 中若干个元素异或起来的结果”，所以如果一个数在不断异或的过程中，能变成 $0$，那就存在于集合中。 12345678I bool Query(int x){ for(int i(62);i&gt;=0;--i) if(x&amp;(1&lt;&lt;i)) x^=p[i]; Heriko !x;} 「查询异或最大值」贪心即可。 12345678910I int XorMax(int x){ int res(0); for(int i(62);i&gt;=0;--i) if((res^p[i])&gt;res) res^=p[i]; Heriko res;} 「查询异或最小值」贪心即可，但是要特判 $0$，即存在 $0$ 的时候最小值为 $0.$ 123456789I int XorMin(int x){ if(HaveZero) Heriko Deltana; for(int i(62);i&gt;=0;--i) if(p[i]) Heriko p[i];} 暂且就先这些，还有一个查询第 $k$ 大异或值的操作，因为我还没用过所以就先不写。","link":"/2021/12/09/Linear-basis/"},{"title":"Hash 回顾","text":"对于 Hash 的一些回顾 前言可能要给学弟学妹普及一下这个东西，所以顺便重新回顾一下吧。 Hash 的内容还是比较宽泛的，这里主要是 OI 中常用的字符串 Hash. 本文缺省源使用：V5.3。 Hash 思想我们总会遇到非常大不便于存储或使用的数据，换一种方式来表示往往是一种比较好的解决方案。 这里说的方式常是将数据映射到值域较小，可以比较的范围，一般来说这个范围在 $10^9$ 或者 long long 之内。 下面以字符串 $\\to$ 整数为例具体说一下。定义一个将字符串映射到整数的 Hash 函数 $F$，这个函数的作用就是能让我们快速的比较原来的字符串。 具体一点来说，$F$ 函数就需要有以下两个性质： $\\forall i,j$，若 $F(i) \\ne F(j)$，则 $i \\ne j.$ $\\forall i,j$，若 $F(i)=F(j)$，则 $i=j.$ 然而第二条性质往往会有偏差，也就是说，会有 Hash 值相同但是对应字符串不同的情况，我们称这种情况为哈希碰撞。 所以在实现的时候除了时空复杂度，还需要考虑准确率。 Hash 实现通常，我们选用一个类似 $X$ 进制数的方式来定义 Hash 函数，即多项式式。 也就是说，对于一个长度为 $len$ 的字符串 $s$，有： $$F(s)=\\sum\\limits_{i=1}^{len} s_i \\times X^{i-1} \\pmod {MOD}$$ 一般来说，这里的 $X$ 和 $MOD$ 都是质数。 举个例子，对于字符串 $knd$，有： $$F(knd)=d \\times X^2+n \\times X^1+k \\times X^0$$ 可以看到就是一个 $X$ 进制数的表示形式。 一般 $MOD$ 是一个比最大字符要大的质数，而 $X$ 则是从 $(0,MOD)$ 中选取一个。 Code1234567891011121314CI MOD(1e9+7),X(233);I int Hash(char s[]) { int res(0),len(strlen(s)); for(int i(0);i&lt;len;++i) res=(res*X+s[i])%MOD; Heriko res;}I bool CMP(char s1[],char s2[]) { Heriko Hash(s1)==Hash(s2);} 这样实现的话，每次查询 Hash 值是 $O(len)$ 的。进行 $n$ 次比较，每次比较错误率为 ${1}\\over{MOD}$，总错误率就是 $1-(1-\\frac{1}{MOD})^n$ $n=10^6$，$MOD=10^9+7$ 的时候，大约是 $\\dfrac{1}{1000}$，其实不低。 所以我们可以通过分别对两个模数取模来得到两个 Hash 值以扩充值域。 12345678910111213141516171819202122232425262728293031323334353637383940414243CI MXX(1501),NXX(10005),MOD1(19260817),MOD2(998244353);int n;char s[MXX];namespace Hash { #define ULL unsigned long long struct Node { ULL h1,h2; I bool operator &lt; (const Node &amp;co) const { Heriko (h1==co.h1)?(h2&lt;co.h2):(h1&lt;co.h1); } I bool operator != (const Node &amp;co) const { Heriko !((h1==co.h1)&amp;(h2==co.h2)); } } a[NXX]; I void GetHash1(int pos,char s[]) { int len(strlen(s)); ULL tmp(0); for(int i(0);i&lt;len;++i) tmp=(tmp*255+s[i])%MOD1; a[pos].h1=tmp; } I void GetHash2(int pos,char s[]) { int len(strlen(s)); ULL tmp(0); for(int i(0);i&lt;len;++i) tmp=(tmp*255+s[i])%MOD2; a[pos].h2=tmp; }} 当然，这样常数也会大上不少，不过，准很多。 但是显然多次询问的时候可以用更优的实现方式来优化查询的时间复杂度。 首先，$s$ 子串 $s_{l\\cdots r}$ 的 Hash 值为： $$F(s_{l\\cdots r})=F(s_r)-F(s_{l-1}) \\times X^{r-l+1}$$ （这个简单推一下就能出来） 然后我们就可以 $O(n)$ 预处理 $X$ 的幂和求 $F(s)$，于是就可以做到查询 $O(1).$ Hash 应用字符串匹配这个将匹配串和文本串相比对即可。 最长回文子串分别求出正反的 Hash 值，判断两侧是否相等，复杂度 $O(n \\log n).$ 最长公共子字符串若存在长度为 $k$ 的公共串，那么长度为 $k-1$ 的公共串也一定存在，所以可以二分长度，每次把每个原串中当前长度的字符串的 Hash 求交集，总体时间复杂度 $O(n \\log_2 \\frac{n}{m})$ 骗分其实还有很多，而且例题也不少，所以我放一个不是哈希的题在这（ NOIP 2021 T3 方差题目链接（洛谷） 这题有一个 $n \\le 10$ 的部分分，于是我当时在考场就寻思打一个暴力。 然后发现 DFS 的时候需要记录当前序列有没有被查过…… 所以我就每次把当前序列整一个 Hash 值，开个 map 存一下有没有出现过即可。 因为本身不是字符串题，也肯定不会有人卡模数，所以就用了 unsigned long long 的自然溢出。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384template &lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y){ Heriko x&gt;y?x:y;}template&lt;typename J&gt;I J Hmin(const J &amp;x,const J &amp;y){ Heriko x&lt;y?x:y;}CI MXX(10001),MOD(998244353),INF(0x7f7f7f7f);LL n,a[MXX],sm,ans,b[MXX];I LL Hash(LL tmp[]){ LL res(0); for(LL i(1);i&lt;=n;++i) res=(res*211+tmp[i])%MOD; Heriko res;}map&lt;LL,bool&gt; ump;void DFS(LL tmp[]){ LL v(Hash(tmp)),res(0),sum(0); if(ump[v]) Heriko; ump[v]=1; for(LL i(1);i&lt;=n;++i) sum+=tmp[i]; for(LL i(1);i&lt;=n;++i) res+=(tmp[i]*n-sum)*(tmp[i]*n-sum); res/=n; ans=Hmin(ans,res); for(LL i(2);i&lt;n;++i) { LL t(tmp[i]); tmp[i]=tmp[i+1]+tmp[i-1]-tmp[i]; DFS(tmp); tmp[i]=t; }}S main(){ // freopen(&quot;variance.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;variance.out&quot;,&quot;w&quot;,stdout); fr(n); for(LL i(1);i&lt;=n;++i) fr(a[i]),sm+=a[i]; ump[Hash(a)]=1; for(LL i(1);i&lt;=n;++i) ans+=(a[i]*n-sm)*(a[i]*n-sm); ans/=n; for(LL i(2);i&lt;n;++i) { LL t(a[i]); a[i]=a[i-1]+a[i+1]-a[i]; DFS(a); a[i]=t; } fw(ans,1); Heriko Deltana;} 然后可能数据比较水，过了 24 分。","link":"/2022/03/25/Hash-review/"},{"title":"Heriko Deltana&#39;s Social Behavior Note","text":"社会行为实录。 Heriko Deltana’s Social Behavior Note，其实大约就是一个日记之类的什么东西。 记忆最深的日记是 LSP 的焚燃指间の回忆和 SZT 的梦回还 他们的起名看起来都很文艺范，所以我反其道而行之：《Social Behavior Note》，以此来彰显 HD 同学是喜欢窥探自己和别人。 2022.5.27明明是夏天刚开始，但是这一周脑子里总是あの夏が飽和する。 为什么呢，我也不知道（ 还是希望这个夏天心情和去年相似吧。 给我整不会了，我电脑的 Edge 加载不出来公式，但是我手机的任意浏览器都可以。。 2022.5.21在思考到底要不要买 knd 的手办啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊我得在她和 F122 之间做出抉择了啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊年轻人没钱是 真 的 好！ 最终结果是付了 knd 手办的定金，不过尾款要等到九月（（ 2022.5.15今天是 SDOI2022，祝愿各位胜选，线上选手今天暂且看看题吧。 或许想写什么但是……没空写，悲。 2022.5.14原道，触发悔恨之泪，我真的泪目了这个通透感。 明天就是 SDOI 了，祝愿各位成功吧！（好吧，虽然没人看） 很好！树剖一遍过，330 行不忘初心（ 2022.5.8怎么说呢，你永远叫不醒一个装睡的人。 2022.5.7好久没更新了，放一些歌词罢，会有人来看吗，会吗（ 这段歌词有好多点让我触动呢……会有人同感吗…… 時ノ雨、最終戦争 Orangestar / IA止まない憂いの最中在不曾停息的忧郁之中二つ感情は対を成して願いを放つ两种感情成对地释放着心愿君は覚えてるかな你还记得吗あの日涙の意味を那天流下的眼泪的意义 この世はまだ終わらない这个世界还没有完结明けぬ夜が今日を塞いでたって即使极夜将今天堵截僕は歌う「嫌いじゃないな」って我也会唱到「并不讨厌呢」さぁクラい空が ハれる来吧 漆黑的天空再次放晴 泣き止んだ今日にさらば与不再哭泣的今日别过変わらない思いを如挥动着不变的思念这般振り翳すように生きてく生活下去泣きながらでいいさ即使哭着也没关系それを繰り返して笑える生涯在这样重复着然后欢笑的一生 2022.4.29今天心有点堵。 先是提不起精神来，学不动，也玩不动。 然后是快递给我发成都去了。。我都傻了，“快件已到，距离收货地 1514KM“ 然后想起来还有给 ysa 和 ysc 的生日礼物压在上海。。 烦啊。 2022.4.27好吧！爷就是吃醋了！自己给自己做的那种！ 2022.4.26相比起前段时间，看淡了，可能是准备省选和推原神占据课余主要精力了。 其实省选也没准备什么，本来就没机会，就这样吧。 我不去想的时候，不会让我有任何感受，所以就不要想了。 可是就像现在一样，其实是无意去想的，但是我看到就会让我感到难受。但是这难受没有理由啊，这不是我能管到的事情，我不能也不应该让事情都向着我想要的地步去发展，更何况，我也不知道到底我在这件事上想要的是什么。。 所以我真的…… 2022.4.24我现在一听部分人说话就难受。 血压真的被拉的很高。 我真的会被气炸。 心中万句吐槽，懒得打了，滚吧……让我血压起飞的人。 2022.4.21放一点歌词： ティアドロップス（Teardrops） 柊キライ / v flower 延々エンエンと泣いている 哭得不像样的我 それは誰の為 自分の為で 究竟是因为谁呢 是因为自己吗 「悲しいの」そう言って酔いあがる為さ 只是无力地在丧气的话语中沉醉 そのエンターテイメントに合わせ 是否更加符合这场闹剧 踊る 踊る 心躍るよ 舞动吧 跳跃吧 让心也狂欢起来吧 この先「楽しい」に何度出会うだろう 就这样让欢悦永远充满心间吧 それなのに 即使这样 無垢な気持ちで泣いてみたい 我也想要怀着澄澈的心大哭一场啊 無垢な気持ちで泣いてみたい 我也想要怀着澄澈的心大哭一场啊 こんがらがった 涙 涙 ぽとぽと 哭得泪流满面 泪水 泪水 缓缓滴落 悪いことをしてるんじゃないか？ 这算不算是在做坏事呢 無垢な気持ちで泣いてみたい 想要如同孩子一般地大哭起来啊 無垢な気持ちで泣いてみたい 想要如同孩子一般地大哭起来啊 だって 悲しいんです 本当です 因为 我是那么的悲伤 绝没有骗你 真意を証明出来ないのも 即使是不能好好的表达自己的心情 悲しいです 虽然我现在以及麻木了但是听到还是能短暂的想起来之前。 我分散注意力的方法可能大约大概很有效，现在已经不会想那些了（ 2022.4.20 白葱 2022/4/19我刚才寻思着反正都攒了 80 了这个实乃里生日卡真的很好看要不然抽一个吧 白葱 2022/4/19然后控（）室多了十个可兑换 然后看见正好这次司活的 Live 要开始了，就去看了看。 我本来以为也是和上次 1.5 周年一样两首歌的样子的，没想到，最后……就一首歌（ 今天想想前段时间真的有些敏感了。 2022.4.19最近好烦呐。 梦里啥都有，我现在梦越发真实而醒来之后越想越不可能…… 我感觉我确实是疯了。 今天找到了 Formula1 的字体，虽然官方并不公开这个字体，但是还是有民间的模仿字体（大概 于是就把浏览器默认字体和博客默认字体改成了这个。 只可惜这种字体字间距太小不能写代码（ 但是看起来真的好高级（（（（ 这几天的经历告诉我，我（）（）了（）（）（）真的会死……已经不敢想今年暑假之后的事情了…… 2022.4.17417，谐音有点意思。 达芬奇我真谢谢你，我做了一个小时的动画。 去整了个 Pr22，看看能不能好一点。 还在试图复健树剖。 一口气注销了很多东西。 我为什么要看起来好像无所谓，我不理解。 意识到自己不想用括号或者省略号结尾还是挺恐怖的。 2022.4.16但其实昨天因为自己想要好好上课所以昨天上课体验是非常好的（ 于是就被叫起来回答问题两次对吧 网课这个延迟真的跪了hh，我和 QKD 之间的延迟高的离谱，大概 3~4s. 我说下一个题他问我上一个题的级别（ 昨天晚上试图去宽哥的腾讯会议进行学习，但是没坚持太长时间就退了（主要是人都不在了我就润了 ……周末卷子有点闹心。 略感离谱，我想知道这些网课软件都是咋写的。 您软件内存和 CPU 占用都大于我 Edge 和 VSCode 总和。 还是在我 VSCode 和 Edge 很多插件的情况下…… 哇我真的不理解（ 好烦啊好多事情撞在一起。。 随便画了几笔，因为突然想画个小头头（ 大概是参照了一下白葱，但是画的完全不像就是了（ 今天看到一张 20 年八月的照片，好怀念，这上面的所有东西都和现在不一样了（ 虽然说并不是说新的不好，但是就是好怀念之前在那个家，用着老电脑，夕阳下的时光。 2022.4.15好想和这个世界说再见了……我怎么又这样。。 我「振作」起来，愁绪「去TM」！ 2022.4.12感觉这几天都没啥好记的东西，但是感觉到很多危机感，好烦。 省选又延迟了，但是跟我没有太大关系。 但是又是好久不碰奥赛了，感觉是时候安排一下自己的计划了。 2022.4.10好几天没动博客了，主要是懒，而不知道写什么。 其实要脑子里有的东西好多，都扔到 Reverie 里面吧（然而并不能知道什么时候能写完）。 感觉自己最近总是在担心一些东西，然而这件事，或者这个人，并不需要我担心，就是我自己瞎想罢了。 算是比较偶然，打开 PJSK 看见有 LIVE，于是就进去看，第一次只看到了最后的自傷無色和 Tell Your World. 因为第一次看这种虚拟 LIVE，相当激动。 然后发现后面还有一场一样的，就把后面一场看完了。 白葱 1:21:36我发现我看这个也好激动（） 白葱 1:21:56虽然sega很敷衍的就放了一个歌 白葱 1:22:10哦不是，是两个 白葱 1:22:25但是我还是好激动看这个 白葱 1:22:35我越看越想去现场。。 白葱 1:22:47傻呗疫情赶紧过去 白葱 1:23:0124年我要去霓虹 白葱 1:23:12寝了 未来的悲鸣时时在耳旁幻起。 现在的我却感觉无能为力。 不能探知到自己真的太痛苦了，别人不懂，我也不懂，谁懂了告诉我好吗。 回想之前，我是怎么在虚幻有无走过来的。 每一次做出决定之前，我是……哪一个我呢…… 2022.4.9企鹅回滚真的好听，我之前没听真的相对失败，今天不听明天停止公开了失败一辈子。 2022.4.7好几天没动博客了，原因未知。 2022.4.3今天下楼拍了拍花（ 更了谜语集。 看了 wxm 博客之后想简单改改 About. 因为没啥好写的了，放一个谜语罢（信： 颤抖的心情，等待的凉意。 2022.4.2感觉今天 nothing to record（ 2022.4.1愚人节快乐，一会再写（ 上网课第二天，没啥特殊体验，和昨天差不多。 除了下午多了一节美术，我是真的要笑死在这节课上（ 老师放的视频没有画面只有声音，皮影戏的声音还贼吓人哈哈哈哈哈哈哈哈哈哈哈哈哈 然后讨论区因为是全级部大课，一堆社牛哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈（ PJSK 愚人节活动真的笑死我，五个 SEKAI 空无一人，现实世界 C 社六子联会（ MIKU RIN LUKA MEIKO 五倍体（x） KAITO 和 LEN 四倍体（x） 还有 $2 \\times$ RIN + $1 \\times$ Len（XXY，信），$2 \\times$ KAITO + $1 \\times$ MEIKO （XYY，信） 然后发现自己又攒了一个十连，所以就去抽 FES 池子了（ 然后……出了小白葱！ 我圆满了.jpg 还有就是这回愚人节的重排（信）组合，真的好惊喜（ YUME YUME JUMP | 永远的神！！！！！！！可爱死了我的奏宝😭😭😭😭😭 Fantasista SQUAD | 我的亲娘…… ハピネス戦隊サニサニ☆ワンダー | 把 mfy 和 emu 放在一起我笑死了哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈 休日、趣味人同士で。 | 这个猛毒啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊真的太好听了呜呜 然后……还有啥来着，忘了…… 哦对，换了特等俘虏的头像，还是和牛爷爷一起（ 我用的白葱，牛爷爷用的奏宝。 然后 wxm 换成了 mfy（ identity 觉得很淦（信 wxm 想建博客（ 岚 2022/4/1 0:25:46四月快乐 岚 2022/4/1 0:25:51寝之前 岚 2022/4/1 0:25:58感觉还是得说 岚 2022/4/1 0:26:22当我们姑且把一个月的第一天当做新的开始的时候 岚 2022/4/1 0:26:33就必须要好好生活下去了 白葱 2022/4/1 0:27:17是呢（） 岚 2022/4/1 0:27:17这是一个清澈温暖的季节 岚 2022/4/1 0:27:26不管外面怎么样 岚 2022/4/1 0:27:34我们 白葱 2022/4/1 0:28:35我们（） 岚 2022/4/1 0:28:58 每一天都要明媚喔 岚 2022/4/1 0:29:03（sign） 白葱 2022/4/1 0:29:06呜呜 挖一个，坑. 2022.3.31关于网课： 第一天上网课，老师可能还没找到节奏，所以今天推的不算是特别快（ 班主任课前专场单口相声（ 关于 F1： 今天官宣了 2023 年加入拉斯维加斯夜赛。 一条大大大大大大大大大直道，可以预计达到 342 KM/H 的直道，而且就 14 个弯，你为啥不直接去 NASCAR 赛道（ 加上拉斯维加斯美国就三场比赛了（ VET 这周末要回归了，希望能有拿分的可能吧，马丁今年这车真是……寄往开来，2020 粉红梅奔到 2021 削了底板掉到中下游，再到 2022 和威廉姆斯夺倒数…… 下一场是澳大利亚，一条我觉得非常难把持的赛道…… 开一个一般的圈速不难，但是开一个相对不错的圈速有点难把持（ 关于 PJSK： Nothing,but after updating the v2.0.0, my phone always EAT MY HOLDS!! Why?? I don’t know! What happened? We need to know!! So I just registered an Apple ID to try to download PJSK on the iPad. Then I had better score. 请无视所有的语法错误，单纯打英语玩。 简单来说就是……想再整出来一发十连（ 但是手机断触，于是首次尝试 iPad $\\times$ PJSK，确实比手机强多了，第一次活着打完了火花的 28，miss18（ 因为明天是愚人节，等一个活动。 谜语： 好，虽相比有差，然我觉得这更好，人格差恰适应此。 2022.3.30昨天晚上还在感叹，还有四五天才能放假。 我怎么都想不到，今天居然回家了，因为疫情。 网课时代，又要开始了。 晚上说要测试网课，最一开始在学校说的是五点半，然后后来通知说七点半，然后发现平台一直都没调试好，我们就等了三个多小时…… 最后终于在十点多整好了…… 不知道什么情况，PJSK 这回更新之后，总是莫名断触，咋整啊…… 因为上回攒了一发十连，再加上这回 Potato Sekai，加起来有两发十连。 因为相当喜欢小白葱，所以就去抽 fes 池子，然后，十连第一次出彩…… 喜提一发十连两个四星两个三星…… 虽然没有白葱，但是有冬弥和杏（ 然后因为 1.5 周年更新仅仅在 39 日的之后 21 天，于是专门开了个卡池送了 3.9 发十连（ 然后试了两次十连，第一次正常单三星，第二次一个天马咲希的四星，外加两个三星（ 然而我要我的小白葱啊呜呜呜呜呜呜（x） wxm 2022/3/30 23:54:30？？？？？？？？？？？？？？？？？？？？？？？、、 wxm 2022/3/30 23:54:35号送我 wxm 2022/3/30 23:54:41我这辈子没出一个fes 2022.3.29不得不称赞一下学校的组织能力，可以说是 SD，乃至全国的顶尖水准。 顺便，今天早读老师读了一个高三学长写的“表扬信”，简单来说就是说我们住在他们楼下敲暖气管子，然后还“以头抢地，奏翁击缶”。 我倒是觉得提出来挺好的，但是，倒是说哪个房间有水管声啊……也让我们好核查一下。 免得每天吹哨之后我们听着楼上咣咣当当还得写信给校长（笑 说啥来啥，学长真的是相当勤奋！！ 今天中午在吹哨之后还在勤奋的讨论问题、舒展身体，让暖气管不仅情不自禁的叮当想响起来，而且传来讨论问题的刻苦声音！ （笑） 其实觉得这玩意属于是谁先写谁占优呗。 不太懂，学校信息老师都…… 算了，没必要。 2022.3.28早上一点是沙特大奖赛，但是因为在学校所以就没看。 其实在家也看不了，谁在第二天早上五点二十起床的时候熬夜啊 然后中午让 SKP 奶一下周冠宇和冠军，SKP 奶的冠宇 P9，冠军法拉利。 然后下午一看冠宇 P11，冠军红牛（ 不愧是毒奶之王 SKP 就应该把阿罗车组当场拿下！！！！ 2022.3.24学校这个网给我整无语了真的，你 LC** 吃枣药丸。 2022.3.23今天是世界小狗日好像（ 学校开始实名上网……无语 2022.3.22这玩意是真给我整无语了，最近 Github 难以访问可还行，push 不上去。。 整了好长时间终于整上去了。。。 我的评价是：抽象。 2022.3.21窝法一二带回，冠宇首秀拿分，红牛颗粒无收，老汉再度登台，法家阵营起飞，梅奔阵营提前备战 2023，好时代，来临了！ 我真的高兴坏了真的真的真的真的真的真的真的真的真的真的真的真的真的真的真的真的真的真的 法拉利阵营整体起飞！！ 本来我昨天晚上光看了起步，一看阿罗两位都晕厥（ 本来觉得能回到排位位置就好了，今天早上一起来就看到周冠宇是 P10！ 附，某两位铁佛寺： [保留]绝顶我为峰 2022/3/21 0:45:55窝法一二带回了啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊 [保留]绝顶我为峰 2022/3/21 0:46:00周冠宇拿积分了啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊 [保留]绝顶我为峰 2022/3/21 0:46:04过年了啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊 [保留]绝顶我为峰 2022/3/21 0:46:06【庆祝】 25時、コードを書く 2022/3/21 16:50:38好时代来临了！ 25時、コードを書く 2022/3/21 16:50:39窝法一二带回，冠宇首秀拿分，红牛颗粒无收，老汉再度登台，法家阵营起飞，梅奔阵营提前备战 2023，好时代，来临了（x） 25時、コードを書く 2022/3/21 16:50:49真的过年 [保留]绝顶我为峰 2022/3/21 16:50:57【庆祝】 25時、コードを書く 2022/3/21 16:51:07高兴坏了真的 25時、コードを書く 2022/3/21 16:51:31我因为今天要五点二十起床 25時、コードを書く 2022/3/21 16:51:34昨天晚上就没看 25時、コードを書く 2022/3/21 16:51:37光看了发车 25時、コードを書く 2022/3/21 16:51:50看着冠宇起步掉到20，觉得有点危 25時、コードを書く 2022/3/21 16:52:08但是就我过了一会发现冠宇超到 15 25時、コードを書く 2022/3/21 16:52:34然后我上床就祝愿冠宇和77能保持排位成绩 25時、コードを書く 2022/3/21 16:52:45法拉利双台 25時、コードを書く 2022/3/21 16:52:50今天早上起来一看 [保留]绝顶我为峰 2022/3/21 16:52:56【狂笑】 25時、コードを書く 2022/3/21 16:53:01爽飞了 以及，刚才有一架 737 失联了…… 希望能有奇迹🙏 2022.3.20早上起来看见 LEC 夺杆，真的，高兴坏了（ Forza Ferrari 然后把今天 QQ 空间的东西搬过来： 某个屑 B 因为不想现在开电脑所以就过会再扔博客里吧。简单来说，生日以来的这这两周是我 20.9 以来最开心的一段时间。希望能延续好心情（（顺便提一句日推真有你的。。我都忘了要找这首，你主动给我推了）因为比较菜听日语做不到听英语的水平，所以经常去翻歌词。逐渐的就喜欢上翻歌词，因为真的有许多术曲的歌词让我很有同感。（然而并不是专指什么厌弃自己淡漠世界的歌词，但是变故总是会让我和它们走近。嘛，不过，现在好多了嘛。）因为脑袋里记的东西一向比较奇怪，好多东西都是连在一起一串起来一堆的水准，所以会发生各种奇怪的遐想和梦境。（其实好像上了初三以来还没有没梦睡一次的。。）（等一个无梦之梦（x））哦好像某种意义上来讲，无梦之梦是我今年入坑之前最喜欢的一首术曲。（然而屑 B 网易云要 VIP）济南没有春秋所以随着气温升高是不是可以期待夏了。作为 IA 推（）然而感悟一通，随着脑袋瞎想瞎写，我发现我还有一个问题找不到答案。我啥时候能知道咋学习？（……毕竟学习好了才能完成生日愿望的某一条）好，我宣布某个谜语人又开始了。读自己之前写的东西，就很容易读不懂……因为写的实在是太迷离了。尤其是越对公众开放的东西越谜语。。某些在博客角落藏着的东西……他也很谜语。这就不是一个良性循环，因为我记东西比较连锁，可能就拽出来一堆之前的事情。不喜欢回顾初三之前的事情，因为现在就觉得人傻没做不出什么对的事。然而初三上学期，和高一上学期的回忆一个比一个寄，本身性格比较脆就可能直接手把手借之前的刀把自己再干碎一次（）不过某种意义上来讲，通过去年，我好像更知道我了。但是可能我的像太宽而淡了，就像是找到了自己在世界的哪个位置，但是找&gt; 不到自己在哪。不是……我是有病吧写这么一堆乱七八糟的东西。但是我是真的懒得开电脑（） 2022.3.19今天早上挺有意思，SKP 说我五点多一点开始在床上笑，然后就把全宿舍人整醒了（ 问题是我把他们笑醒了我没醒（（ 我起来之后怎么都想不起来为啥会笑，我梦里明明梦见 yym 拿着菜刀在宿舍追杀我和别人来着（？ 回家之后浅浅试了一下糖豆人和战舰世界（感觉还行 然后开着 20 年周冠宇的车挑战了一下 90 难度的 AI 跑河内，发现其实超车没啥难度（ 好奇怪我玩生涯的时候 AI 开 81 排位赛速度都不是很好（相对队友），但是 F2 正赛连着两次三段刷紫（ 好像我确实也是正赛节奏比较稳，排位纯靠天意（ 下回试试 95 AI，跑河内（不得不说这赛道是真恶心人，到底谁想出来的！） 2022.3.18我的想法是，要不然单独开一个写（ 但是今天还是先把之前博客里一些非学术的东西搬一搬。 2022.3.17终于有机会写一点东西了吗（ 笑死又没时间了，每天一个小时做个题都不够的（ 2022.3.16我是锅王，四道题的比赛锅三道，有两道是因为我，tnnd. HelloWorld2022 出假了，我对不起绊爱。。 2022.3.13昨天晚上把 HelloWorld2022 的三削版写完了，今天早上造了数据，于是乎给学弟学妹的题大约就剩下最后一道了。 但是这道我没啥想法（ 最后是把去年 Aik T1 搬来了，重设了一下题面。 但是不知道什么时候才能让他们做这道题呢……今天已经不够四个小时了（ 我发现我出题特点就是题目背景瞎糊一堆，然后题贼简单。 今天猫夸头像结束了长达九个月的服役，大概是我初中以来用过时间最长的头像了。 换掉的原因有两点，第一点是我个人逐渐不再看 VTB/VUP 了，第二点是即使 Aqua 虽然在最后的 Hololive 事件上并没有如哈卡哈卡吗和煌虫那么负面，但是毕竟还是有过各种事情吧，然后就换了。 （找理由） 可以看到的是现在换成了 knd，呜呜我的奏宝（ 2022.3.12今天去打 THUPC 初赛，当然是没想着晋级，因为菜。 目标是我们队能有题就好。 最后的结果就是做出来 K，A 和 D 差点，果真还是菜。 早上忘了买吃的，中午没吃东西（ 今天去萌娘百科看了 mzk 的经历啥的，发现你 sega 是真会写 25h，四个人各种戳我（ 虽然我是 knd 推，但是对 mzk 好像感悟更多欸（不是伪娘这一点 2022.3.11今天想了想，又改成了 Heriko Deltana’s Social Behavior Note（ 什么是架空世界啊（谜语人笑） 有道这个翻译我属实看不懂： 宵崎奏 → Night battery play 2022.3.10今天发现 16 岁以来每一天都挺……（ 有点担心之后。 2022.3.939日快乐（ 上午第三节课课间开始戴着 leo/need 的 miku 徽章，然后 wxm 带着 leo/need 的 luka 徽章（ 然后我戴到下午实在社牛不了了（ [INFO] - 2022/03/09 17:00:35 - nmdlasd:我自己带逮捕证 [INFO] - 2022/03/09 17:00:40 - nmdlasd:*带不正 [INFO] - 2022/03/09 17:12:26 - nmdlasd:然后就带不上去了 [INFO] - 2022/03/09 17:12:38 - nmdlasd:主要是这玩意和校徽一样大 [INFO] - 2022/03/09 17:12:51 - nmdlasd:我就把它挂在领子上 [INFO] - 2022/03/09 17:12:56 - nmdlasd:结果感觉很奇怪 [INFO] - 2022/03/09 17:13:19 - nmdlasd:但是如果和校徽放在一起更加离谱的样子 [INFO] - 2022/03/09 17:13:30 - nmdlasd:所以最好的方式是盖住校徽/kx [INFO] - 2022/03/09 17:13:37 - nmdlasd:但是那样更会被干 后续：昨天一直戴到回家。 deco 新专辑 suki！ 2022.3.8发现随着某些事情越来越好，精神状态有很大恢复（ 我发现我就是巨大谜语人（ 2022.3.7没想到今天这么好（各种意义上 2022.3.5又要从昨天晚上说起了。 因为难得的大于一天的假期，wxm 说要周末一起出去打 mai（ 因为开学故意考砸，所以不是很敢和妈妈说来着（ 但是没想到同意了（ 然后今天上午就可以第二次去 mai 了，这次除了 mfj 和 wxm 还有妈沫（ 最一开始是我和 wxm 一个机子，mfj 和妈沫一个机子，但是因为是周六，来的人还是比上次去多的，因为太菜了不敢占机子就让了一个机子（ 最一开始找不太到感觉，后来就开始有感觉的糊（ mfj 最一开始形容我打 mai 宛若逛大街，后来我也学会了快乐糊（ 然后用着妈沫的号怒干用着 mfj 号的 wxm （中间 mfj 和妈沫打累了我俩就直接上了） 再加上后面 mfj 用妈沫的号怒干用着 mfj 号的 wxm，所以妈沫的记录上估计就有了五连干 mfj（ 话说我用自己号最一开始干不过 wxm 来着，属于是不用别人号不会玩了（ 然后我和 wxm 累了就带着 wxm 去玩了一下湾岸（？ 然后因为下午要上课就提前走了，没能和生物的人去吃火锅（ 要不然我可能重现蛋饺事件（见 2021.1.20 Sec2 2022.3.4十六了，HD 生日快乐（ 班里各位是 真 会 送 东 西（ 怒提 45 包餐巾纸，虽然不知道送我这干啥（ 2022.3.3写了好多天的十六巨献终于写完了（ 因为明天不来机房了，不知道还碰不碰得电脑，于是把 3.4 的日记提前写上（ 2022.3.1今天阳历生日欸，虽然我不过就是了（ 青柠起始页的这个小细节suki 今天信息课被拉来拉去（草） 今天信息课和 wxm 看了好多东西，毕竟在学校呆了两周多了她啥都没看（ 2022.2.28学弟学妹机房氛围真™好。 2022.2.26绊爱 HelloWorld2022 相关 18：08 开始倒计时。 18：11 开始。 18：13 老爱入场（） 我真的好想看视频，但是机房真的蛋疼。。 只能先听声了/ll 希望我能听懂一两句话吧，剩下的只能回家看了/ll 最一开始好像是英文 Hello My World，开场主题曲挺好（ 平常英语没少听，这次派上用场了终于呜呜，能听懂居然（ “米娜！” 老爱还是傻笑啊ww，呜呜 果然还是五岁小孩（x） 声音变了好像是黑爱出来了（ 草为什么会自己暂停/fn 现在纯靠我脑子想象呜呜。 没事，能听着也好（ 她在笑啊，在笑啊，呜呜 好高兴啊，但是…… 傻笑还是傻笑（） 呜呜好好听吧（ 无意之间居然听了一个小时了（） 可恶，zj 居然可以用手机看/fn AIAIAI！ -19：12 好多人都来了！ 都来给元老送别呐（） CEVIO AI!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 这是今天晚上最好的消息！！！！！！！！！！！！！！！！！！ 之前看见民间有人做绊爱音库，现在有官方了呜呜 另一种形式留下来了呐，这啥今天晚上最好的消息了！ 本来是要和 wxm 一块看来着，但是发现学校条件不太允许，就我自己听了（ 她要是和我一块看，也会像是和我一样在机房直接喊出来一个“卧槽”吧应该（ 想买 CEVIO AI 了（ 草，我还以为结束了，刚才（ –19：32 呜呜，她哭了，她哭了，她哭了，她哭了…… 我也想哭啊…… “哦嗨呦，哦嗨呦，Good Moring，Hello，Hello，Hello” 我看见后面这么多人，真的想哭，真的…… \\ 说实话还是不能相信为什么绊爱真的要暂时停止活动了呜呜…… 她还在笑，但是明显带着哭腔啊呜呜 最后还是 AIAIAI 收尾，我真的哭了…… 呜呜啊啊呜呜…… 真的写不出来那种感觉，明明最后的 AIAIAI 的钢琴伴奏是轻快的，但是我听得好伤感，真的真的真的…… 写不出来，写不出来…… 我真的好伤心，真的…… 草，居然有 HONDA 和日清，幻视 F1 和 pjsk（ 哭了。 好像旁边要打 ABC，但是 Atcoder 炸了（ 八点，结束了，呜呜，呜呜…… 感谢绊爱，这些年的陪伴…… 感谢绊爱，每天早上的早安…… 希望总会有 First Live 到来…… 总会再见的，总会再见的…… 看完之后去操场跑了几圈，不知道为啥（ 单纯的有点伤心吧，毕竟…… 今天晚上天气晴朗，抬头能看到很多星星。 真好，不是吗。 我会等你回来，一定。 2022.2.24今天好几次呐，好开心。 上述内容和俄乌局势无关。 希望战争早日结束，没有人喜欢战争。 2022.2.23妈妈生日快乐！ 我服气了，我从我电脑上把系统安装到硬盘（这样的话会带着我电脑的驱动），然后去机房电脑升级内核，显示因为英伟达驱动版本过高不能合并所以不能更新版本。 但是我从机房电脑安装的话倒是可以更新内核，但是插到我电脑上因为没有屏幕驱动不能亮屏…… 那我就从我电脑上安装然后去机房电脑单独安驱动，但是整完之后插回我电脑还是没有网卡驱动。 服了。 2022.2.22试图装 Manjaro，结果发现 RTL8825AE 的网卡驱动还是没有（ 发现已经合并到 5.16 了，但是 Manjaro 虽然写了有 5.16，但是还是默认 5.15…… 2022.2.20学弟刚来就在机房看冬奥会了，很有精神。 2022.2.7返校。 2022.2.1新年快乐。 2022.1.31除夕快乐。 2022.1.22 - 2022.1.26因为这些天是 WC，所以主要写在游记里吧。 如发奇想，有没有一种可能，心理咨询师，自己也有心理问题，为了挽救别人向自己坠落的方向而努力。（2022.1.25） 2022.1.21延长了一晚上的假期，顺便把原神里的 4800 原石抽掉了，歪了刻师傅，草。 2022.1.20目前来说，初高中四年以来，最【无法描述】的一天，不恰当来说就是高开而低走（x） SecOne一切一切还要从前一天晚上开始，十九日十一点多，mfj 问曰：你明天去打 maimai 么。 作为一个从未和同学出去玩过人，欣然同意（x） 其实是好久之前 wxm 问要不要出去打 maimai来消费她上次和 mfj 充的币，大约上次月考的之前一周的时候吧（ 但是显然就我这样学习成绩再加上刚停课回来的周末出去的可能性约为 0 吧，于是就觉得元旦出去。 然后元旦之前先是 mfj 发烧，然后我发烧， wxm 声带出问题，然后就（（ 然而这次 51.5h 的假期包含一整天，确实是非常好的选择的吧。 然后去问母，母问谁与同去，我曰 mfj ，母曰不知其人也，但终了母曰之可。（虽然莫名就又一次引起来了关于她对我们班人名的询问？） 因为下午要去社会实践，于是就顺便拉着这两位去。 当然还有 tsy，他和 wxm 看电影去，于是最后打 maimai 的就剩下我和 mfj 了（ SecTwo早上五点半自己醒了……果然还是被学校的作息整怕了……然后回去睡到八点（ 起来之后进行一个饭的吃，然后一看手机发现一堆人找我，好久没看见这么多人找我了（） 原来是 wsr 的社会实践手册忘了拿，然后因为我离学校近就问我能不能去拿，然后因为我没回他就让 wxm 问我，然后 wxm 找不到我就让 mfj 找我，还有 yx 找我问下午的团员人数（？） 然后就是出发去打 mai 之前去给 wsr 拿了一趟（保安大爷居然也没问我干么去，难道是我没穿校服像是个老师，还是我天天通校认识我了，还是？） 总之在约定的十点到了，因为我第一次打，所以经常找不到键，不过逐渐好起来了（ 旁边貌似有大佬，怒 FC 13+（ 然后我们大约玩到最后就发现玩不了我们事先预计的 30 个币，就开始挥霍瞎搞，然后…… 然后我就莫名的往一个开 ce 的机子里扔了四个……然后……然后……它居然在维修把我币吞了！ 然后最后去玩湾岸 5，拿老 NSX 刷着玩，快跑完的时候 wxm 带着 tsy 来了，然后就进行一个吃饭。 他们带着我去吃火锅，然后吃饭之前 wxm 带着我打了一次 pjsk 的多人，虽然不知道有啥不同，但是我 pjsk 终于有好友了（（ 然后中间的时候上了个蛋饺， wxm 问曰能否直接吃，然后我就莫名的拿起来吃了（？） 然后路过的服务员哥哥看见我生吃非常惊恐，曰：哎！———————————— 然后就社死了，死在旁边的衣服里不敢抬头（（（ SecThree下午就是一个社会实践，去的新华书店，然后我和 mfj 和 wxm 在二楼，大约就是干一些引路人和擦东西的事情。 然后偶遇一个翔 B（ 然后就快乐的站了两个小时没做下，然后活动结束后，就进行了【数据删除】的【数据删除】。 晚上知道了成绩，和我的期望差距很大，除了数学级部 99 还凑合，剩下的考的都是个么玩意。。 比我刚停课回来还低……比一个周前的模拟掉了 300 名。。 然后就很生气难过，反复观看乙女解剖。。。 至于为什么是乙女解剖呐？ 哈哈。 2022.1.19开启了长达 51.5h 的寒假。 前段时间因为准备期末考试所以没让来机房，但是，我觉得我还不如停课。。 复习了一周还不如一周之前考得好。。 生气.jpg 2022.1.8全天奥赛喜闻乐见。 今天挺高兴的，因为树剖复健非常成功（ 唯一一次调的时间长了点是读题锅了（ 上次全天奥赛好像也在这写了一堆东西，大约每次大考前十天就会全天奥赛一次的样子么（ 已经对期末考试考多少分不抱希望了，状态不行。 现在只希望着早点考完，上奥赛，放假，回家。 除了早上被某些奇怪的东西吓醒，今天挺好的。 2022.1.7发现了，增强新鲜感能显著增强的我的学习兴趣。 今天把 Fira Code 换成了 JetBrains Mono，于是兴趣巨大提升。 所以什么时候 whk 也能给我提升学习兴趣的东西？ 比如突然给我毕老师的脑子 明天早上要在宿舍打扫卫生，然而我今天晚上回家，所以就能多睡一个小时，这样好（ 今天下午来的时候发现 WTG 炸了，试图修了一下发现不行，危（ 不过现在用的比较少了先不修了吧（（ 发现机房网好快，于是就将买了好久没玩的战地 5 下到硬盘里（ 峰值速度 32Mb/s+，害怕，害怕，平均速度 26Mb/s，害怕，害怕。 二十分钟过去下载 50%，害怕，害怕（ 2022.1.6前几天吃药吃的总是困。。 2022.1.1新年，好（ 放一下空间发的什么鬼玩意吧。 2021.12.31很 好 的 一 天 呢。 2021.12.26 - 30在帮忙忙活元旦活动。 2021.12.25和 wxm、mfj 在上午大课间进行了一个尝试安装 pgr，但是发现需要有密码才能安装，试图猜了一下 Hitevision 不对（ 于是就没装上，中午下课之后试图搜了一下没搜到（ 下午寻思是不是要搞个虚拟机或者模拟器什么的，然后，wxm 过来说好像要 32 33 一起搞于是就大概去报告厅，所以就不能在大家面前擦黑板了玩 pgr 了 下午下课之后和 mfj 去心灵港湾玩，第一次去，那里有个画板，上面好多画的样子（ 看到很多很好的元素，比如，居然，LCEZ 有这么多车万人，好多同学的画工真滴好，那个胡桃，warma （居然）还有 fufu …… 好多人玩原神啊，好多的原神相关（ 气抖冷，日 v 什么时候能站起来（不是说 vtb 看到了关注嘉然，顿顿解馋（（ 看到了石之海（ 车万相关居然能占据整个版面的 1/5 是我没想到的（ 然后原神大约又占了 1/5 的样子（ 其余的就是很多杂杂的东西（ 我拿笔写了个“卓爹 yyds”、“翔B yyds”和“我已经完全爱上 warma 啦”就溜了（ 本来想写个“我是 ___ 的狗”（然后 mfj 还说要写个 x2，（笑）），但是好像写全名不太好就没写（ 话说本来想更新里记来着，但是旁边人好多人好多人好多（ 2021.12.24下雪了，真·雪降り、メリクリ 有点冷，但是你卓爹还是穿短袖（ wxm 说要元旦的时候在教室尝试让我们在大屏上搓 pgr，于是今天拿了个安装包（（ 2021.12.23rnm，月考没了！ 2021.12.19上午进行一些活动，下午他们在给新实验班出 NB 题。 2021.12.18据说幻塔隐私政策很垃圾，所以昨天决定的东西干掉了。 2021.12.17好像有个什么东西是幻塔来着，好像能捏人，捏个同学进去（x（？ 2021.12.12首先恭喜 MAX，然后就是 Fia 确实智障。 LAPPED CARS WILL NOT BE ALLOWED TO OVERTAKE. LAPPED CARS 4 (Norris) - 14 - 31 - 16 - 5 TO OVERTAKE SAFETY CAR. 2021.12.11之前的以后再说，今天的想到啥写啥。 突然想寒假的时候手画一下头像（？ 突然想把一些东西做成皮扔到地平线 4 里开着车玩（ 今天 ceh 的《Noi Linux To Go》因为硬盘炸了好多次，从六点到十点已经重启了 10 次了快？ 真的是离谱坏了，写题的话每隔 30 min 炸一次差不多，但是只要他不写代码就没事（ 下午就回去 whk 了，班主任过来发的一堆卷子让我深感危险（ 话说真的发现自己在机房的状态比在教室好多了，昨天居然中午听见了吹哨，起来还贼早。 莫名，莫名。","link":"/2021/12/10/HDSBN/"},{"title":"平面最近点对","text":"平面最近点对 闲来无事，学个新东西。 问题概述求有 $n$ 个点的平面上欧几里得距离最近的两个点。 算法考虑分治，将当前的点集经过按照 $x$ 坐标为关键字排序之后，不断的分为两段分别求解再合并。 分治是好想的，问题是如何合并。 假设我们要合并的两个区间的最近距离分别是 $h_1,h_2$，取较小值之后记作 $h$，区间中点为 $mid$。然后将所有满足 $| x_mid - x_i | &lt; h$ 的点放到一个新的集合中。 然后再将这个集合按照 $y$ 为关键字排序，然后每次枚举两个点，只用满足 $| y_j - y_i | &lt; h$ 的点更新答案。 而最后这个满足条件的点集的大小最大为 $7$，OI-wiki 上有其证明。 Code这个是洛谷模板题 P1429的代码，复杂度为 $O(n \\log^2 n)$，使用缺省源「V5.2」。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566template&lt;typename J&gt;I J Hmin(const J &amp;x,const J &amp;y){ Heriko x&lt;y?x:y;}CI MXX(2e5+1);const double INF(1e12);I bool CMP(const pair&lt;double,double&gt; &amp;a,const pair&lt;double,double&gt; &amp;b){ Heriko a.second&lt;b.second;}I double Dist(const pair&lt;double,double&gt; &amp;a,const pair&lt;double,double&gt; &amp;b){ Heriko sqrt((long double)(a.first-b.first)*(a.first-b.first)+(long double)(a.second-b.second)*(a.second-b.second));}int n;pair&lt;double,double&gt; a[MXX],tmp[MXX];double Merge(int l,int r){ if(l==r) Heriko INF; int mid((l+r)&gt;&gt;1),top(0); double dis(INF); dis=Hmin(Merge(l,mid),Merge(mid+1,r)); for(int i(l);i&lt;=r;++i) if(fabs(a[mid].first-a[i].first)&lt;dis) tmp[++top]=a[i]; std::sort(tmp+1,tmp+1+top,CMP); for(int i(1);i&lt;=top;++i) for(int j(i+1);j&lt;=top;++j) { if(tmp[j].second-tmp[i].second&gt;=dis) break; dis=Hmin(dis,Dist(tmp[i],tmp[j])); } Heriko dis;}S main(){ Files(); fr(n); for(int i(1);i&lt;=n;++i) scanf(&quot;%lf%lf&quot;,&amp;a[i].first,&amp;a[i].second); std::sort(a+1,a+1+n); double ans(Merge(1,n)); printf(&quot;%.4lf&quot;,ans); Heriko Deltana;}","link":"/2022/01/04/Narest-points/"},{"title":"NOIP 2021 游记","text":"NOIP 2021 游记 不知道为什么，写不出什么积极的东西。 2021.11.17 「2021.11.9」离开学校去到 BCT，开始 8 天的集训。 「2021.11.16」听说考场有 sublime text 3，于是开始在 BCT 电脑上下一个开始用。 「2021.11.17」集训今天结束，算是很不错的体验，考试基本能正解一题，认识很多新朋友，见到了 UF 真人/se，手残删掉的 Phigros 的 rks 回到了原来的分，甚至现在到了 12.83. 今天老师说要欢乐赛，结果…… 这里说甚至 UF 还能发说说是因为 UF 只能用那里的电脑上 QQ. T1诈骗，然后就把T1切了。 最一开始用的 sublime 的自带编译，后来发现不能加其它编译选项，于是学会了写 makefile. 准备明天回学校。 「2021.11.18」回了学校，打板子，发现了 360 的优美特效：占用 .exe 文件运行时间 1s. 「2021.11.19」晚上不知道干啥，心情随着🐏删除东西，格盘逐渐down起来。 明天之后高二好多人就退役了。。。。 而我平时除了 Dfkuaid，就高二的人玩的多了吧。 孩子还小，接受不了。 昨天晚上辗转睡不着。。 去阳台打开窗户吹了一段时间风。 风。 初冬风。 但是有点冷。 我在干啥。 我不知道。 于是就迷迷糊糊回去睡了。 半夜， 梦见 NOIP 成绩出了，我卡线1=？ 不懂。 不知道是在梦里醒了， 还是现实醒了。 我发现我在床上反着躺着。 于是正了过来，继续睡。 不知道为啥我要写这个。 不知道。","link":"/2021/11/17/NOIP2021Days/"},{"title":"Models","text":"模板库。 「Pre」临近 CSP-S2 2021 的时候，我决定把板子都打一遍，顺便就把这些板子整理成一个模板库罢。 然而 CSP-S2 2021 都爆了我还没整完（ 现在备战 NOIP2022 了（ 本模板库最新的内容为 2022.2.20 更新，最老内容为 2022.1.23 更新，最近的码风翻新日期为 2022.1.23. 以下代码若无特殊情况皆可使用的缺省源： UPD 2022.1.23 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;#define Heriko return#define Deltana 0#define Romanno 1#define S signed#define LL long long#define DB double#define R register#define I inline#define CI const int#define CL const long long#define mkp(a,b) make_pair(a,b)#define mst(a,b) memset(a,b,sizeof(a))#define ON std::ios::sync_with_stdio(false);cin.tie(0)#define Files() freopen(&quot;RNMTQ.in&quot;,&quot;r&quot;,stdin);freopen(&quot;RNMTQ.out&quot;,&quot;w&quot;,stdout)using namespace std;template&lt;typename J&gt;I void fr(J &amp;x) { short f(1); x=0; char c(getchar()); while(c&lt;'0' or c&gt;'9') { if(c=='-') f=-1; c=getchar(); } while(c&gt;='0' and c&lt;='9') { x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^=48); c=getchar(); } x*=f;}template&lt;typename J&gt;I void fw(J x,bool k) { if(x&lt;0) x=-x,putchar('-'); static short stak[35]; short top(0); do { stak[top++]=x%10; x/=10; } while(x); while(top) putchar(stak[--top]+'0'); k?puts(&quot;&quot;):putchar(' ');} 「快速排序」 UPD 2022.1.23 1234567891011121314151617181920212223242526272829303132333435363738394041CI MXX(1e5+1);int a[MXX];void Mysort(int l,int r) { int i(l),j(r),mid(a[(l+r)&gt;&gt;1]); do { while(a[i]&lt;mid) ++i; while(a[j]&gt;mid) --j; if(i&lt;=j) swap(a[i],a[j]),++i,--j; } while(i&lt;=j); if(l&lt;j) Mysort(l,j); if(i&lt;r) Mysort(i,r);}int n;S main() { fr(n); for(int i(1);i&lt;=n;++i) fr(a[i]); Mysort(1,n); for(int i(1);i&lt;=n;++i) fw(a[i],0); Heriko Deltana;} 「并查集」 仅使用了路径压缩。 UPD 2022.1.23 12345678910111213141516171819202122232425262728293031323334353637383940CI MXX(2e5+1),NXX(10001);int fa[NXX],n,m;int Find(int x) { if(fa[x]!=x) fa[x]=Find(fa[x]); Heriko fa[x];}I void Uni(int x,int y) { int fx(Find(x)),fy(Find(y)); if(fx!=fy) fa[fx]=fy;}S main() { fr(n),fr(m); for(int i(1);i&lt;=n;++i) fa[i]=i; for(int i(1);i&lt;=m;++i) { int x,y,z; fr(z),fr(x),fr(y); if(z==1) Uni(x,y); else { if(Find(x)==Find(y)) puts(&quot;Y&quot;); else puts(&quot;N&quot;); } } Heriko Deltana;} 「线性筛」 这里是按照洛谷模板来写的，不过平时用不着询问部分，主要是 Es 函数。 UPD 2022.1.23 12345678910111213141516171819202122232425262728293031323334CI MXX(1e8+1);int n,prime[MXX],cnt,q;bool nopr[MXX];I void Es() { nopr[1]=1; for(int i(2);i&lt;=n;++i) { if(!nopr[i]) prime[++cnt]=i; for(int j(1);j&lt;=cnt and prime[j]*i&lt;=n;++j) { nopr[i*prime[j]]=1; if(i%prime[j]==0) break; } }}S main() { fr(n),fr(q); Es(); while(q--) { int x; fr(x); fw(prime[x],1); } Heriko Deltana;} 「堆」 一般来说，都直接用 priority_queue. UPD 2022.1.23 123456789101112131415161718192021priority_queue&lt; int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q;int n;S main() { fr(n); while(n--) { int opt,x; fr(opt); if(opt==1) fr(x),q.push(x); else if(opt==2) fw(q.top(),1); else q.pop(); } Heriko Deltana;} 「单调栈」 UPD 2022.1.23 1234567891011121314151617181920212223CI MXX(3e6+1);int n,a[MXX],f[MXX],stak[MXX],top;S main() { fr(n); for(int i(1);i&lt;=n;++i) fr(a[i]); for(int i(n);i&gt;=1;--i) { while(top and a[stak[top]]&lt;=a[i]) --top; f[i]=top?stak[top]:0; stak[++top]=i; } for(int i(1);i&lt;=n;++i) fw(f[i],0); Heriko Deltana;} 「快速幂」 2021.12.25 更新了那行 x%=p，调了三天 ODT 居然是这里爆了……我从来没写过这，于是加上。 UPD 2022.1.23 1234567891011121314I LL FstPow(LL x,LL y,LL p) { LL res(1); x%=p; while(y) { if(y&amp;1) (res*=x)%=p; (x*=x)%=p; y&gt;&gt;=1; } Heriko res;} 「单调队列」 第一个循环是求区间最小值，后者则为最大值。 UPD 2022.1.23 1234567891011121314151617181920212223242526272829303132333435363738394041CI MXX(1e6+1);int n,k,a[MXX],qmin[MXX],qmax[MXX],hd(1),tl;S main() { fr(n),fr(k); for(int i(1);i&lt;=n;++i) fr(a[i]); for(int i(1);i&lt;=n;++i) { while(hd&lt;=tl and a[qmin[tl]]&gt;=a[i]) --tl; qmin[++tl]=i; while(qmin[hd]&lt;=i-k) ++hd; if(i&gt;=k) fw(a[qmin[hd]],0); } puts(&quot;&quot;); hd=1,tl=0; for(int i(1);i&lt;=n;++i) { while(hd&lt;=tl and a[qmax[tl]]&lt;=a[i]) --tl; qmax[++tl]=i; while(qmax[hd]&lt;=i-k) ++hd; if(i&gt;=k) fw(a[qmax[hd]],0); } Heriko Deltana;} 「最小生成树」 UPD 2022.1.23 「Prim」 因为没写挂了（？）暂时咕了 「Kruskal」1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556CI MXX(2e5+5),NXX(5001);struct Node { int x,y,z; I bool operator &lt; (const Node &amp;co) const { Heriko z&lt;co.z; }}r[MXX&lt;&lt;1];int fa[NXX],n,m,ans,k;int Find(int x) { if(fa[x]!=x) fa[x]=Find(fa[x]); Heriko fa[x];}I void Uni(int x,int y,int z) { int fx(Find(x)),fy(Find(y)); if(fx!=fy) { fa[fx]=fy; ++k; ans+=z; }}S main() { fr(n),fr(m); for(int i(1);i&lt;=n;++i) fa[i]=i; for(int i(1);i&lt;=m;++i) fr(r[i].x),fr(r[i].y),fr(r[i].z); std::sort(r+1,r+1+m); for(int i(1);i&lt;=m;++i) { Uni(r[i].x,r[i].y,r[i].z); if(k==n-1) break; } if(k==n-1) fw(ans,1); else puts(&quot;orz&quot;); Heriko Deltana;} 「字符串哈希」「单哈希+自然溢出」 UPD 2022.1.23 12345678910111213141516171819202122232425262728293031323334353637#define LL unsigned long longconst LL b(211),prime(19260817);LL h[10015];char s[10015];int n,ans=1;I LL hso(char x[]) { int lx=strlen(x); LL t=0; for(int i=0;i&lt;lx;i++) t=(t*b+(LL)x[i])+prime; Heriko t;}S main() { fr(n); for(int i=1;i&lt;=n;i++) { scanf(&quot;%s&quot;,s); h[i]=hso(s); } sort(h+1,h+1+n); for(int i=1;i&lt;n;i++) if(h[i]!=h[i+1]) ans++; fw(ans,1); Heriko Deltana;} 「双哈希」 UPD 2022.1.23 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374CI MXX(1501),NXX(10005),MOD1(19260817),MOD2(998244353);int n;char s[MXX];namespace Hash { #define ULL unsigned long long struct Node { ULL h1,h2; I bool operator &lt; (const Node &amp;co) const { Heriko (h1==co.h1)?(h2&lt;co.h2):(h1&lt;co.h1); } I bool operator != (const Node &amp;co) const { Heriko !((h1==co.h1)&amp;(h2==co.h2)); } } a[NXX]; I void GetHash1(int pos,char s[]) { int len(strlen(s)); ULL tmp(0); for(int i(0);i&lt;len;++i) tmp=(tmp*255+s[i])%MOD1; a[pos].h1=tmp; } I void GetHash2(int pos,char s[]) { int len(strlen(s)); ULL tmp(0); for(int i(0);i&lt;len;++i) tmp=(tmp*255+s[i])%MOD2; a[pos].h2=tmp; } I void GetHash(int pos,char s[]) { GetHash1(pos,s); GetHash2(pos,s); } I void Solve() { sort(a+1,a+1+n); int cnt(0); for(int i(1);i&lt;=n;++i) if(a[i]!=a[i-1] or i==1) a[++cnt]=a[i]; fw(cnt,1); exit(0); }}S main() { fr(n); for(int i(1);i&lt;=n;++i) { scanf(&quot;%s&quot;,s+1); Hash::GetHash(i,s+1); } Hash::Solve(); Heriko Deltana;} 「单端最短路」「Dijkstra」 UPD 2022.1.23 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374CI MXX(5e5+1),NXX(1e5+1);struct node { int nex,to,val;}r[MXX];int cnt,head[NXX];I void Add(int x,int y,int z) { r[++cnt]=(node){head[x],y,z}; head[x]=cnt;}struct co { int dis,id; I bool operator &lt; (const co &amp;x) const { Heriko x.dis&lt;dis; }};priority_queue&lt;co&gt; q;int dis[NXX],n,m,s;bool vis[MXX];I void Dijkstra() { dis[s]=0; q.push((co){0,s}); while(q.size()) { int x(q.top().id); q.pop(); if(vis[x]) continue; vis[x]=1; for(int i(head[x]);i;i=r[i].nex) { int y(r[i].to); if(dis[y]&gt;dis[x]+r[i].val) { dis[y]=dis[x]+r[i].val; if(!vis[y]) q.push((co){dis[y],y}); } } }}S main(){ fr(n),fr(m),fr(s); mst(dis,0x7f); dis[0]=0; for(int i(1);i&lt;=m;++i) { int x,y,z; fr(x),fr(y),fr(z); Add(x,y,z); } Dijkstra(); for(int i(1);i&lt;=n;++i) fw(dis[i],0); Heriko Deltana;} 「树状数组」「单点修改区间询问」 UPD 2022.1.23 1234567891011121314151617181920212223242526272829303132333435363738394041CI MXX(5e5+1);#define lowbit(x) (x&amp;(-x))LL n,t[MXX],a[MXX],m;I void Modify(int x,int v) { while(x&lt;=n) t[x]+=v,x+=lowbit(x);}I LL Query(int x) { int res(0); while(x) res+=t[x],x-=lowbit(x); Heriko res;}S main() { fr(n),fr(m); for(int i(1);i&lt;=n;++i) fr(a[i]); for(int i(1);i&lt;=n;++i) Modify(i,a[i]); while(m--) { int opt,l,r; fr(opt),fr(l),fr(r); if(opt==1) Modify(l,r); else fw(Query(r)-Query(l-1),1); } Heriko Deltana;} 「区间修改单点询问」 UPD 2022.1.23 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#define lowbit(x) ((x)&amp;(-x))CI MXX(5e5+1);int n,m,t[MXX],a[MXX];I void Add(int x,int val) { while(x&lt;=n) t[x]+=val,x+=lowbit(x);}I int Query(int x) { int res(0); while(x) res+=t[x],x-=lowbit(x); Heriko res;} S main() { fr(n),fr(m); for(int i(1);i&lt;=n;++i) fr(a[i]); for(int i(1);i&lt;=n;++i) Add(i,a[i]-a[i-1]); while(m--) { int opt,x,y,z; fr(opt); if(opt==1) { fr(x),fr(y),fr(z); Add(x,z); Add(y+1,-z); } else { fr(x); fw(Query(x),1); } } Heriko Deltana;} 「乘法逆元」 UPD 2022.1.23 12345678910111213141516CI MXX(3e6+1);LL inv[MXX],n,m;S main() { fr(n),fr(m); inv[1]=1; for(int i(2);i&lt;=n;++i) inv[i]=m-(m/i)*inv[m%i]%m; for(int i(1);i&lt;=n;++i) fw(inv[i],1); Heriko Deltana;} 「高精度」 UPD 2022.1.23 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176CI MXX(105);struct Pic { int num[MXX],sz; Pic() { mst(num,0); sz=1; } I void Clear() { mst(num,0); sz=1; } /*---- int * Pic ----*/ I Pic operator * (const int &amp;co) const { Pic res; res.sz=sz; for(int i(1);i&lt;=sz;++i) res.num[i]=num[i]*co; for(int i(1);i&lt;=sz;++i) res.num[i+1]+=(res.num[i]/10),res.num[i]%=10; while(res.num[res.sz+1]) { ++res.sz; res.num[res.sz+1]+=(res.num[res.sz]/10); res.num[res.sz]%=10; } Heriko res; } /*---- Pic * Pic ----*/ I Pic operator * (const Pic &amp;co) const { Pic res; res.sz=co.sz+sz; for(int i(1);i&lt;=sz;++i) for(int j(1);j&lt;=co.sz;++j) { res.num[i+j-1]+=(num[i]*co.num[j]); res.num[i+j]+=(res.num[i+j-1]/10);res.num[i+j-1]%=10; } while(!res.num[res.sz] and res.sz&gt;1) --res.sz; Heriko res; } /*---- Pic + Pic ----*/ I Pic operator + (const Pic &amp;co) const { Pic res; res.sz=sz+2; for(int i(1);i&lt;=sz;++i) { res.num[i]+=num[i]+co.num[i]; if(res.num[i]&gt;10) ++res.num[i+1],res.num[i]%=10; } while(!res.num[res.sz] and res.sz&gt;1) --res.sz; Heriko res; } /*---- Pic - Pic ----*/ /*Need to ensure *this &gt; co*/ I Pic operator - (const Pic &amp;co) const { Pic res; res.sz=sz; for(int i(1);i&lt;=sz;++i) { res.num[i]+=num[i]-co.num[i]; if(res.num[i]&lt;0) --res.num[i+1],res.num[i]+=10; } while(!res.num[res.sz] and res.sz&gt;1) --res.sz; Heriko res; } /*---- Pic&gt;&gt;1 ----*/ I void RightShift() { for(int i(sz);i;--i) { if(num[i]&amp;1) num[i-1]+=10; num[i]&gt;&gt;=1; } while(!num[sz] and sz&gt;1) --sz; } /*---- Pic &lt; Pic ----*/ I bool operator &lt; (const Pic &amp;co) const { if(sz!=co.sz) Heriko sz&lt;co.sz; for(int i(sz);i;--i) if(num[i]!=co.num[i]) Heriko num[i]&lt;co.num[i]; Heriko Deltana; } /*---- Pic &gt; Pic ----*/ I bool operator &gt; (const Pic &amp;co) const { if(sz!=co.sz) Heriko sz&gt;co.sz; for(int i(sz);i;--i) if(num[i]!=co.num[i]) Heriko num[i]&gt;co.num[i]; Heriko Deltana; } /*---- Pic &lt;= Pic ----*/ I bool operator &lt;= (const Pic &amp;co) const { Heriko !((*this)&gt;co); } /*---- Pic &gt;= Pic ----*/ I bool operator &gt;= (const Pic &amp;co) const { Heriko !((*this)&lt;co); } /*---- Pic == Pic ----*/ I bool operator == (const Pic &amp;co) const { Heriko (!((*this)&gt;co))&amp;(!((*this)&lt;co)); } /*---- Pic Input (char[] -&gt; Pic) ----*/ I void Into(char s[]) { sz=strlen(s+1); for(int i(1);i&lt;=sz;++i) num[i]=s[sz-i+1]-'0'; } /*---- Pic == 0 ? ----*/ I bool Zero() { Heriko (sz==1)&amp;(num[1]==0); } /*---- Pic Output ----*/ I void fw() { for(int i(sz);i;--i) putchar(num[i]+'0'); putchar(' '); }}n,m; 「线段树」 UPD 2022.1.23 这里只放了个区间加和区间改，其它东西改一改就有了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y) { Heriko x&gt;y?x:y;}const LL MXX(1e6+1),INF(1e12);int n,q;struct Node { int l,r;LL mx,tg1,tg2;}t[MXX&lt;&lt;2];I void Pushup(int x) { t[x].mx=Hmax(t[lc(x)].mx,t[rc(x)].mx);}I void Pushdown(int x) { if(t[x].tg2!=INF) { t[lc(x)].tg1=0; t[lc(x)].tg2=t[x].tg2; t[lc(x)].mx=t[x].tg2; t[rc(x)].tg1=0; t[rc(x)].tg2=t[x].tg2; t[rc(x)].mx=t[x].tg2; t[x].tg2=INF; } if(t[x].tg1) { t[lc(x)].tg1+=t[x].tg1; t[lc(x)].mx+=t[x].tg1; t[rc(x)].tg1+=t[x].tg1; t[rc(x)].mx+=t[x].tg1; t[x].tg1=0; }}void Build(int x,int l,int r) { t[x].l=l,t[x].r=r; t[x].mx=t[x].tg1=0; t[x].tg2=INF; if(l==r) { fr(t[x].mx); Heriko; } int mid((l+r)&gt;&gt;1); Build(lc(x),l,mid); Build(rc(x),mid+1,r); Pushup(x);}void ModifyAdd(int x,int lx,int rx,LL v) { if(lx&lt;=t[x].l and t[x].r&lt;=rx) { t[x].tg1+=v;t[x].mx+=v; Heriko; } Pushdown(x); int mid((t[x].l+t[x].r)&gt;&gt;1); if(lx&lt;=mid) ModifyAdd(lc(x),lx,rx,v); if(rx&gt;mid) ModifyAdd(rc(x),lx,rx,v); Pushup(x);}void ModifyChange(int x,int lx,int rx,LL v) { if(lx&lt;=t[x].l and t[x].r&lt;=rx) { t[x].tg1=0;t[x].tg2=v;t[x].mx=v; Heriko; } Pushdown(x); int mid((t[x].l+t[x].r)&gt;&gt;1); if(lx&lt;=mid) ModifyChange(lc(x),lx,rx,v); if(rx&gt;mid) ModifyChange(rc(x),lx,rx,v); Pushup(x);}LL Query(int x,int lx,int rx) { if(lx&lt;=t[x].l and t[x].r&lt;=rx) Heriko t[x].mx; LL res(-INF); int mid((t[x].l+t[x].r)&gt;&gt;1); Pushdown(x); if(lx&lt;=mid) res=Hmax(Query(lc(x),lx,rx),res); if(rx&gt;mid) res=Hmax(Query(rc(x),lx,rx),res); Heriko res;}S main() { fr(n),fr(q); Build(1,1,n); while(q--) { int opt,l,r;LL x; fr(opt),fr(l),fr(r); if(opt==1) fr(x),ModifyChange(1,l,r,x); else if(opt==2) fr(x),ModifyAdd(1,l,r,x); else fw(Query(1,l,r),1); } Heriko Deltana;} 「主席树」 UPD 2022.2.20 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667CI MXX(1e5+1);int n,q,lc[MXX&lt;&lt;5],rc[MXX&lt;&lt;5],sum[MXX&lt;&lt;5],t[MXX],a[MXX],b[MXX],id;int Build(int l,int r) { int x(++id),mid((l+r)&gt;&gt;1); if(l&lt;r) { lc[x]=Build(l,mid); rc[x]=Build(mid+1,r); } Heriko x;}int Insert(int pre,int l,int r,int v) { int x(++id),mid((l+r)&gt;&gt;1); lc[x]=lc[pre],rc[x]=rc[pre],sum[x]=sum[pre]+1; if(l&lt;r) { if(v&lt;=mid) lc[x]=Insert(lc[pre],l,mid,v); else rc[x]=Insert(rc[pre],mid+1,r,v); } Heriko x;}int Query(int x,int y,int l,int r,int v) { if(l&gt;=r) Heriko l; int nw(sum[lc[y]]-sum[lc[x]]),mid((l+r)&gt;&gt;1); if(nw&gt;=v) Heriko Query(lc[x],lc[y],l,mid,v); else Heriko Query(rc[x],rc[y],mid+1,r,v-nw);}S main() { fr(n),fr(q); for(int i(1);i&lt;=n;++i) fr(a[i]),b[i]=a[i]; sort(b+1,b+1+n); int nl(unique(b+1,b+1+n)-b-1); for(int i(1);i&lt;=n;++i) a[i]=lower_bound(b+1,b+1+nl,a[i])-b; t[0]=Build(1,nl); for(int i(1);i&lt;=n;++i) t[i]=Insert(t[i-1],1,nl,a[i]); while(q--) { int l,r,k; fr(l),fr(r),fr(k); fw(b[Query(t[l-1],t[r],1,nl,r-l+1-k+1)],1);//求区间第 K 大 fw(b[Query(t[l-1],t[r],1,nl,k)],1);//求区间第 K 小 } Heriko Deltana;} 「ST表」 UPD 2022.1.23 123456789101112131415161718192021222324252627282930313233343536template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y) { Heriko x&gt;y?x:y;}CI MXX(1e5+1);LL a[MXX][22];int n,m;I LL Query(int l,int r) { int tmp(std::log2(r-l+1)); Heriko Hmax(a[l][tmp],a[r-(1&lt;&lt;tmp)+1][tmp]);}S main() { fr(n),fr(m); for(int i(1);i&lt;=n;++i) fr(a[i][0]); for(int lg(1);lg&lt;=21;++lg) for(int i(1);i+(1&lt;&lt;lg)-1&lt;=n;++i) a[i][lg]=Hmax(a[i][lg-1],a[i+(1&lt;&lt;(lg-1))][lg-1]); for(int i(1);i&lt;=m;++i) { int l,r; fr(l),fr(r); fw(Query(l,r),1); } Heriko Deltana;} 「三分法」 UPD 2022.1.23 123456789101112131415161718192021222324252627282930313233343536373839404142template&lt;typename J&gt;I J Habs(const J &amp;x) { Heriko x&lt;0?-x:x;}const double EPS(1e-7);CI MXX(15);int n;double a[MXX],l,r;double Solve(double x) { double res(0); for(int i(n);i&gt;=0;--i) res*=x,res+=a[i]; Heriko res;}S main() { fr(n); scanf(&quot;%lf%lf&quot;,&amp;l,&amp;r); for(int i(n);i&gt;=0;--i) scanf(&quot;%lf&quot;,&amp;a[i]); while(Habs(r-l)&gt;=EPS) { double mid((l+r)/2); if(Solve(mid+EPS)&gt;Solve(mid-EPS)) l=mid; else r=mid; } printf(&quot;%.5lf\\n&quot;,r); Heriko Deltana;} 「KMP」 UPD 2022.1.23 123456789101112131415161718192021222324252627282930313233343536373839CI MXX(1e6+1);int lena,lenb,nex[MXX],kmp[MXX];char a[MXX],b[MXX];S main() { scanf(&quot;%s%s&quot;,a+1,b+1); lena=strlen(a+1),lenb=strlen(b+1); for(int i(2),j(0);i&lt;=lenb;++i) { while(j&gt;0 and b[i]!=b[j+1]) j=nex[j]; if(b[i]==b[j+1]) ++j; nex[i]=j; } for(int i(1),j(0);i&lt;=lena;++i) { while(j&gt;0 and a[i]!=b[j+1]) j=nex[j]; if(a[i]==b[j+1]) ++j; kmp[i]=j; } for(int i(1);i&lt;=lena;++i) if(kmp[i]==lenb) fw(i-lenb+1,1); for(int i(1);i&lt;=lenb;++i) fw(nex[i],0); Heriko Deltana;} 「LCA」「倍增」 UPD 2022.1.23 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273CI MXX(5e5+1);int n,m,rt;struct Node { int nex,to;}r[MXX&lt;&lt;1];int cnt,head[MXX];I void Add(int x,int y) { r[++cnt]=(Node){head[x],y};head[x]=cnt; r[++cnt]=(Node){head[y],x};head[y]=cnt;}int dep[MXX],f[MXX][35],lg[MXX];I void PreLog() { for(int i(1);i&lt;=n;++i) lg[i]=lg[i-1]+((1&lt;&lt;lg[i-1])==i);}void DFS(int x,int fa) { f[x][0]=fa; dep[x]=dep[fa]+1; for(int i(1);i&lt;=lg[dep[x]];++i) f[x][i]=f[f[x][i-1]][i-1]; for(int i(head[x]);i;i=r[i].nex) if(r[i].to!=fa) DFS(r[i].to,x);}I int LCA(int x,int y) { if(dep[x]&lt;dep[y]) swap(x,y); while(dep[x]&gt;dep[y]) x=f[x][lg[dep[x]-dep[y]]-1]; if(x==y) Heriko x; for(int i(lg[dep[x]]-1);i&gt;=0;--i) if(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i]; Heriko f[x][0];}S main() { fr(n),fr(m),fr(rt); for(int i(1);i&lt;n;++i) { int x,y; fr(x),fr(y); Add(x,y); } PreLog(); DFS(rt,0); for(int i(1);i&lt;=m;++i) { int x,y; fr(x),fr(y); fw(LCA(x,y),1); } Heriko Deltana;} 「树剖」 UPD 2022.1.23 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182CI MXX(500001);struct Node { int nex,to;}r[MXX&lt;&lt;1];int rcnt,head[MXX];I void Add(int x,int y) { r[++rcnt]=(Node){head[x],y},head[x]=rcnt; r[++rcnt]=(Node){head[y],x},head[y]=rcnt;}int sz[MXX],son[MXX],top[MXX],fa[MXX],dep[MXX];void DFS1(int x,int fath) { sz[x]=1,fa[x]=fath,dep[x]=dep[fath]+1; for(int i(head[x]);i;i=r[i].nex) { int y(r[i].to); if(y==fath) continue; DFS1(y,x); sz[x]+=sz[y]; if(!son[x] or sz[son[x]]&lt;sz[y]) son[x]=y; }}void DFS2(int x,int nw) { top[x]=nw; if(son[x]) DFS2(son[x],nw); for(int i(head[x]);i;i=r[i].nex) { int y(r[i].to); if(y==fa[x] or y==son[x]) continue; DFS2(y,y); }}int n,m,s;S main() { // Files(); fr(n),fr(m),fr(s); for(int i(1);i&lt;n;++i) { int x,y; fr(x),fr(y); Add(x,y); } DFS1(s,0); DFS2(s,s); for(int i(1);i&lt;=m;++i) { int x,y; fr(x),fr(y); while(top[x]!=top[y]) { if(dep[top[x]]&gt;=dep[top[y]]) x=fa[top[x]]; else y=fa[top[y]]; } fw((dep[x]&lt;dep[y])?x:y,1); } Heriko Deltana;} 「矩阵加速」 UPD 2022.1.23 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162CI MOD(1e9+7);int n,T;struct Matrix { LL a[5][5]; Matrix() { mst(a,0); } I void BuildB() { mst(a,0); a[1][1]=a[1][3]=a[2][1]=a[3][2]=1; } I void BuildA() { mst(a,0); a[1][1]=a[2][1]=a[3][1]=1; } I Matrix operator * (const Matrix &amp;co) const { Matrix res; for(int k(1);k&lt;=3;++k) for(int i(1);i&lt;=3;++i) for(int j(1);j&lt;=3;++j) (res.a[i][j]+=(a[i][k]*co.a[k][j])%MOD)%=MOD; Heriko res; }}A,B;I void MatrixFstPow(int x) { while(x) { if(x&amp;1) A=A*B; B=B*B; x&gt;&gt;=1; }}S main() { fr(T); while(T--) { fr(n); if(n&lt;=3) puts(&quot;1&quot;); else { A.BuildA(),B.BuildB(); MatrixFstPow(n-1); fw((A.a[1][1]+MOD)%MOD,1); } } Heriko Deltana;} 「SPFA判负环」 UPD 2022.1.23 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980CI MXX(3001),INF(0x3f3f3f3f);int n,m,T;struct Node { int nex,to,val;}r[MXX&lt;&lt;1];int cnt,head[MXX];I void Add(int x,int y,int z) { r[++cnt]=(Node){head[x],y,z}; head[x]=cnt;}int co[MXX],dis[MXX];bitset&lt;MXX&gt; vis;I bool SPFA(int s) { queue&lt;int&gt; q; q.push(s); dis[s]=0,vis[s]=1,++co[s]; while(q.size()) { int x(q.front()); q.pop(); vis[x]=0; for(int i(head[x]);i;i=r[i].nex) { int y(r[i].to); if(dis[y]&gt;dis[x]+r[i].val) { dis[y]=dis[x]+r[i].val; if(!vis[y]) { vis[y]=1; q.push(y); ++co[y]; if(co[y]&gt;n) Heriko Deltana; } } } } Heriko Romanno;}S main() { Files(); fr(T); while(T--) { fr(n),fr(m); cnt=0,vis=0; mst(dis,0x3f),mst(co,0),mst(head,0); for(int i(1);i&lt;=m;++i) { int x,y,z; fr(x),fr(y),fr(z); if(z&gt;=0) Add(x,y,z),Add(y,x,z); else Add(x,y,z); } if(!SPFA(1)) puts(&quot;YES&quot;); else puts(&quot;NO&quot;); } Heriko Deltana;} 「矩阵快速幂」 UPD 2022.1.23 12345678910111213141516171819202122232425262728293031323334353637383940414243444546CI NXX(101),MXX(21),MOD(1e9+7);struct Matrix { int n,m,a[MXX][MXX]; Matrix() { n=m=0,mst(a,0); } I void Build() { for(int i(1);i&lt;=m;++i) a[i][i]=1; } I Matrix operator * (const Matrix &amp;co) const { Matrix res; res.n=n,res.m=co.m; for(int i(1);i&lt;=n;++i) for(int k(1);k&lt;=m;++k) for(int j(1);j&lt;=co.m;++j) (res.a[i][j]+=(1ll*a[i][k]*co.a[k][j])%MOD)%=MOD; Heriko res; }}ans;int n,m;I Matrix MFP(Matrix x,int y) { Matrix res; res.n=res.m=m; res.Build(); while(y) { if(y&amp;1) res=res*x; x=x*x; y&gt;&gt;=1; } Heriko res;} 「AC自动机」 UPD 2022.1.23 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273CI MXX(1e6+5);struct ACAM { int c[MXX][26],val[MXX],fail[MXX],cnt; queue&lt;int&gt; q; I void Insert(char s[]) { int len(strlen(s)),nw(0); for(int i(0);i&lt;len;++i) { int v(s[i]-'a'); if(!c[nw][v]) c[nw][v]=++cnt; nw=c[nw][v]; } ++val[nw]; } I void Build() { for(int i(0);i&lt;26;++i) if(c[0][i]) fail[c[0][i]]=0,q.push(c[0][i]); while(q.size()) { int x(q.front()); q.pop(); for(int i(0);i&lt;26;++i) if(c[x][i]) fail[c[x][i]]=c[fail[x]][i],q.push(c[x][i]); else c[x][i]=c[fail[x]][i]; } } I int Query(char s[]) { int len(strlen(s)),nw(0),res(0); for(int i(0);i&lt;len;++i) { nw=c[nw][s[i]-'a']; for(int j(nw);j and ~val[j];j=fail[j]) res+=val[j],val[j]=-1; } Heriko res; }}AC;int n;char s[MXX];S main() { Files(); fr(n); for(int i(1);i&lt;=n;++i) scanf(&quot;%s&quot;,s),AC.Insert(s); AC.Build(); scanf(&quot;%s&quot;,s); fw(AC.Query(s),1); Heriko Deltana;} 「差分约束」 UPD 2022.1.23 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475CI MXX(5e3+5),INF(0x3f3f3f3f);int n,m,T;struct Node { int nex,to,val;}r[MXX&lt;&lt;1];int cnt,head[MXX];I void Add(int x,int y,int z) { r[++cnt]=(Node){head[x],y,z}; head[x]=cnt;}int co[MXX],dis[MXX];bitset&lt;MXX&gt; vis;I bool SPFA(int s) { queue&lt;int&gt; q; q.push(s); mst(dis,0x3f); dis[s]=0,vis[s]=1,++co[s]; while(q.size()) { int x(q.front()); q.pop(); vis[x]=0; for(int i(head[x]);i;i=r[i].nex) { int y(r[i].to); if(dis[y]&gt;dis[x]+r[i].val) { dis[y]=dis[x]+r[i].val; if(!vis[y]) { vis[y]=1; q.push(y); ++co[y]; if(co[y]&gt;=n+1) Heriko Deltana; } } } } Heriko Romanno;}S main() { Files(); fr(n),fr(m); for(int i(1);i&lt;=n;++i) Add(0,i,0); for(int i(1);i&lt;=m;++i) { int x,y,z; fr(x),fr(y),fr(z); Add(y,x,z); } if(!SPFA(0)) puts(&quot;NO&quot;); else for(int i(1);i&lt;=n;++i) fw(dis[i],0); Heriko Deltana;} 「欧拉路径」 UPD 2022.1.23 调了 $\\tt 114514$ 年，结果是答案栈开小了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y) { Heriko x&gt;y?x:y;}CI MXX(1e5+5);int n,m,into[MXX],outo[MXX],lst[MXX],ans[MXX&lt;&lt;1],s,t,cnt;vector&lt; pair&lt;int,int&gt; &gt; r[MXX];bitset&lt;(MXX&lt;&lt;1)&gt; vis;void DFS(int x) { for(int i(lst[x]);i&lt;(int)r[x].size();i=Hmax(i+1,lst[x])) { int y(r[x][i].first),id(r[x][i].second); if(!vis[id]) { vis[id]=1; lst[x]=i+1; DFS(y); } } ans[++cnt]=x;}S main() { Files(); fr(n),fr(m); for(int i(1);i&lt;=m;++i) { int x,y; fr(x),fr(y); ++outo[x],++into[y]; r[x].push_back(mkp(y,i)); } int tot(0); for(int i(1);i&lt;=n;++i) if(into[i]!=outo[i]) { ++tot; if(into[i]==outo[i]-1) s=i; if(into[i]==outo[i]+1) t=i; } if(tot!=0 and tot!=2) { puts(&quot;No&quot;); Heriko Deltana; } if(!tot) s=t=1; if(!s or !t) { puts(&quot;No&quot;); Heriko Deltana; } for(int i(1);i&lt;=n;++i) sort(r[i].begin(),r[i].end()); DFS(s); for(int i(cnt);i;--i) fw(ans[i],0); Heriko Deltana;} 「康托展开」 UPD 2022.1.23 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#define lowbit(x) ((x)&amp;(-x))CI MXX(1e6+1),MOD(998244353);int n;LL t[MXX];I void Add(int x,LL v) { while(x&lt;=n) t[x]+=v,x+=lowbit(x);}I LL Query(int x) { LL res(0); while(x) res+=t[x],x-=lowbit(x); Heriko res;}LL pw[MXX],ans;S main() { Files(); fr(n); for(int i(1);i&lt;=n;++i) Add(i,1); pw[0]=1; for(int i(1);i&lt;=n;++i) pw[i]=(pw[i-1]*i)%MOD; for(int i(1);i&lt;=n;++i) { int x; fr(x); (ans+=((Query(x)-1)*pw[n-i])%MOD)%=MOD; Add(x,-1); } fw(ans+1,1); Heriko Deltana;} 「威佐夫博弈」 UPD 2022.1.23 结论：若两堆物品的初始值为 $(n,m)$，且 $m&lt;n$，则使 $z=n-m.$ 记 x=(LL)(((sqrt(5.0)+1.0)/2.0)*w); 若 $m=x$，则先手必败，否则先手必胜。 1234567891011121314151617181920LL n,m,w,x;S main() { Files(); fr(n),fr(m); if(n&lt;m) swap(n,m); w=n-m; x=(LL)(((sqrt(5.0)+1.0)/2.0)*w); if(x==m) puts(&quot;0&quot;); else puts(&quot;1&quot;); Heriko Deltana;} 「莫队」 UPD 2022.1.23 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566CI MXX(5e4+1);int n,m,k,a[MXX],sqn;LL ans[MXX],co[MXX],cnt;struct Node { int l,r,id; I bool operator &lt; (const Node &amp;co) const { if(l/sqn!=co.l/sqn) Heriko l&lt;co.l; if((l/sqn)&amp;1) Heriko r&lt;co.r; Heriko r&gt;co.r; }}q[MXX];I void Add(int x) { }I void Del(int x) { }S main() { Files(); fr(n),fr(m),fr(k),sqn=sqrt(n); for(int i(1);i&lt;=n;++i) fr(a[i]); for(int i(1);i&lt;=m;++i) fr(q[i].l),fr(q[i].r),q[i].id=i; sort(q+1,q+1+m); int lx(1),rx(0); for(int i(1);i&lt;=m;++i) { while(lx&lt;q[i].l) Del(a[lx++]); while(lx&gt;q[i].l) Add(a[--lx]); while(rx&lt;q[i].r) Add(a[++rx]); while(rx&gt;q[i].r) Del(a[rx--]); ans[q[i].id]=cnt; } for(int i(1);i&lt;=m;++i) fw(ans[i],1); Heriko Deltana;} 「vector 存图遍历模板」 UPD 2022.1.23 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354CI MXX(1e6+1),NXX(1e5+1);bitset&lt;NXX&gt; vis;vector&lt;int&gt; r[NXX];int n,m;void DFS(int x) { fw(x,0); vis[x]=1; int sz(r[x].size()); for(int i(0);i&lt;sz;++i) if(!vis[r[x][i]]) DFS(r[x][i]);}I void BFS() { queue&lt;int&gt; q; q.push(1),vis[1]=1; while(q.size()) { int y(q.front()); q.pop(); fw(y,0); int sz(r[y].size()); for(int i(0);i&lt;sz;++i) if(!vis[r[y][i]]) q.push(r[y][i]),vis[r[y][i]]=1; }}S main() { Files(); fr(n),fr(m); for(int i(1);i&lt;=m;++i) { int x,y; fr(x),fr(y); r[x].push_back(y); } for(int i(1);i&lt;=n;++i) std::sort(r[i].begin(),r[i].end()); DFS(1),puts(&quot;&quot;); vis=0; BFS(),puts(&quot;&quot;); Heriko Deltana;} 「Dinic」 UPD 2022.1.23 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899template &lt;typename J&gt;I J Hmin(const J &amp;x,const J &amp;y) { Heriko x&lt;y?x:y;}CI MXX(5001),NXX(201),INF(998244353);struct Node { int nex,to; LL val;}r[MXX&lt;&lt;1];int cnt(1),head[NXX],now[NXX],n,m,s,t;I void Add(int x,int y,LL z) { r[++cnt]=(Node){head[x],y,z},head[x]=cnt; r[++cnt]=(Node){head[y],x,0},head[y]=cnt;}LL dis[NXX],ans;bitset&lt;NXX&gt; vis;I bool BFS() { mst(dis,0); queue&lt;int&gt; q; q.push(s); dis[s]=1,now[s]=head[s]; while(q.size()) { int x(q.front()); q.pop(); for(int i(head[x]);i;i=r[i].nex) { if(r[i].val and !dis[r[i].to]) { int y(r[i].to); q.push(y); now[y]=head[y],dis[y]=dis[x]+1; if(y==t) Heriko Romanno; } } } Heriko Deltana;}LL Dinic(int x,LL flow) { if(x==t) Heriko flow; LL rst(flow),k; for(int i(now[x]);i and rst;i=r[i].nex) { int y(r[i].to); if(r[i].val and dis[y]==dis[x]+1) { k=Dinic(y,Hmin(rst,r[i].val)); if(!rst) Heriko flow; if(!k) dis[y]=0; r[i].val-=k,r[i^1].val+=k,rst-=k; } now[x]=i; } Heriko flow-rst;}S main() { // Files(); fr(n),fr(m),fr(s),fr(t); for(int i(1);i&lt;=m;++i) { int x,y; LL z; fr(x),fr(y),fr(z); Add(x,y,z); } LL flow(0); while(BFS()) while((flow=Dinic(s,INF))) ans+=flow; fw(ans,1); Heriko Deltana;} 「Tarjan求强连通分量」 UPD 2022.1.23 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889template &lt;typename J&gt;I J Hmin(const J &amp;x,const J &amp;y) { Heriko x&lt;y?x:y;}CI MXX(100001),NXX(10001);struct Node { int nex,to; }r[MXX];int rcnt,head[NXX];I void Add(int x,int y) { r[++rcnt]=(Node){head[x],y}; head[x]=rcnt;}int dfn[NXX],low[NXX],cnt,stak[NXX],top,tot,c[NXX];bitset&lt;NXX&gt; vis;vector&lt;int&gt; v[NXX];void Tarjan(int x) { dfn[x]=low[x]=++cnt; stak[++top]=x,vis[x]=1; for(int i(head[x]);i;i=r[i].nex) { int y(r[i].to); if(!dfn[y]) Tarjan(y),low[x]=Hmin(low[x],low[y]); else if(vis[y]) low[x]=Hmin(low[x],dfn[y]); } if(dfn[x]==low[x]) { ++tot; int tmp(0); while(tmp!=x) { tmp=stak[top--]; vis[tmp]=0; c[tmp]=tot; v[tot].push_back(tmp); } }}int n,m;S main() { // Files(); fr(n),fr(m); for(int i(1);i&lt;=m;++i) { int x,y; fr(x),fr(y); Add(x,y); } for(int i(1);i&lt;=n;++i) if(!dfn[i]) Tarjan(i); fw(tot,1); for(int i(1);i&lt;=n;++i) { int x(c[i]); if(vis[x]) continue; vis[x]=1; std::sort(v[x].begin(),v[x].end()); int sz(v[x].size()); for(int j(0);j&lt;sz;++j) fw(v[x][j],0); puts(&quot;&quot;); } Heriko Deltana;} 「珂朵莉树」 直接把我 CF896C 的代码拿过来了。 UPD 2022.1.23 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798I LL FstPow(LL x,LL y,LL p) { LL res(1); x%=p; while(y) { if(y&amp;1) (res*=x)%=p; (x*=x)%=p; y&gt;&gt;=1; } Heriko res;}//其实这个快速幂没啥用，只是下面的 Query 的时候有用到，和 ODT 本身关系不大。struct Node { LL l,r; mutable LL v; Node(LL l,LL r=0,LL v=0) : l(l),r(r),v(v) {} I bool operator &lt; (const Node &amp;co) const { Heriko l&lt;co.l; }};set&lt;Node&gt; s;I auto Split(LL pos) { auto it(s.lower_bound(Node(pos))); if(it!=s.end() and it-&gt;l==pos) Heriko it; --it; if(it-&gt;r&lt;pos) Heriko s.end(); LL l(it-&gt;l),r(it-&gt;r),v(it-&gt;v); s.erase(it); s.insert(Node(l,pos-1,v)); Heriko s.insert(Node(pos,r,v)).first;}I void Assign(LL l,LL r,LL x) { auto itr(Split(r+1)),itl(Split(l)); s.erase(itl,itr); s.insert(Node(l,r,x));}I void Add(LL l,LL r,LL x) { auto itr(Split(r+1)),itl(Split(l)); for(auto it(itl);it!=itr;++it) it-&gt;v+=x;}struct Rank { LL val,cnt; Rank(LL val,LL cnt) : val(val),cnt(cnt) {} I bool operator &lt; (const Rank &amp;co) const { Heriko val&lt;co.val; }};I LL QueryRank(LL l,LL r,LL x) { auto itr(Split(r+1)),itl(Split(l)); vector&lt;Rank&gt; v; for(auto it(itl);it!=itr;++it) v.push_back(Rank(it-&gt;v,it-&gt;r-it-&gt;l+1)); sort(v.begin(),v.end()); LL i(0); for(;i&lt;(LL)v.size();++i) if(v[i].cnt&lt;x) x-=v[i].cnt; else Heriko v[i].val; Heriko v[i].val;}I LL QueryVal(LL l,LL r,LL x,LL y) { auto itr(Split(r+1)),itl(Split(l)); LL res(0); for(auto it(itl);it!=itr;++it) res=(res+FstPow(it-&gt;v,x,y)*(it-&gt;r-it-&gt;l+1)%y)%y; Heriko res;} 「平面最近点对」 $O(n \\log^2 n)$ 的做法。 UPD 2022.1.23 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960template&lt;typename J&gt;I J Hmin(const J &amp;x,const J &amp;y) { Heriko x&lt;y?x:y;}CI MXX(2e5+1);const double INF(1e12);I bool CMP(const pair&lt;double,double&gt; &amp;a,const pair&lt;double,double&gt; &amp;b) { Heriko a.second&lt;b.second;}I double Dist(const pair&lt;double,double&gt; &amp;a,const pair&lt;double,double&gt; &amp;b) { Heriko sqrt((long double)(a.first-b.first)*(a.first-b.first)+(long double)(a.second-b.second)*(a.second-b.second));}int n;pair&lt;double,double&gt; a[MXX],tmp[MXX];double Merge(int l,int r) { if(l==r) Heriko INF; int mid((l+r)&gt;&gt;1),top(0); double dis(INF); dis=Hmin(Merge(l,mid),Merge(mid+1,r)); for(int i(l);i&lt;=r;++i) if(fabs(a[mid].first-a[i].first)&lt;dis) tmp[++top]=a[i]; std::sort(tmp+1,tmp+1+top,CMP); for(int i(1);i&lt;=top;++i) for(int j(i+1);j&lt;=top;++j) { if(tmp[j].second-tmp[i].second&gt;=dis) break; dis=Hmin(dis,Dist(tmp[i],tmp[j])); } Heriko dis;}S main() { Files(); fr(n); for(int i(1);i&lt;=n;++i) scanf(&quot;%lf%lf&quot;,&amp;a[i].first,&amp;a[i].second); std::sort(a+1,a+1+n); double ans(Merge(1,n)); printf(&quot;%.4lf&quot;,ans); Heriko Deltana;}","link":"/2021/11/19/Models/"},{"title":"Note18 : 杂题二","text":"第二堆持续更新的杂题 第一堆是我从 2021.4.12 开始的做题记录的前 200 道，这里的第二堆则是 201 以后的（ 这里的题目是按照我做的时间顺序排放的，是从博客园搬来的，之所以叫做 Note18 也是因为之前在博客园的编号是 18. 201 | P4643 阿狸和桃子的游戏 [国家集训队]洛谷 | P4643 阿狸和桃子的游戏 [国家集训队] [省选+/NOI-] 时隔 114514 年的更新。 考虑将边权转化到点上，无论是阿狸还是桃子同时取到两点，他们都可以获得 $u+v+c$ 的权值；若是分取两端点，则最终答案可抵消为 $u-v$ 或者 $v−u.$ 然后排序即可，因为没保证输入的权值是偶数，所以先×2最后再除掉。 202 | P2863 The Cow Prom S洛谷 | P2863 The Cow Prom S [普及+/提高] 又是时隔 114514 年的更新。 一道比较板子的 Tarjan 求 SCC 个数，直接写一个 Tarjan 即可。 203 | CF915E Physical Education Lessons洛谷 RemoteJudge [提高+/省选-] CodeForce 原题 观察完这道就发现是一道 DS，而且还挺水的好像（ 看到只有区间赋值的操作，所以就考虑用珂朵莉树来解决。很简单的乆切掉了（ 最一开始单独统计答案，但是这样显然是会被卡掉的，所以后来改成在 $Assign$ 的时候乆把答案修改掉。 复杂度是 $O(n \\log n)$ 的样子o(=•ェ•=)m 204 | P6792 区间和 [SNOI2020]洛谷 | P6792 [SNOI2020] 区间和 [NOI/NOI+/CTSC] 年轻人的第一道黑题。 虽然是黑题但是数据水了，所以最终的难度并没有那么高，一个暴力修改的线段树 + 前缀和后缀和来维护最大字段和的 trick 就解决掉了（ 因为我也是第一次写这个 trick 所以在这里简单记录一下。 对于每个结点我们要维护：区间和，区间最大前缀和，区间最大后缀和，区间最大子段和，那么在转移的时候，需要写出以下的 Pushup： 123456789I void Pushup(int x){ t[x].sm=t[lc(x)].sm+t[rc(x)].sm; t[x].mx=Hmax(t[lc(x)].mx,t[rc(x)].mx); t[x].mi=Hmin(t[lc(x)].mi,t[rc(x)].mi); t[x].psm=Hmax(t[lc(x)].psm,t[lc(x)].sm+t[rc(x)].psm); t[x].usm=Hmax(t[rc(x)].usm,t[lc(x)].usm+t[rc(x)].sm); t[x].sbmx=Hmax(Hmax(t[lc(x)].sbmx,t[rc(x)].sbmx),t[lc(x)].usm+t[rc(x)].psm);} 然后就是正常的操作，中间有一次 WA 是因为 Query 忘了写 Pushdown. 注明：我过了这道题之后，这道题就被加了 Hack 数据，现在我这个做法已经过不了了，正解大约是势能线段树啥的 205 | P4301 新Nim游戏 [CQOI2013]洛谷 | P4301 新Nim游戏 [CQOI2013] [省选+/NOI-] 显然我做这道题的原因不是因为初中班号是 4301. 如果不让对方赢，就不能让对方在自己选完后剩下的数中选出 xor 和为 0 的，也就是不能让线性基被插满或者存在不能插入的值（因为线性基内的数不能异或出来 0），所以我们在将数插入线性基的时候，不能插入的直接加到答案里。 206 | 鉄道旅行 [JOI 2015]ATCoder | A - 鉄道旅行 (Railroad Trip) 说起来，这题是在 rui_er 的珂朵莉树题单里来着（ 然而当我看这道题的想法从“看起来像是树”变成“其实是个序列”的时候，我就不知道怎么往珂朵莉树上想了，因为……差分 + 贪心还挺显然的（ 考虑到路线固定，所以我们只需要知道一条道路要经过几次即可，然后对于每条边，要不然全买原价，要不然买一张 IC 卡再用 IC 卡，所以我们每次比较哪个更优就可以了，设当前边被用了 co 次，每次累加答案的时候整一个 ans+=max(a*co,b*co+c) 就行了。 之所以没放洛谷链接是因为这个题面确实没法看，也没有数据范围，还不如我直接看原题面。 207 | P3974 组合数学 [TJOI2015]洛谷 | P3974 组合数学 [TJOI2015] [省选+/NOI-] 好喵一题。 其实做这道题只是在看自己之前的博客的时候想起来之前有个 Dilworth 定理，然后就随着一个博客（浅谈Dilworth定理 - cmwqf）学习的时候，找到了这道题。 众所周知题目名字里有啥，这道题就不用啥做，所以这道题用不到组合数学（ 我们把这道题中的每个点 $(i,j)$ 拆成 $val(i,j)$ 个点，然后把能够到达的点之间连边，最后变成了一个 DAG，题目所求就是求这个图的最小链的划分，根据 Dilworth 定理，这个 DAG 的最小链划分就等于它的最长反链的长度。 按照我们建图的操作来说的话，这个反链就是说的最长的不能到达的链，也就是说要求每个点的右上和左下矩阵中点权值的最大值，于是直接 DP 即可。 123456for(int i(1);i&lt;=n;++i) for(int j(m);j;--j) { f[i][j]=f[i-1][j+1]+a[i][j]; f[i][j]=Hmax(Hmax(f[i][j],f[i-1][j]),f[i][j+1]); } 答案即为 f[n][1]. 208 | CF1603B Flog Traveler洛谷 RemoteJudge Frog Traveler 虽然但是，这题有一点恶心人，不能一遍写对就很烦。 看完题之后，有三个想法：BFS（最短路），DP，瞎搞。 首先排除瞎搞（ 然后考虑 DP，然后考虑了半天没考虑出来，感觉 DP 不太能做的样子。于是就考虑建图跑最短路，但是想了想建出来的图可能有亿点大，于是需要寻求更好的建图方法（ 然后就去看了线段树建图（ 209 | 引越しできるかな？题解以及翻译 210 | P4302 字符串折叠 [SCOI2003]洛谷 | P4302 字符串折叠 [SCOI2003] [提高+/省选-] 考虑设计一个二维状态 $f(l,r)$ 表示 $[l,r]$ 能缩成的最短的长度，显然当 $l=r$ 的时候 $f(l,r)=1$，然后再考虑其他的状态。 对于一个区间 $[l,r]$，要不然是由一个字符串反复出现组成的，要不然就能拆成能压缩的几个部分，于是我们只需要考虑如何把这个区间中的字串找出来即可，因为这道题的 $n \\le 100$，所以可以直接枚举区间长度的约数，这样的话，整体的复杂度就是 $O(n^3 \\log n).$ 210B | UVA1630 Folding洛谷 RemoteJudge [省选+/NOI-]原题 虽然这两道题就差一个输出不一样但是评级不一样（ 既然要输出方案，了解到一个神秘操作叫做 stringstream，可以直接把各种奇怪的类型转化为 string，比如说这个题： 1234int val(len/(i-l+1));stringstream tmp;string tms;tmp&lt;&lt;val,tmp&gt;&gt;tms; 有一点方便的感。 （把上面的全划掉） 然而，我重写的 stringstream 错了，而且贼慢，所以就把 P4302 的代码复制过来，改成了记录倍数的转折点递归输出（ 211 | P4342 Polygon [IOI1998]洛谷 | P4342 Polygon [IOI1998] [提高+/省选-] 只能说是洛谷我谢谢你，这个输入数据太不纯净了点…… 首先考虑断环为链，然后就变成了区间 DP，设 $f(l,r)$ 为 $[l,r]$ 上最大的结果。 那么在没有负数的情况下，转移就是这样的： $$\\begin{aligned}f(l,r) = \\max{f(l,r),f(l,k) + f(k+1,r)} \\f(l,r) = \\max{f(l,r),f(l,k) \\times f(k+1,r)}\\end{aligned}$$ 但是这道题有负数，所以可能会存在负负得正的优美情况，所以我们还需要维护一个最小值 $g(l,r)$，然后加法的转移不变，乘法的转移变为： $$\\begin{aligned}f(l,r) = \\max{f(l,r),f(l,k) \\times f(k+1,r),g(l,k) \\times g(k+1,r),f(l,k) \\times g(k+1,r),g(l,k) \\times f(k+1,r)} \\g(l,r) = \\min{g(l,r),f(l,k) \\times f(k+1,r),g(l,k) \\times g(k+1,r),f(l,k) \\times g(k+1,r),g(l,k) \\times f(k+1,r)}\\end{aligned}$$ 然后这题就结束了（ 212 | CF149D Coloring Brackets洛谷 RemoteJudge [普及+/提高] Coloring Brackets 先考虑最朴实的没有颜色的情况，我们用匹配的括号序列之间转移即可，即设状态为 $f(l,r)$ 即可，但是这道题需要我们保证染色，所以我们需要考虑新的合并方式。 记录每个匹配括号的左端和右端颜色在状态里，即 $f(l,r,colorleft,colorright).$ 首先考虑当 $[l,r]$ 是一个匹配串的时候的转移，显然需要枚举所有的颜色情况，并从 $[l+1,r-1]$ 转移过来，当然，为了满足题目的要求，转移相加的时候是有颜色限制的，如果相邻的括号相同那就需要跳过这个状态。 否则，我们 $[l,r]$ 不匹配的时候可以从 $[l,match_l]$ 和 $[match_l+1,r]$ 这两个匹配的序列转移过来，当然，前提是 $match_l$ 和 $match_l+1$ 这两个位置的颜色不能相同。 转移的话就是 $f(l,r,i,j)$ 加上这两段相乘。 因为我们要从小的往大里转移，所以方便起见使用 DFS 转移。 213 | CF1617A Forbidden Subsequence洛谷 RemoteJudge Forbidden Subsequence 考完月考不知道干嘛，于是做个没啥用的智障题。 先排序然后遇到小串为 abc 的时候特判，先输出 c 再输出所有 b. 214 | CF1617B GCD Problem洛谷 RemoteJudge GCD Problem 来到机房不知道做啥，于是做个没啥用的智障题。 先对这个要求的形式进行一个转化：$a + b + c = n \\Rightarrow x \\times c + y \\times + c = n \\Rightarrow c \\times (x + y + 1) = n.$ 于是我们枚举 $n$ 的因数，也就是这个 $c$，然后再枚举 $x$ 和 $y$ 即可。 215 | CF1617C Paprika and Permutation洛谷 RemoteJudge Paprika and Permutation 做完上一个之后不知道做啥，于是继续做个没啥用的智障题。 首先，题目要求将整个序列转化为一个 $1$ 到 $n$ 的排列，所以我们把已经符合条件的 $a_i$ 扔掉不用管。 然后将剩下的排序，按照大小顺序去一个一个判断能不能往排列里面填，判断的依据是：对于一个数 $x$，它在本题所述的变换中，只能变为自己本身或 $\\le \\dfrac{x}{2}$ 的数，于是 $x$ 越小，能变成的数的范围也就越小，所以我们贪心让小的数先去填补排列。 于是我们每次判断是否 $\\dfrac{x}{2} \\ge i$ 即可。如果不行的话就说明不存在解，输出 $-1$，否则累加答案。 216 | P4766 Outer space invaders [CERC2014]洛谷 | P4766 Outer space invaders [省选+/NOI-] 莫名的感觉这个题实际上配不上紫题（ 考虑我们如果要消灭时间 $i$ 时的 Invaders，就要让打击功率为最远的 Invader 的距离。 设 $f(l,r)$ 为清除存在时间在 $[l,r]$ 之间的 Invaders 所需要的最小功率。 假设区间 $[l,r]$ 中距离最远的 Invader 的时间点为 $i$，则我们在清除它的时候就可以一起把时间点为 $i$ 的 Invader 一起消灭，然后我们这个区间剩下的就是 $[l,i-1] \\cup [i+1,r]$，于是我们在转移的时候枚举这个 $i$ 即可，即 $f(l,r) = \\min\\limits_{l_{id} \\le i \\le r_{id}}{d_id + f(l,i-1) + f(i + 1,r)}$，其中 $id$ 是距离最远的 Invader 的编号。 217 | P2470 压缩 [SCOI2007]洛谷 | P2470 压缩 [SCOI2007] [省选+/NOI-] 紫 40 AC 祭 我们考虑一个区间 $[l,r]$ 里面有 M 的情况是 $f(l,r,1)$ 没有则为 $f(l,r,0).$ 当区间里没有 M 的时候，如果可以从中间折叠，那么就更新 $f(l,r,0)$，即 $f(l,r,0) = \\min{f(l,r,0),f(l,mid,0)+1}.$ 然后正常的转移就是枚举断点更新： 12f[l][r][0]=Hmin(f[l][r][0],f[l][i][0]+r-i);f[l][r][1]=Hmin(f[l][r][1],Hmin(f[l][i][0],f[l][i][1])+Hmin(f[i+1][r][0],f[i+1][r][1])+1); 懒了不想打公式 218 | P1043 数字游戏 [NOIP2003PJ]洛谷 | P1043 数字游戏 [NOIP2003PJ] [普及+/提高] 2022 第一题（笑 $f(l,r,k)$ 表示 $[l,r]$ 分成 $k$ 段的最大值，$g(l,r,k)$ 为同意义下的最小值。 处理一个前缀和然后暴力枚举分段即可。 219 | CF1615B And It’s Non-Zero洛谷 RemoteJudge And It’s Non-Zero 因为如果让某一二进制位为 $1$，那么就需要每个参与运算的数字二进制下这一位为 $1$，所以处理出来有多少数有 $1$，那么剩下的就是要去掉的。 220 | P6247 最近最远点对 [SDOI2012]洛谷 | P6247 最近最远点对 [SDOI2012] [提高+/省选-] 不明白，为什么我的 KDT 会 T，摆烂交了个贪心。 贪心就是了，排序之后选一定长度的点，这题最小 13 就够。 221 | CF1615C Menorah洛谷 RemoteJudge Menorah 一共是四种状态 $f(1,0)\\ f(1,1)\\ f(0,0)\\ f(0,1)$ 于是我们的目标是 $f(0,1)+f(1,1)=n$ 化简一下： f(x,0) -&gt; f(x,1) -&gt; f(x,0)，也就是说，奇数次操作会让不同状态变为相同状态，偶数次则为变回来。 反之亦然，奇数同变不同，偶数不同变同。 而显然我们只能 $101010101……$ 这样的进行操作，于是奇数次的操作之后相当于所有的不同变成同，反之亦然。 因为每次对 $f(1,0)$ 操作的时候会让 $f(1,1)-1$，并让 $f(0,0)+1$，所以只有 $f(1,1)-f(0,1)=1$ 和 $f(0,0)=f(1,0)$ 的时候可以去更新答案为 $\\min{f(1,1)+f(0,1),f(0,0)+f(1,0)}$，其实就是从奇偶考虑。 如果最后答案大于 $n$ 显然不行，否则输出答案。 222 | P3038 Grass Planting G [USACO11DEC]洛谷 | P3038 Grass Planting G [USACO11DEC] [提高+/省选-] 树剖复健成功，基本一次成功大约，没有遇到什么问题：） 223 | P2486 染色 [SDOI2011]洛谷 | P2486 染色 [SDOI2011] [省选+/NOI-] 不得不说虽然长是长了点，树剖还是好玩的，对于我这种没有脑子的人来说，不用想就能打的东西太好了。 其实就是普通的树剖，然后我们在线段树内记录每个区间的左端颜色和右端颜色，在合并的时候注意一下，如果一样就让 valve-1 就行。 224 | P1505 旅游 [国家集训队]洛谷 | P1505 旅游 [国家集训队] [省选+/NOI-] 我在上个题的时候曾经说过： 不得不说虽然长是长了点，树剖还是好玩的，对于我这种没有脑子的人来说，不用想就能打的东西太好了。 确实，于是这个题的代码长度就成为了我目前为止通过代码中最长的，415 行，7Kb。（当然，和我码风有空行有关系） 树剖部分基本是一遍写对的，最后错了半天是因为题目说的边的编号要是 $0 \\sim n-1$，但是我读入的时候忘了 +1，害的我把前面的重新看了一遍。。 但是还好这是 7Kb 的树剖而不是其它别的什么鬼东西。 225 | P3178 树上操作 [HAOI2015]洛谷 | P3178 树上操作 [HAOI2015] [提高+/省选-] 开这个题的时候没想到因为期末考试复习一周多没去机房。。 假期的时候因为期末考试成绩的事情生气，所以就把这个题写完了，然后在家没调，早上来学校发现是线段树 Build 时给结点赋值错了，然后改完就对了。 226 | P6772 美食家 [NOI2020]洛谷 | P6772 美食家 [NOI2020] [省选+/NOI-] 一份，长达，一年零五个月的代码。 大约在好久之前立了个 Flag： 大约是元旦之前就 99 粉了，当时就感到一丝危机，因为美食家这个题给我留下的阴影还是挺大的（ 当时咋想的咱也不知道，总之就是一个奇怪的思路骗过了样例（？ 当然当时的我就莫名的感觉到这个题复杂度的奇怪，那么，确实是挺奇怪的：$O((5n)^3 \\log T + k \\dot (5n)^2 \\log T).$ 当时我看到正解复杂度是这个玩意就觉得很淦，这东西不像是我能分析的出来的东西。 于是试着想些什么，首先这个题不像是图论之类，所以向着 DP 的方向考虑，考虑到数据范围，最后可能是个二维 DP 状态之类的（ 那么就能设 $f(i,j)$ 表示第 $i$ 天在编号为 $j$ 的城市，然后用枚举出边来更新，即 $f(i,j)+v(j,k)$ 更新 $f(i+w,k).$ 然后这样大约就能有 $40$，复杂度大约是 $O(T(n+m))$，但是想不出来什么更厉害的状态了…… 所以可以优化么？好像可以，但是我只会矩阵，但是一般的矩阵都是加和且为逐项转移（如 $f(i,j)$ 转移到 $f(i,j+1)$ 这样）的，这个首先是取最大值，而且每次转移需要距离都为 $w.$ 后者还比较好解决，因为 $w \\le 5$，所以拆点即可，前者的话……改变矩阵相乘的时候的合并方式（？ 于是我就拉了，遂观 duyi 佬之题解，原来如此。 本来矩阵乘法的柿子为： $$C = A \\times B \\Leftrightarrow C(i,j) = \\sum\\limits_{k=1}^{n} A(i,k) \\times B(k,j)$$ 因为我们这里需要取最大值，考虑到转移方式，于是我们可以重新定义一种“类矩阵乘法”： $$C = A \\times B \\Leftrightarrow C(i,j) = \\max\\limits_{k=1}^{n} {A(i,k) + B(k,j)}$$ 语言描述就是把原来的相乘求和改为了相加取最大值。 因为矩阵快速幂优化 DP 主要是用到了矩阵的结合律，而在这里重新定义的“类矩阵乘法”仍然符合矩阵结合律。 为了下面描述方便，把这种运算简记为 $A \\dagger B$（莫名找到的小符号 \\dagger，即匕首，短剑）。 当 $k = 0$，即没有美食节的时候，直接将一个点拆为 $w$ 个点即可，也就是在相邻编号之间的点之间加入边权为 $0$ 的边，然后把拆出来的最后一个点和第一个点建一条原本点权值的边，设转移矩阵为 $M$，那么转移方程就是 $f(i) = f(i-1) \\dagger M$，答案即为 $(f(T),1) = (f(1) \\dagger M^T,1)$，时间复杂度为 $O((5n)^3 \\log T).$ 再考虑 $k \\ne 10$ 的时候，因为题目数据保证了美食节分布在不同天，所以我们可以先排序，考虑其单独贡献，即在两个美食节之间单独进行转移，即为：$g(i) = g(i-1) \\dagger M$，转化到刚才的 DP 状态上，即，设本次时间为 $t_i$，那么上次的时间即为 $t_{i-1}$，那么每个美食节的贡献就是 $f(t_i) = f(t_{i-1}) \\dagger M^{t_i - t_{i-1}}$，最后再让 $(f(t_i),x_i)$ 加上 $y_i$ 就计算出了贡献。 最后若转移到的时间不为 $T$，再转移一次即可。若最后拆完后的第一个结点的权值仍为 $\\tt -INF$，那么就说明无解。 现在的复杂度是 $O(k(5n)^3 \\log T)$ 我们再把 $M^{2^x}(x \\in [0,30])$ 预处理出来，就能把复杂度降到 $O((5n)^3 \\log T + k \\dot (5n)^2 \\log T).$ 顺便，这次代码的 return 0，叫做 HerikoDeltana_LG100FansAnniv. 最后的 Anniv 是周年纪念的意思，因为明天就是来高中部一周年了，今天新实验班学弟学妹都来了（ 嗯，没错，有学妹。 227 | P4069 游戏 [SDOI2016]洛谷 | P4069 游戏 [SDOI2016] [省选+/NOI-] 调题历程。 这道题从昨天晚上 6:28 开题到现在 10:36 AC 耗时大约 7h，我是真的服了啊（ 这个题中说到每次对于树上点权值修改的是一个和距离相关的一次函数，于是我们可以树剖然后把这些修改通过每次找 LCA 用李超线段树来维护，即插入线段（ 挺简单的对吧，但是这么长时间没过去。 228 | CF932F Escape Through Leaf洛谷RemoteJudge [NOI/NOI+/CTSC] CodeForces 932F Escape Through Leaf 真正意义上的第一道正解黑题，不过也有可能是评高了，CF 上 2700 我也不知道什么水平，反正比我水平高就是了（ 题目就令人很莫名不是么，很容易想到 DP： $$f(x) = \\min{f(y) + a(x) \\times b(y)}\\ (y \\in subtree(x))$$ 但是这是个 $O(n^2)$ 的 DP，于是我们考虑优化（ 这个形式，多是个一次函数啊（呆 所以我们考虑把后面这些东西当作直线用李超线段树来维护，只不过需要还一些合并（ 时间复杂度是 $O(n \\log n)$，但是好像不合并，用树剖也能 $O(n \\log^2 n)$ 的做？没去试（懒 229 | P4556 [Vani有约会] 雨天的尾巴 /【模板】线段树合并洛谷 | P4556 [Vani有约会] 雨天的尾巴 /【模板】线段树合并 [省选+/NOI-] 我们需要对每个结点维护一个权值线段树，因为是一棵树，所以我们考虑把修改操作用树上差分来实现，因为可能值域重合，所以我们进行线段树合并（ 230 | P4254 Blue Mary开公司 [JSOI2008]洛谷 | P4254 Blue Mary开公司 [JSOI2008] [省选+/NOI-] 哇，李超线段树板子（ 这个比板子还板子的李超线段树什么都不需要，只需要支持把直线插进去，然后查询最大值即可。 最一开始不知道什么地方写挂了，最后发现它最一开始给的是斜率和 $x=1$ 的取值（ 顺便吐槽一下这个样例，给了和没给没啥区别（ 231 | P4655 Building Bridges [CEOI2017]洛谷 | P4655 Building Bridges [CEOI2017] [省选+/NOI-] 哇，又是李超线段树（ 首先有柿子（这里 $w$ 是原题中 $w$ 的前缀和）： $$\\begin{aligned}f(i) &amp;= \\min{(h(i)-h(j))^2+f(j)+w(i-1)-w(j)} \\ &amp;= \\min{h(i)^2+h(j)^2-2h(i)h(j)+f(j)-w(j)}+w(i-1) \\ &amp;= \\min{h(j)^2-2h(i)h(j)+f(j)-w(j)}+h(i)^2+w(i-1)\\end{aligned}$$ 设 $g(x,j) = -2h(j)\\times x+(f(j)+h(j)^2-w(j))$，则有： $$f(i) = \\min{g(h(i),j)}+h(i)^2+w(i-1)$$ 于是我们只需要在转移的时候找到 $h(i)$ 取最大值的对应 $g(h(i),j)$ 即可，也就是把 $g(x,j)$ 当作直线用李超线段树来维护。 232 | CF1615E Purple Crayon洛谷 RemoteJudge CF1615E Purple Crayon 最聪明的情况下，A 只会选叶子结点，剖出来链之后按照提议操作。 233 | P2680 运输计划 [NOIP2015TG]洛谷 | P2680 运输计划 [NOIP2015TG] [省选+/NOI-] 树上差分 + LCA + 二分 Future Search Technology. 234 | P8110 矩阵 [Cnoi2021]洛谷 | P8110 矩阵 [Cnoi2021] [普及/提高-] 碰见的题，拿来做做（ 对于前三个部分分，直接暴力矩阵快速幂即可。对于全部数据的 $n \\le 10^5$，显然二维数组是开不下了，于是考虑优化，可以按照 $k$ 的取值来分类： $k=0$ 时，直接输出 $n \\bmod k;$ $k=1$ 时，输出 $A$ 的元素和，即 $\\sum\\limits_{i=1}^{n}\\sum\\limits_{j=1}^{n}a_ib_j=(\\sum\\limits_{i=1}^{n}a_i)(\\sum\\limits_{i=1}^{n}b_i);$ 否则，由题意应输出 $A^k$ 的元素和，即 $(\\sum\\limits_{i=1}^na_ib_i)^{k-1}*(\\sum\\limits_{i=1}^{n}a_i)(\\sum\\limits_{i=1}^{n}b_i).$ 234 | P2325 王室联邦 [SCOI2005]洛谷 | P2325 王室联邦[SCOI2005] [提高+/省选-] SDWC 提到的一种树上分块的思路，即在树上砸 $O(\\sqrt{n}))$ 个点（也就是分成 $O(\\sqrt{n})$ 个块），DFS 一遍即可，对于每个结点 $x$ 枚举其儿子，把他们扔到当前的临时集合中，若当前的临时集合大于了要求的城市大小，那就新开一个以 $x$ 为省会的城市，不断从临时集合中将结点放到新城市中，直到小于城市块大小，总体复杂度 $O(n).$ 235 | P8113 自我主义的平衡者 [Cnoi2021]洛谷 | P8113 自我主义的平衡者 [Cnoi2021] 最近的一道比赛题，还是 E 题，没太想到能被这么简单的水过去（ 因为每个人评价的标准是当前的平均值和自己期望值之间的大小关系，而且每次对于平均值的贡献只有在当前平均值小于等于自己期望值的时候才会贡献一个最大值 $m$，而且我们只需要求最大值和最小值，因此贪心的将期望值序列分别升序和降序排序即可求出最大值和最小值。 最一开始因为没看见那个小于等于只得了 90（ 236 | P4168 [Violet]蒲公英洛谷 | P4168 [Violet]蒲公英 [省选+/NOI-] 其实，我不太常写分块，平常区间问题想到的都是线段树或者 ODT. 上次练习和分块相关的题目，还是练习普通莫队的时候。 然而这道题需要强制在线，莫队就没用了。当然莫队是有在线化改造的，但是，本来就是暴力根号数据结构的莫队，再在线化改造之后更像分块了吧。 因为值域很大，我们不可能直接在值域上进行维护，所以需要离散化。 然后考虑暴力怎么做，显然，开桶对每个区间进行统计即可，那么我们考虑分块怎么做。显然对于询问区间端点所在块相邻的，直接暴力开桶统计。否则，我们先预处理出来每个块内众数出现的次数，复杂度为 $O(\\sqrt(n)\\sqrt(n)\\sqrt(n))$，然后我们可以直接利用中间块内信息辅助开桶统计。 237 | AT1219 歴史の研究AT1219 歴史の研究 [省选+/NOI-] AtCoder原题链接 一个断断续续调了一天半的回滚莫队。 大体思路就是一个块内的暴力修改，不在一个块内的莫队维护。 因为排序询问的时候错放在预处理前，错的很惨。 顺便，600 AC 祭，紫题 50 AC 祭。 238 | P2501 数字序列 [HAOI2006]洛谷 | P2501 数字序列 [HAOI2006] [省选+/NOI-] 一道非常妙的题，第二问的解决方案很有意思，利用单调的序列的性质贪心找到最优的划分平台。 239 | P4027 货币兑换 [NOI2007]P4027 货币兑换 [NOI2007] [省选+/NOI-] 这题就题面就很有意思，说明提示里面给做法：“必然存在一种最优的买卖方案满足：每次买进操作使用完所有的人民币，每次卖出操作卖出所有的金券。” 那么我们就考虑每次拿不拿即可，设 $f_i$ 为第 $i$ 天能赚得的最大钱数，$X_i,Y_i$ 分别为第 $i$ 天用 $f_i$ 可以换得的 $A,B$ 的数量： $$X_i=\\dfrac{f_i \\times rate_i}{a_i \\times rate_i + b_i},Y_i=\\dfrac{f_i }{a_i \\times rate_i + b_i}$$ 假如不卖出的话，$f_i=\\max{f_i,f_{i-1}};$ 假如卖出的话，$f_i=\\max{a_i \\times X_j + b_i \\times Y_j}=\\max b_i{\\frac{a_i}{b_i} \\times X_j + Y_j}.$ 那么把后面这个东西看成直线表达式，就可以用李超线段树维护了。因为精度问题，这里使用了离散化，但是要注意的是使用 unique 去重的时候，不传参判浮点数相等会出现精度丢失了。（见这个讨论） 240 | P2466 Sue 的小球 [SDOI2008]洛谷 | P2466 Sue 的小球 [SDOI2008] [省选+/NOI-] 最近不知道做啥题了，随便捡一些 DP 玩玩，虽然我 DP 不行才是找 DP 题做的原因。 显然要先根据 $x$ 坐标排序。 这道题显然直接开二维数组来记录位置是不行的，所以用当前 $x$ 坐标和当前到第几个了来作为状态。 241 | P4560 Wall [IOI2014]洛谷 | P4560 Wall [IOI2014] [省选+/NOI-] 我的评价是：抽象，为啥这题是紫的？ 感觉这个题完全配不上紫，很水的一个线段树，维护两个 TAG 每次下传的时候修改即可。 242 | P3066 Running Away From the Barn G [USACO12DEC]洛谷 | P3066 Running Away From the Barn G [USACO12DEC] [提高+/省选-] 这题可以 $O(n \\log n)$ 的做，每次从它到根节点的树链上寻找深度小于 $len$ 的点，然后差分统计答案即可。 243 | P1360 Gold Balanced Lineup G [USACO07MAR]洛谷 | P1360 Gold Balanced Lineup G [USACO07MAR] [提高+/省选-] 可以处理出来前缀和，然后相同的增长区间就是两个差相等的值的位置之差。 不太会描述，不过确实挺好想，最一开始还以为 map 套 vector 过不去，后来发现是我多虑了（ 244 | P8255 数学游戏 [NOIOL 2022 PJ]洛谷 | P8255 数学游戏 [NOIOL 2022 PJ] [提高+/省选-] 说实话，这题我感觉评绿合适一点。 最一开始听说今年的 NOIOL 普及两蓝，以为又是坑蒙拐骗初学者场。刚才偶然想到，不如拿来一做。 首先是排除无解，$x$ 不能整除 $z$ 显然无解。 然后将 $z$ 除以 $x$， 设 $d=\\dfrac{\\dfrac{z}{\\gcd(x,z)}}{\\gcd(\\dfrac{z}{\\gcd(x,z)},x)}$，$d’=\\dfrac{z}{\\sqrt{\\dfrac{z}{d}}}$，若 $d’ \\times \\gcd(d’,x)=z$，那么 $d’$ 就是所求的 $y$，否则无解。 不过，写完这一堆之后，我觉得评蓝也不是不合适（ 245 | P4116 QTree3洛谷 | P4116 QTree3 [提高+/省选-] 简单复健了一下树剖。 246 | P4315 月下“毛景树”洛谷 | P4315 月下“毛景树” [提高+/省选-] 同样是简单复建树剖，比较惊喜的是可以一遍 AC，之前的树剖还算是没忘（ 这个题的线段树也不难，两个 tag，一个累加一个覆盖即可，保证覆盖在累加之前就行。 247 | P4114 QTree1洛谷 | P4116 QTree1 [提高+/省选-] 非常简单树剖，但是傻逼错误（题目中的边的标号和我插入的双向边的编号不一样导致我写代码佷快然后调了万年），爱来自瓷器。","link":"/2021/12/06/Note18-2/"},{"title":"Nothing : 20220401","text":"四月一日。 启记所想而已。 没有及时写下来，属实是语文太差，而自感过多（ 没有什么逻辑性，单纯想到什么写什么。 春源 岚 2022/4/1 0:25:46四月快乐 岚 2022/4/1 0:25:51寝之前 岚 2022/4/1 0:25:58感觉还是得说 岚 2022/4/1 0:26:22当我们姑且把一个月的第一天当做新的开始的时候 岚 2022/4/1 0:26:33就必须要好好生活下去了 白葱 2022/4/1 0:27:17是呢（） 岚 2022/4/1 0:27:17这是一个清澈温暖的季节 岚 2022/4/1 0:27:26不管外面怎么样 岚 2022/4/1 0:27:34我们 白葱 2022/4/1 0:28:35我们（） 岚 2022/4/1 0:28:58 每一天都要明媚喔 岚 2022/4/1 0:29:03（sign） 白葱 2022/4/1 0:29:06呜呜 四季印象四月…… 我的记忆里，四月好像一直没有什么特殊的事情。 可能是因为对于季节的概念随着在济南上学的时间增长而淡化了。 去年一整年对于季节的更替好像只有冷暖之分，因为绝大多数时间都在机房和教室，就没有去关注周遭的环境。 顺着想一下对于季节的记忆罢…… 春天，我印象里的春天，就是春的……花？现在去想小时在聊城，对于春天，脑袋里只有花了…… 花，于我而言，是什么呢……好像说不清楚，因为我不是那种专门去了解某种植物的人，所以我也只能分辨出来这些色彩的植株是花。 我不是很喜欢看起来比较富贵或者说华丽的花，可能跟我不喜欢华丽闪亮的东西有关。 喜欢比较纯净颜色的花，让我心情愉快（） 总之春花于我的感觉比夏花更单纯啥的，所以春的记忆是花。 今年无意中开始观察校园里的花，从冬末春初到现在渐入繁春，从等着它们开放到风过花现满眼，这就是我这里的春罢。 月份的话，聊城和济南的春天时间差不多，基本都是二月中旬盼花开，五月初暮春初夏。 我的夏，总是快乐，当然可能主要是有暑假（ 但是整个夏天的心态都会很好，干什么事情也都会很顺心，作为 IA 推人，Orangestar 和 *Luna 的夏曲是不能少的，当然，正式入术坑也是从夏天开始的。 于是夏天在印象中是亮的，明亮，阳光与夏日的微风恰逢，融合出我心中的夏气。 夏天的代表事物好多的样子，好像不太能是描述的样子。 聊城记不清了，因为主要在济南嘛，所以只有假期才会回去，基本都是冬和夏，分不清时间了。 济南好像从五月到十月初都是夏的样子（ 因为我想这些季节印象的时候首先会参考去年，所以其实不太想想秋天来着…… 但是又不是秋天的错，毕竟济南入冬还挺早的，十一月那个时候都下雪了，所以去年十一月算在冬天罢（ 都扯到哪去了（意识流也不能瞎扯啊ww 但是秋天给我的总体印象是枫叶万叶的枫红和叶黄，这两个在我心中真的是非常温暖的颜色。 所以秋天是温暖的，大概是续了盛夏后的余温，不至于热烈，但是平和而温暖。 秋天最喜欢干的事情是看秋风过枫叶飘飞和沉浸在秋日的暖阳下，喜欢的颜色是蓝色，偏冷的蓝，但是秋的红橙黄总能带给我暖意，从目染，慢慢的，扩散至全身。 所以我说过秋日的暖阳下是最舒服的（ 想起来去年停课的时候宽哥在一天阳光非常好的中午说，今天就应该在阳台上晒太阳（ 晒太阳好啊，晒太阳好（ 但是济南的秋天太短暂了，十月初夏还未散去，十一月初就开始下雪了（指去年 冬。 小时候问我最喜欢哪个季节的时候，我说的都是冬天，原因很简单，冬天下雪，雪纯净洁白，而我喜欢这种纯色的天然；冬天冷，水会成冰，冰质透，而我喜欢无色的原晶。 可是去年冬天是真的冷啊w 冬天好像没有什么花呐……不过也不是很重要啦，冬天我都是呆在屋子里罢（ 下雪会非常高兴，每次下雪跟没见过雪一样（（ 济南的冬天也很长，十一月就开始冷、下雪，然后一直到二月（ 那么，差不多就写完了欸。 雨源出门买奶，下雨了。 春雨想起来之前课文里的：“光头浇更舒服”了hh 本来想在楼下多转几圈的，结果突然点雨点了（ 但是，我真的好喜欢这种小雨。雨落下的沙沙声，让这个世界不再是寂静或是小小的嘈杂，它掩盖了熵增，将天地连接成一体，仿佛，全世界都在雨中静默的思索着自己。 喜欢在小雨中漫步，打不打伞并无所谓，反正我是喜欢小雨点在身上的清凉。 雨中漫步，周围的景观仿佛更加清晰，而远方因为雨的笼罩而渐渐模糊。 我常常在雨中忘了这个世界的外围，这种自己归属自己的感觉真好。于是有时候就在想，是不是在意别人太多了。当然，想了也改不掉了，我社交的习惯已经养成如此了。 于是雨中就把自己留给自己罢。 末本来可能写更多来着，但是 4.1 的东西已经拖到 4.3 了，真的写不出来了（） 还是没有勇气找到自己到底是谁。","link":"/2022/04/02/Nothing-4-1/"},{"title":"Predict of F1 2022","text":"关于 F1 2022 赛季的预测（ 同步于知乎：2022年新规大改后，哪些F1车队变数会特别大？ 冬测时的瞎想首先窝法冬测表现仍然不错，希望正赛能好一点，起码给 LEC 和 SAI 争冠的机会吧（ 麦队整个冬测的表现也没有太多的问题，而且好像大家关注点都不太在麦队上（ 梅奔在巴塞罗那和巴林拿出了两版车，巴塞罗那的测试很稳定，但是巴林测试的这个表现…… 反正我是看着 W13B 的直道表现真的令人无语……有点不像是藏东西（当然马桶狼老奸巨猾也不是没有可能 红牛 RB18 设计思路很多地方都很有意思，测试也基本上很稳定，小红牛除了巴塞罗那 GAS 撞了好像也比较平淡。不过感觉小红牛在巴林的表现不是很好的样子（ 马丁这车……从巴林的表现来看……估计要寄。VET 那几圈真是可以说惨目忍睹，一条赛道所有的可能锁死的地方都锁死了，甚至转向过度转向不足兼而有之…… 威廉姆斯整个冬测都很稳定，没有太大的亮点也没有什么槽点，感觉是比哈斯和阿尔法罗密欧强得多。 然后就是难兄难弟，哈斯和阿尔法罗密欧。 先是巴塞罗那的时候，两家车都一直因为各种原因寄掉，总里程数完全不够。巴塞罗那最后一天俄对乌特别行动，导致哈斯和乌拉尔钾肥的赞助关系取消，马泽平的席位后来也就没了（虽然换来了马格努森 冬测之前的瞎想争冠行列前面有位老哥已经大体说过了，我的感觉也差不多（ 首先就研发实力来说的话，梅奔应该是比较确定的独一档。 红牛因为今年的研发投入，明年车搞成啥样目前还没太有定数，不过就算崩了也不会太逊。 上游然后就是法拉利和迈凯伦，感觉就上赛季来看，今年这两家还是会争一段时间。 从研发角度来说，法家实力强一点，从今年仅有两个研发 token 的 SF21 的改进，以及赛季末期引擎升级来看，我更看好法家，当然迈凯伦适应梅奔动力单元之后带来的提升也是个未知数。 从车手角度来说 LEC 和 NOR 都是天赋异禀，但是就目前来看 SAI 的稳定发挥拿分是要比 RIC 强不少的。（说实话 RIC 适应了一个赛季的车是我没想到的，虽然迈队的车适合带速度入弯，不符合 RIC 开红牛和雷诺时期早刹车入弯的习惯，，但是一个赛季都没配合好还是觉得有点……） （UPD 2022.2.5 ：感谢知乎上米兰米兰​的补充：RIC 的习惯并不是晚刹车，是迈凯轮的车低速晚需要晚刹慢抬带比较重的 Trail Brake 导致的 RIC 不适应） 我个人还是希望这两家都能有个好的表现的（ 中游雷诺在 2021 失去了所有的客户车队之后，就剩下自己家的 Alpine 了（ 就今年的表现来说，奥康的皮夹和头哥的领奖台算是非常惊喜了，剩下的表现也都符合中游厂队的表现，至于研发方面，希望明年新引擎和新底盘能有好的表现吧（ 小红牛今年表现算是出色了，研发方面我感觉可能要寄（莫名），但是拿分还是非常稳的，角田明年应该能体现出来实力了，加斯利现在状态在顶峰，冲击领奖台还是有可能的。 当然这个策略组我是真的看不懂了……今年小红牛策略真的无语…… 马丁今年拉还是比较能感觉出来的，去年的地球组第一（当然粉红梅奔也不是吹的）变成今年的……绿色拖拉机，心疼一波歪头……太会选队了，大有头哥之势（ 明年的研发估计不会太有起色，毕竟研发方式就比较被动，说好听了叫做逆向开发，说不好听了就是比着梅奔改……今年削底板、改后悬挂带来的后果也是非常明显了，据说本赛季还是保持之前的研发策略不变……我估计要寄。 中下游都说哈斯放弃 2021 备战 2022 所以 2022 的成绩可能会有大的提升。确实，但是提升估计大不了，而且两位公子爷的表现无法预测，2022 将是哈斯生死攸关一年了，如果还是今年这个寄样，吉恩估计要卖队了。 至于因为小周而备受关注的阿尔法，明年的主要提升，估计在窝法引擎上，其它估计没啥看头（ 威廉姆斯今年稍有起色，但是我个人觉得 RUS 是火星人占据小半部分，明年估计威队或许能和马丁一战（？ ALB 的水平还是不错的，LAT 水平也一直有小的进步，威队 2022 表现还是值得期待的。 补充以上纯属个人根据最近两三个赛季的车队表现得出，因为是新规，所以不确定性还是很大的（ 万一窝法起来了呢（","link":"/2022/01/30/PredictOfF12022/"},{"title":"珂朵莉树","text":"Chtholly Tree 简记 「启」 关于为啥我要学这个？ 闲的。 本篇中所有 Code 的缺省源使用 「V5.2」. 「关于 ODT」 ODT 用处？ （大多数是）在有区间赋值操作的 DS 题里面骗分，因为好像专门为 ODT 设计的题不多吧？反正我只知道 CF896C. 时间复杂度？ ODT 的复杂度正确建立在数据随机上，这点一定牢记。 对于所有的基础操作（如 $Assign$ 和 $Add$ 等），使用 set 实现的 ODT 的复杂度为 $O(n \\log\\log n)$，而链表实现的复杂度为 $O(n \\log n)$，不过我目前只会用 set 实现就是了（ 注意事项？ ODT 的复杂度正确建立在数据随机上，ODT 的复杂度正确建立在数据随机上，ODT 的复杂度正确建立在数据随机上。不然的话出题人很容易构造数据让你 T 掉。 别被没有区间赋值的部分分卡了。 「实现」先是核心思想：把值相同的区间合并成结点，存到 set 里面。 于是就有了以下的结构体来存结点： 「结点 Node」1234567891011121314struct Node{ LL l,r; mutable LL v; Node(LL l,LL r=0,LL v=0) : l(l),r(r),v(v) {} I bool operator &lt; (const Node &amp;co) const { Heriko l&lt;co.l; }};set&lt;Node&gt; s; 这里的 mutable 是为了突破 const 的限制，便于我们后面直接修改 set 中的值，而不是拿出来改完再扔进去。 「分裂 Split」$Split$ 算是 ODT 中最重要的操作了，简单来说就是把区间 $[l,r]$ 分成 $[l,pos-1]$ 和 $[pos,r]$ 两段，便于我们操作。 实现也很简单，我们先用 set 自带的 lower_bound 确定 $pos$ 对应位置，然后删除原区间分成两半插入。 123456789101112131415161718I auto Split(LL pos){ auto it(s.lower_bound(Node(pos))); if(it!=s.end() and it-&gt;l==pos) Heriko it; --it; if(it-&gt;r&lt;pos) Heriko s.end(); LL l(it-&gt;l),r(it-&gt;r),v(it-&gt;v); s.erase(it); s.insert(Node(l,pos-1,v)); Heriko s.insert(Node(pos,r,v)).first;} 这样的话所有的区间 $[l,r]$ 上的操作都可以转化为 $[Split(l),Split(r+1)].$ 「推平 Assign」$Assign$ 也是很重要操作，主要就是完成缩点的任务，实现起来也很简单，找到区间之后删除插入新的就行。 123456I void Assign(LL l,LL r,LL x){ auto itr(Split(r+1)),itl(Split(l)); s.erase(itl,itr); s.insert(Node(l,r,x));} 实际上最基本的操作也就上面这俩了，下面再扩展一点常用的操作。 「区间加 Add」如何区间加呐？暴力。 嗯，没错就是暴力，找到对应区间之后暴力加就是了（ 1234567I void Add(LL l,LL r,LL x){ auto itr(Split(r+1)),itl(Split(l)); for(auto it(itl);it!=itr;++it) it-&gt;v+=x;} 「排名 Rank」查询区间排名的话，我们先声明一个结构体或者 pair 便于对相同的数操作。 1234567891011struct Rank{ LL val,cnt; Rank(LL val,LL cnt) : val(val),cnt(cnt) {} I bool operator &lt; (const Rank &amp;co) const { Heriko val&lt;co.val; }}; 然后我们就用最好想的思路，先找到对应区间，然后把所有的数排序，直接去找要求排名即可。 12345678910111213141516171819I LL QueryRank(LL l,LL r,LL x){ auto itr(Split(r+1)),itl(Split(l)); vector&lt;Rank&gt; v; for(auto it(itl);it!=itr;++it) v.push_back(Rank(it-&gt;v,it-&gt;r-it-&gt;l+1)); sort(v.begin(),v.end()); LL i(0); for(;i&lt;(LL)v.size();++i) if(v[i].cnt&lt;x) x-=v[i].cnt; else Heriko v[i].val; Heriko v[i].val;} 「其它 Other」其实观察上面的也能发现在 ODT 上的操作，先找到对应区间之后就很好办了，所有大概的代码框架都是这个样子： 123456I auto Function(int l,int r,...){ auto itr(Split(r+1)),itl(Split(l)); ...} 然后知道了这些就可以去把 CF896C 干掉了。 「CF896C Code」123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158CI MXX(1e5+1),MOD(1e9+7);LL n,m,seed,vmax,a[MXX];I LL GetData(){ LL res(seed); seed=(seed*7+13)%MOD; Heriko res;}I LL FstPow(LL x,LL y,LL p){ LL res(1); x%=p; while(y) { if(y&amp;1) (res*=x)%=p; (x*=x)%=p; y&gt;&gt;=1; } Heriko res;}struct Node{ LL l,r; mutable LL v; Node(LL l,LL r=0,LL v=0) : l(l),r(r),v(v) {} I bool operator &lt; (const Node &amp;co) const { Heriko l&lt;co.l; }};set&lt;Node&gt; s;I auto Split(LL pos){ auto it(s.lower_bound(Node(pos))); if(it!=s.end() and it-&gt;l==pos) Heriko it; --it; if(it-&gt;r&lt;pos) Heriko s.end(); LL l(it-&gt;l),r(it-&gt;r),v(it-&gt;v); s.erase(it); s.insert(Node(l,pos-1,v)); Heriko s.insert(Node(pos,r,v)).first;}I void Assign(LL l,LL r,LL x){ auto itr(Split(r+1)),itl(Split(l)); s.erase(itl,itr); s.insert(Node(l,r,x));}I void Add(LL l,LL r,LL x){ auto itr(Split(r+1)),itl(Split(l)); for(auto it(itl);it!=itr;++it) it-&gt;v+=x;}struct Rank{ LL val,cnt; Rank(LL val,LL cnt) : val(val),cnt(cnt) {} I bool operator &lt; (const Rank &amp;co) const { Heriko val&lt;co.val; }};I LL QueryRank(LL l,LL r,LL x){ auto itr(Split(r+1)),itl(Split(l)); vector&lt;Rank&gt; v; for(auto it(itl);it!=itr;++it) v.push_back(Rank(it-&gt;v,it-&gt;r-it-&gt;l+1)); sort(v.begin(),v.end()); LL i(0); for(;i&lt;(LL)v.size();++i) if(v[i].cnt&lt;x) x-=v[i].cnt; else Heriko v[i].val; Heriko v[i].val;}I LL QueryVal(LL l,LL r,LL x,LL y){ auto itr(Split(r+1)),itl(Split(l)); LL res(0); for(auto it(itl);it!=itr;++it) res=(res+FstPow(it-&gt;v,x,y)*(it-&gt;r-it-&gt;l+1)%y)%y; Heriko res;}S main(){ Files(); fr(n),fr(m),fr(seed),fr(vmax); for(int i(1);i&lt;=n;++i) a[i]=(GetData()%vmax)+1,s.insert(Node(i,i,a[i])); while(m--) { LL opt((GetData()%4)+1),l((GetData()%n)+1),r((GetData()%n)+1),x,y; if(l&gt;r) swap(l,r); if(opt==3) x=(GetData()%(r-l+1))+1; else x=(GetData()%vmax)+1; if(opt==4) y=(GetData()%vmax)+1; if(opt==1) Add(l,r,x); else if(opt==2) Assign(l,r,x); else if(opt==3) fw(QueryRank(l,r,x),1); else fw(QueryVal(l,r,x,y),1); } Heriko Deltana;} 「其它例题」调了三天 CF896C 最后发现是快速幂少了 x%=p 之后就做了一点简单 ODT 板子题。 「HAOI2014 贴海报」 HAOI2014 贴海报 这个题巨大显然了吧，贼板子吧。 只需要区间推平，最后开个桶记录一下就行了，直接切了对吧。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465CI MXX(1001);struct Node{ int l,r; mutable int val; Node(int l,int r=0,int val=0) : l(l),r(r),val(val) {} I bool operator &lt; (const Node &amp;co) const { Heriko l&lt;co.l; }};set&lt;Node&gt; s;I auto Split(int pos){ auto it(s.lower_bound(Node(pos))); if(it!=s.end() and it-&gt;l==pos) Heriko it; --it; if(it-&gt;r&lt;pos) Heriko s.end(); int l(it-&gt;l),r(it-&gt;r),v(it-&gt;val); s.erase(it); s.insert(Node(l,pos-1,v)); Heriko s.insert(Node(pos,r,v)).first;}I void Assign(int l,int r,int v){ auto itr(Split(r+1)),itl(Split(l)); s.erase(itl,itr); s.insert(Node(l,r,v));}int n,m,x,y,tot,ans(-1);bitset&lt;MXX&gt; vis;S main(){ Files(); fr(n),fr(m); s.insert(Node(1,n+1)); while(m--) fr(x),fr(y),Assign(x,y,++tot); for(auto it(s.begin());it!=s.end();++it) if(!vis[it-&gt;val]) ++ans,vis[it-&gt;val]=1; fw(ans,1); Heriko Deltana;} 「CF343D Water Tree」这个题是个树上问题，比较板的树剖（ 不过我们不写线段树，我们直接上 ODT，在两边 DFS 处理出来 id 序之后按照普通的序列操作即可。 第二个操作就需要我们在 DFS 的时候记录一下 top，修改的时候不断跳 top 进行 $Assign$ 即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143CI MXX(5e5+5);struct ODT{ int l,r; mutable int v; ODT(int l,int r=0,int v=0) : l(l),r(r),v(v) {} I bool operator &lt; (const ODT &amp;co) const { Heriko l&lt;co.l; }};set&lt;ODT&gt; s;I auto Split(int pos){ auto it(s.lower_bound(ODT(pos))); if(it!=s.end() and it-&gt;l==pos) Heriko it; --it; if(it-&gt;r&lt;pos) Heriko s.end(); int l(it-&gt;l),r(it-&gt;r),val(it-&gt;v); s.erase(it); s.insert(ODT(l,pos-1,val)); Heriko s.insert(ODT(pos,r,val)).first;}I void Assign(int l,int r,int x){ auto itr(Split(r+1)),itl(Split(l)); s.erase(itl,itr); s.insert(ODT(l,r,x));}struct Node{ int nex,to;}r[MXX&lt;&lt;1];int rcnt,head[MXX];I void Add(int x,int y){ r[++rcnt]=(Node){head[x],y},head[x]=rcnt; r[++rcnt]=(Node){head[y],x},head[y]=rcnt;}int n,m,sz[MXX],dep[MXX],id[MXX],top[MXX],fa[MXX],son[MXX],tot;void DFS1(int x,int fath){ sz[x]=1,fa[x]=fath,dep[x]=dep[fath]+1; for(int i(head[x]);i;i=r[i].nex) { int y(r[i].to); if(y==fath) continue; DFS1(y,x); sz[x]+=sz[y]; if(sz[y]&gt;sz[son[x]]) son[x]=y; }}void DFS2(int x,int tp){ top[x]=tp,id[x]=++tot; if(son[x]) DFS2(son[x],tp); for(int i(head[x]);i;i=r[i].nex) { int y(r[i].to); if(y==fa[x] or y==son[x]) continue; DFS2(y,y); }}I void ModifyZero(int x){ int tp(top[x]); while(tp!=1) { Assign(id[tp],id[x],0); x=fa[tp],tp=top[x]; } Assign(id[1],id[x],0);}S main(){ Files(); fr(n); for(int i(1);i&lt;n;++i) { int x,y; fr(x),fr(y); Add(x,y); } DFS1(1,0); DFS2(1,1); s.insert(ODT(0,MXX)); fr(m); while(m--) { int opt,x; fr(opt),fr(x); if(opt==1) Assign(id[x],id[x]+sz[x]-1,1); else if(opt==2) ModifyZero(x); else fw(Split(id[x])-&gt;v,1); } Heriko Deltana;} 「终」那么就写这些吧。","link":"/2021/12/05/ODT/"},{"title":"Nothing : Reverie","text":"我常常思索，可我思索不出来。 前言可能是喜欢瞎想，而瞎想的程度又很深，所以有些东西想的确实很多，其实很多时候都是懒得开电脑或是在学校无法用电脑的时间段想到的，所以有些就埋藏起来了。 然而有机会还是写一点吧，先把标题写出来，剩下的慢慢补吧。 自由、爱、生活、生命这是仿佛是一个最近的东西，让人来排序，和 MBTI 有关好像。 从标题也能看出来我的排序了。 为什么这样排序呢？其实没有想太多东西，单纯就是看见哪个排哪个。 首先是自由，个人觉得自由是很重要的东西，没有自由，剩下的三者没有了太大的意义。 没有自由的爱，那是套着枷锁的舞蹈。 没有自由的生活，那是树上枯末的灰叶。 没有自由的生命，是麻木的存在。 其次是爱和生活，实际上我觉得这俩其实是一个东西，所以并不好排序，然而我感觉被人爱了才有生活的价值，所以我把爱放在前面。 最后是生命，很简单，没了上面，生命只是机体正常工作这种状态。 我个人的感觉是，如果生命真的最重要，也不会有用生命换别的东西的人。 没看过对于排序后的进一步人格分析，但我是 ENFP-T. 占有锐评（信）：占有欲是人类最恐怖的欲望。当然，如果我不是人类这玩意再说（ 其实对不是很重要的东西并没有什么占有欲，所以一般来说找我借一般的东西还是挺容易的。 不过想想平时，因为我占有的东西好像只有我（存疑）、我的电脑、手机而已。 然而总是想得到一些自己可能这辈子都不会有的…… 网络之前在 16 岁的回顾里说过我的线上线下逐渐分裂了，现在疫情停课在家可能更严重了。 因为家里大部分时间都没人，所以感觉自己的语言能力快要消失了。 不过最近这两天和🐏、🍑、🐟，以及 ysa 和 ysc 打过几次电话，感觉好多了。 于是网络成为了我的发声平台，也成为了我在家唯一的外界通道。 意识到，网络是信息交互的载体，但是信息量好大，大到会影响我的很多方面，所以开始间断性的退网。 但其实，即便是网络，也只是那几个支柱牵动神经，和在学校一样，只不过在网上更敢说一些东西了。 我我感觉自己的样子，在自己脑海中越来越模糊了。 大约是因为做出每个决定的我，好像都不太一样，而我在感知自己这一方面做的还是不太好的样子。我并不能感受到我做出某些选择的时候的原因，或者说，我并不太能明确的感知到自己。 这个问题仿佛不是在家的问题，在学校也一样。在学校的时候因为天天有更多的学习压力，对自己的感知就更不清楚了，当然也没那个时间像在家一样内耗。 所以我现在只是一个混合物的样子，不过也没人在意我是什么罢了，在我认识的绝大多数人来看，我是人是别的都无所谓罢。 梦境和真实本来这两个是分开列出的，但是我想了想应该放在一起。 我有时候就非常佩服自己做梦的本领，我真的好会做梦，梦见的东西相当真实，以至于让我常常分不清我到底是在梦中还是在醒着。当然，不排除我现在还在做一个长梦…… 做梦真的很有意思，尤其是在我分不清梦和真实的情况下。我的梦中总是能出现现实中不太可能发生但是发生了也不是很离谱的事情。 梦里的我似乎更加完整，更能做到我想做的事情，真的好羡慕（ 不过有时候做梦太真实也不是什么好事，比如上课的时候假如有点困，脑子里就开始做梦，梦到的东西还是老师在讲课，讲的东西也和之前能对接上，班里上课的气氛也和现实一样，但是是在做梦。 然后 SKP 把我碰起来或是我自己压到自己的时候，才会发现，老师其实讲的不是那些东西，我睡着了。 虽然已经很久没有上课睡着了。 未来对于未来，我一直是抱着一种不确定的忐忑心理。太多的不确定性让我无法下决定，目标也随着经历逐渐淡化。 但是一味的失落迷茫也是没有用的，所以我试图尽力去找到我的未来。 即使有些愿两年之后的愿望实现的希望还很是渺茫，但是我努力去做吧。因为，这很重要。 世界与重度依赖「世界」是我去年网易云的年度词汇，主要是来自于 IA 的一些歌。 而我在元旦发烧的时候也写过，现实世界让我真的很绝望，这大概是去年试图自杀的主要原因之一。 从某种意义上来讲，发烧的时候写出来的东西或许是最真切的体验，但全写出来还是于心不忍。 现在来说世界于我而言就是那几个人，他们是我全部的支柱，于是也就有了精神状态会随着他们而波动的风险。然而我不知道他们中的每个人是不是都能接受我，所以我有时只能默默的想着，或者写点东西记录一下，窥探着，确定自己的世界不会突然坍塌。 可我真的害怕没有人能注意到我，理解哪怕一部分的我。 但是我真的好怕过度打扰他们了……可能他们之中可能有人开始烦我了吧。 对于自己在家的时候，网络成为了和世界连接的唯一通道，所以只要我退网，我就可以给这个世界说再见了吧。 空在很多时候会感到空寂，并不是没有事情去做，而是没有自己想做的事情。 我可能真的需要有人理我，但是也可能不需要，因为我并不重要hh 锁这个博客有些文章锁上了，密码并不是一样的，所以可访问的人的范围也会不同。 为什么要锁呢，可能是个性所然，我一直喜欢把自己很多东西锁起来。 或许锁起来的东西成为我情绪不稳定而不能向别人诉说的诱因。但是我选择仍然锁着，可能我决定好了和世界告别，就会把一切揭开吧。 玩我喜欢玩，原因很简单，我不想面对。我在玩的时候，会忘掉很多，算是我最好的忘掉东西的方法了。 负罪感小时候性格就是容易担心很多东西，按照妈妈的话就是多愁善感，所以小时候真的很容易哭。 现在或许能忍住或是掩饰眼泪了，但是或许性格的底层未改，很容易担心人，或者事情。 我真的很讨厌我这一点，这是我目前明确最讨厌的自己的一点，为什么总是担心这么多东西啊，担心了又有什么用吗，你活了十五年又不是不知道，你担心了这么多东西最后有几个有用的？不都是最后只能白白给自己增加难受吗…… 可是我懂了又能怎样啊，我没能改变，十五年了。 如果这种东西也会传递的话，我还是早一点和这个世界告别的好，就看我啥时候决定了。 真是矛盾，想要不影响别人，但是还去找别人，我有病。 所以会一直一直一直一直一直一直一直一直一直一直一直一直一直一直一直一直一直一直一直一直一直为自己负罪，我永远有罪。 光我喜欢光明，向往光，可是就算阳光正好，能否有一丝的光透进我呢。 尾声那么这一些东西经过一个多周，大约就写完了吧。 写下 Nothing 这一类的文章，大约是向这个世界告别之前留下一些东西。","link":"/2022/04/07/Reverie/"},{"title":"Note18 : 杂题一","text":"第一堆持续更新的杂题 前言 这里是我从 2021.4.12 开始的做题记录，每个题目都有大约的讲解思路（有些偷懒就直接放的题解的链接） 这里的每一个题目都没有标程，但是都有题目的链接，可以根据右面的目录点到对应的题目去 这里的题目是按照我做的时间顺序排放的，难度主要是 黄 $\\to$ 绿 $\\to$ 蓝的样子。 因为好像篇幅好长的样子所以就开了第二堆杂题，这里就到 200 吧（ 2021.12.6 UPD 1 | P1144 最短路计数P1144最短路计数 [普及+/提高] 由于这道题的特殊性（所有边的边权都是1），所以我们可以只进行简单的BFS 由于要求最短路，所以当前在求的点$i$的上一个点在搜索树种一定是来自于上一层，不可能来自同一层，所以到点$i$的当前路径的长度只需要让上一层的那个点对他进行更新即可 再因为本题的$ans$要求的是到$i$点的最短路的个数，所以如果到点$i$的当前路径的长度等于上一层的每一个点的路径+1，那么这肯定是到点$i$的最短路 2 | P1352 没有上司的舞会P1352没有上司的舞会 [普及/提高-] 这是我第一次做有关树形DP的题目，因为题目难度不高，所以还是比较好想的S设$f_{i0}$是当第$i$个人不参加舞会时的$max$，$f_{i1}$是他参加舞会时的$max$ 根据题目所给到的关系，当一个结点（人）的父节点（领导）来的时候，这个人是不参加舞会的，所以对于$i$的下属$j$就有，$\\begin{cases} f_{i0}=max{ f_{j0},f_{j1}} \\ f_{i1}=a_i+f_{j0}\\end{cases}$ 这里的$a_i$是每个人的欢乐值（结点的权值） 可以显然得到的是，上述柿子只有从根节点开始才能计算出对于每个节点的$f_{i0} , f_{i1}$，从而才能算出对于根节点的$f_{root0},f_{root1}$，最后$ans=max{f_{root0},f_{root1}}$即可 那么我们就需要找到$root$的编号，根据本题的特殊性，$root$结点即为没有上司的结点，在输入关系的时候我们用一个$bool$数组来标记即可，全部输入完毕之后，再根据标记来判断$root$ 3 | P1015 回文数P1015回文数 [普及-] 其实做这道题的初衷是为了让橙题AC数量凑个整数 这道题其实按照题目的要求进行模拟即可，每次将一个数的位数正序与逆序相加，需要用到高精。对于大于10进制的情况，将其每一个用字母来表示的位对应的转化为一个十进制数即可 4 | P1158 导弹拦截[NOIP2010PJ]P1158导弹拦截[NOIP2010PJ] [普及/提高-] 看似这道题是和另外一道DP题重名，实际上这个题是一个排序+模拟，因为只有两个导弹系统，所以我们考虑用第一套拦截较小范围的，第二套拦截较大范围的 在用到第一套系统的距离进行排序，然后依次枚举即可 5 | P1190 接水问题[NOIP2011PJ]P1190接水问题[NOIP2021PJ] [普及-] 这题就真的是老水题了，模拟一下接水过程即可 6 | P1309 瑞士轮[NOIP2011PJ]P1309瑞士轮[NOIP2011PJ] [普及/提高-] 这道题是一个很典型的归并排序 主要思路就是每次维护赢家和输家两个数组，然后在每次比赛之后进行归并 在最一开始使用sort排序一遍，然后每次比赛完之后merge即可 PS：STL中是有merge的： merge函数的作用是：将两个已经排好序的序列合并为一个有序的序列 函数参数：merge(first1,last1,first2,last2,result,compare); 实际上就可以这样用： 1234inline bool cmp(int x,int y){return x&lt;y;}int a[114514],b[114514],c[114514];...merge(a+1,a+114514,b+1,b+114514,c+1,cmp); 7 | P1982 小朋友的数字[NOIP2013PJ]P1982小朋友的数字[NOIP2013PJ] [普及+/提高] 我直接推荐第一篇题解 8 | P1095 守望者的逃离[NOIP2007PJ]P1095守望者的逃离[NOIP2007PJ] [普及/提高-] 能闪则闪，否则就走，若能力值够了就恢复，最后将本次的值进行比对， 看是这次 走 快还是 停下来恢复 或 闪 快 9 | P2398 GCD SUMP2398 GCD SUM [提高+/省选-] 设$f_i=\\gcd(i,j)=k$ $g_k$为能被k整除的$\\gcd(i,j)$的个数 很明显就有$g_k=\\sum\\limits_{t=1}^nf_{t*k}$，因此$g_k=\\lfloor\\frac{n}{k}\\rfloor^2$(对于i有floor（n/k）种，对于j也一样) 10 | P1390 公约数的和P1390公约数的和 [省选+/NOI-] 思路和上一题基本一致，最后答案输出时$\\frac{ans-k}{2}$即可，其中$k=\\frac{n(1+n)}{2}$ 11 | P1541 乌龟棋[NOIP2010TG]P1541乌龟棋[NOIP2010TG] [普及+/提高] 很明显的一个DP题，且方程是比较好推的 由于题目中说了一共只有4种卡牌，且对于100%的数据：每种牌的数量都小于等于40 因此我们可以开4维数组，$f_{xyzw}$代表分别用x张1，y张2，z张3，和w张4所能得到的最大值 那么就可得出方程：$$f_{xyzw}=max{f_{xyzw},f_{x-1yzw}+a_{x+2y+3z+4w},f_{xy-1zw}+a_{x+2y+3z+4w},f_{xyz-1w}+a_{x+2y+3z+4w},f_{xyzw-1}+a_{x+2y+3z+4w}}$$当然，前提是保证计算$x-1,y-1,z-1,w-1$时，对应的$x,y,z,w$都不为0 12 | P3842 线段[TJOI2007]P3842线段[TJOI2007] [普及/提高-] DP，在这里是设置了二维的一个状态，$f_{i,0}$表示从第i行最左端开始走的最短路径长度，$f_{i,1}$则是到第i行最右端开始走的最短路径长度 那么除了第一行外，当前的从左端点开始走的最短的路径就是上一行的对应的左端点+上一行的线段的左端到这一行的线段的右端的长度+这一行的线段长度+1。或者是从上一行的右端点来（计算方法同理，将左端点改为右端点即可）。 当然，从右边开始同理。 那么状态转移方程就是这样的：$$f_{i,0}=\\min{f_{i,0}+dis{x_{i-1,0},x_{i,1}}+dis{x_{i,0},x_{i,1}},f_{i-1,1}+dis{x_{i-1,1},x_{i,1}}+dis{x_{i,0},x_{i,1}}}+1 \\f_{i,1}=\\min{f_{i,0}+dis{x_{i-1,0},x_{i,0}}+dis{x_{i,0},x_{i,1}},f_{i-1,1}+dis{x_{i-1,1},x_{i,0}}+dis{x_{i,0},x_{i,1}}}+1$$ 13 | P2016 战略游戏P2016战略游戏 [普及/提高-] 一个最为基础的树形DP 通过观察样例我们可以发现：实际上只需要考虑对于某个节点，我们只需要考虑这个节点要不要放士兵即可 那么我们每次取放/不放的最小值即可 14 | P1359 租用游艇P1359租用游艇 [普及-] 树形DP，先存边，然后遍历n的上游和i的下游节点，比较路径长度即可 15 | P1122 最大子树和P1122最大子树和 [普及/提高-] 树形DP，先存边，然后进行两个DFS 16 | P1747 好奇怪的游戏P1747好奇怪的游戏 [普及/提高-] BFS，做这道题的初衷是为了复习一下搜索，感觉自己快忘了 最一开始提交竟然WA，原来是BFS第二个时把BFS(X2,Y2)错写成了BFS(X2,Y1)，草（一种植物+中日双语） 17 | P1746 离开中山路P1746离开中山路 [普及/提高-] BFS，和上面那道题基本一致 简单的打了一遍模板，修改几个参数就好了（ 18 | P2615 幻方[NOIP2015TG]P2615幻方[NOIP2015TG] [普及-] 不是吧2015年的D1T1就这么水 做题的初衷是为了完成任务 一眼知模拟，所以就按照条件简单做就行 因为数组表示起来不是很好想，直接放弃使用数组下标 选择用结构体，求每个数字的坐标，最后再赋值给数组以便输出，中间走样例炸了一次，是没做位置是否有数的判断，因为懒得再去大改，而且这题范围允许，就维护了一个bool数组 做的时候觉得应该能煺柿子，AC完一看题解，还真有公式啊 19 | P2298 Mzc和男家丁的游戏P2298Mzc和男家丁的游戏 [普及/提高-] BFS，和前面的P1746思路基本一致，典型的迷宫+BFS，维护一个dis数组即可 但是分析的时候错误的打了个else导致我调了二十分钟？？？ 20 | P1332 血色先锋队P1332血色先锋队 [普及/提高-] 看完题面第一反应：好！我是叛徒 BFS，但不完全是BFS板子，这是多起点多终点的 啊那就直接把起点全部压进队列去不就行了么 然后更新dis，最后按照顺序输出即可 然后我因为BFS函数没调用查了≈40min？？？ 感谢！已经气懵了 21 | P1141 01迷宫P1141 01迷宫 [普及-] 别看这是一道普及-，这题可比前面的5道题强多了 首先输入需要用字符串，迷宫类问题常规操作，还行 然后这题如果直接按照输入数据一组一组的BFS的话最多拿70pts，会TLE三个点 那么我们考虑计算连通块，然后输出要查询的点所在的连通块的大小即可 22 | P1162 填涂颜色P1162填涂颜色 [普及-] 哦，又是一道普及- 这道题做法很多，我在这里考虑DFS 因为在题目当中0有两个意思，所以将他们换成不同的数字在进行分析 但是不能直接DFS，那样会把边缘误涂，应该先DFS一边边缘，再进行正常DFS，所以最一开始输入的是DFS(0,0) 23 | P1683 入门P1683入门 [普及-] 哦，双是一道普及- 这道题显然的DFS，甚至还不用回溯，找到起点直接DFS即可 24 | CF414B Mashmokh and ACM洛谷：CF414B Mashmokh and ACM [普及/提高-] CF：Codeforces Round #240(Div.1) ##B 搜索做累了，水一个DP 由于对于一个数而言，它的因数并不好枚举，所以在这里考虑倒退，即去推某个数的倍数 25 | P1586 四方定理P1586四方定理 [普及/提高-] DP，状态很好想，是一个类似部分背包 由于是多组数据，可以先预处理，然后把输入的数据的f[n][1~4]加起来就行 26 | AT1350 深さ優先探索AT1350 深さ優先探索 [普及/提高-] 顾名思义，这是AtCoder的DFS模板题，锻炼一下DFS用的 27 | P1387 最大正方形P1387最大正方形 [普及/提高-] 智能推荐的题，DP 由于给了图，而且n和m都小于100，所以上手模一下图大概的柿子就有了 本题实际上只需要对数值是1的点进行操作，所以以当前这个点为顶点的最大的不含0的正方形的边长就是它的上，左，左上端点的最小值再加一，柿子大约就是：$$f_{i,j}=\\min{f_{i-1,j},f_{i,j-1},f_{i-1,j-1}}+1$$ 28 | P1157 组合的输出P1157组合的输出 [普及-] DFS，但是我白给了，完全不会DFS.jpg 实际上思路很好想，从1开始搜，然后搜每一个能符合的下一个数，如果当前搜到的位数大于r了，就输出+回溯 但是我就是不会打（ 最一开始看到这个题突然想起来有个东西叫做next_permutation，然后看本题的推荐题目，发现有一道裸的输出全排列（P1706全排列问题 [普及-]），就顺便用这个STL函数搞了一下 29 | P2372 yyy2015c01挑战算周长哦我又双叒叕在DFS上面白给了 P2372yyy挑战算周长 [普及-] DFS，一上来就读不懂题，样例都看不懂 看了一眼题解发现原来是对于每个中心的X，只有它的上下左右才算周长，否则不算（比如说角上就不算） 30 | P1681 最大正方形IIP1681最大正方形II [普及/提高-] 是刚才上面那道题的变式，实际上只需要多开一维数组来表示当前是0还是1了 这个数据范围搞得我严重浪费评测机资源 31 | P2426 删数P2426删数 [普及/提高-] 区间DP，我没见过 准确来说是我忘了，但是看题解说这个题比较水 不过也确实比较水，因为从头上删除和从尾删除到了最后应该是等价的（也就是从头上删除的最优解留下来的部分也正是从尾端开始的最优解） 最一开始过不了样例，因为我把求值的公式打错了（谁让题面上没用$\\LaTeX$呢) 看到样例答案突然就想讽刺一下膏通的某挤牙膏SoC 32 | P1036 选数[NOIP2002PJ]P1036组合的输出 [普及-] 一道NOIP的上古题目 DFS，和昨天那个组合数类似，都是确定当前数字的基础上确定下一个数 本来是想打一手欧拉筛预判一下，结果发现不是很好用，于是乎打完就去掉了，换成了试除法 33 | P1063 能量项链[NOIP2006TG]P1063能量项链[NOIP2006TG] [普及+/提高] 众所周知这是某本书的区间DP的例题，但我没看那本书的区间DP 好久没做绿题了 区间DP，首先这题数据是个环，我们需要破环成链，实际上只需要在数组里面再复制一遍数据就可以 我们从中间选一个点k，然后每次比较i到j的原值大还是从中间选一k点得到的值大 最后找一个最大值即可 34 | P1605 迷宫P1605 迷宫 [普及-] 不是吧不是吧不会这个题也有人不会吧 Dfkuaid_First_Search，实际上就是每次扩展结点简单DFS即可 但是我最一开始忘了判断是否越界&amp;起点设置为已经过而WA 说明我DFS还是8行 35 | P1005 矩阵取数游戏[NOIP2007TG]P1005 矩阵取数游戏[NOIP2007TG] [提高+/省选-] 终于是把我主页智能推荐天天在推荐的题调出来了 实际上是一个区间DP，我们每行维护一个最大值，最后加起来即可 对于每一行的每一个数，当要去掉的数到它时，它的最大值一定来自它的左边或右边，因为只能从两头进行操作 然后就是高精度，感谢，已经快敲死了 实际上第一次模着题解写对了99%，但是当把每一行的最大值加入ans的时候忘了给每一行的最大值赋值时清空了:joy: 36 | P1019 单词接龙[NOIP2000TG]注意：本题为上古 NOIP 原题，不保证存在靠谱的做法能通过该数据范围下的所有数据。 P1019 单词接龙[NOIP2000TG] [普及/提高-] 一道比较巨大的DFS，很考察细节，思路不难想，问题是怎么一点一点的把细节抠出来 37 | P4170 涂色P4170 涂色 [普及+/提高] 说实话好久没做题了 这个题是一个区间DP，考虑一个特殊的判断，即为枚举到相同时直接继承，剩下的就是经典的区间DP，枚举一个断点进行计算 38 | P2014 选课[CTSC1997]P2014 选课 [普及+/提高] 一看年份就知道是一道上古的CTSC题目，我们先来看这个题面 题面中提到很多课程都会有其预备课程，然后再根据本题输入的数据的特点是输入0即为没有前继节点，于是这句话可以翻译为：这是一棵根节点为0的树 没错，这道题分析到这里就应该能看出来是树形DP了 首先是进行常规操作，用邻接表来存下这些边，生成一棵树 于是我们就从最小内容的节点开始拓展（递归），也就是从 Root 开始DP 这里设计的方程是 $ f[j][k] $ 是指前 j 个节点选了 k 节课，我们可以从根节点开始，顺着树进行DP（DFS） 39 | P2015 二叉苹果树P2015 二叉苹果树 [普及+/提高] 顾名思义，这是一颗树，并且还是二叉树 这里推荐一篇54级学长的[树形DP入门] 学长讲的真的挺好的，推荐去看 HD只能在这里粗略的重复一遍，实际上就是考虑到每个节点的数据都是由他的子节点传递过来的，因此我们在找方程的时候就要找当前节点和它的子节点的传递/递推关系 40 | P2880 Balanced Lineup G + P2251 质量检测Balanced Lineup G 质量检测 之所以把这两个题放在一起，就是因为这都是ST表的板子题，前者只需在ST表板子的基础上维护一个最小值，然后查询的时候输出 max-min 即可 后者只是把查询的区间改为了一个规定的柿子，传参的时候注意一下就可 41 | P1816 忠诚P1816 忠诚 [普及/提高-] 我是真的没想到ST表居然这么多板子题（虽然说相比于并查集少了很多） 这个就是把模板的max改为min即可，因为ST表在维护最大值和最小值的时候原理是一致的 42 | P1040 加分二叉树[NOIP2003TG]P1040 加分二叉树 [普及+/提高] 这个题是一个长得像树形DP的区间DP 数据只给出了中序遍历，因此我们不能确定树的样子，再加上我们最后要输出能够得到最大加分的树的先序遍历，于是我们就着手与在这里设计方程 用 $f[i][j].a$ 来表示从编号 i 到 j 这些点形成的最优二叉树（即分数最大），因为我们还有输出这棵树，所以我们在进行状态转移的时候还需要记录刚才那棵树的根节点，保存到 $f[i][j].r$ 中 根据题目加分的原则，我们再枚举一个区间变量 k 去找这个最大值，我们可以得到下面的状态转移方程 $$f[i][j].a=\\max(f[i][k-1].a \\times f[k+1][j].a + f[k][k].a)$$ 根据我们设计的方程，最后再输出 $f[1][n].a$ 以及以 $f[i][n].r$ 为根节点的二叉树的先序遍历即可 43 | P1440 求m区间内的最小值P1440 求m区间内的最小值 [普及/提高-] 这个题一眼单调队列（滚动数组），就比模板还简单 但是这题题意不清楚，题目中说到的”求出每一项前的 m 个数到它这个区间内的最小值”中，这个区间是前闭后开的（ PS：最近做了一些模板题，可能会写个汇总 谁让今天洛谷给我智推五道板子题呢（笑） 44 | P1638 逛画展P1638 逛画展 [普及/提高-] 简单来说这也是个单调队列的题，因为我们只需要保证区间内每个作家有至少一幅画，所以当一个画家的画出现了两次之时，可以直接让前面那个出队，毕竟保留它并不会更优 45 | P1901 发射站P1901 发射站 [普及/提高-] 总之来说，就还是维护一个单调队列，保证能量能传的最远，所以要保证后入队的塔比前面的矮 46 | P3146 248 GP3146 248 G [普及+/提高] 我是真的不敢相信这题是绿的 实际上这道题说起来是要比石子合并简单的，因 为这题的转移方程仅仅是f[i][j]=max(f[i][j],f[i][k]+1) 注意在合并的时候要判断两者必须相同且均不为 0 47 | P1714 切蛋糕P1714 切蛋糕 [普及+/提高] 这是我做的第40道绿题！ 这道题本质上让人一眼想暴力，但是50w的范围很明显会Time Limit Enough 于是我们就有两个出路,线段树(具体我不会搞,kkk说的能搞)或者维护个单调队列 我这是第一次用STL的deque,大体思路就是满足条件就进队(进队的元素是前缀和),每次和当前ans进行比较,选取大的那个 由于输入的Pi可能是负数,所以ans最一开始要初始为一个负数(我选的-114514) 最后得到的一定就是最优解了 48 | P6599 异或P6599 异或 [普及/提高-] 由于我太懒了,建议直接看DX的题解 其实是写完题之后去整了整AFOed的同学的链接,唉…… 49 | P4391 Radio Transmission 无线传输[BOI2009]同上,简单说一下吧,相当于KMP的小扩展形式 50 | P6051 求和P6051 求和 [普及/提高-] 说实话这题不是很难 如果是经常用快读的同学们应该知道，快读的本质就是读取字符，因为getchar()读取效率更快一些 而本题就是从字符串中读取出来数字再进行求和，我这边直接用快读读入的话可以发现它是能读出来所有数字 于是可以直接从快读的基础上进行更改，多维护一个变量来求和即可 51 | P1083 借教室[NOIP2012TG]P1083 借教室 [普及+/提高] 暴力很好想，直接打就行，就是只有45pts（ 正解是差分+二分查找答案 52 | P2420 让我们异或吧P2420 让我们异或吧 [普及/提高-] 这道题稍微一看题解区就会发现什么做法都有 我这里选用的是披着 LCA 名字的 DFS ，因为题目是说两点之间的路径上所有边的边权的异或值，所以就相当于是这两点分别到 LCA 的边权异或值的异或值 由于本题过水，所以我们甚至只需要直接一共 DFS 预处理出每个点的 LCA 以及其对应的异或值即可 53 | P1351 联合权值[NOIP2014TG]P1351 联合权值 [普及+/提高] 我们联合！ 两面包夹芝士！ 这个题首先告诉我们了一个信息：这是一棵树 再根据题意，两个能联合的点之间必然有一个点 于是我们可以枚举这个中间点，扩展一边它周围的边，就能算出来最大的联合军费，一步步枚举，就可以算出联合军费之和 54 | P1613 跑路P1613 跑路 [普及+/提高] 确实，我要跑路了 这个题很显然要用到最短路，我们可以这样想：把能用跑路机的两个点之间（2^n^）的边连为 1 ，接下来就无脑 Floyd 55 | P1168 中位数P1168 中位数 [普及+/提高] 这道题题意非常易于理解，我第一反应是每次输入的时候 sort 一下，但是仿佛这复杂度会立即炸掉 于是突然想起 vector 的 insert 的复杂度是 $O(n)$ 好像能使（ 于是就把 upper_bound + insert 合起来用了（ 隔壁的 Dfkuaid 默默拿出一手权值线段树，这玩意效率比 vector 强多了，但是我不会:D 56 | P1853 投资的最大效益P1853 投资的最大效益 [普及/提高-] 算是复习一下背包，这是一个完全背包 就是多开了一层循环，要遍历年数 这题最离谱的是给的 $s \\le 10^6$ ，但是数组开 1e6+5 还不够，需要 1e7 …… 57 | P2918 Buying Hay SP2918 Buying Hay S [普及/提高-] 这题真是把我整笑了，就一个裸的完全背包 但是因为我赋的初始值不够大就 WA 了一页…… 58 | P5365 英雄联盟[SNOI2017]P5365 英雄联盟[SNOI2017] [普及+/提高] 简单来说是一个多重背包，但是我们里要考虑的东西多了不少（ 这里的钱的总数需要乘一下 Dfkuaid 是一样的方程却下溢出了，咱也不知道为什么我没有溢出 不过加上防止下溢出的 if 之后，我开 O2 能跑到最优解第一页了（虽然是最后一个） 59 | P2347 砝♂码称重[NOIP1996TG]P2347 砝♂码称重[NOIP1996TG] [普及-] 这题，屑题，不讲 60 | P1832 A+B Problem 再升级P1832 A+B Problem 再升级 [普及-] 这个题先欧拉筛一遍质数然后完全背包 61 | P1244 青蛙过河[NOI2000]P1244 青蛙过河[NOI2000] [普及-] 这就是2000年的 NOI 的水题吗 这个题显然发现有这样一个柿子： $f[i]=\\sum\\limits^{i-1}_{j} f[j] $ ，其中 $f[0]=k+1$ 然而这样也就告诉我们根本不需要数组 f ，所以我是直接使 k++ 然后乘 这也是我的第 100 道橙题 62 | P2370 yyy2015c01 的 U 盘P2370 yyy2015c01 的 U 盘 [普及/提高-] 总之来说是 01背包 之前排序一下即可 有了 O2 以及快读快输常数小的优势，拿了第 6 优解 63 | P2904 River Crossing SP2904 River Crossing S [普及/提高-] 这个题数据一看就非常水吧，就 2.5k 的 n …… 最一开始算一个前缀和 + 完全背包即可 又是由于常数小，拿了第 11 优解，诶嘿 64 | P1631 序列合并P1631 序列合并 [普及+/提高]f这个题，题面确实对我来说有点迷，就是那种，读懂了但是没完全读懂的感觉…..就是，你懂！ 强迫文学奖 这个题有一点非常好的就是题目给出的数据已经排好序了，因此我们不必再次排序 由于题目中说到要输出最小的 N 个，那么很容易想起来要维护一个小根堆，这里我用的 priority_queue ，单纯是因为懒，而且太久没手写堆了 可以假定这两个序列选择时是有先后的，于是我们最一开始让 a1 + bi 入队，然后一个个出队，再把 a2 + bi 入队，直到到达要求 为了记录是扔进去的是第几个 b ，这里在 pq 里用 pair 还存了填入的 b 的编号 65 | P5020 货币系统 [NOIP2018TG]P5020 货币系统 [NOIP2018TG] [普及+/提高] 题面可以说是看起来比较难受，这里直接简述一下 个人理解就是要找一个新的由 m 种货币组成的货币系统，要保证它和给你的那个货币系统是等价的 我看了一眼 Tag 发现是有背包之后 果断想到这个貌似是完全背包的样子！ 于是就往完全背包上面凑，设了一个 fx 来表示 x 能不能被表示出来，然后显然在状态转移的时候，需要判重，不让这个 m 在一个价钱上被重复加 状态转移方程就是 f[j]=f[j-a[i]]; 66 | P6771 Space Elevator 太空电梯P6771 Space Elevator 太空电梯 [普及/提高-] 这个题显然是和背包有关，而且是多重背包，这里我采取的状态转移方程是 f[x]|=f[x-h[i]] 67 | CF189A Cut RibbonCF189A Cut Ribbon [普及/提高-] 显然这题橙题水准，但是众所周知 CF 题都是恶评，即使这是 A 就是一个完全背包板子… 所以试图拿最优解，但是很明显我不够格（ 68 | CF417A Elimination写了题解，希望能通过，毕竟我到现在咕值只有练习分和信用分 题解在这里 (UPD:题解已经过了！) 69 | P1941 飞扬的小鸟 [NOIP2014TG]P1941 飞扬的小鸟 [NOIP2014TG] [普及+/提高] 哇这题真的是……令人害怕，2014 TG 就这么恐怖，觉得自己 2021 可能要挂（ CSP 2021 &amp; NOIP 2021 RP++ ! 这个题细节多的离谱，这也是我做到现在觉得应该放代码的一道题（虽然已经变成了题解的样子（ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;#define Heriko return#define Deltana 0#define Romano 1#define S signed#define U unsigned#define LL long long#define R register#define I inline#define D double#define LD long double#define INF (LLONG_MAX-114)#define mst(a, b) memset(a, b, sizeof(a))#define ON std::ios::sync_with_stdio(false)using namespace std;I void fr(LL &amp; x){ LL f = 1; char c = getchar(); x = 0; while (c &lt; '0' || c &gt; '9') { if (c == '-') f = -1; c = getchar(); } while (c &gt;= '0' &amp;&amp; c &lt;= '9') { x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); } x *= f;}I void fw(LL x){ if(x&lt;0) putchar('-'),x=-x; static LL stak[35]; LL top=0; do { stak[top++]=x%10; x/=10; } while(x); while(top) putchar(stak[--top]+'0'); putchar('\\n');}const int MXX=10005;LL n,m,k,h[MXX],l[MXX],f[MXX][1005],t,fans[MXX],ans,x[MXX],y[MXX];bool o[MXX];S main(){ fr(n),fr(m),fr(k); for(R LL i=0;i&lt;n;++i) fr(x[i]),fr(y[i]); for(R LL i=1;i&lt;=k;++i) fr(t),fr(l[t]),fr(h[t]),o[t]=true; for(R LL i=0;i&lt;=m;++i) f[0][i]=0; for(R LL i=1;i&lt;=n;++i) f[i][0]=INF; for(R LL i=1;i&lt;=n;++i) { fans[i]=INF; for(R LL j=1;j&lt;=m;++j) f[i][j]=INF; for(R LL j=x[i-1]+1;j&lt;=m;++j) f[i][j]=min(min(f[i-1][j-x[i-1]],f[i][j-x[i-1]])+1,f[i][j]); for(R LL j=m-x[i-1];j&lt;=m;++j) f[i][m]=min(f[i][m],min(f[i-1][j],f[i][j])+1); for(R LL j=1;j+y[i-1]&lt;=m;++j) f[i][j]=min(f[i-1][j+y[i-1]],f[i][j]); if(o[i]){for(R LL j=1;j&lt;=l[i];++j) f[i][j]=INF;for(R LL j=h[i];j&lt;=m;++j) f[i][j]=INF;} for(R LL j=1;j&lt;=m;++j) fans[i]=min(f[i][j],fans[i]); if(fans[i]==INF) { ans=0;for(R LL j=1;j&lt;i;++j) if(o[j]) ++ans; fw(0);fw(ans); Heriko Deltana; } } fw(1); fw(fans[n]); Heriko Deltana;} 70 | P2938 Stock Market GP2938 Stock Market G [普及+/提高] 这个题和之前的一道投资的题（# 56 ）基本一致，基本就是完全背包小变形，思路基本一致，可以直接去看那道题 PS：这题最一开始跑出 4.6s 把我吓着了，然后开 O2 就 722ms ，于是我觉得能卡卡，现在是卡到 609ms 拿到第 12 优解，欸嘿 这貌似是我的第 50 道绿题 71 | P1782 旅行商的背包P1782 旅行商的背包 [提高+/省选-] 我直接宣布这是我这几天做过最迷幻的题目 上来一看这显然是个背包，前 n 个是多重背包，后 m 个是完全背包 前 n 个直接打一个二进制优化，先搞♂一边 f ，然后直接暴力三层循环求后 m 个 最一开始数组开的 2e4+5 ，有 RE ，本着 RE 我就超级加倍的原则，一直到 6e4+5 和 8e4+5 ，RE 没了，拿了 80pts 本来想着就直接去看看能不能优化，最后试了一次 1e5+5 欸，就很离谱，过了，然后发现仿佛卡卡 + O2 能进最优解第一页，然后就卡，最后进去了 别的我不知道，但是为什么同样是 1.14s ，却不一样优？ 72 | P1858 多人♂背包P1858 多人♂背包 [提高+/省选-] 这个题的题面就非常离谱，不光告诉你了这题要算啥，还告诉你这题每个背包要装满….. 奇妙的是 memset 只能是 128~4000+ 就非常离谱，我测试了半天都不知道是干啥了 就是在 01背包 的方程上多加了一维变成 $f[i][j]$ ，第二维代表是第 j 优解，然后因为告诉你要算每个背包装满之后的和，因此在转移的时候就是把 max 改为 sum 提交的时候直接开的 O2 ，直接进最优解第一页 73 | P1198 最大数[JSOI2008]P1198 最大数[JSOI2008] [普及/提高-] 这个题有许多的做法，比如 ST表，树状数组，线段树，分块，单调栈+并查集…… 我选择的是树状数组，因为它代码比较少， 写一个 add 和 query 就行。 123456789101112131415I LL query(LL l,LL r){ LL ans=0; while(l&lt;=r) { if(ans&lt;num[r]) ans=num[r]; for(--r;r&gt;=l+lowbit(r);r-=lowbit(r)) if(ans&lt;tree[r]) ans=tree[r]; } Heriko ans;}I void add(LL x){ num[++n1]=(x+t)%mod; tree[n1]=max(num[n1],query(n1-lowbit(n1)+1,n1-1));} 比较恶心的是这题不能用 scanf(&quot;%c&quot;,&amp;ch); ，用了就 RE 。 74 | P1417 烹调方案P1417 烹调方案 [普及+/提高] 这个题显然的是一个 01 背包的问题，但是这里的费用是会随着时间而改变的， 因此应该比较好想到要先排序一下以保证我们在状态转移的时候是最优的。 然后就是自然的 O1 背包。 75 | P1531 I ↑ Hate ↓ It ↑P1531 I ↑ Hate ↓ It ↑ [普及/提高-] 线段树，甚至比板子还简单就非常离谱。练练板子（ 76 | P1883 函数 &amp; UVA 1476 Error CurvesP1883 函数 [普及/提高-] UVA 1476 Error Curves [普及+/提高] 两个基本一样的题，评分居然不一样（ 这个写了题解，链接放在这。 在 76 和 77 之间略去了一堆不知道有啥好说的 DS 板子题。 77 | P3870 开关 [TJOI2009]P3870 开关 [TJOI2009] [普及/提高-] 其实这也是个线段树的板子，就是想说一点。 这个题每次进行操作的时候相当于是把开着的灯的总数和关着的灯的总数对调了一下。 78 | P1471 方差P1471 方差 [提高+/省选-] 这个题我摸了一下午…… 太累了先题解先摸了。（略略略 79 | P2412 查单词P2412 查单词 [普及/提高-] 我做过最™骚的线段树！ 真没想到还有这种线段树，开眼了，甚至一个黄题调了一晚上！ 大约就是把线段树里维护的东西变为原字符串和比较字符串（因为题目中说字符串在比较的时候要求不考虑大小写，所以我们应当将原字符串统一转为大 / 小写才能比较）。 不过最离谱的是这个题还卡时间于是我不敢用 string ，于是就用 char 数组，但是 char 数组的比较和赋值不像 string 那么简单，需要用到 strcmp 和 strcpy ，可把我恶心坏了（ 80 | P2434 区间 [SDOI2005]P2434 区间 [普及/提高-] 差分yyds！ 77A | P2574 XOR的艺术P2574 XOR的艺术 [普及/提高-] 之所以是标的 77A 而不是 81 ，就是因为这个题和 上面的 # 77 是一样的，就是改了个输入。 甚至交错了代码（ 77B | SP7259 LITE - Light Switching77C | P2846 [USACO08NOV]Light Switching G77D | P5057 [CQOI2006]简单题彳亍！ 77 是五倍经验题！ 81 | P1972 HH的项链 [SDOI2009]P1972 HH的项链 [SDOI2009] [提高+/省选-] 这道题是非常适合锻炼树状数组的（ 首先观察这个题要进行区间的查询，然后看到数据范围是 1e6，于是我就想到了线段树和树状数组。 再因为这个题没有说到要区间修改，我就直接选择了码量比较少的树状数组去离线做。 我们考虑，因为是问某个区间内的种类个数，所以我们其实对于一个种类可以只记录一个特殊的位置，这里参考抄袭大佬们的做法是记录每个查询区间最右的每个种类，然后就是正常的树状数组。 我们再更新位置的时候，从左向右遍历。之前若是记录过位置的，把那个记录的位置的前缀和 -1，把现在这个枚举到的位置的前缀和 +1。最后只需再更新位置以及答案。 最后按照询问的顺序进行输出即可~ UPD 2021.7.8 SP 3267 和这题一样（ 82 | P1966 火柴排队 [NOIP2013TG]P1966 火柴排队 [NOIP2013TG] [提高+/省选-] 这个题思想非常之巧妙，虽然我想了半天没想出来，爬了就是了。 最一开始搞了个瞎搞的玩意，放在最后说，反正全 WA（ 这个题利用了一个很巧妙地东西就是这里树状数组维护的是一个“符合数列”的下标，然后求的这个数组的逆序对个数。 这很像很久之前做的某个求最长公共子序列的 DP 题。 下面放一下代码核心部分，毕竟还是很妙的。。 1234567891011121314151617I bool cmpa(LL x,LL y){Heriko a[x]&lt;a[y];}I bool cmpb(LL x,LL y){Heriko b[x]&lt;b[y];}...S main(){ fr(n); for(R LL i=1;i&lt;=n;++i) da[i]=db[i]=i; for(R LL i=1;i&lt;=n;++i) fr(a[i]); for(R LL i=1;i&lt;=n;++i) fr(b[i]); sort(da+1,da+1+n,cmpa);sort(db+1,db+1+n,cmpb); for(R LL i=1;i&lt;=n;++i) qq[da[i]]=db[i]; for(R LL i=n;i&gt;=1;--i) ans+=query(qq[i]-1)%mod,modify(qq[i],1); fw(ans%mod); Heriko Deltana;} 然后我瞎搞的做法就是类似于凑，算出来两列对应位置的差，然后依次判断两个是否为零，否则就消（ 能过样例就离谱…… 既然正确性不对那就不仔细说了~ 话说这里破 1k 行了呢（在我习惯性的空行的情况下）。 83 | P4933 大师P4933 大师 [提高+/省选-] 非常熟悉我的同学应该知道我为什么要做这道题（ 因为是等差数列，所以在区间内对公差进行枚举，每次更新。 不写更多的说明是因为我太菜了只会看题解不知道该说些啥（ 84 | P2303 Longge 的问题P2303 Longge 的问题 [提高+/省选-] 上来显然是要煺柿子： $$\\begin{aligned}\\sum\\limits_{i=1}^n \\gcd(i,n) =&amp;\\sum\\limits_{d|n} d \\sum\\limits_{i=1}^n [\\gcd(i,n)=d] \\=&amp;\\sum\\limits_{d|n}d\\sum\\limits_{i=1}^n [\\gcd(i,\\frac{n}{d})=1] \\=&amp;\\sum\\limits_{d|n}d\\varphi(\\frac{n}{d})\\end{aligned}$$ 然后我们枚举因数即可。 85 | P4145 上帝造题的七分钟 2 / 花神游历各国P4145 上帝造题的七分钟 2 / 花神游历各国 [提高+/省选-] 这个题要区间修改和区间查询，于是我就写了个线段树。 本来是想着能不能煺煺柿子用 LazyTag 去做，但是没煺出来，于是突然想着能不能暴力去做。一看数据 1e5，于是就直接去用线段树去维护区间最大值和区间和。 这里维护区间最大值的原因是，题目要求下取整，而我们知道不断开根的话这个值会趋近于 1，所以当这个区间最大值小于等于 1 的时候我们就不去修改了。 86 | P1382 楼房P1382 楼房 [提高+/省选-] 这个题算是线段树的一个变种，这个题可能是子节点运用的最充分的线段树？ 这个题上来需要先对数据进行离散化，然后在修改的时候改为确定单点修改。 现在真的是对我来说蓝题就难度上来了 87 | P1438 无聊的数列P1438 无聊的数列 [提高+/省选-] 这道题无聊，但是不完全有意思。 首先这道题一眼就是树状数组或者线段树，可惜我不会用树状数组解决这，就爬线段树。 看了一眼 Tag 发现这道题有个“差分”，于是就思考怎么把等差数列用差分数组⛏掉。 让差分数列来简化在区间 $[l,r]$ 上加等差数列的运算：在 $a_l$ 上加上首项，$a_{r+1}$ 上减去末项，中间加上公差即可。 然后就是线段树板子（ 88 | P2257 YY的GCDP2257 YY的GCD [省选+/NOI-] 这道题事一道要用到莫比乌斯反演的题（ 但是我不是很会就只能按照别人煺得柿子来算，还被卡了 long long …… 因为不想再打 $\\LaTeX$ 于是就截图力（ 89 | P2205 [USACO13JAN]Painting the Fence SP2205 [USACO13JAN]Painting the Fence S [普及+/提高] 扫描线 + 差分，前者用来判断当前线段是否加到要求的 k 以上，后者是简化在区间内加同一个数。 但是因为本题的数据范围不小，因此我们需要离散化，用每次经过的区间的端点来排序。 89A | P2070 刷墙P2070 刷墙 [提高+/省选-] 我们至今未能知道为什么这道题是蓝题而上面那道是绿题。 这个题只需要把上个题要输入的 k 改为 2 即可。 中间去学了一些平衡树，于是可能没太做什么题 90 | P7075 儒略日 [CSP-S2020]P7075 儒略日 [CSP-S2020] [普及+/提高] 做这道题的缘由有两个，第一个是想看看去年那个“远近闻名”的儒略日，第二个是想把这个题当作我 AC 的第 60 道绿题。 不得不说这道题是真的恶心，把这么一个搞人心态题放在 T1…… 大约就是使劲分类讨论，细节多的离谱…… 实际上把分类离清楚了，就很好想了。大约是分成这样几类：-4317 年 ~ 1999 年，一共是 2451545 天。 然后是 2000 年及以后的。 需要一个判断闰年的函数，以及判断下一天的函数（这个函数中需要考虑很多特判，比如跨公元前后和 1582 年，还有就是闰年，不过想清楚了还是很好打的） $\\texttt{main}$ 函数里还需要一些玄学操作…… 总之这道题在模拟难度上看我觉得至少是个蓝，绿有点低。 总之 $\\texttt{CSP2021 and NOIP2021 RP++}$ 罢。 91 | P7076 动物园 [CSP-S2020]P7076 动物园 [CSP-S2020] [普及+/提高] 感觉这道题才是名副其实的 T1，看起来题面非常的模糊，但是数据范围里的一个数据保证，就让人很快乐。 数据保证所有 $a_i$ 互不相同，所有的 $q_i$ 互不相同。 因此我们只需要考虑哪些是被要求过一定需要，否则就是一定没有，然后我们剩下的的部分中选取是 1 的位的个数即可。 因为问的是还能有多少，所以最后显然答案是 $\\texttt{ans-n}$。 这才是真正的 T1 啊，绿的合情合理，真是为去年把儒略日出在 T1 的人的家人担忧（ 总之 $\\texttt{CSP2021 and NOIP2021 RP++}$ 罢。 92 | P2184 贪婪大陆P2184 贪婪大陆 [提高+/省选-] 一眼树状数组+差分，但是最一开始假了。这样例也太水了点，最一开始以为直接用树状数组维护一个差分数组的前缀和就行，但是没想到这完全假掉。 但是还好大体的思路仍然是树状数组+差分，不过需要一些变通，为我们维护的东西变成了重叠数（也就是区间叠加数），把 $\\texttt{tree}$ 数组再开一维，表示以这个点为开头（0）还是结尾（1），最后输出 $\\texttt{Query(r,0)-Query(l-1,1),1}$ 即可。 其实就是建了两个树状数组分别维护区间头和区间尾。 93 | P5664 Emiya 家今天的饭 [CSP-S2019]P5664 Emiya 家今天的饭 [CSP-S2019] [提高+/省选-] 这题就离谱！调了一下午！ 大约思路就是统计不可行的方案的个数，然后 mod 减一下就是答案。 大约是看了题解里 Akarui 的思路。 94 | P2894 Hotel G [USACO08FEB]P2894 Hotel G [USACO08FEB] [提高+/省选-] 这道题显然是线段树去解，不过在这里要维护的东西很不一样。 因为是每次要从左端开始找，所以我们维护一个左端最大值，同时我们也要维护一个右端最大值，具体原因下面会说。 同时我们要维护当前有多少房间是有人住的（其实维护没人住的也行，毕竟区间是给定的），然后要维护一个最大值。 而我们的 Tag 就是表示当前要把这个区间修改为住或不住。 我们考虑到区间的最大值不一定会全部取自左右（这里说的左右是二分后的左右区间，也就是左右儿子），还可能跨过 mid，因此我们在更新最大值的时候，不光要把左右区间（左右儿子的最大值）考虑进来，还要考虑跨过中间的值，也就是这样： t[x].val=max(max(t[lc(x)].val,t[rc(x)].val),t[lc(x)].rmx+t[rc(x)].lmx); 95 | P4059 找爸爸P4059 找爸爸 [提高+/省选-] 写了题解，在这里（ 96 | P2341 受欢迎的牛 G [USACO03FALL] [HAOI2006]P2341 受欢迎的牛 G [USACO03FALL] [HAOI2006] [提高+/省选-] 这题目长度就离谱，这河南这么屑的吗，06 年省选出个 03 年 USACO 原题 这个题题目看上去就非常显然，Tarjan 缩点然后判断每个强连通分量内有几个结点（奶牛~） 96 | P3718 Alter [AHOI2017]P3718 Alter [AHOI2017] [普及+/提高] 不知道是 AHOI17 的第几道题，但是还是蛮水的。 大约经历就是从骗分到优先队列到二分正解。 最一开始的骗分因为觉得贪心贪的太拉就写了一半放弃了，然后就在我那个骗分的基础上写了个优先队列，然后在我交之前居然发现这玩意假了，然后就囸了一下题解写了个二分。 97 | P1896 互不侵犯 [SCOI2005]P1896 互不侵犯 [SCOI2005] [提高+/省选-] 算是状压的模板题罢，我们考虑用二进制数来表示我们的国王们都放在了哪里。 98 | P2756 飞行员配对方案问题P2756 飞行员配对方案问题 [提高+/省选-] 显然是二分图最大匹配，把外籍的飞行员放在左边，英籍的放在右边。 对于左边的每个点跑一边匈牙利即可。 99 | P1330 封锁阳光大学P1330 封锁阳光大学 [普及+/提高] 这道题的数据如果是个无向图可以用二分图的判定 DFS 来做，但是数据并没有保证图是联通的。 但是我们可以仍然去参考染色的思想，实际上 DFS 根本不用改太多，只不过每次染色的时候加上当前是染了什么颜色即可。 然后每次 ans 加上两个颜色中比较小的那个即可（因为我们要最少的河蟹）。 100 | P1129 矩阵游戏 [ZJOI2007]P1129 矩阵游戏 [ZJOI2007] [提高+/省选-] 是一道显然的二分图最大匹配！考虑到我们每次能够调换的是行和列，于是我们在输入时遇到 1 时就把 i 和 j+n 建边，然后正常的跑匈牙利，最后判断一下 ans&gt;=n 是否成立即可。 第 100 道题了！纪念一下： $$\\texttt{CSP2021 &amp; NOIP2021 RP++ !}$$ 101 | P2740 Drainage Ditches [USACO4.2]P2740 Drainage Ditches [USACO4.2] [提高+/省选-] 不得不说 USACO 的题在洛谷上的题名都好长…… 是一道网络最大流的板子题，$\\texttt{EK}$ 和 $\\texttt{Dinic}$ 都可以过，数据还贼水…… 102 | P1343 地震逃生P1343 地震逃生 [提高+/省选-] 又是一道网络最大流的板子题，这个数据范围也是 $\\texttt{EK}$ 和 $\\texttt{Dinic}$ 都可以过，不过为了保险起见，还是写了 $\\texttt{Dinic}$ 。 这个题就一点和 # 101 以及板子不一样：最后要判断一下 maxflow 是不是为 $0$ 来看能不能到达终点。 还有就是为什么不行就要输出 $\\texttt{Orz Ni Jinan Saint Cow!}$ 啊（ Bing 翻译过来是 “大麦尼济南圣牛！”？？？？ 难不成是“Orz 您济南神犇？” 103 | SP300 &amp; UVA1660 Cable TV NetworkSP300 Cable TV Network [省选+/NOI-] UVA1660 Cable TV Network [省选+/NOI-] 这 $\\texttt{SPOJ}$ 和 $\\texttt{UVA}$ 的重题率是真的高…… 直接把我紫题整到 10 AC 祭~ 好了不说废话，我写的题解放在这里了。 104 | P2055 假期的宿舍 [ZJOI2009]P2055 假期的宿舍 [ZJOI2009] [提高+/省选-] 显然是要用到二分图最大匹配，于是我决定就用匈牙利来做（ 这个题麻烦的是有很多的约束条件，不过建模还是比较好想的，左边为人，右边是床。 最一开始我在 $\\texttt{match}$ 的时候一次双向，然后卡 70pts 卡的我很懵。 其实这是不对的啊，这毕竟不是飞行员配对，我们总不能让床睡在人上罢（ （其实这样对不对好像也和存图的方式有关，我直接一个二维数组模拟邻接表存图就貌似不行） 105 | P3522 TEM-Temperature [POI2011]洛谷 | P3522 TEM-Temperature [POI2011] [提高+/省选-] LOJ | #2164. [POI2011 R2 D2] 气温Temperature （推荐去 LOJ 做，有更好的翻译和更强的数据） 是单调队列题（ 这个题和普通的单调队列不一样的点在于这道题给出的是一个区间，要求你求出最长的不下降天数。 枚举 i 进队的时候考虑如下两点： 如果第 i 天的最高温度小于当前队首的最小温度，将队首出队。 如果当前队列中最低温度最高的天不在队首，就把他调至队首（让队尾出队）。 待这两个条件全部考虑完之后，让第 i 天进队。 那么如何计算连续的天数呢（ 不知道。 最一开始确实是不知道，题解里面说到，在这几天之前的那一天一定是出队的，于是连续的天数就是 i-q[hd-1] ，然后每次和 ans 取个 $\\min$。 最一开始不会算连续天数，于是就莽着去搞连续的出入队关系，最后居然还把样例搞过了，然后放在 LOJ 上一看，假了…… 今天逐渐的开始用起来 LOJ，确实是环境要比洛谷干净的多，评测机跑的比香港记者还快，于是从这道题开始部分题会加上 LOJ 的题目链接，不过还是以洛谷为主。 106 | P3512 PIL-Pilots [POI2010]洛谷 | P3512 PIL-Pilots [POI2010] [提高+/省选-] LOJ | [POI2010] 驾驶员 Pilots 还是一道单调队列（话说为什么学长光扔单调队列题啊） 因为题目要求是最大值和最小值的差的绝对值不超过 $k$，于是我们就要去时刻维护区间最大值和最小值，所以我们要用 ST表 单调队列。 考虑维护两条单调队列，一条是最大值的单调队列，另外一条是最小值的，都是入队的时候常规的单调队列判断。 只不过有一点需要特殊关注：当任意一条队列中只剩下一个元素的时候，将另外一个队列的队首出队，然后记录这个刚刚出队的元素。 107 | P2841 &amp; P1402 &amp; P1231洛谷 | P2841 Dining G [提高+/省选-] 洛谷 | P1402 酒店之王 [省选+/NOI-] 洛谷 | P1231 教辅的组成 [省选+/NOI-] 都是网络流水题的样子，还是三倍经验的说~ 因为每个人（P1402） / 书（P1231） / cow（P2841） 的需求都是两个，而且只能选一次，于是我们就把 人 / 书 / cow 拆成两个点，自己连起来，然后再和其要求连接起来。然后经典人连源点，需求连汇点，然后跑 Dinic。 108 | CF438D The Child and Sequence洛谷 | CF438D The Child and Sequence [提高+/省选-] 话说这题目翻译过来就是“孩子和序列” 线段树的裸题，看似区间取模的复杂度难搞而且没有什么区间性质，但是我们考虑以下两点： 如果要计算 x%y 而 $y&gt;x$，则这次取模操作没有实质意义。 当我们进行一定次的取模之后，x 只会是 0 或 1，而上文所述的次数是 $\\log x$ 级别的。 针对第一条，我们维护区间的最大值，在要进行区间取模的时候判断一下即可，针对第二条，我们能知道区间取模的复杂度约为 $O(\\log x)$，那么总的时间复杂度就是 $O(n\\log n)$ 级别的。 于是就线段树随便写。 109 | P1659 [国家集训队]拉拉队排练洛谷 | P1659 [国家集训队]拉拉队排练 [提高+/省选-] 是一道用 Manacher 算法的题，相比于板子，我们需要再开一个桶，然后每次 p[i]-1 为奇数的时候往桶里加一次，最后需要这样处理 ans： 12345678for(R LL i=n;i&gt;=1;--i){ if(i%2==0) continue; tot+=cnt[i]; if(k&gt;=tot) ans=(ans*FastP(i,tot))%mod,k-=tot; else {ans=(ans*FastP(i,k))%mod,k-=tot;break;}}if(k&gt;0) ans=-1; 因为这道题有一个测试点的 $k$ 在 1e12 级别，所以要来个快速幂防止炸 longlong。 110 | P1345 Telecowmunication[USACO5.4]洛谷 | P1345 Telecowmunication[USACO5.4] [提高+/省选-] 这道题非常显然的网络流，然后我就去莽 Dinic 跑最大流求最小割了，但是兴奋的打完 Dinic，开始写 main 包的时候，发现这道题居然是割点，但是又发现求割边能过样例于是就去交了一发，这数据水的，我有 80pts。 于是就懵逼了，于是就看题解，发现是拆点，即为把一个点拆为两个点，将这两个点相连，然后删掉这个点的操作就相当于去掉这两点之间的边，于是就转化为求最小割了（ 111 | P1361 小M的作物洛谷 | P1361 小M的作物 [提高+/省选-] ~~ [数据销毁] 卡常题~~ 本来以为是个挺正常的拆点跑 Dinic，没想到这题 [数据销毁] 卡常…… 看了讨论区发现了一个简单的优化，好像对于这种类似稠密的图很有作用，即在 DFS 中加入： if(!rst) Heriko flow; 112 | P2936 Total Flow S [USACO09JAN]洛谷 | P2936 Total Flow S [USACO09JAN] [提高+/省选-] 是一道网络流的板子题，实际上题目中所述的我们可以的对水管的简化就是变相的简述了一下我们如何暴力找最大流，也就是说这道题是让我们求最大流，于是乎我们直接跑一边 Dinic 即可。 113 | P3931 SAC E#1 - 一道难题 Tree洛谷 | P3931 SAC E#1 - 一道难题 Tree [提高+/省选-] 大概就是一道网络流的快乐板子，因为原来的图是一颗有根树，所以我们只需要构造一个虚拟汇点就能完成网络流的建模。 我们只需要把叶结点连向汇点，所以我们在读入的时候记录一下每个点的出度，然后循环让叶结点和汇点连一条 inf 的边即可。 Dinic 正常跑是 80 ms，开了 02 直接拿最优解。 114 | P1879 Corn Fields G [USACO06NOV]洛谷 | P1879 Corn Fields G [USACO06NOV] [提高+/省选-] 是一道状压 DP，但是我 DP 太烂就完全不会。 记录了能否被选中，是通过左移右移来实现的（题目要求不能选相邻的草地，而我们每次考虑一行，于是只需要考虑左移右移） 115 | P4016 负载平衡问题洛谷 | P4016 负载平衡问题 [提高+/省选-] 显然这是一个要转化为费用流的题。 我们考虑这样建图：如果当前点的值 a[i] 小于平均值 per，那么我们把这个点和源点连一条容量为 per-a[i] 的边，费用为 0；反之，若当前点的值 a[i] 大于平均值，那么把这个点和汇点相连，同样是费用 0，容量改为 a[i]-per。 然后因为原本的图是一个环，还是无向图，于是我们再把图上本来就有的边建好，正边费用为 1，反边费用为 -1，正边容量 inf，反边容量 0。 实际上还有贪心数学做法，在下面两道题说。 116 | P2512 &amp; UVA11300洛谷 | P2512 [HAOI2008] 糖果传递 [提高+/省选-] 洛谷 | UVA11300 [提高+/省选-] 本来以为是三倍经验，没想到 116 这两个题比 115 数据范围大，不能费用流，于是乎就数学贪心做法，代码也很好懂于是就放在这里罢。（实在是不想打字了ww，取平均数大家应该都会罢) 1234567fr(n);for(R LL i=1;i&lt;=n;++i) fr(a[i]);for(R LL i=1;i&lt;=n;++i) per+=a[i];per/=n;for(R LL i=1;i&lt;=n;++i) f[i]=f[i-1]-a[i]+per;sort(f+1,f+n+1);mid=f[(n+1)&gt;&gt;1];for(R LL i=1;i&lt;=n;++i) ans+=Habs(f[i]-mid);fw(ans,1); 117 | P2668 斗地主 [NOIP2015 TG]洛谷 | P2668 斗地主 [NOIP2015 TG] [提高+/省选-] 哪个亲(【数据销毁】)爱(【数据销毁】)的学长在团队题单里放的斗地主？？？？？？？我爱您！！1 这个题思路简单清晰数据范围小爆搜可过复杂度优无常数困扰真是一道不可多得的水题呢！！1 啊那她为什么是蓝的呢？ 因为她是【数据销毁】的模拟！ 思路很简单，只需要分以下几种情况，而且贪心的顺序我在这里也直接排好，因为这是显然的： 顺子 $\\to$ 四带 $\\to$ 三带 $\\to$ 对子、王炸、炸弹、单走一个六 展开就是： $$\\begin{cases}1.&amp; 顺子\\begin{cases}1.&amp; 单顺 \\ 2.&amp; 双顺 \\ 3.&amp; 三顺\\end{cases}\\2.&amp; 三带\\ \\tt{n}\\begin{cases}1.&amp; \\tt{n=1} \\ 2.&amp; \\tt{n=2}\\end{cases}\\3.&amp; 四带\\ \\tt{n}\\begin{cases}1.&amp; \\tt{n=1} \\ 2.&amp; \\tt{n=2} \\ 3.&amp; 四带两对\\end{cases}\\4.&amp; 对子、单走、王炸、炸弹\\\\end{cases}$$ 别问我为什么用 $\\LaTeX$，问就是被这题做疯了。 到这里都很平常对吧，然后我就写嘛，从四点开始写。 我在写之前直接放话，说儒略日比这分支多比这难这怎么是蓝的 Julian 是绿的。 四点半写完第一遍，没过样例，感觉可能有些小地方没写对，静态查了一边错，觉得自己可能查不太出来，于是就重构了一遍。 重构完大约五点多一点，我想这次可能没什么问题了吧，于是就跑样例，然后，又™没过！ 然后就查错，找不到错；和题解差错，找不到错；和学长的代码差错，找不到错；和学姐的代码差错，找不到错….. 然后简单重构了一些小地方毫无效果。 然后就生气了，五点半正好也是该吃饭了，就去吃饭了。 六点回来之后快速和以上三者的代码又进行了一遍逐行对比之后发现还是查不出来，然后考虑控制变量法进行差错。 把题解的顺子部分复制过来，然后我以为样例 1 过了，实际上是我用样例 2 跑出来样例 1 的结果。 然后我就很开心觉得这题终于能调出来了，然后把顺子部分重构。重构着，突然想起来刚才好像我放的样例 1 的输入，然后我去试了一下果然 nmd 白高兴了…… 然后我就想着反正也重构了就继续重构罢，然后重构完了就去试样例，发现啊完全就和刚才一样，艹。 然后就把题解的后半部分复制过来发现还是不对，一气之下就把 DFS 全都复制过来，然后跑，然后就过了™样例。 然后我就用手指着两份代码进行静态人眼高端差错，然后无果。 这个时候 Dfkuaid 建议我去重构，我说重构个卵我重构了 n 遍了。 最后还是去重构了，然后重构完大约七点，不知道为什么就 RE 了，后来调试发现其实是死循环了，然后也不知道是为什么，然后就又一次一一对照静态差错，然后我就硬是找不出来。 然后 Dfkuaid 发现我有个循环变量写串了，然后我就改过来，走样例，好我过了，然后提交，过了，彳亍，正好七点半。 然后我去看我重构之前的代码，到现在也不知道是哪错了，神™题！！1 所以最后得出来的结果就是 OIer 请必备黄帝内经！我现在还感觉想把电脑砸了但是这不是我电脑我不行（话说就算是我的也不行的说） 118 | P2071 座位安排洛谷 | P2071 座位安排 [提高+/省选-] 是一道显然的二分图最大匹配，我用网络流做的，总的来说体验不错，个球。 最一开始的思路是把一排座位拆为两个点，然后连容量为 1 的边到汇点，但是发现自己不会对应起来边了，于是就不拆了，把容量改为 2。 最一开始写的 ISAP，写挂了好像，于是就捡起来 Dinic，然后又写挂了…… 最后是发现把所有的 r[i].val 都写成 r[i].to 了…… 119 | P2319 超级英雄 [HNOI2006]洛谷 | P2319 超级英雄 [HNOI2006] [提高+/省选-] 又是一道显然的二分图最大匹配，但是用网络流不好做，于是就写个 Hungary ，然后一直过不了样例，最后发现是写网络流写习惯了建了条反向边（） 120 | P1350 车的放置洛谷 | P1350 车的放置 [提高+/省选-] 不会，看了题解，爬了。 121 | P1640 连续攻击游戏 [SCOI2010]洛谷 | P1640 连续攻击游戏 [SCOI2010] [提高+/省选-] 实际上这个题拖了好久了才做，今天终于发现原来我之前一直不想做的原因是我读错题了……. 实际上这个题非常的简单，把属性放左边，装备放在右边跑 Hungary 即可。 但是还有一点就是时间戳优化，memset 太慢。 122 | P2057 善意的投票 [SHOI2007]/冠军调查 [JLOI2010]洛谷 | P2057 善意的投票 [SHOI2007]/冠军调查 [JLOI2010] [提高+/省选-] 一眼最大流最小割，转化：我们把小朋友们割开跑 Dinic 即可，但是我 Dinic 又写挂了？？？ 还是挺好吃的ww 123 | P2598 狼和羊的故事 [ZJOI2009]洛谷 | P2598 狼和羊的故事 [ZJOI2009] [省选+/NOI-] 考虑最小割，我们这样连边：狼的领地和源点相连（INF），羊的领地和汇点相连（INF），然后把每个格子和周围四个格子相连（1）。 实际上这样建图的话，我们割掉一条边就相当于建上篱笆啦~ 124 | P2774 方格取数问题洛谷 | P2774 方格取数问题 [省选+/NOI-] 做了羊和狼的故事之后回来看这个题，发现思想基本一致！ 上一题是把羊和狼分类，这次我们把 (i+j)&amp;1 作为条件分类，剩下的和上一道基本一致，只不过在和周围连边的时候，边的容量是这个方格的权值。 然后最后输出 sum-maxflow，sum 是所有方格权值和。 125 | P4001 狼抓兔子 [ICPC-Beijing 2006]洛谷 | P4001 狼抓兔子 [ICPC-Beijing 2006] [省选+/NOI-] 算是很离谱了啊（ 网络流很好想，可是这题正解貌似不是网络流的样子（ 但是还是过去了，但是留下了一个疑惑 然后 @Prean 的解答如下： 126 | P2580 于是他错误的点名开始了洛谷 | P2580 于是他错误的点名开始了 [普及/提高-] unordered_map 直接莽过（ AC 400 祭，提交 1.41k，比例大约是 2.83%，下降不少（（（ 127 | P1251 餐巾计划问题洛谷 | P1251 餐巾计划问题 [省选+/NOI-] em，是一个费用流问题，写一个 SSP 即可，但是今天写的时候挺玄学的…… 建图如下： 每天晚上从起点获得 x 条脏餐巾 每天白天,向汇点提供 x 条干净的餐巾,流满时表示第 i 天的餐巾够用 每天晚上可以将脏餐巾留到第二天晚上 每天晚上可以送去快洗部,在第 i+c 天早上收到餐巾 每天晚上可以送去慢洗部,在第 i+e 天早上收到餐巾 每天早上可以购买餐巾 没错就是题解的注释 128 | P2045 方格取数 加 强 版洛谷 | P2045 方格取数 加 强 版 [省选+/NOI-] 这个数据加强就很有意思了，加强前是最小割最大流，加强之后是最大费用最大流（ 既然是最大费用最大流，那么我们就跑一手 SSP（把 SPFA 里面的松弛操作的大于号改为小于号） 把一个格子拆成两个点，一个出点一个入点，每个入点和它对应的出点都连上两条边，一条费用为 $k-1$，容量为 1，另外一条的容量本身这个格子的权值，费用为 0。 把源点设为 $(1,1)$，汇点设为 $(n,m)$，于是我们就把每个格子和其下方和右方的格子建立联系，于是就把 $(i,j)$ 和 $(i+1,j),(i,j+1)$ 对应的出点和入点连接起来，容量为 $k$，费用为 0。 129 | P2153 晨跑 [SDOI2009]洛谷 | P2153 晨跑 [SDOI2009] [省选+/NOI-] 因为要一个最长的周期和一个最短的里程，所以我们考虑用最小费用最大流，即里程是费用周期是流。 还是拆点，拆成一个入点一个出点，因为每个点只能过一次，所以我们连的边费用是 0 ，容量为 1. 然后对于题目中给出的每一条边，我们把其容量设为 1，费用设为边权，然后跑 SSP。 130 | P3980 志愿者招募 [NOI2008]洛谷 | P3980 志愿者招募 [NOI2008] [省选+/NOI-] 最一开始一看就是很明显的最小费用最大流，但是想了半天建图，其实志愿者之间并不难建边，但是实在是不知道如何去维护人数限制，甚至还想过去套一个背包，但是想了想这玩意硬转移的话会爆炸，然后就懵逼。 然后就爬去看题解，不得不说第一篇题解确实分析的很透彻，思路很清晰（虽然他是从暴力到背包到网络流，而我是网络流到 网络流+背包 到懵逼，但是并不影响理解） 以下截自 Orion545 的 P3980 题解 此时我们需要想办法把人数限制放到图里 我们考虑最大流算法：它会求出最大的流量 那我们既然用一点流量表示一个人，那么为什么我们不把这个“需要用人”的限制，放到另外几条边上呢？ 我们在点(i,i+1)之间建边，设流量为-a[i]，也就是负的当天需求数，费用自然是零的 然后，令上文中的志愿者(si,ti,ci)，建边(si,ti+1)，费用ci，流量无限 此时我们相当于是把第i天的决策放到了第i个点和第i+1个点之间的所有边上（就是把所有点排成一排，这两个点之间的那一条位置里的所有边，包括跨过这个区间的志愿者边） 需要志愿者？让它们从志愿者边上流过去，同时让人数限制边满流到-a[i]，这样求一个1-n+1的最大流，流量为0的最小费用就是雇佣人的最小费用了 为了让这个限制起效，又因为网络流中流量非负，所以我们建立点SS和TT，连边(SS,1)(n+1,TT)，限制为inf，费用为0 同时，我们把之前的人数限制边的流量改成(inf-a[i])，这样最终的SS-TT最大流一定是inf，而且限制依然成立 131 | SP3267 DQUERY - D-query洛谷 | SP3267 DQUERY - D-query [提高+/省选-] 想见识一下什么是莫队，于是乎去找个博客学习，然后就跟着那个博客做了这道题（ 实际上这个题先是发现和 HH 的项链一样于是就直接先用线段树双倍经验（ 先挖个坑，写博客的时候把这个题当作例题，然后再挂个 Link 在这。 132 | P1903 数颜色 / 维护队列 [国家集训队]洛谷 | P1903 数颜色 / 维护队列 [国家集训队] [提高+/省选-] 和上面那个题一样，还是等我写完博客挂 Link。 133 | P1494 小Z的袜子 [国家集训队]洛谷 | P1494 小Z的袜子 [国家集训队] [提高+/省选-] 同上，这道也当例题，欢迎去看（ 134 | P2709 小B的询问洛谷 | P2709 小B的询问 [提高+/省选-] 同上，这题又双叒叕是例题（ 135 | P3901 数列找不同洛谷 | P3901 数列找不同 [普及+/提高] 突然发现好久没做绿导致蓝题快赶上绿了（？）于是找了这个题来做其实是搜莫队标签发现就这一个紫色以下的我没做过了 因为这个题是个绿的就不用它当例题了，一看不强制在线直接用莫队搞一搞（ 我们考虑我们让 $l$ 和 $r$ 指针移动的时候如何去记录这个区间是否所有的数都互不相同。 第一个想法是只考虑本次转移涉及的那两个数，但显然这样并不能保证之前或之后没有相同的，Pass 掉。 第二个想法是考虑开一个桶，记录数的个数，假如超过了 $1$ 那么显然这个询问区间就有相同的数。 但是不知道为啥这个看起来挺正确的我实现挂了。 于是决定把延续第二个想法得出第三个想法：当桶里的数为 $1$ 就 ++cnt，若为 0 就 --cnt，若最后 cnt==q[i].r-q[i].l+1 那么就记录本次查询结果为 $\\tt{Yes}$，否则为 $\\tt{No}$。 然后就过了（ 136 | P1042 乒乓球 [NOIP2003PJ]洛谷 | P1042 乒乓球 [NOIP2003PJ] [普及-] 怎么说呢，请了假在家自闭，然后想到 EZEC R10 Div3 A 没有场切，就觉得自己模拟还是应当练一练，光会那种图论和数据结构在 T1 上基本毫无作用（ 于是可能在家这几天就多做做模拟。 这个题简单来看两种思路，第一种是边读边计算输出，第二种是先把全部字符串存下来然后判断输出。 最一开始写的第一种，然后写炸了连个破模拟都能写炸我屑的离谱，于是就按照第二种，然后判断错了了…… 总的来说我模拟是真不行，希望今年 CSP 和 NOIP 考场上不要搞离谱的模拟。 137 | P2670 扫雷游戏 [NOIP2015PJ]洛谷 | P2670 扫雷游戏 [NOIP2015PJ] [入门] 这是这整个杂题集里面第一次出现红题 甚至这还是我的第 21 道红题！红题超过紫题！！！1 但是nmd为什么EZEC R10 A 是个红题啊，多不给我面子啊（ 回归正题，这道题很显然了，对于每一个位置扫一遍其上下左右左上左下右上右下即可。 138 | P1563 玩具谜题 [NOIP2016TG]洛谷 | P1563 玩具谜题 [NOIP2016TG] [普及-] 这个题还是非常迷惑的（ 整体思路是好想的，因为这个题数据范围不大，所以我们直接枚举一个指针按照指令跳就行。 经过简单手模可以发现，如果当前玩具的朝向（0 或 1）和当前指令的方向（0 或 1）相同，则把指针向右移动（加），否则向左（减）。 注意模完 $n$ 可能会出现指针为 0，于是我们最一开始存的时候从 0 开始就好了（ 139 | P1328 生活大爆炸版石头剪刀布 [NOIP2014TG]洛谷 | P1328 生活大爆炸版石头剪刀布 [NOIP2014TG] [普及-] 大约也是一道非常简单的模拟罢，因为空间和时间都非常冗余，所以直接随便开即可（bushi 用 cna 和 cnb 来分别记录当前到没个人周期的第几位即可（ 140 | P3174 毛毛虫 [HAOI2009]洛谷 | P3174 [HAOI2009]毛毛虫 [提高+/省选-] 大约是一个 SDSC 都没有写这个，于是回来之后觉得应当继续接着写（ 这道题是一个显然的树形 DP，不知道出题人在想啥给了个完全木大的 m。 设 $f[x]$ 为以 $x$ 为根的最长链，这样设是因为这个题实际上就是在找最长的链。 不过我们要在 DFS 的时候同时维护最长链和次长链，因为这个题可能会出现毛毛虫跨过根节点的情况，但是这种情况也可以是看作最多两条链连在一起组成的，于是我们同时维护最长链和次长链。 141 | P1472 奶牛家谱 Cow Pedigrees [USACO2.3]洛谷 | P1472 奶牛家谱 Cow Pedigrees [USACO2.3] [提高+/省选-] 嗯，奶牛家谱果然和奶牛没有一点关系。 142 | P1453 城市环路洛谷 | P1453 城市环路 [提高+/省选-] 树形 DP，这道题有一点不太一样的是，本题给出的图是一个基环树。 我们设 $f[x][0/1]$ 表示以 $x$ 为根的子树的最大独立集，0 和 1 表示选 $x$ 或不选 $x$。 143 | P3205 合唱队 [HNOI2010]洛谷 | P3205 合唱队 [HNOI2010] [提高+/省选-] 用了一种类似小学 插空法 的东西。 144 | P5999 kangaroo [CEOI2016]洛谷 | P5999 kangaroo [CEOI2016] [提高+/省选-] 特判边界情况。 12if(i==s or i==t) f[i][j]=(f[i-1][j]+f[i-1][j-1]+MOD)%MOD;else f[i][j]=(f[i-1][j-1]*(j-(i&gt;s)-(i&gt;t))+f[i-1][j+1]*j+MOD)%MOD; 145 | P1550 Watering Hole G [USACO08OCT]洛谷 | P1550 Watering Hole G [USACO08OCT] [普及+/提高] 在普通边的基础上我们连 i 和 n+1 （一个虚拟点），权值为费用，代表挖井。 146 | P3535 TOU-Tour de Byteotia [POI2012]洛谷 | P3535 TOU-Tour de Byteotia [POI2012] [普及+/提高] 并查集判环，这里因为是让编号小于 k 的结点不在环上，于是我们可以先把大于 k 的并在一起。 然后再统计一下小于等于 k 的即可。 写了[题解]。 147 | P3916 图的遍历洛谷 | P3916 图的遍历 [普及+/提高] 反向建边 BFS。 148 | P4878 Layout G [USACO05DEC]洛谷 | P4878 Layout G [USACO05DEC] [普及+/提高] 差分约束的一个相对模板的题（？） 题目要求的距离远近直接转换化为不等式建边即可，但是要主要每两个牛之间都要建边。 149 | P3128 Max Flow P [USACO15DEC]洛谷 | P3128 Max Flow P [USACO15DEC] [普及+/提高] LCA + 树上差分，LCA 是倍增做的。 150 | P2158 仪仗队 [SDOI2008]洛谷 | P2158 仪仗队 [SDOI2008] [提高+/省选-] 是一道欧拉函数的板子题的样子，算是回忆了一下欧拉筛求欧拉函数（ 151 | CF1559A Mocha and Math洛谷 | CF1559A Mocha and Math [暂无评定]（预计 [入门]） Codeforces | CF1559A Mocha and Math 送分 A 题就不多说罢……直接暴力 &amp; 就行 昨天晚上本来是想写个题解，写完之后手残按了书签链接……然后就没再写，今天回来一看已经 10 篇题解了就懒得写了。 152 | CF1559D1 Mocha and Diana (Easy Version)洛谷 | CF1559D1 Mocha and Diana (Easy Version) [暂无评定]（预计 [普及/提高-]） Codeforces | CF1559D1 Mocha and Diana (Easy Version) 题目大意是有两个森林，问你在保证还是两个森林的情况下还能连多少边。 这个 EZ Ver 的 $n \\le 1000$，所以直接暴力枚举即可。 用两个并查集来分别维护这两个森林即可。 153 | P1108 低价购买 &amp; P2687洛谷 | P1108 低价购买 [提高+/省选-] 这个题实际上是两个 DP 的叠加。 P2687 的链接就不放了，反正很好找，两者题都一样就是了，后者需要高精。 154 | T189961 [Wdoi R3] 夜雀 dreaming因为这个比赛的题都还没入主题库，于是就先挂这个链接，等进了主题库再改链接罢。 洛谷 | T189961 [Wdoi R3] 夜雀 dreaming [暂无评定]（预计 [普及+/提高]） 这个题是 Wdoi R3 的 A 题，也就是签到题，但是很可惜的我没签上（ 简化版的题意算是很清晰了，因为时间轴的上限是 $9966^{9966}-1$，所以直接求出所有的时间点的倍数再去判断是木大的。 于是我们考虑同一个时间会在什么情况下出现两个不同的菜。因为放入菜的时间都是每个命令时间的倍数，所以我们考虑对于两个时间点的 $\\operatorname{lcm}$，那么根据题意我们最后选取的 $\\operatorname{lcm}$ 越小越好，于是我们在枚举之后进行一次排序。（用优先队列也可以） 因为题目中计算每个时间点所点菜的公式已经给出，于是我们就可以每次取出 $\\operatorname{lcm}$ 后计算对应的两条命令在这个时间点的菜，若不同那么这个时间点就是答案。 ……但是这样还不对，因为假如相同的话，我们再考虑 $2 \\times \\operatorname{lcm}$ 处，如果再相同就真的没解了。场上我就因为没考虑另外一种情况而喜提两个 WA 痛失签到机会。 感谢 @Fan_Tuan 大佬帮忙纠错。 155 | P4310 绝世好题洛谷 | P4310 绝世好题 [普及+/提高] 所以绝世好题就是良心 DP（ 这个题 $O(n^2)$ 的 DP 思路很好想： 12345for(R int i(1);i&lt;=n;++i) for(R int j(1);j&lt;i;++j) if(a[i]&amp;a[j]) f[i]=Hmax(f[i],f[j]+1); 即使这个题的数据及其水，这个做法也是不能 AC 哒，只有 90pts （ 于是我们考虑优化。在不改变状态设计的情况下，我们只能着手于内层循环。考虑 $j$ 时我们发现实际上有很多的状态都被浪费掉了，她们到达不了更大的答案。 于是我们进行一个最优性剪枝，记录当前的最大答案。 156 | P1944 最长括号匹配洛谷 | P1944 最长括号匹配 [普及/提高-] 看起来是一道相当相当相当相当相当相当相当相当相当相当相当相当相当相当相当相当相当相当相当相当相当相当的 DP （ 核心如下： 123456for(R int i(2);i&lt;=n;++i) { if(c[i]=='(' or c[i]=='[') continue; if((c[i]==')' and c[i-f[i-1]-1]=='(') or (c[i]==']' and c[i-f[i-1]-1]=='[')) f[i]=f[i-1]+f[i-f[i-1]-2]+2; if(f[i]&gt;len) len=f[i],pos=i; } len 记录的是最长的匹配括号序列的长度，pos 则是最后能匹配的位置。 157 | P2340 Cow Exhibition G [USACO03FALL]洛谷 | P2340 Cow Exhibition G [USACO03FALL] [提高+/省选-] 是一道清新的背包！ 如果 iq&gt;=0 那么跑 01 背包，反之跑完全背包。 不过由于可能会出现负数的情况所以我们多用浪费一倍空间去干掉可能出现的负数下标的情况。 158 | T193697 信号塔洛谷 | T193697 信号塔 [暂无评定]（预计 [普及/提高-]） 据说是巨大重题来着，虽然我没做过但也是觉得眼熟，好像来自于某个神必的结论来着（ 中午刚到机房比较热，就先随便开个题 Cold down，上来一看 D2A 是个交互题我不会（虽然后来看算是幸好没有做 A），于是去做 D2B。 这题一看就觉得眼熟，感觉是个 x%y==0 之类的结论题，然后看了下样例只有 12 的倍数输出了 1，就先交了个 x%12==0 的，全 WA。 然后去手模了一下发现其实是 x%6==0 ，于是交上去得了 10 pts（ 于是去看数据范围，哦原来有负数，最后 20pts 还爆 ull 范围了，那就先把快读的判负号去掉拿了 80 pts。 最后看是不是需要高精度啥的，然后发现实际上每一位加起来判断一下是否为 3 的倍数再看一眼最后一位判断是不是偶数即可。 然后就交上去过了。 159 | CF1560A Dislike of Threes洛谷 | CF1560A Dislike of Threes [暂无评定]（预计 [入门]） Codeforces | CF1560A Dislike of Threes 题意简述：输出第 $k$ 个个位不为 $3$ 且不被 $3$ 整除的数。 思路简述：A 题还是一个手速题，因为 $k \\le 1000$，所以我们可以直接枚举 $i$。 160 | P3868 猜数字 [TJOI2009]洛谷 | P3868 猜数字 [TJOI2009] [提高+/省选-] 这是一个 CRT 的题，原式可以化为： $$\\begin{cases}n - a_1 &amp;\\equiv \\pmod {b_1} \\n - a_2 &amp;\\equiv \\pmod {b_2} \\n - a_3 &amp;\\equiv \\pmod {b_3} \\n - a_4 &amp;\\equiv \\pmod {b_4} \\&amp;\\cdots \\n - a_k &amp;\\equiv \\pmod {b_k} \\\\end{cases}$$ 那这样就很 CRT 的板子了，但是这题的最后一个点爆 long long 了，于是就写个乌速乘罢，然而题目的数据中 $|a_i| \\le 10^9$，也就是说会有负数。 所以我们要进行神必的提前取模来干掉负数的情况。 算是题外话，这是第一个在 Manjaro Linux 上做出来的题，同时这个 “简单记录.md” 也突破了 2000 行 :D 161 | P1169 棋盘制作 [ZJOI2007]洛谷 | P1169 棋盘制作 [ZJOI2007] [提高+/省选-] 是一道垂涎垂线法的例题（？） 这道题定义了三个递推用的二维数组：l，r，u，分别表示从 $(i,j)$ 开始能到达的最远的左右位置和能向上扩展的最长长度。 12345678if(f[i][j]!=f[i-1][j] and i&gt;=2){ l[i][j]=Hmax(l[i][j],l[i-1][j]); r[i][j]=Hmin(r[i][j],r[i-1][j]); u[i][j]=u[i-1][j]+1;}int x(r[i][j]-l[i][j]+1);int y(Hmin(x,u[i][j]));ans[0]=Hmax(ans[0],y*y);ans[1]=Hmax(ans[1],x*u[i][j]); 同时因为本题给出的是一个 01 矩阵，所以在判断的时候只需要判定两者不同即可符合条件，进行递推。 162 | P4147 玉蟾宫洛谷 | P4147 玉蟾宫 [提高+/省选-] 这还是一道垂线法的题，整体思路和上一题相似，还是定义三个数组来递推。 从某种意义上来说这道题比上一道题简单一些。 163 | P2051 中国象棋 [AHOI2009]洛谷 | P2051 中国象棋 [AHOI2009] [提高+/省选-] 百蓝祭。 是一道状压 DP，有两个大类五个情况需要讨论： 123456if(k&gt;=1) f[i][j][k]+=f[i-1][j+1][k-1]*(j+1);if(j&gt;=1) f[i][j][k]+=f[i-1][j-1][k]*(m-j+1-k);if(k&gt;=2) f[i][j][k]+=f[i-1][j+2][k-2]*(((j+1)*(j+2))&gt;&gt;1);if(k&gt;=1) f[i][j][k]+=f[i-1][j][k-1]*j*(m-k+1-j);if(j&gt;=2) f[i][j][k]+=f[i-1][j-2][k]*C2(m-j+2-k); 164 | P1578 奶牛浴场洛谷 | P1578 奶牛浴场 [提高+/省选-] 还是垂线法，不过这道题的数据范围为 $0 \\le $ 长，宽 $\\le 30000$，于是我们就不能和玉蟾宫、棋盘制作一样开二维数组去做了。 同时我们注意到 $n \\le 5000$，说明障碍点相对较少，于是我们可以枚举障碍点来做。 参考到的题解 @Ofnoname。 165 | P2701 Big Barn [USACO5.3]洛谷 | P2701 Big Barn [普及/提高-] 最一开始以为是跟玉蟾宫一样的板子，然而我多虑了，其实是更简单的 DP。 $$f(i,j) = \\max { f(i-1,j-1),f(i-1,j),f(i,j-1) } + 1$$ 属于是 了属于是。 166 | SP1805 Largest Rectangle in a Histogram洛谷 | SP1805 HISTOGRA - Largest Rectangle in a Histogram [普及+/提高] SPOJ | HISTOGRA - Largest Rectangle in a Histogram 在这里我们因为最终极大面积肯定是出于某个位置 $i$ 的面积 $i \\times h_i$，因此我们需要枚举 $i$ 的位置去不断的向左右扩展。 以向左为例，显然的是满足 $i&gt;1$ 且 $a_i \\le a_{i-1}$ 时，可以继续向左扩展，即：$l_i = l_{l_i-1}$。 167 | UVA1619 Feel Good洛谷 | UVA1619 Feel Good [提高+/省选-] UVA (Vjudge) | Feel 🤺 Good 和上一题类似的扩展方式，只不过要求一个前🤺缀🤺和🤺。 168 | P2216 理想的正方形 [HAOI2007]LOJ | #10182.理想的正方形 洛谷 | P2216 理想的正方形 [HAOI2007] [提高+/省选-] 总之很感谢 LOJ 就是了（ 这个题我从开题到 AC 的总时间，和斗地主差不多了，都是上午十一点到晚上七点多。 突然想像头哥一样怒斥 GP2 Engine： GP2!GP2 Engine↺Uh!!!↷ 当然我之所以这道题从上午十一点开题做到晚上七点多只是因为我菜。 这个题的题意很清晰了，要求能使得其内最大值与最小值之差最小的 $n \\times n$ 的矩形，而因为题目中 $a,b,n$ 都不变且 $n$ 比较小，于是我们可以直接考虑去求每个 $n \\times n$ 中的最大值和最小值的差。 我们考虑对于最大值和最小值分别用两次单调队列： 先求出原矩阵中每一行所有长为 $n$ 的序列内的最大值，得到一个新的矩阵。这一步求出来的是所有 $1 \\times n$ 大小矩阵内元素的最大值。 将新矩阵的每一列所有长为 $n$ 的序列内的最大值记录到一个新的矩阵中。这一步就是所有 $n \\times n$ 大小矩阵内元素的最大值。 将所有 $n \\times n$ 大小的矩阵最小值按照上面方法求出。 枚举元素，找到最小的差。 然后因为某个神必原因我调了一下午（ 最后还是 LOJ 的代码格式化启发了我让我面向题解查错了一波才找到这个神必错误…… 169 | P2831 愤怒的小鸟 [NOIP2016TG]洛谷 | P2216 理想的正方形 [HAOI2007] [提高+/省选-] Uh Luogu! Luogu Wisdom Engine！ Wisdom! Uh! 突然找到了头哥怒斥 GP2 Engine 的感觉 170 | P2331 最大子矩阵 [SCOI2005]洛谷 | P2331 最大子矩阵 [SCOI2005] [提高+/省选-] Uh Luogu! Luogu Wisdom Engine！ Wisdom! Uh!又给我推 DP！ 算是一道分讨类的 DP ？因为 $1 \\le m \\le 2$，所以我们可以先考虑 $m=1$ 的情况再合理推至 $m=2$。 讨论的情况参照的这里。 171 | CF1354D Multiset洛谷 | CF1354D Multiset [提高+/省选-] CF | CF1534D 一道线段树？因为是维护了一个桶，所以大约是我写过最短的线段树了，本来还想拿这个题来复建线段树手感呢（ 因为觉得全扔进结构体里整洁于是就在其他常数比 Dfkuaid 小的情况下的慢了 $n$ 秒嘤（ 172 | CF1181D Irrigation洛谷 | CF1181D Irrigation [提高+/省选-] CF | CF1181D 属于是阴间题目了属于是，这题的官方题解不超过 15 行，但是我们自己想的却是 $n \\times \\texttt{std}$ 的权值线段树和权值树状数组（ 173 | P2245 星际导航洛谷 | P2245 星际导航 [省选+/NOI-] 属于大重题了属于是，和货车运输做法一模一样（ 看着旁边的 Dfkuaid 因为写的倍增求 LCA 还要改一些取 $\\min$ 和取 $\\max$ 的地方，我直接宣布双 set + vector 找 LCA 完全胜利！！！1 （完全不用改） 173 | P3959 宝藏 [NOIP2017TG]洛谷 | P3959 宝藏 [NOIP2017TG] [省选+/NOI-] 这道题的数据范围看起来就很像是个状压 DP，于是我最一开始决定要用大约贪心 + 状压来写。 然而想着想着发现正确性不对，如果要正确性对的话我复杂度就炸到大约 $n!$ 了（ 于是看着扶苏的题解写了一个状压 DP。 174 | P2602 数字计数 [ZJOI2010]LOJ | #10169.数字计数 洛谷 | P2602 数字计数 [ZJOI2007] [提高+/省选-] 是一道数位 DP 的板子题，正好遇上洛谷日爆（ 采用模板化的 DFS 做法，定义 $f$ 数组如下 $f(i,j)$ 表示是从高到低第 $i$ 位，$j$ 则是数字出现次数。 DFS 函数为 $DFS(pos,num,ans,lead,limit)$，参数分别表示：从高到低第几位，要求哪个数出现的次数，当前出现次数，前导零的状态，当前位置上限的状态。 175 | P6218 Round Numbers S [USACO06NOV]洛谷 | P6218 Round Numbers S [USACO06NOV] [提高+/省选-] 还是数位 DP，因为我在套模板，所以和上一题的区别只有 $f(i,j)$ 中的 $j$ 变为了 $1$ 和 $0$ 出现次数的差。 对应的，$DFS$ 中的 $ans$ 也变成了 $dlt$（ 176 | P4317 花神的数论题洛谷 | P4317 花神的数论题 [提高+/省选-] 又双叒是数位 DP，这道题我还是套模板，$f(i,j)$ 代表第 $i$ 位的乘积为 $j$。 因为这道题不需要考虑前导 $0$，所以 $DFS$ 函数也变得简单：$DFS(pos,st,limit)$。 177 | P4999 烦人的数学作业洛谷 | P4999 烦人的数学作业 [提高+/省选-] 又双叒叕是数位 DP，这道题第一次居然读错题了认为是求 $[l,r]$ 内所有数的和，我还想这题怎么样例不对啊（ 回归正题，这仍然能套模板，而且和数字计数很像，但是因为本题要求的东西简单一些，所以 $DFS$ 函数中不需要记录所求数和前导 $0$ 的问题。 也就是变成了：$DFS(limit,pos,st)$。 178 | P3413 SAC#1 - 萌数洛谷 | P3413 SAC#1 - 萌数 [省选+/NOI-] 虽然 De 了很长时间的 Bug，但是总体上这个题的思维难度却是不高（ 难就难在神必字符串，这题不把数据范围搞到 $10^{1000}$ 也就是个蓝题（ 这个题总体上还是相对于前几个只需要板子的题要难一点的，主要体现在你需要记录两个 $pre$ 以及奇偶不同时的判断（？） 当然我字符串一塌糊涂于是去看大佬的操作，大佬是先补全的前面那个短的字符串，总之我不是很懂这神必字符串就是了，大佬总能想出巧妙的方法而我只能背模板（ 题外话，这个杂题简单记录的原 .md 文档的大小在我打出这个题的标题和链接的时候正好达到了 100kB（ 179 | P4127 同类分布 [AHOI2009]洛谷 | P4127 同类分布 [AHOI2009] [省选+/NOI-] 仍然是数位 DP，仍然是能套模板。 暴力枚举模数！于是我们在 $f$ 和 $DFS$ 里面加上一维来表示余数。 180 | P4124 手机号码 [CQOI2016]洛谷 | P4124 手机号码 [CQOI2016] [省选+/NOI-] 数位 DP，这个题相当的良心，可以让我随便了开数组去记录信息，但是 Debug 太久就是我的问题。 看着空间如此宽裕，那么我就开了个 $f(p1,p2,p3,same,limit,h4,h8)$。$p1$ 到 $p3$ 记录的是这三个连续的数，$same$ 是标志 $p1$ 是否满足连续相同的三个数字，$limit$ 意义和之前一样，$h4,h8$ 表示有没有出现 $4$ 和 $8$。 181 | P2518 计数 [HAOI2010]洛谷 | P2518 计数 [HAOI2010] [省选+/NOI-] 虽然我是跟着数位 DP 的 Tag 进的这个题，但是看完之后确实觉得组合数学的感觉溢出来了（插入 $0$，删除 $0$，这真的很明显了属于是。） 但是我的组合数学过于差了，看完题之后能大约知道是个什么组合意义但是我一个柿子都不会推。 于是去看题解，发现第一篇题解就是组合数学做法，于是就本着体验惩罚自己太菜用 gedit 写这个题。 除了没有括号自动补全不太适应以外感觉比 DevC++ 好用（bushi 182 | P4768 归程 [NOI2018]洛谷 | P4768 归程 [NOI2018] [省选+/NOI-] LOJ | #2718.「NOI2018」归程 这个题算是历史很悠久了，当时 SDSC D1 讲了 Kruskal 重构树，然后《推荐习题》就是这个题，然后 7.16 一下午 + 晚上 + 7.17 下午模拟赛前就光调这个题了，当时搞得心态非常崩溃（ 前几天突然在移动硬盘备份的老移动硬盘的资料里发现了我去年啥都不会的时候在 NOI2020 线上同步赛大的惊天神必暴力，大概复杂度在 $O(完全算不出来)$ 的级别，然后我想着这玩意交上去怎么着也能过掉 4 pts 左右罢，然后全 TLE，但是我好像跑题了（ 于是在那个时候突然想起来我还有一份智熄的归程没有写完，于是就决定 500 AC 祭和百粉祭的时候把这两个题干掉（ 然后没想到很快就 499 了，于是就在早上的机房打开了我智熄的代码（ 这个题的总体思路是将整个路径分为两端：$n \\to u$ 开车，$u \\to 1$ 走路，那么我们就需要枚举这个断点 $u$。 根据题意有水坑的地方是不能走车的，也就是说 $n \\to u$ 这一段都不能有海拔低于水位线，于是我们把海拔按照降序排序。 跑 Dijkstra 后 Kruskal 重构树，然后每次询问去找公共祖先即可。 但是这 $lastans$ 也挺恶心的（ 不过上面这些东西我基本上在一个月之前就调的差不多了（除了 $sum,cnt,tot$ 用混了以外） 然后最后发现是并查集的 $Find$ 写智熄了： 12345int Find(int x){ if(x!=fa[x]) fa[x]=Find(fa[x]); Heriko fa[x];} 183 | P1868 饥饿的奶牛洛谷 | P1868 饥饿的奶牛 [普及+/提高] 一道线性 DP，方程是 $f(i)=\\max{f(i),f(v(i,j)+i-v(i,j))}$ 184 | P1341 无序字母对洛谷 | P1341 无序字母对 [普及+/提高] 是一道题意很显然的欧拉路，然而我最易开始一只以为是欧拉回路，然后就很淦的卡了两个小时（ 185 | P6722 「MCOI-01」Village 村庄洛谷 | P6722 「MCOI-01」Village 村庄 [普及+/提高] 是一道图论题，因为题意比较清晰，我们可以分为两部分去求解。 第一部分是把符合条件的新图建出来，第二部分则是去判断二分图。第二部分实现起来很简单，染色即可，主要是第一部分的实现。 我们考虑如果树上最长的路径都 $\\le k$ 的话，那么显然不存在符合题意的图。 反之，如果存在二分图，必然最长路径的两端不在一个集合中，也就是说树的直径两端不在一个集合中，因此我们只需要找到直径的两端进行两遍 $DFS$，最后再进行一次 $DFS$ 染色判断即可。 有水题解（ 186 | P7113 排水系统 [NOIP2020]洛谷 | P7113 排水系统 [NOIP2020] [普及+/提高] NOIP2020 的 T1，现在来看题意确实很清晰的是个拓扑排序，正好 2021.9.1 CCF 宣布 NOI 系列赛事 C++14 和 下划线开头的函数解禁，所以就直接写的 __int128（ 187 | P6560 时光的流逝 [SBCOI2020]洛谷 | P6560 时光的流逝 [SBCOI2020] [普及+/提高] 比较显然是一个博弈论 + 拓扑排序的题目，不过实际上不是太难的博弈论，要不然我也想不到。 大体的思路是建反边，将终点和所有入度为 $0$ 的点的先手胜负设为 $-1$，如果一个点能到达一个必败点，那么是必胜态。 188 | P4513 小白逛公园洛谷 | P4513 小白逛公园 [提高+/省选-] 实际上这应该是一道挺经典的线段树 + 最大子端和的题，不过我今天才过，拿来复苏我的线段树也是不错啦。 大约就是单点修改的线段树，维护分别从左右开始的最大子段和，同时维护一个最大值。 189 | P3177 树上染色 [HAOI2015]洛谷 | P3177 树上染色 [HAOI2015] [提高+/省选-] 一道树形 DP，题意是让我们把 $k$ 个点染成黑色，其余为白色，求满足两两黑点之间距离最长和两两白点之间距离最长的染色方案。 因为一条边只有在两个同色点之间时才有贡献，所以一条边被经过的次数等于边的两侧同色点个数的乘积，即为： $$temp = w * (k-w) + (sz(y)-w) * (n-k-sz(y)+w) * r(i).val$$ 于是方程即为： $$f(x,j) = \\max {f(x,j),f(x,j-w)+f(y,w)+temp}$$ 接下来想练一下树剖。 190 | P2146 软件包管理器 [NOI2015]LOJ | #2130.「NOI2015」软件包管理器 洛谷 | P2146 软件包管理器 [NOI2015] [提高+/省选-] 上面说过要练一下树剖，于是就看到了这道题，大体的思路就是安装状态为 $1$，未安装状态为 $0$，算是比较板子的树剖。 下面写一点这回和上次 Debug 时出现的智熄操作。 在 DFS1 中 ：if(sz[y]&gt;son[x]) son[x]=y;，应写为 if(sz[y]&gt;sz[son[x]]) son[x]=y;。 在线段树 Query 中忘了 Pushdown. 遍历边的时候将 int i(head[x]) 错写为 int i(head[i])。 在 QTree 和线段树 Query 中返回值错写为 x，但是应当是 res。 在线段树 Modify 中忘了 Pushup. 191 | P2619 Tree I [国家集训队]洛谷 | P2619 Tree I [国家集训队] [提高+/省选-] 题目的说法很清楚是要求最小生成树了，但是因为求 MST 的算法都是基于贪心，所以我们不能钦定 $need$ 条白边去做。 于是我们就顺着贪心的想法去做，二分答案即可。 192 | UVA12888 Count LCM洛谷 | UVA12888 Count LCM [省选+/NOI-] UVA | Count LCM 煺柿子题。 $$\\begin{aligned}&amp;\\sum\\limits_{i=1}^{n}\\sum\\limits_{j=1}^m[[i,j]=i \\times j]\\&amp;\\sum\\limits_{i=1}^{n}\\sum\\limits_{j=1}^m[\\dfrac{i \\times j}{(i,j)}=i \\times j]\\&amp;\\sum\\limits_{i=1}^{n}\\sum\\limits_{j=1}^m[(i,j)=1]\\&amp;\\sum\\limits_{i=1}^{n}\\sum\\limits_{j=1}^m\\sum\\limits_{d|n}\\mu(d)\\&amp;\\sum\\limits_{d=1}^{\\min{n,m} }\\left\\lfloor\\dfrac{n}{d}\\right\\rfloor\\left\\lfloor\\dfrac{m}{d}\\right\\rfloor\\end{aligned}$$ 于是用欧拉筛筛一下 $\\mu$ 再整除分块。 193 | P4981 父子洛谷 | P4981 父子 [提高+/省选-] 有个东西叫做 $Prüfer$ 编码与 $Cayley$ 公式。 一棵无根树的 $Prüfer$ 编码的值运算如下： 首先定义无根树中度数为1的节点是叶子节点。 找到编号最小的叶子并删除，序列中添加与之相连的节点编号，重复执行直到只剩下2个节点。 $Cayley$ 公式是说，一个完全图 $K_n$ 有 $n^{n-2}$ 棵生成树，换句话说 $n$ 个节点的带标号的无根树有 $n^{n-2}$ 个。 在这个题这里我们有 $n$ 种选根的方法，所以总共是 $n^{n-1}$ 种方案，快速幂做即可。 194 | P2590 树的统计 [ZJOI2008]洛谷 | P2590 树的统计 [ZJOI2008] [提高+/省选-] 191 到 193 都是在补齐周末测试题的时候随便做的题，这是回归之前说要练一练树剖的初心的题。虽然我补题太慢了这一周又过去了…… 这是一道树剖的入门题，需要支持三个操作：单点修改，求路径上最大值，求路径上点权之和。 那么这个显然就是树剖来做，简单写写即可。 写一下这次写的时候 Debug 出来的智熄操作： 线段树所有操作全都忘了 Pushup(x)。 输入询问的时候把输入的种类都搞成 char 了，但是很奇怪的过了样例…… 在 Query 里面递归的时候全写的 Modify…… 一个 n 个节点的树我输入了 n 条边……… 因为时单点修改，但是我最一开始穿的是原标号而不是新标号…… 其实都是在查到第 $3$ 个错之前查出来的…… 总之就是写一次涨一次畸形。 195 | P1265 公路修建洛谷 | P1265 公路修建 [普及+/提高] 是一道比较显然的最小生成树，因为这个题主要是围绕着点来进行计算，所以这里用一下 Prim 算法。 两点间距离公式非常简单了，然后就是 Prim 的板子，只不过一些地方要记得开 double. 196 | P1119 灾后重建洛谷 | P1119 灾后重建 [提高+/省选-] 一道最短路，主要考察对于 Floyd 算法实现过程理解。Floyd 是基于动态规划，每次找到一个中间点 k 来更新最短路信息，对与这道题来说只有能被选择的点才能更新其他的点，于是我们在每次询问时先把能更新的点都更新掉保证最短路。 不知道为什么这个题是蓝，感觉黄差不多。 197 | P5658 括号树 [CSP-S 2019]LOJ | #3209. 「CSP-S 2019」括号树 洛谷 | P5658 括号树 [CSP-S 2019] [普及+/提高] 先考虑括号匹配计数，再考虑如何在树上解决这个问题。 首先对于单纯的括号匹配计数，用一个栈就能解决，但是本题需要统计一个路径上的括号匹配数。 先考虑链的情况，那么我们每次新匹配一个括号，就只需要单纯的继承上一个点的信息即可。 然后考虑树上的情况。刚才之所以可以直接继承上一个节点，就是因为每个节点的父节点都是其上一个节点，所以我们在这里直接把继承的信息来由改为其父节点即可。 这里说两个 Debug 的时候发现的写挂点： 卡在 55pts：在 DFS 的 if 中使用了 return. 卡在 88pts：在回溯的时候错把栈数组写为了字符数组。 198 | P2742 Fencing the Cows [USACO5.1]洛谷 | P2742 Fencing the Cows [USACO5.1] [提高+/省选-] 当然，这道题再洛谷上也叫做模板，所以就是板子。 做这道题的缘由是 ZROI CSP D5 T4 用到了凸包，但是我没学过，于是就学了来这个题练手。 最后选用的 Andrew 算法，第一是这个算法的排序想法简单，第二是这样排序常熟更小。 199 | P2116 城墙洛谷 | P2116 城墙 [省选+/NOI-] 一道凸包的板子题，这道题和上道题的唯一区别就是多了一个 $L$，但是因为我们要找到最短的，所以显然当城墙距离 $=L$ 的时候是最优的，而此时最短距离其实就为直线凸包 + $pi \\times 2 \\times L.$ 200 | P1463 反素数 [POI2001 and HAOI2007]洛谷 | P1463 反素数 [POI2001 and HAOI2007] [提高+/省选-] 算是一道数学题（？） 若设 $x = \\Pi p_i^{k_i}$，则 $d(x)=\\Pi (k_i).$ 那么我们就直接搜索（ 因为前 $12$ 个素数的乘积已经超过了 $2 \\times 10^9$，所以我们只需要前 $12$ 个素数，这个直接写出来就行。 同时庆祝一下 $200$ 题（","link":"/2021/12/06/Note18/"},{"title":"回滚莫队浅记","text":"浅谈回滚莫队。 前置知识之前写的普通莫队笔记，在这里当个前置知识，其实大约知道莫队大概就是把询问离线下来，分块并排序之后用两个指针 $l,r$ 来更新信息统计答案即可。 有时在区间转移的时候，有些删除或添加的操作无法实现，那么当只有一种操作不能实现的时候，就可以用莫队来解决这个问题，然而普通莫队是很难解决（或者说是不能解决）这个问题的，所以我们要对普通莫队进行改造，也就是回滚莫队。 本文出现所有代码缺省源使用V5.3. 「例题一」洛谷模板原题链接：P5906 【模板】回滚莫队&amp;不删除莫队。 「例题一」题目简述给定一个序列，多次询问一段区间 $[l,r]$，求区间中相同的数的最远间隔距离。 序列中两个元素的间隔距离指的是两个元素下标差的绝对值。 「例题一」思路简述首先来说这个题有什么操作不能实现。显然增加是好实现的，只需要每次在增加时更新距离信息（记录第一次出现和最后一次出现）即可。但是删除操作不能这样实现，因为在删除的时候若要更新答案，需要知道次大值……肯定是不能这样维护的，所以我们要让 $l$ 和 $r$ 在移动的过程中尽量避免删除操作，也就是尽量让 $l$ 向左端移动，$r$ 向右端移动。 那么我们每次枚举块，把块内的询问解决的时候，每次把 $l$ 拉回当前块的右端，然后保证 $r$ 只向右端移动，$l$ 不断根据询问反复横跳，对于在一个块内的询问暴力更新（复杂度 $O(\\sqrt{n})$，不过可能实际略大），否则跳两个指针更新答案。因为块的是 $O(\\sqrt{n})$ 的，所以对于每个询问，$l$ 的移动是 $O(\\sqrt{n})$ 的，所以这样做的复杂度就是 $O(n\\sqrt{m}).$ 「例题一」Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y) { Heriko x&gt;y?x:y;}template&lt;typename J&gt;I J Hmin(const J &amp;x,const J &amp;y) { Heriko x&lt;y?x:y;}CI MXX(2e5+1);int ans[MXX],a[MXX],b[MXX],n,blo[MXX],len,blocnt,qn,appeared[MXX],fstpos[MXX],lstpos[MXX],apn;struct Query { int l,r,id; I bool operator &lt; (const Query &amp;co) const { Heriko (blo[l]==blo[co.l])?(r&lt;co.r):(blo[l]&lt;blo[co.l]); }}q[MXX];int lst[MXX];I int Clac_Faster_Than_SF1000(int l,int r) { int res(0); for(int i(l);i&lt;=r;++i) lst[a[i]]=0; for(int i(l);i&lt;=r;++i) if(!lst[a[i]]) lst[a[i]]=i; else res=Hmax(res,i-lst[a[i]]); Heriko res;}S main() { Files(); fr(n),len=sqrt(n); for(int i(1);i&lt;=n;++i) fr(a[i]),b[i]=a[i]; sort(b+1,b+1+n); int nl(unique(b+1,b+1+n)-b-1); for(int i(1);i&lt;=n;++i) a[i]=lower_bound(b+1,b+1+nl,a[i])-b; for(int i(1);i&lt;=n;++i) blo[i]=(i-1)/len+1; blocnt=blo[n]; fr(qn); for(int i(1);i&lt;=qn;++i) fr(q[i].l),fr(q[i].r),q[i].id=i; sort(q+1,q+1+qn); int l(0),r(0),nw(1),tmpans(0); for(int i(1);i&lt;=blocnt;++i) { int rx(Hmin(n,i*len)); l=rx+1,r=rx,tmpans=0,apn=0; for(;blo[q[nw].l]==i;++nw) { if(blo[q[nw].r]==i) ans[q[nw].id]=Clac_Faster_Than_SF1000(q[nw].l,q[nw].r); else { while(r&lt;q[nw].r) { ++r; lstpos[a[r]]=r; if(!fstpos[a[r]]) fstpos[a[r]]=r,appeared[++apn]=a[r]; tmpans=Hmax(tmpans,r-fstpos[a[r]]); } int lsttmp(tmpans); while(l&gt;q[nw].l) { --l; if(lstpos[a[l]]) tmpans=Hmax(tmpans,lstpos[a[l]]-l); else lstpos[a[l]]=l; } ans[q[nw].id]=tmpans; while(l&lt;=rx) { if(lstpos[a[l]]==l) lstpos[a[l]]=0; ++l; } tmpans=lsttmp; } } for(int i(1);i&lt;=apn;++i) fstpos[appeared[i]]=lstpos[appeared[i]]=0; } for(int i(1);i&lt;=qn;++i) fw(ans[i],1); Heriko Deltana;} 「例题二」AT1219 歴史の研究原题链接：AtCoder-JOI2014 歴史の研究； 洛谷链接：AT1219 歴史の研究。 「例题二」题目简述给出长度为 $N$ 的序列，$Q$ 次询问，每次询问区间 $[L,R]$ 中最大的重要度。 重要度的定义为当前事件的权值 $X_i$ 乘上事件在区间中出现次数 $T_i.$ 「例题二」思路简述和上个题一样，这个题添加操作也是很好实现的，维护一个桶即可，删除操作一样的不能实现，所以我们用同样的策略。 「例题二」Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y) { Heriko x&gt;y?x:y;}template&lt;typename J&gt;I J Hmin(const J &amp;x,const J &amp;y) { Heriko x&lt;y?x:y;}CI MXX(2e5+1);int a[MXX],b[MXX],lx[MXX],rx[MXX],blo[MXX],n,qn,len,blocnt,cnt[MXX],co[MXX];LL ans[MXX],tmpans;struct Query { int l,r,id; I bool operator &lt; (const Query &amp;co) const { Heriko blo[l]==blo[co.l]?r&lt;co.r:l&lt;co.l; }}q[MXX];I void Add(int x) { ++cnt[a[x]]; tmpans=Hmax(tmpans,(LL)cnt[a[x]]*b[a[x]]);}S main() { Files(); fr(n),fr(qn),len=sqrt(n),blocnt=n/len; for(int i(1);i&lt;=n;++i) fr(a[i]),b[i]=a[i]; for(int i(1);i&lt;=qn;++i) fr(q[i].l),fr(q[i].r),q[i].id=i; sort(b+1,b+1+n); int nl(unique(b+1,b+1+n)-b-1); for(int i(1);i&lt;=n;++i) a[i]=lower_bound(b+1,b+1+nl,a[i])-b; for(int i(1);i&lt;=n;++i) blo[i]=(i-1)/len+1; for(int i(1);i&lt;=blocnt;++i) lx[i]=rx[i-1]+1,rx[i]=lx[i]+len-1; if(rx[blocnt]&lt;n) ++blocnt,lx[blocnt]=rx[blocnt-1]+1,rx[blocnt]=n;//这里用了一种和前面不同的处理每个块端点的方法，都不难写 int l(0),r(0),nw(1); sort(q+1,q+1+qn); for(int i(1);i&lt;=blocnt;++i) { mst(cnt,0); r=rx[i],tmpans=0; while(blo[q[nw].l]==i) { l=rx[i]+1; if(q[nw].r-q[nw].l&lt;=len) { mst(co,0); LL anothertmpans(0); for(int i(q[nw].l);i&lt;=q[nw].r;++i) ++co[a[i]]; for(int i(q[nw].l);i&lt;=q[nw].r;++i) anothertmpans=Hmax(anothertmpans,(LL)co[a[i]]*b[a[i]]); for(int i(q[nw].l);i&lt;=q[nw].r;++i) --co[a[i]]; ans[q[nw].id]=anothertmpans; } else { while(q[nw].r&gt;r) Add(++r); LL lsttmp(tmpans); while(q[nw].l&lt;l) Add(--l); ans[q[nw].id]=tmpans; tmpans=lsttmp; while(l&lt;=rx[i]) --cnt[a[l++]]; } ++nw; } } for(int i(1);i&lt;=qn;++i) fw(ans[i],1); Heriko Deltana;} 终了终了。","link":"/2022/02/22/Rollback-Mo-s-Algorithm/"},{"title":"SDOI2022 线上游记","text":"如题。 请注意我是线上省选和所有内容和现场省选不相关 Day -INF因为今年 SD 疫情，所以 SD 省选一推再推，从最一开始的参与联合省选，再到推迟到 5.1 再到推迟到 5.15，然后甚至 9H6T 创造人类耐力省选奇迹。 因为 JN 的疫情还没有太好，于是济南就单独出来考了，省选这天正好也是非毕业年级的返校日，这次疫情导致在家上网课了 40 多天。 同样是因为疫情及场地原因，原本是二等线之上都能参加省选改成了 112 分以上参加线下正式省选，其余参加线上同步省选，不计入成绩。 于是我就线上了。 其实本来不太像参加了，但是一直没找到人退钱。。（先交钱才改成的线上。。） 所以就线上游记了。 Day 1早上没去教室直接来机房了。 上午先是过了一遍 3 题，初步判断是：T1 感觉可做，T2 大概 DP，T3 大概计数但是不懂。 T1 观察到每次询问 $b$ 和 $c$ 都是固定的，所以可以预处理出前缀和方便做，这样的话 $O(qn^2)$ 的暴力显然。于是最一开始的想法是莫队找区间，但是每次询问都要生成一次 C 成了瓶颈，就不知道咋搞。 最后解决方案是在分块去找 $x$ 和 $y$ 累积答案，不知道对不对。 T2 暴力能拿几分不知道。 下午T1 感觉不可做，T2 卡空间不会做，T3 不会做。 说到 T2，昨天才说了今天省选可能考树剖，然后 T2 整一个……树剖，但是卡空间 64M…… 好吧！是一条链的情况我上一个树状数组。 但是我写挂了，麻了不写了，因为这几天一直心情不好，然后就交了，管你几分吧。 END省选无关，我现在是想写想说的东西太多了但是并找不到人去诉说，或者绝对一点的讲……根本就没有。","link":"/2022/05/15/SDOI2022/"},{"title":"SEKAI R1 赛后认锅","text":"我是锅王。 前言首先呢，我是傻逼，昨天因为加字幕去了忘了二次验题。 得分情况总体正常，不再说，下面来一一说我的锅。 A 憧憬の翼 题目链接 题目背景歌曲链接 于是我们贪心的从和里面，答案即为 $\\left\\lfloor\\dfrac{sum}{x^y}\\right\\rfloor.$ STD 就不放了，反正签到题。 B HelloWorld2022 视频链接 这题本身是一个树上每次将结点修改为其子树中最大值，每次询问子树中最大值的题，但是我寻思学弟学妹应该还不是都会树链剖分，所以就削了一刀到序列上了。 但是我今天上课的时候突然想起来这玩意好像不太能 $O(n \\log n)$ 的做，但是不能及时过来说，所以真的很对不起。 C Identity 题目链接 歌曲链接 这个题本身是周末闲的没事想起来的一个东西，因为看起来问题好像也挺经典，所以拿来出应该也不会太难。 然后最后 STD 有个地方溢出了于是数据锅了，真的很对不起。 60 分做法设 $F(n,m)$ 表示考虑将 $n$ 个区域用 $m$ 种颜色分。 首先考虑边界，显然 $F(1,m)=n,F(2,m)=m(m-1),F(3,m)=m(m-1)(m-2).$ 然后，我们先把这个圆拆为一条链，即不考虑首尾互斥的情况，那么答案显然是 $m(m-1)(m-1)\\cdots(m-1)=m(m-1)^{n-1}$，然后我们考虑首尾冲突，可得多出来的方案数正好是 $n-1$ 块用 $m$ 种颜色填的情况，那么就有转移方程 $F(n,m)=m(m-1)^{n-1}-F(n-1,m).$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*60pts Solution By Dfkuaid*/#define LOCAL#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int N = 100010;const int INF = 0x3f3f3f3f;const ll MOD = 1e9 + 7;template &lt;typename T&gt; inline void read(T &amp;x) { x = 0; int f = 1; char c = getchar(); for (; !isdigit(c); c = getchar()) if (c == '-') f = -f; for (; isdigit(c); c = getchar()) x = x * 10 + c - '0'; x *= f;}ll n, m, ans, t;inline ll fpow(ll a, int b) { ll res = 1; while (b) { if (b &amp; 1) (res *= a) %= MOD; b &gt;&gt;= 1, a = a * a % MOD; } return res;}inline void MAIN() { read(n), read(m); if (n == 1) ans = m; else if (n == 2) ans = m * (m - 1) % MOD; else ans = m * (m - 1) % MOD * (m - 2) % MOD; for (int i = 4; i &lt;= n; ++ i) ans = (m * fpow(m - 1, i - 1) % MOD - ans + MOD) % MOD; printf(&quot;%lld\\n&quot;, ans);}int main() {#ifdef LOCAL freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);#endif read(t); while (t --) MAIN(); return 0;} 100 分做法首先，上面不考虑首尾矛盾的情况的柿子可以表示成这样： $$m(m-1)^{n-1} = a_n + a_{n-1}$$ 没错，这玩意最后能变成一个可以求通项的东西，下面写一下： $$\\begin{aligned}m(m-1)^{n-1} &amp;= a_n + a_{n-1} \\\\a_n &amp;= -a_{n-1}+m(m-1)^{n-1} \\\\\\\\a_n+x(m-1)^n &amp;= -[a_{n-1}+x(m-1)^{n-1}] \\\\a_n &amp;= -a_{n-1}-x(m-1)^{x-1}-x(m-1)^n \\\\ &amp;= -a_n-x(m-1)^{n-1}\\cdot(1+m-1)\\\\ &amp;= -a_n-x(m-1)^{n-1}m \\\\\\Rightarrow x&amp;=-1\\\\\\\\a_n-1(m-1)^n &amp;= -[a_{n-1}-1(m-1)^{n-1}]\\\\\\because a_3&amp;=m(m-1)(m-2)\\\\\\therefore a_n-1(m-1)^n &amp;= -[a_3-1(m-1)^3]\\cdot(-1)^{n-3}\\\\ &amp;= a_n=(m-1)^n+(m-1)\\cdot(-1)^{n-1}\\\\ &amp;= (m-1)^n+(-1)^n\\cdot(m-1)\\\\\\end{aligned}$$ 1234567891011121314151617181920212223242526272829303132333435363738CI MOD(1e9+7);I LL FstPow(LL x,LL y) { x%=MOD; LL res(1); while(y) { if(y&amp;1) (res*=x)%=MOD; (x*=x)%=MOD; y&gt;&gt;=1; } Heriko res;}LL T,n,m,ans;S main() { Files(); fr(T); while(T--) { fr(n),fr(m); ans=FstPow(m-1,n)%MOD; if(n&amp;1) ans-=(m-1); else ans+=(m-1); fw(ans%MOD,1); } Heriko Deltana;} D 世界寿命と最後の一日 题目链接 歌曲链接 题解","link":"/2022/03/16/SEKAI-R1/"},{"title":"谜语集","text":"记录一些谜语。 启这些谜语，或没有谜底，或不是谜语。 大多是在学校写的，所以在家的时间段会显著的少。 2022.04.03颤抖的心情，等待的凉意。 2022.03.31好，虽相比有差，然我觉得这更好，人格差恰适应此。 2022.03.30 为什么，为什么，为什么，为什么，为什么，为什么，为什么，为什么，为什么，为什么，为什么，为什么，为什么，为什么，为什么，为什么，为什么，为什么，为什么 #某人潜伏生物宿舍一个半学期最终带领信息并入生物# 2022.03.29 昨天真有意思 2022.03.28 甚至不看我一眼 阿罗车队就是晕蛋 我的评价是：没必要 我的评价是：为什么 我的评价是：：：：：：：： 我的评价是：所以。 我的评价是：我真抽象。。 2022.03.27 Nothing - Kimi 优美，左手冰凉右手热，左半边脸热右半边凉，为啥会有这样的分差！祝我早日一分为二（） 一只人类尚未能探知到自我 占有欲是人类最恐怖的东西 毒电波毒电波毒电波毒电波毒电波毒电波 2022.03.26 What’s Happened? We need to know! What’s Happened? We need to know! What’s Happened? We need to know! What’s Happened? We need to know! 假面骑士 STROLL 无知者无罪（信） 2022.03.25 有被笑到我过生日成为纸王，宽哥过生日成为水果（木瓜）摊（ 2022.03.24 恢复跑操 我就是那种除了学术问题都能问我的 B. 2022.03.22 这周从家里回来之后，总觉得手脚冰凉，即使上周三到周六气温比这几天低。 好不容易把手捂热，一节课过去温度又下来了…… 2022.03.21 窝法一二，冠宇夺分，彳亍 什么是报告之王啊（后仰）真就近水楼台先得月 恰当的用例总是能引发人的感情 2022.03.20 注意力偏移（信） 2022.03.18 腹有诗书气善华 清早：谢谢有被吓到（再放送x） 《假如我成为大导体》 ↓深海烧酒↑ 有些人好会（指又看了一下贺卡） 人类，自相矛盾 2022.03.17 当我昨天第一个什么都没写（） 浮想行止 里表情人（x）、电火花（ 已经好久没数猎杀清单里多少人了，可能多了两三个 2022.03.16 可惜我执的笔写不出我真切的愿，而另一张纸上早已写满华章 引用 SAI 的一句话：So close but so far. 引用 LEC 的一句话：I am stupid；引用 VER 的一句话：Stupid idiot.","link":"/2022/04/03/Set-of-Riddles/"},{"title":"Start.","text":"此博客启用于 2021.10.30 再进行了一些列调试之后，这个博客大约可以开始正常使用力ヽ(✿ﾟ▽ﾟ)ノ 那么就开始啦，这个博客（ 这个博客目前好像和 Cnblogs 的那个博客没太有区分度呐（ 不过以后肯定会不太一样罢，这边会更新一些生活上的东西罢，而那边更偏向 OI 的样子。 目前是这样想的，其它以后再说吧，现在还不知道呐（ ε=ε=ε=(~￣▽￣)~ 大约是关于我的东西。","link":"/2021/10/30/Start/"},{"title":"Tarjan","text":"铊金金。 「启」之前一直没空写，NOIP 考前重新学了一下，虽然考场上完全没用到就是了。 大概按照 OI-Wiki 来简单写一点。 同步发布于Cnblogs. 「Pre」首先是一些前置知识。 「强连通分量」在有向图 $G$ 中强连通是指 $G$ 中的任意两个节点联通，强连通分量则是极大的强连通子图。 强连通分量的英文是 Strongly Connected Components，简称 SCC. 「DFS 搜索树」 除了普通的树边之外，DFS 搜索树中还有可能出现以下三种类型的边： 回边（红），即指向祖先结点的边。 横叉边（蓝），即边的另一端是一个已经遍历过，但不是当前结点祖先的点。 前向边（绿），搜索时遇到一个子树中的结点生成的。 那么在这颗搜索树中求 SCC，有以下的性质： 设结点 $x$ 为某个 SCC 在搜索树中遇到的第一个结点，那么这个 SCC 的剩余结点一定是搜索树中以 $x$ 为根的子树中。 可以反证证明：设有一个结点 $y$ 在当前 SCC 中但是不在搜索树中以 $x$ 为根的子树中，那么 $x$ 到 $y$ 的路径上一定有一条离开子树的边，即存在一条横叉边或者回边，然而根据定义发现两条边要求指向的结点是被访问过的，这和 $x$ 的定义矛盾，得证。 「Tarjan」Tarjan 主要是为每个结点 $x$ 维护了两个变量：dfn[x] 和 low[x]. 前者表示在 DFS 时 $x$ 被遍历到的次序，后者表示 $x$ 能回溯到的 dfn 最小的栈中的结点。显然的是后者可以用未访问过的子树中的结点 $y$ 的 low[y] 来更新，否则用 dfn[y] 更新。 「Code」之前的模板库里放了个栈用 vector 的，这里再放一个手写栈的，缺省源使用 「V5.2」. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465template &lt;typename J&gt;I J Hmin(const J &amp;x,const J &amp;y){ Heriko x&lt;y?x:y;}CI MXX(5e4+1),NXX(1e4+1);int n,m;struct Node{ int nex,to;}r[MXX];int rcnt,head[NXX];I void Add(int x,int y){ r[++rcnt]=(Node){head[x],y}; head[x]=rcnt;}int dfn[NXX],low[NXX],dfsid,stak[NXX],top,sz[NXX],scc[NXX],scctot;bitset&lt;NXX&gt; instak;void Tarjan(int x){ low[x]=dfn[x]=++dfsid; stak[++top]=x,instak[x]=1; for(int i(head[x]);i;i=r[i].nex) { int y(r[i].to); if(!dfn[y]) { Tarjan(y); low[x]=Hmin(low[x],low[y]); } else if(instak[y]) low[x]=Hmin(low[x],dfn[y]); } if(dfn[x]==low[x]) { ++scctot; while(stak[top]!=x) { scc[stak[top]]=scctot; ++sz[scctot]; instak[stak[top]]=0; --top; } scc[stak[top]]=scctot; ++sz[scctot]; instak[stak[top]]=0; --top; }} 「终」还是，不知道啥时候写游记（","link":"/2021/12/05/Tarjan/"},{"title":"树链剖分中的边权变点权","text":"浅谈树链剖分中的边权变点权 前言因为我只会轻重链剖分，所以下面都是说的轻重链剖分。 发现自己会写这个也有很长时间了，所以来水丶东西。 最近写了好两个，稍微借题来搞一搞，估计篇幅会很短，因为主要是简单说一说思路啥的。 思路首先，都知道树链剖分是用来维护一棵树上的结点信息的一种思想，而对于一些题，我们需要维护树上的边权，于是我们就需要将边权等效替换到点权上。 貌似这样的题在洛谷上的评级都是紫，但是其实没那么难（话说你谷评级啥时候准过。。） 首先简单画棵树： 显然如果我们要把边权变为点权，需要把权值化到边的两端。 而因为一个结点会出现对应多条边的情况，所以我们将权值放到深度浅的结点是不合适的，于是我们把他放在深度深的那个点： 于是我们就可以进行快乐的操作了。 实现线段树部分显然是不用动了，因为我们不需要对线段树做出特定的要求，换句话说，如果写树状数组或者珂朵莉树的话也是可以用的。 于是就来看前置的两个 DFS 和后面的树链部分需要作何修改。 DFS首先，因为我们要重新划归权值到点上，所以我们需要建立一个映射到点上的权值数组，这个直接在遍历的时候建立即可。 1234567891011121314151617181920void DFS1(int x,int fath){ sz[x]=1,fa[x]=fath; for(int i(head[x]);i;i=r[i].nex) { int y(r[i].to),v(r[i].val); if(y==fath) continue; dep[y]=dep[x]+1; tmp[y]=v;//这里 tmp 就是。 DFS1(y,x); sz[x]+=sz[y]; if(sz[y]&gt;sz[son[x]]) son[x]=y; }} 然后，因为我们还需要建立原树结点到线段树上的结点的映射，所以方便起见把权值也映射过去（ 1234567891011121314151617void DFS2(int x,int tp){ top[x]=tp,id[x]=++cnt,antid[cnt]=x,a[cnt]=tmp[x];//这里的 a 就是。 if(son[x]) DFS2(son[x],tp); for(int i(head[x]);i;i=r[i].nex) { int y(r[i].to); if(y==fa[x] or y==son[x]) continue; DFS2(y,y); }} 树链部分需要注意到的是我们询问一段路径上的边权最大值的时候，由于我们把权值全部下方到深度深的结点，所以路径上最浅结点的权值是不能计算在内的： 于是我们把原本修改和查询中最后在一条链上的情况稍作修改，即从 Modify(1,id[x],id[y],v); 和 Query(1,id[x],id[y]); 变为 Modify(1,id[x]+1,id[y],v); 和 Query(1,id[x]+1,id[y]);. 全部代码即为： 12345678910111213141516171819202122232425262728293031323334353637I void MTree(int x,int y,int val){ while(top[x]!=top[y]) { if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); Modify(1,id[top[x]],id[x],val); x=fa[top[x]]; } if(dep[x]&gt;dep[y]) swap(x,y); Modify(1,id[x]+1,id[y],val);}I int QTree(int x,int y){ int res(0); while(top[x]!=top[y]) { if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); res+=Query(1,id[top[x]],id[x]); x=fa[top[x]]; } if(dep[x]&gt;dep[y]) swap(x,y); res+=Query(1,id[x]+1,id[y]); Heriko res;} 例题洛谷 | P1505 旅游 [国家集训队] Time: 1s | Memory: 256Mb 这道题就需要用到上面的操作把边权下放到点权。 当然，因为这个题的特殊性（需要维护最大值、最小值、区间和），所以代码会很长（（ 不过还是不难的，线段树多复制几个函数分别维护即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define Heriko return#define Deltana 0#define Romanno 1#define S signed#define LL long long#define R register#define I inline#define CI const int#define mkp(a,b) make_pair(a,b)#define mst(a,b) memset(a,b,sizeof(a))#define ON std::ios::sync_with_stdio(false);cin.tie(0)#define Files() freopen(&quot;RNMTQ.in&quot;,&quot;r&quot;,stdin);freopen(&quot;RNMTQ.out&quot;,&quot;w&quot;,stdout)using namespace std;template&lt;typename J&gt;I void fr(J &amp;x){ short f(1); x=0; char c(getchar()); while(c&lt;'0' or c&gt;'9') { if(c=='-') f=-1; c=getchar(); } while(c&gt;='0' and c&lt;='9') { x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^=48); c=getchar(); } x*=f;}template&lt;typename J&gt;I void fw(J x,bool k){ if(x&lt;0) x=-x,putchar('-'); static short stak[35]; short top(0); do { stak[top++]=x%10; x/=10; } while(x); while(top) putchar(stak[--top]+'0'); k?puts(&quot;&quot;):putchar(' ');}template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y){ Heriko x&gt;y?x:y;}template&lt;typename J&gt;I J Hmin(const J &amp;x,const J &amp;y){ Heriko x&lt;y?x:y;}CI MXX(2e5+1),INF(0x7fffffff);struct Edge{ int nex,to,val;}r[MXX&lt;&lt;1];int rcnt,head[MXX];I void Add(int x,int y,int z){ r[++rcnt]=(Edge){head[x],y,z},head[x]=rcnt; r[++rcnt]=(Edge){head[y],x,z},head[y]=rcnt;}int tmp[MXX],cnt,a[MXX],sz[MXX],fa[MXX],dep[MXX],son[MXX],top[MXX],id[MXX],antid[MXX];void DFS1(int x,int fath){ sz[x]=1,fa[x]=fath; for(int i(head[x]);i;i=r[i].nex) { int y(r[i].to),v(r[i].val); if(y==fath) continue; dep[y]=dep[x]+1; tmp[y]=v; DFS1(y,x); sz[x]+=sz[y]; if(sz[y]&gt;sz[son[x]]) son[x]=y; }}void DFS2(int x,int tp){ top[x]=tp,id[x]=++cnt,antid[cnt]=x,a[cnt]=tmp[x]; if(son[x]) DFS2(son[x],tp); for(int i(head[x]);i;i=r[i].nex) { int y(r[i].to); if(y==fa[x] or y==son[x]) continue; DFS2(y,y); }}#define lc(x) (x&lt;&lt;1)#define rc(x) (x&lt;&lt;1|1)struct Node{ int l,r,tg,mx,mi,v;}t[MXX&lt;&lt;2];I void Pushup(int x){ t[x].mi=Hmin(t[lc(x)].mi,t[rc(x)].mi); t[x].mx=Hmax(t[lc(x)].mx,t[rc(x)].mx); t[x].v=t[lc(x)].v+t[rc(x)].v;}I void Cover(int x){ t[x].tg^=1; t[x].v=-t[x].v; t[x].mi=-t[x].mi; t[x].mx=-t[x].mx; swap(t[x].mi,t[x].mx);}I void Pushdown(int x){ if(!t[x].tg) Heriko; Cover(lc(x)); Cover(rc(x)); t[x].tg=0;}void Build(int x,int l,int r){ t[x].l=l,t[x].r=r,t[x].tg=0; if(l==r) { t[x].v=t[x].mi=t[x].mx=a[l]; Heriko; } int mid((l+r)&gt;&gt;1); Build(lc(x),l,mid); Build(rc(x),mid+1,r); Pushup(x);}void ModifyOne(int x,int pos,int val){ if(t[x].l==t[x].r) { t[x].mx=t[x].mi=t[x].v=val; Heriko; } Pushdown(x); int mid((t[x].l+t[x].r)&gt;&gt;1); if(pos&lt;=mid) ModifyOne(lc(x),pos,val); if(pos&gt;mid) ModifyOne(rc(x),pos,val); Pushup(x);}void ModifyAll(int x,int lx,int rx){ if(lx&lt;=t[x].l and t[x].r&lt;=rx) { Cover(x); Heriko; } Pushdown(x); int mid((t[x].l+t[x].r)&gt;&gt;1); if(lx&lt;=mid) ModifyAll(lc(x),lx,rx); if(rx&gt;mid) ModifyAll(rc(x),lx,rx); Pushup(x);}int QueryMax(int x,int lx,int rx){ if(lx&lt;=t[x].l and t[x].r&lt;=rx) Heriko t[x].mx; Pushdown(x); int res(-INF),mid((t[x].l+t[x].r)&gt;&gt;1); if(lx&lt;=mid) res=Hmax(res,QueryMax(lc(x),lx,rx)); if(rx&gt;mid) res=Hmax(res,QueryMax(rc(x),lx,rx)); Heriko res;}int QueryMin(int x,int lx,int rx){ if(lx&lt;=t[x].l and t[x].r&lt;=rx) Heriko t[x].mi; Pushdown(x); int res(INF),mid((t[x].l+t[x].r)&gt;&gt;1); if(lx&lt;=mid) res=Hmin(res,QueryMin(lc(x),lx,rx)); if(rx&gt;mid) res=Hmin(res,QueryMin(rc(x),lx,rx)); Heriko res;}int QuerySum(int x,int lx,int rx){ if(lx&lt;=t[x].l and t[x].r&lt;=rx) Heriko t[x].v; Pushdown(x); int res(0),mid((t[x].l+t[x].r)&gt;&gt;1); if(lx&lt;=mid) res+=QuerySum(lc(x),lx,rx); if(rx&gt;mid) res+=QuerySum(rc(x),lx,rx); Heriko res;}I void MTree(int x,int y){ while(top[x]!=top[y]) { if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); ModifyAll(1,id[top[x]],id[x]); x=fa[top[x]]; } if(dep[x]&gt;dep[y]) swap(x,y); if(x!=y) ModifyAll(1,id[x]+1,id[y]);}I int QTreeMax(int x,int y){ int res(-INF); while(top[x]!=top[y]) { if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); res=Hmax(res,QueryMax(1,id[top[x]],id[x])); x=fa[top[x]]; } if(dep[x]&gt;dep[y]) swap(x,y); if(x!=y) res=Hmax(res,QueryMax(1,id[x]+1,id[y])); Heriko res;}I int QTreeMin(int x,int y){ int res(INF); while(top[x]!=top[y]) { if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); res=Hmin(res,QueryMin(1,id[top[x]],id[x])); x=fa[top[x]]; } if(dep[x]&gt;dep[y]) swap(x,y); if(x!=y) res=Hmin(res,QueryMin(1,id[x]+1,id[y])); Heriko res;}I int QTreeSum(int x,int y){ int res(0); while(top[x]!=top[y]) { if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); res+=QuerySum(1,id[top[x]],id[x]); x=fa[top[x]]; } if(dep[x]&gt;dep[y]) swap(x,y); if(x!=y) res+=QuerySum(1,id[x]+1,id[y]); Heriko res;}int n,m;pair&lt;int,int&gt; E[MXX];S main(){ Files(); fr(n); for(int i(1);i&lt;n;++i) { int x,y,z; fr(x),fr(y),fr(z); Add(x+1,y+1,z); E[i].first=x+1,E[i].second=y+1; } fr(m); DFS1(1,0); DFS2(1,1); Build(1,1,n); while(m--) { char opt[10]; int x,y; scanf(&quot;%s&quot;,opt+1),fr(x),fr(y); if(opt[1]=='C') { if(dep[E[x].first]&gt;dep[E[x].second]) ModifyOne(1,id[E[x].first],y); else ModifyOne(1,id[E[x].second],y); } else if(opt[1]=='N') MTree(x+1,y+1); else if(opt[1]=='S') fw(QTreeSum(x+1,y+1),1); else if(opt[1]=='M' and opt[2]=='A') fw(QTreeMax(x+1,y+1),1); else if(opt[1]=='M' and opt[2]=='I') fw(QTreeMin(x+1,y+1),1); } Heriko Deltana;} 关于这道题做完之后在杂题记录里的感想： 我在上个题的时候曾经说过： 不得不说虽然长是长了点，树剖还是好玩的，对于我这种没有脑子的人来说，不用想就能打的东西太好了。 确实，于是这个题的代码长度就成为了我目前为止通过代码中最长的，415 行，7Kb。（当然，和我码风有空行有关系） 树剖部分基本是一遍写对的，最后错了半天是因为题目说的边的编号要是 $0 \\sim n-1$，但是我读入的时候忘了 +1，害的我把前面的重新看了一遍。。 但是还好这是 7Kb 的树剖而不是其它别的什么鬼东西。 终声水完力（","link":"/2022/01/08/Tree-chain-splitting/"},{"title":"WC 2022 线上游记","text":"WC 2022 线上游记。 Day -?WC 又一次因为疫情改到了线上，于是我也有了机会进行一个报名（ Day 0下午开幕式，体验很莫名，但是居然有人跳舞是我没想到的。 Day 1早上直接来机房，好事（虽然不如放假，但是也比上 whk 好得多了），进行一个语文课文的背（ 上午上午是刘汝佳老师和曹钦翔讲的信息学竞赛中的直觉与证明。 首先是一个证明一些贪心和 DP 决策正确性的常见证明思路，就是要证明在任何时刻换一个决策都不会有更好的结果，因为我们会有很多的直觉（我没有），所以证明这些直觉是否正确是一个很重要的东西（ 讲了一种方法： Exchange Argument：假设存在一个更优的算法和我们的决策相接近，然后通过交换两个算法里的一个步骤（或元素），得到一个新的更优的算法，同时这个算法比前一个最优算法更接近于我们的贪心算法，从而得到矛盾，原命题成立。过程就是交换元素后比较，不算难理解。 决策规范化是个好东西，有时可以同时简化思路、证明和代码。 找反例也是一个好习惯，可以精准的知道一个错误算法的缺陷到底在哪，当然若找不到，也是一种证明的过程，在时间有限的情况下，如果找了很多看起来能推倒当前结论的“反例”，那么也算是一种相对可信的证明过程（当然前提是你的“反例”有足够的强度）。 当然把东西抽象出来也是好事，便于我们分析东西。 还有一个 rewrite，即改写，常用来证明等价性，常见的例子就是多项式展开、微积分（我不会）、手玩过程展开等 第一段的时候讨论区无人发言，课间就变得活跃了起来，然后上课就一直很活跃了（ 草，第二节突然开始提速，SPEEEEEED UP. 第三节持续 SPEEEEEED UP（坏 两分钟一道题，害怕，害怕。 下午下午的第一课堂是：网站可靠性工程中的算法，老师是钟诚。 第二课堂是链表相关，但是我看了一遍课件只有跳跃表我不会，但是前段时间 tyy 画的不用学的东西里就有这个（ 所以就去第一课堂听，然后顺便整理一下上午的内容。 中间老师为了铺垫放了一段某电影的预告片，结果班主任进入机房问我为什么看电影。。 然后中间因为打错个字被管理员踢出去了（？ 不能理解哦。 然后因为疫情我不能通校了，但是……为什么学弟学妹今天就直接放假了（？ 不懂哦（ 前面那个事情，是因为管理员说要把说*脏话*的人踢出去，起因是老师一不小心说了个：wc，非常符合主题（bushi 然后截止到五点，已经出现了 3*wc了（ 但是我寻思我也没发脏字啊（？ 不理解哦（ 晚上晚上是集训队大佬们的交流分享，先是”浅谈一类哈希表的复杂度分析“。 说是和 OI 里学的关系不算很大，当作科普（ 那么就听吧，顺便把刚才选的树剖 + 李超线段树写一写（ 飞速讲完，居然是多人讲么，我还以为是就一个人（ 然后是“双射在划分计数上的应用”，有例题（ 然后是“模拟费用流”，这个时候正好我那题写完了，但是……略离谱，样例都不对。 然后是……额这位大佬比较特别，ppt 名字就叫营员交流（ 然后晚上就一直在调 [SDOI2016]游戏……死活找不到错……日。 Day2上午第一课堂看起来像是给集训队爷颓废指点前方道路的课，于是来第二课堂听网络瘤（ 讲课老师是李健欸（ 这些边我不加，这些边我不加，暴力怎么做？ 加边加边加边，冰茶姬查询（ 然鹅他今天讲的网络瘤（ 下午钱易佬讲 DS 杂题，这不得听之。 但是发现越来越写不出来笔记了（呆 前面能跟上，后面直接掉线（呆 下课之后有位同学放出来了自己的灵梦fumo（好 Day3上午dmy 讲杂题ww “我不会啊我就是个憨憨” ”不要急优势在我“ “有一个憨憨故事……啊三国演义，就锦囊” “怎么这么多评论区，哦说我现写，没有关系我和大家同场竞技” 《我是椰树牌椰汁的粉丝，我很会排版》 神峰：金 句 频 出 神虎：我宣布，这里就是金句广场 “有些同学说没听懂，没听懂还加个问号，那就是听懂了”（确信 “初三开始给北京队讲，讲到现在” 《没问题》 《大家都很有智慧，谢谢大家》 “恍然大雾我也不知道是恍然还是大雾，这可能是个偏义复词” 《连 根 拔 起》 《掀起波兰》 神虎：《dmy 掀起波兰》 “大家都是成熟的 OI 人了都会很熟练的使用 $\\LaTeX$ 拉泰科了大家自己渲染一下” “给大家表演一下找代码，给大家表现一下我的技术（计数？）实力，我是纯憨憨，一个野蛮人” “哇我粘一下” “我给大家放大，很大很大“（指超出屏幕 “return (0-0);//&lt;3” “这个题目很好，好就好在它什么是地方都很好，就都很好” “我认为这个题很好，你们都应该看看，因为这个题很好，就大家多看看非常好” “不是说这个题怎么，他就是非常好” “这个题很好，真的很好，非常有教育意义，就是对于刚学 DP” “有人会 $O(n^4)$，有人会 $O(n^3)$，有人会 $(2^n)$，有人会 $O(n^2 \\log n)$，这个题就是好在这个地方“ ”有的人读不懂题，确实” “啊对对对对，苹果输入法她很憨” “哎呀不想共享桌面，这样的话其他同学给我编做法就会被看见了” “优势在我，在不在，好像不太在” “我跟几个老哥交流做法，然后他们过来我没过就有点难过”（看起来是物理难过（ “腾讯会议设计的人是个鬼才，大家以后设计东西一定不要设计成这样，我登录一下输验证码 10 几次” “这题当时只有三个人过” “这个题（指上面那个三个人过的题）还是挺简单的” “很奇怪的就是做出来的好像都赢过 IOI” “后面还有好多道题，没有关系，优势（逐渐小声）……优势在谁（声音渐无）” 《benq写了一年，dmy写了十分钟》 《benq怎么做到的 很难理解》 《很难理解》 《benq的不会的题 我会 都是好题》 “不要慌，优势在我，给大家表演一下光速讲课，我超会讲的啦，给大家共享一下，做大共享家” “这题我 20 分钟就过了，下个题我用了 114514 分钟” “这和我最近写的论文差不多，但是我写的论文的方法吊打他，这个不需要我论文的做法” “剩下还有六道题，四十分钟够了，不要急，优势在我” 《luogu上能有加强版？》 《luogu这么有实力的吗》 “我题解进步很大，自从我用了太婆rua” “现在快晚上一点了，明天还有考试，上个大学怎么这么多事嘛” 《构造主要就是图一乐》 《T姓选手》 “我电脑怎么卡了” 《冷静一下，不要寄》 《人工智能觉醒》 《裹上鸡蛋面包糠》 《苹果就这？》 《有人在用他挖矿》 《苹 果 就 是 垃 圾》 《卡老师，不卡》 神虎：#【】老师 SSH 侵入 MIT 网络并给 dmy 电脑下病毒# 《是因为苹果太好了，所以永不重启》 一上午的金句（ 发现同样的记录人：邓老师2022冬令营讲课简介 下午鱼大讲构造，不过莫名 rap（ 我构造不能，冬眠营（ 草，完全掉线，写题去了（ Day4上午大约只有第一课堂能听了吧（ 那就听彭老师讲 IOI2022 题目预测吧（ 虽然我这辈子估计都看不到IOI、NOI（ 说到动态电阻是 CTSC 标准题目（ #物理被四大学科夺舍 ¯\\_(ツ)_/¯ 这表情好好笑（ IOI: Host didn’t want a 600 dmy: 优势在我 冬令营梗蜂以及梗鼠： 椰树：dmy：《我是椰树牌椰汁的粉丝，我很会排版》 fumo：上面说到了。 土拨鼠：今天老师喜欢使用土拨鼠来表示惊讶（ 仓鼠：…… 离谱题： 下午DCX 讲杂题（ 之前在 zr 听他讲题就觉得他声音特别像张京华，现在越听越像（ 就是声音像张京华，说话方式像 Tim（影视飓风） 观看了评论区的 dmy 名言之后，发出感叹：《邓老师好有水平》 草，综合版 晚上测试平台，额……和 NOI ONLINE/NOI 同步赛是一样的平台，给的测试题是 NOIO 2020 #3 入门组题目 幸好不是那个 T2 紫题的 NOIO 入门。 T1 读错题了（ 然后做的还挺快的，没多久就全交上了，洛谷测了应该都对。 今天晚上回家，希望明天考试 RP++. Day5 因为今天考试而我又非常菜啥都不会，所以没有什么东西可以记的 上午昨天晚上定了早上六点半的铃，铃响，我醒了，非常冷静的关掉了铃，然后接着睡（ 最后是七点起的床（ 八点二十多的时候把东西大约都准备好了（指本地的文件夹 然后就开始做。 上来看 T1，怎么又是括号序列，我谢谢你，大约分析了十分钟左右发现可以将题目中给的操作转化为括号树上的旋转操作，然后能转化成一个链…… 然后我就不知道怎么搞了于是去看 T2. T2 的十分暴力非常显然，于是开始思考正解。 因为是个排列所以思考如何利用排列性质……想了快一个小时没分析出来（ 然后因为一看就是 DS 题，所以考虑我曾经学过的 DS，经过了筛选之后 $n \\log n$ 我都觉得不太行，于是最后剩下了分块和莫队。 但是这题需要回滚莫队，我不会，爬了。 T3 简而言之就是《我读不懂题但是写了纯随机但是觉得没用就没交》 然后就寄了，10 分，可能就？ 那么这个 WC，就这样画上句号吧，哦对了下午还有讲评。 下午T1：《小清新构造题》 T2：《lxl DS 题》，说实话我看到成员列表出现 lxl 就觉得事情不妙（ T3：《游戏改编但是随机化好多分 std 甚至写了 20k》 那么这个 WC，就这样画上句号吧，哦对了明天还有闭幕式，不过我个打铁的有啥好期待的。 Day6啊哈哈哈，出分啦，差五分 Cu，菜，那么这个 WC，就这样画上句号吧。","link":"/2022/01/23/WC2022Notes/"},{"title":"引越しできるかな？","text":"藉以此篇，纪念刚学 OI 的我。 当我今天看我未 AC 的题面时，看到了这道题，想起我当时的样子，看到这个题没有人做，题面还有锅，于是决定提供翻译，以及修复样例，来纪念十一个月前啥都不会的我。 引越しできるかな？你 会 搬 家 吗？ 原题链接。 题目翻译现在有 $C$ 件长方体物品，给出其长，宽，高，求能够单独放得下每个物体所需最小的长方体盒子的体积。 物品不会倾斜放置。 输入格式输入共 $C+1$ 行，第一行为一个整数 $C.$ 第二行到第 $C+1$ 行，每行三个整数 $N,M,L$ 表示第 $i$ 个物体的长宽高。 输出格式一行一个整数表示所需的最小长方体盒子的体积。 输入输出样例输入#1 123210 20 3020 20 20 输出#1 112000 输入#2 1234310 20 3020 20 2030 20 10 输出#2 112000 输入#3 12345410 20 3020 20 2030 20 1010 40 10 输出#3 116000 输入#4 123210 10 1011 1 1 输出#4 11100 数据范围对于 $40%$ 的数据，满足 $1 \\le C \\le 10.$ 对于 $100%$ 的数据，满足 $1 \\le C,N,M,L \\le 100.$ 思路简述题面意思很明了，所以直接说做法。 因为我们只需要保证能有一种姿势能放进去就行，所以每次读入的时候按照大小顺序去更新盒子的三维即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define Heriko return#define Deltana 0#define Romanno 1#define S signed#define LL long long#define R register#define I inline#define CI const int#define mkp(a,b) make_pair(a,b)#define mst(a,b) memset(a,b,sizeof(a))#define ON std::ios::sync_with_stdio(false);cin.tie(0)#define Files() freopen(&quot;RNMTQ.in&quot;,&quot;r&quot;,stdin);freopen(&quot;RNMTQ.out&quot;,&quot;w&quot;,stdout)using namespace std;template&lt;typename J&gt;I void fr(J &amp;x){ short f(1); x=0; char c(getchar()); while(c&lt;'0' or c&gt;'9') { if(c=='-') f=-1; c=getchar(); } while(c&gt;='0' and c&lt;='9') { x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^=48); c=getchar(); } x*=f;}template&lt;typename J&gt;I void fw(J x,bool k){ if(x&lt;0) x=-x,putchar('-'); static short stak[35]; short top(0); do { stak[top++]=x%10; x/=10; } while(x); while(top) putchar(stak[--top]+'0'); k?puts(&quot;&quot;):putchar(' ');}template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y){ Heriko x&gt;y?x:y;}CI MXX(101);int n,ans[3],tmp[3];S main(){ Files(); fr(n); for(int i(1);i&lt;=n;++i) { fr(tmp[0]),fr(tmp[1]),fr(tmp[2]); sort(tmp,tmp+3); sort(ans,ans+3); ans[0]=Hmax(ans[0],tmp[0]); ans[1]=Hmax(ans[1],tmp[1]); ans[2]=Hmax(ans[2],tmp[2]); } fw(ans[0]*ans[1]*ans[2],1); Heriko Deltana;}","link":"/2021/12/10/%E5%BC%95%E8%B6%8A%E3%81%97%E3%81%A7%E3%81%8D%E3%82%8B%E3%81%8B%E3%81%AA%EF%BC%9F/"},{"title":"ZR NOIP21 D9 简记","text":"雪降り、メリクリ 圣诞，圣诞，圣诞节！ 「启」立冬就下暴雪，好。 随便写一下，因为 C 和 D 都不想写代码了，所以就快快口胡一下吧。 缺省源使用：「V5.2」。 「A」按照 %m 来统计方案数，每次用矩阵来转移。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778CI NXX(101),MXX(21),MOD(1e9+7);struct Matrix{ int n,m,a[MXX][MXX]; Matrix() { n=m=0,mst(a,0); } I void Build() { for(int i(1);i&lt;=m;++i) a[i][i]=1; } I Matrix operator * (const Matrix &amp;co) const { Matrix res; res.n=n,res.m=co.m; for(int i(1);i&lt;=n;++i) for(int k(1);k&lt;=m;++k) for(int j(1);j&lt;=co.m;++j) (res.a[i][j]+=(1ll*a[i][k]*co.a[k][j])%MOD)%=MOD; Heriko res; }}ans;int n,m;I Matrix MFP(Matrix x,int y){ Matrix res; res.n=res.m=m; res.Build(); while(y) { if(y&amp;1) res=res*x; x=x*x; y&gt;&gt;=1; } Heriko res;}S main(){ Files(); fr(n),fr(m); ans.n=1,ans.m=m; ans.a[1][m]=1; for(int i(1);i&lt;=n;++i) { int x,y; fr(x),fr(y); Matrix tmp; tmp.n=tmp.m=m; for(int j(1);j&lt;=m;++j) ++tmp.a[j][j],++tmp.a[j][(j+y-1)%m+1]; ans=MFP(tmp,x)*ans; } fw((ans.a[1][m]+MOD-1)%MOD,1); Heriko Deltana;} 「B」结论题，好像有很多人是直接上了平衡树（ 但是其实玩一玩就能发现，假如我们给 $[1,a_1],[a_1+1,a_2] \\cdots [a_{n-1}+1,a_n]$ 这些段编上编号：$1,2,\\cdots,k$，就会发现，这些段在最后的顺序只和 $k$ 的奇偶性相关，即偶数的时候先倒序输出偶数编号的段再顺序输出奇数段，反之先倒叙输出奇数段，再正序输出偶数段。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354CI MXX(5e5+1);int n,k,q[MXX],cnt1,cnt2;pair&lt;int,int&gt; co1[MXX],co2[MXX];char s[MXX];S main(){ Files(); fr(n),fr(k); scanf(&quot;%s&quot;,s+1); int lst(1); for(int i(1);i&lt;=k;++i) { fr(q[i]); if(i&amp;1) co1[++cnt1]=mkp(lst,q[i]); else co2[++cnt2]=mkp(lst,q[i]); lst=q[i]+1; } if(k&amp;1) { for(int i(cnt1);i;--i) for(int j(co1[i].second);j&gt;=co1[i].first;--j) putchar(s[j]); for(int i(1);i&lt;=cnt2;++i) for(int j(co2[i].first);j&lt;=co2[i].second;++j) putchar(s[j]); } else { for(int i(cnt2);i;--i) for(int j(co2[i].second);j&gt;=co2[i].first;--j) putchar(s[j]); for(int i(1);i&lt;=cnt1;++i) for(int j(co1[i].first);j&lt;=co1[i].second;++j) putchar(s[j]); } for(int i(lst);i&lt;=n;++i) putchar(s[i]); Heriko Deltana;} 「C」分讨，先把奇数的情况全加上一个 $1$，再把 $20$ 的情况转化为其他数组合的方案，于是就只剩下了 $1,2,5,10$ 需要考虑。 然后考虑如何把 $10$ 转化为其他的数字。考虑模 $10$ 的余数，发现除了余 $1,3,6,8$ 的时候都能有唯一的方案，然后这四种之间通过加减 $2$ 可以最后转化为两类，然后就看要多少的 $5,2,2,2$ 和 $5,1.$ 没写代码，爬。 「D」好像设涉及泰勒展开和多项式求和，这比我技能树高的不知道到哪去了（ 🎨：写完了ヽ(✿ﾟ▽ﾟ)ノ 我去发到博客里。 🐟: $ヽ(✿ﾟ▽ﾟ)ノ$ 「保留内容」🐏：非抄袭，非代表性，个人印象。 🐏：我现在都不会A我靠都 都很厉害AZ很 厉害🤩 🎨：AB 都 A 了，但是我场上没 A 掉 A。嗯😩我胡诌。好多人都是什么伸臂方法啥的，我™硬理解理解出来这个，但是我不会实现。。。。然后看王亦木，发现差不多，然后乆写，最后调了半天发现乘法的地方爆int了（ 🐟: 都在学习, 只有🐟在颓废😭 🎨：呜呜呜 🐏：我写A去了👋🏻草好我要学矩阵 🎨：祝你拿最优解，主要是前面的复杂度和我都不一样。那个我理解不出来，你看 xuruiyang 那个 🐏：我看看去 (【🐟：空格好评玉喜为你点赞】)我哦也不会 🎨：卧槽我用 ☁️ 这个键盘的错字率太高了，平均每个字都能错。 🎨：多 人 混 战","link":"/2021/11/07/ZR-NOIP21-D9-Solu/"},{"title":"ZROI NOIP21 冲刺汇总","text":"正睿 NOIP20 天冲刺 同步发布于ZROI NOIP21 冲刺汇总 (Cnblogs) 「启」[TOC] 实际上之前是单独发的，但是因为每天一测，不一定能够补完当天的题目，所以就将所有的未补完的考试中已经补过的题放在这里。 四道题全部整完的会单独发出。 UPD 2021.11.8 「Day1」讲课，略。 「Day2」✅ ZR-NOIP21-20D-D2 已经整理完，博客为：总之就是 | ZROI NOIP21 冲刺 Day2。 「Day3」⬜ ZR-NOIP21-20D-D3 「启」今天在🐏的强码力支持下没有爆零（ 缺省源和「这一篇」一致； 「A」 一道搞一搞出奇迹的题。 「A」题目简述给出一个 $3 \\times 3$ 的矩阵，里面填入了 $1$ 到 $9$，求问最少进行几次操作可以使得这个矩阵满足：每行三个数之和为 $15$，每列三个数之和为 $15$，且每条对角线三个数之和也为 $15.$ 操作即为交换相邻的两个数，题目为 $T,(T \\le 50)$ 组询问。 「A」思路简述经过手玩/爆搜，发现如果我们把矩阵表述为一个长为 $9$ 的序列，最终只有 $8$ 种目标序列： $$2 7 6 9 5 1 4 3 8 \\2 9 4 7 5 3 6 1 8 \\4 3 8 9 5 1 2 7 6 \\4 9 2 3 5 7 8 1 6 \\6 1 8 7 5 3 2 9 4 \\6 7 2 1 5 9 8 3 4 \\8 1 6 3 5 7 4 9 2 \\8 3 4 1 5 9 6 7 2 \\$$ 于是我们考虑去双向 BFS. 于是考虑一下这样做的复杂度：一共有 $12$ 种操作，一个矩阵最多扩展出 $9!$ 种状态，也就是说复杂度为 $O(8 \\times 9!T).$ 但是这样是过不去的，于是考虑把这个 $8$ 的常数干掉，于是乆有了对于目标矩阵的离散化，所以最终的时间复杂度为 $O(9!T).$ 在 BFS 的过程之中用到了 Hash 去判断重复状态（ 「A」Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149template&lt;typename J&gt;I J Hmin(const J &amp;x,const J &amp;y) {Heriko x&lt;y?x:y;}CI MOD(1000003),TXX(400000);int n,Tco[10],f[10][10],sum,Sco[9][10],co[10],a[10];int r[13][2];void Pre(){ for(int i(1);i&lt;=9;++i) Tco[i]=i; do { if (Tco[1]+Tco[2]+Tco[3] != 15 or Tco[4]+Tco[5]+Tco[6] != 15 or Tco[7]+Tco[8]+Tco[9] != 15 or Tco[1]+Tco[4]+Tco[7] != 15 or Tco[2]+Tco[5]+Tco[8] != 15 or Tco[3]+Tco[6]+Tco[9] != 15 or Tco[1]+Tco[5]+Tco[9] != 15 or Tco[3]+Tco[5]+Tco[7] != 15) continue; ++sum; for (int i(1);i&lt;=9;++i) f[sum][i]=Tco[i],Sco[sum][Tco[i]]=i; puts(&quot;&quot;); } while(next_permutation(Tco+1,Tco+10)); r[1][0]=1,r[1][1]=2; r[2][0]=2,r[2][1]=3; r[3][0]=1,r[3][1]=4; r[4][0]=2,r[4][1]=5; r[5][0]=3,r[5][1]=6; r[6][0]=4,r[6][1]=5; r[7][0]=5,r[7][1]=6; r[8][0]=4,r[8][1]=7; r[9][0]=5,r[9][1]=8; r[10][0]=6,r[10][1]=9; r[11][0]=7,r[11][1]=8; r[12][0]=8,r[12][1]=9;}struct Core{ int id,ans;};struct Node{ int nxt,key,cnt;}t[TXX];int head[MOD+10],tot;I void Add(int x,int k) {t[++tot]=(Node){(int)head[x%MOD],x,k};head[x%MOD]=tot;}I bool CheckBool(int x){ for (int i(head[x%MOD]);i;i=t[i].nxt) if (t[i].key==x) Heriko Romanno; Heriko Deltana;}I int CheckInt(int x){ for (int i(head[x%MOD]);i;i=t[i].nxt) if (t[i].key==x) Heriko t[i].cnt; Heriko Deltana;}int m[10];I int Modify(int x,int id){ int temp(0),now,pw(1); for(int i(9);i;--i) m[i]=(x%10),x/=10; for (int i(9);i;--i) { now=m[i]; if (now==r[id][1]) now=r[id][0]; else if (now==r[id][0]) now=r[id][1]; temp+=pw*now;pw*=10; } Heriko temp;}I void BFS(){ queue&lt;Core&gt; q; q.push((Core){123456789,0}); while (!q.empty()) { int x=q.front().id; int k=q.front().ans; q.pop(); if (CheckBool(x)) continue; Add(x,k); for (int i=1;i&lt;=12;++i) { int Ner(Modify(x,i)); q.push((Core){Ner,k+1}); } }}int main(){ Files(); Pre();BFS(); int T;fr(T); while (T--) { for(int i(1);i&lt;=9;++i) fr(a[i]); int ans(100); for(int i(1);i&lt;=8;++i) { for(int j(1);j&lt;=9;++j) co[j]=Sco[i][a[j]]; int temp(0),pw(1); for(int j(9);j;--j) temp+=pw*co[j],pw*=10; ans = min(CheckInt(temp),ans); } fw(ans,1); } Heriko Deltana;} 「Day4」✅ ZR-NOIP-21-20D-D4 已经整理完，博客为：总之就是 | ZROI NOIP21 冲刺 Day4。 「Day5」⬜ ZR-NOIP21-20D-D5 「启」昨天上大分，今天挂大分，就当是一场梦，醒来还是很感动 缺省源使用「V5」. 「A」 这题我场上写假了两个之后，又交了个假的上去…… 「A」题目简述对于长度同为 $n$ 的数 $a$ 和 $b$，定义其距离为 $d(a,b) = \\sum_{i=1}^n(a_i-b_i)^2.$ 现在你可以任意交换 $a$ 的两个元素，求使得距离最短的最少交换次数。 求距离，若 $opt=1$，输出最少交换次数。 数据范围：$n \\le 300000.$ 「A」思路简述对于最短距离，sort 一下即可。 对于交换次数，我们用冰茶姬维护一下，再比较即可。 「A」Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950CI MXX(3e5+1),MOD(998244353);struct Node{ int val,id; I bool operator &lt; (const Node &amp;co) const {Heriko val&lt;co.val;}}a[MXX],b[MXX];int n,opt,fa[MXX];LL ans;LL Find(int x){ if(fa[x]!=x) fa[x]=Find(fa[x]); Heriko fa[x];}S main(){ Files(); fr(n),fr(opt); for(int i(1);i&lt;=n;++i) fr(a[i].val),a[i].id=i; for(int i(1);i&lt;=n;++i) fr(b[i].val),b[i].id=i; for(int i(1);i&lt;=n;++i) fa[i]=i; sort(a+1,a+1+n);sort(b+1,b+1+n); for(int i(1);i&lt;=n;++i) (ans+=1ll*(a[i].val-b[i].val)*(a[i].val-b[i].val)%MOD)%=MOD,fa[Find(a[i].id)]=Find(b[i].id); fw((ans+MOD)%MOD,0); if(opt) { ans=0; for(int i(1);i&lt;=n;++i) ans+=(fa[i]!=i); fw(ans,1); } Heriko Deltana;} 「B」 场上想的是正解，但是因为做 A 做的心态炸了所以场上就没写出来（ 「B」题目简述国际象棋中，主教这个棋子可以攻击所有与其在同一条斜线上的位置（自己所处位置也算在内），现在在 $n \\times n$ 的棋盘中给出 $m$ 个主教，问棋盘中还有几个不会被攻击到的位置。 数据范围：$1 \\le n,m \\le 10^6.$ 「B」思路简述因为是 $10^6$，即使是三秒时限，$O(n^2)$ 也铁定过不去，所以考虑 $O(n)$ 的做法。 考虑到一个棋子带来的影响只在两条直线上，所以我们考虑这两条直线的解析式：$y_1=x+b_1,y_2=-x+b_2.$ 于是我们只需要记录 $b_1$ 和 $b_2$ 来判断边出现过没有即可。 因为所有的 $y_1$ 都是平行的，所以我们只需要考虑其和所有 $y_2$ 的交点即可，而这个可以前缀和优化。 于是乆做到了复杂度 $O(n).$ 「B」Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849template&lt;typename J&gt;I J Habs(const J &amp;x) {Heriko x&lt;0?-x:x;}CI MXX(2e6+1);int n,m,sum[MXX];LL ans;bitset&lt;MXX&gt; co[2];S main(){ Files(); fr(n),fr(m); for(int i(1),x,y;i&lt;=m;++i) { fr(x),fr(y); int b1(x+y-1),b2(y-x+n); co[0][b1]=co[1][b2]=1; } n&lt;&lt;=1; for(int i(1);i&lt;n;++i) if(co[0][i]) { int temp(Habs((n&gt;&gt;1)-i)); --sum[temp+1],++sum[n-temp+1]; } for(int i(3);i&lt;n;++i) sum[i]+=sum[i-2]; for(int i(1);i&lt;n;++i) if(i&lt;=(n&gt;&gt;1)) sum[i]+=i; else sum[i]+=n-i; for(int i(1);i&lt;n;++i) if(co[1][i]) sum[i]=0; for(int i(1);i&lt;n;++i) ans+=sum[i]; fw(ans,1); Heriko Deltana;} 「Day6」⬜ 21-NOIP21-20D-D6 「启」今天这题给我做离谱了……希望几天之后的 CSP 不要这样出题…… 各种毒瘤题，还卡常（ 缺省源使用「V5」 「A」 这题场上因为读错题耽误了一个半小时，结果最后写完暴力发现又读错了题……我真是服了（ 「A」题目复述 因为读错 $114514$ 遍题，所以就不简述了吧（ 「A」思路简述因为第一页写在了第 $t$ 页，根据题意，那么接下来的几天的页数会一天比一天小，然后会出现一个 $p_i &lt; p_{i+1}$。然后去掉写过的这几页，又会重复这样的情况。 对于 $q$ 中每一段连续的 $q_i&gt;q_{i+1}$，相当于就是要在剩下的页数里，选出若干页给这一段连续的 $q_i&gt;q_{i+1}$ 使用（由于第 $1$ 页一定会选，所以计算组合数时上下都要减 $1$），于是就在排列 $q$ 中找到所有 $q_i&lt;q_{i+1}$ 的 $i$ 构成一个长度为 $len$ 的数列 $w$，那么答案为： $$\\prod\\limits_{i=2}^{len} \\binom{n-w_{i-1}-1}{w_i-w_{i-1}-1} = (n-1)!\\prod\\limits_{i=2}^{len}\\dfrac{1}{n-a_i}\\cdot\\dfrac{1}{(a_i-a_{i-1}-1)}$$ 用 set 维护 $w$，每次修改去修改前驱或后继即可。 「A」Code 我最一开始 ans 开了两个，一个全局，一个在 main 里面，就因为这个调了两个小时。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169CI MXX(3e5+1),MOD(1e9+7);int n,m,a[MXX];LL fac[MXX],inv[MXX],val[MXX],ans(1);bitset&lt;MXX&gt; co;set&lt;LL&gt; s;I LL FstPow(LL x,LL y){ LL res(1); while(y) { if(y&amp;1) (res*=x)%=MOD; (x*=x)%=MOD,y&gt;&gt;=1; } Heriko res;}I void Pre(){ fac[0]=1; for(int i(1);i&lt;=n;++i) fac[i]=fac[i-1]*i%MOD; inv[n]=FstPow(fac[n],MOD-2); for(int i(n-1);i&gt;=0;--i) inv[i]=inv[i+1]*(i+1)%MOD;}I LL C(int x,int y) {Heriko ((fac[x]*inv[y]%MOD)*inv[x-y])%MOD;}I void Add(int x){ auto i(s.lower_bound(x)); auto lst(i); if(i==s.begin()) { (ans*=C(n-1,x-1))%=MOD; (ans*=FstPow(val[(*i)],MOD-2))%=MOD; (ans*=C(n-x-1,(*i)-x-1))%=MOD; val[x]=C(n-1,x-1); val[(*i)]=C(n-x-1,(*i)-x-1); } else if(i==s.end()) { --i; (ans*=C(n-(*i)-1,x-(*i)-1))%=MOD; val[x]=C(n-(*i)-1,x-(*i)-1); } else { --lst; (ans*=C(n-(*lst)-1,x-(*lst)-1))%=MOD; val[x]=C(n-(*lst)-1,x-(*lst)-1); (ans*=FstPow(val[(*i)],MOD-2))%=MOD; (ans*=C(n-x-1,(*i)-x-1))%=MOD; val[(*i)]=C(n-x-1,(*i)-x-1); } s.insert(x);}I void Del(int x){ auto i(s.lower_bound(x)); auto lst(i); auto org(i); if(i==s.begin()) { (ans*=FstPow(val[x],MOD-2))%=MOD; ++i; (ans*=FstPow(val[(*i)],MOD-2))%=MOD; val[(*i)]=C(n-1,(*i)-1); (ans*=val[(*i)])%=MOD; val[x]=0; } else { --lst,++i; (ans*=FstPow(val[x],MOD-2))%=MOD; if(i!=s.end()) { (ans*=FstPow(val[(*i)],MOD-2))%=MOD; (ans*=C(n-(*lst)-1,(*i)-(*lst)-1))%=MOD; val[(*i)]=C(n-(*lst)-1,(*i)-(*lst)-1); } val[x]=0; } s.erase(org);}S main(){ Files(); fr(n),fr(m);Pre(); for(int i(1);i&lt;=n;++i) fr(a[i]); int lsti(0); for(int i(1);i&lt;=n;++i) { co[i]=(a[i]&lt;a[i+1]); if(co[i]) { (ans*=C(n-lsti-1,i-lsti-1))%=MOD; val[i]=C(n-lsti-1,i-lsti-1); s.insert(i);lsti=i; } } fw(ans,1); while(m--) { int x,y;fr(x),fr(y); swap(a[x],a[y]); int lstq; if(x!=1) { lstq=co[x-1]; co[x-1]=(a[x-1]&lt;a[x]); if(lstq != co[x-1]) co[x-1]?Add(x-1):Del(x-1); } if(x!=n) { lstq=co[x]; co[x]=(a[x]&lt;a[x+1]); if(lstq != co[x]) co[x]?Add(x):Del(x); } if(y!=1) { lstq=co[y-1]; co[y-1]=(a[y-1]&lt;a[y]); if(lstq != co[y-1]) co[y-1]?Add(y-1):Del(y-1); } if(y!=n) { lstq=co[y]; co[y]=(a[y]&lt;a[y+1]); if(lstq != co[y]) co[y]?Add(y):Del(y); } fw(ans,1); } Heriko Deltana;} 「Day7」⬜ 21-NOIP21-20D-D7 「启」 4h 做 A，结果多测清空不规范，爆零两行泪。 可是就快要复赛了啊……还在爆零…… 缺省源使用「V5」. 「A」 4h，两个假算法，多测清空不规范，TLE，爆零。 「A」题目简述你参加了一个为期 $D$ 天的夏令营，在此 $1$ 到 $D$ 天内有 $N$ 个活动，其中第 $i$ 个活动对你的吸引力是 $h_i$ ，且将从第 $s_i$ 天持续到第 $e_i$ 天（包括 $s_i$ 和 $e_i$）。 每天你最多参加 kk 个活动，你想知道在此期间，哪一天的活动对你的吸引力总和最大。 数据范围：$1 \\le N,D \\le 3\\times 10^5.$ 「A」思路简述枚举时间，将当前可选的活动加入时间序列，维护两个堆，一个小根堆表示现在选了哪些课程保持大小为 $k$，另一个堆维护剩下的随时准备补位。 「A」Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y) {Heriko x&gt;y?x:y;}CI MXX(3e5+2);int d,n,k,h[MXX];LL ans;bitset&lt;MXX&gt; in,no;vector&lt; pair&lt;int,int&gt; &gt; v[MXX];priority_queue&lt; pair&lt;int,int&gt; &gt; hp,thp;I void Clear(){ for(int i(1);i&lt;=d+1;++i) v[i].clear(); while(hp.size()) hp.pop(); while(thp.size()) thp.pop(); in=no=0;}I void Solve(){ int opt(0),x(0),sz(0),val(0),num(0); LL sum(0);ans=0; for(int i(1);i&lt;=d;++i) { for(auto j:v[i]) { opt=j.first,x=j.second; if(opt) { if(sz&lt;k) { sum+=h[x];++sz;in[x]=1; hp.push(make_pair(-h[x],x)); } else { while(no[hp.top().second]) hp.pop(); val=-hp.top().first;num=hp.top().second; if(h[x]&gt;val) { in[x]=1;in[num]=0; sum+=(h[x]-val); hp.pop(); hp.push(make_pair(-h[x],x)); thp.push(make_pair(val,num)); } else thp.push(make_pair(h[x],x)); } } else { no[x]=1; if(in[x]) { sum-=h[x];--sz; while (thp.size() &amp;&amp; no[thp.top().second]) thp.pop(); if(thp.size()) { val=thp.top().first,num=thp.top().second;thp.pop(); if(!no[num]) { sum+=val,in[num]=1,++sz; hp.push(make_pair(-val,num)); } } } } } ans=Hmax(ans,sum); }}S main(){ Files(); int T;fr(T); for(int ct(1);ct&lt;=T;++ct) { Clear();fr(d),fr(n),fr(k); for(int i(1),l,r;i&lt;=n;++i) { fr(h[i]),fr(l),fr(r); v[l].push_back(make_pair(1,i)); v[r+1].push_back(make_pair(0,i)); } Solve();printf(&quot;Case #%d: %lld\\n&quot;,ct,ans); } Heriko Deltana;} 「Day8」⬜ 21-NOIP21-20D-D8 「Day9」⬜ 21-NOIP21-20D-D9 「启」拉了。 缺省源使用「V5」. 「A」 场上想了一堆拉掉的玩意。 「A」题目简述给定整数 $N$，称它的一个分解为一组正整数 $x_1,x_2,…,x_k$，满足以下条件： $\\sum_{i = 1}^k x_i = N;$ 对于任意 $1 \\le i \\le k$，都有 $x_i=2^a3^b$，这里 $a,b$ 均为非负整数； 对于任意 $1 \\le i,j \\le k,i≠j$，$x_i$ 都不是 $x_j$ 的因子。 现在要求输出一种 $N(N \\le 10^{100})$ 的分解。 「A」思路简述先将 $N$ 不断除掉 $2$，然后再不断减去最大的 $3$ 的幂，答案最后要乘上那些 $2.$ 这个数据范围需要高精（ 「A」Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126CI MXX(105);struct Pic{ int num[MXX],sz; Pic() {mst(num,0);sz=1;} I void Clear() {mst(num,0);sz=1;} I Pic operator * (const int &amp;co) const { Pic res;res.sz=sz; for(int i(1);i&lt;=sz;++i) res.num[i]=num[i]*co; for(int i(1);i&lt;=sz;++i) res.num[i+1]+=(res.num[i]/10),res.num[i]%=10; while(res.num[res.sz+1]) { ++res.sz; res.num[res.sz+1]+=(res.num[res.sz]/10); res.num[res.sz]%=10; } Heriko res; } I Pic operator * (const Pic &amp;co) const { Pic res;res.sz=co.sz+sz; for(int i(1);i&lt;=sz;++i) for(int j(1);j&lt;=co.sz;++j) { res.num[i+j-1]+=(num[i]*co.num[j]); res.num[i+j]+=(res.num[i+j-1]/10);res.num[i+j-1]%=10; } while(!res.num[res.sz] and res.sz&gt;1) --res.sz; Heriko res; } I Pic operator - (const Pic &amp;co) const { Pic res;res.sz=sz; for(int i(1);i&lt;=sz;++i) { res.num[i]+=num[i]-co.num[i]; if(res.num[i]&lt;0) --res.num[i+1],res.num[i]+=10; } while(!res.num[res.sz] and res.sz&gt;1) --res.sz; Heriko res; } I void RightShift() { for(int i(sz);i;--i) { if(num[i]&amp;1) num[i-1]+=10; num[i]&gt;&gt;=1; } while(!num[sz] and sz&gt;1) --sz; } I bool operator &gt; (const Pic &amp;co) const { if(sz!=co.sz) Heriko sz&gt;co.sz; for(int i(sz);i;--i) if(num[i]!=co.num[i]) Heriko num[i]&gt;co.num[i]; Heriko Deltana; } I bool operator &lt;= (const Pic &amp;co) const {Heriko !((*this)&gt;co);} I void Into(char s[]) { sz=strlen(s+1); for(int i(1);i&lt;=sz;++i) num[i]=s[sz-i+1]-'0'; } I bool Zero() {Heriko (sz==1)&amp;(num[1]==0);} I void fw() {for(int i(sz);i;--i) putchar(num[i]+'0'); putchar(' ');}}n,ans[1005];char s[105];int anslen;S main(){ Files(); scanf(&quot;%s&quot;,s+1);n.Into(s);Pic pw;pw.num[1]=1; while(!n.Zero()) { while(!(n.num[1]&amp;1)) pw=pw*2,n.RightShift(); Pic res,nex;res.num[1]=1;nex=res*3; while(nex&lt;=n) res=nex,nex=res*3; n=n-res;res=res*pw;ans[++anslen]=res; } fw(anslen,1); for(int i(1);i&lt;=anslen;++i) ans[i].fw(); Heriko Deltana;} 「Day10」讲课，略。 「Day11」⬜ 21-NOIP21-20D-D11 「启」A 假了，B 场上以为假了但是其实没假，总结还是拉了。 缺省源使用「V5」. 「A」Bad. 「A」题目简述有一颗 $n(n \\le 10^6)$ 个节点的树，每个节点可能是红色或者黑色，每次操作可以选择一个节点，把这个节点所连的同色的结点反色，求把整棵树变成同一种颜色的最小操作次数。 「A」思路简述因为相邻同色的结点可以看作一块，所有缩为一个点，然后对新树找直径，答案即为直径除 $2.$ 「A」Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y) {Heriko x&gt;y?x:y;}template&lt;typename J&gt;I J Hmin(const J &amp;x,const J &amp;y) {Heriko x&lt;y?x:y;}CI MXX(1e6+1);int n,f[MXX],ans;struct Node{ int nex,to;}r[MXX&lt;&lt;1];int cnt,head[MXX];I void Add(int x,int y){ r[++cnt]=(Node){head[x],y};head[x]=cnt; r[++cnt]=(Node){head[y],x};head[y]=cnt;}bitset&lt;MXX&gt; co;void DFS(int x,int fa){ for(int i(head[x]);i;i=r[i].nex) { int y(r[i].to); if(y==fa) continue; DFS(y,x); if(co[y]!=co[x]) { ans=Hmax(ans,f[x]+f[y]+1); f[x]=Hmax(f[x],f[y]+1); } else { ans=Hmax(ans,f[x]+f[y]); f[x]=Hmax(f[x],f[y]); } }}I int GetCo(){ char c(getchar()); while(c!='R' and c!='B') c=getchar(); Heriko c=='R'?1:0;}S main(){ Files(); fr(n); for(int i(1);i&lt;=n;++i) co[i]=GetCo(); for(int i(1),x,y;i&lt;n;++i) fr(x),fr(y),Add(x,y); DFS(1,0);fw((ans+1)&gt;&gt;1,1); Heriko Deltana;} 「B」 场上最后的贪心策略是对的，但是当时以为假了。 「B」题目简述给出一个长度为 $k$ 的数列，然后给出 $n$ 个操作，操作分为三种： $a_i=b$ $a_i=a_i+b$ $a_i=a_i \\times b$ 其中 $i,b$ 是给定的，每个操作只能用一次，最多使用 $m$ 个操作，让整个数列的乘积最大。 「B」思路简述考虑将 Cover 操作转为 Add 操作，然后贪心的选取贡献权值大的即可。 「B」Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y) {Heriko x&gt;y?x:y;}template&lt;typename J&gt;I J Hmin(const J &amp;x,const J &amp;y) {Heriko x&lt;y?x:y;}CI MXX(1e5+1),MOD(1e9+7);int n,k,m,cnt;LL a[MXX],ans(1),cover[MXX];struct CoFuc{ int opt,pos;LL val;long double dlt;}co[MXX],ro[MXX];I bool CMP(const CoFuc &amp;x,const CoFuc &amp;y) {Heriko x.val&gt;y.val;}I bool RMP(const CoFuc &amp;x,const CoFuc &amp;y) {Heriko x.dlt&gt;y.dlt;}S main(){ Files(); fr(k),fr(n),fr(m); for(int i(1);i&lt;=k;++i) fr(a[i]); for(int i(1);i&lt;=n;++i) { fr(co[i].opt),fr(co[i].pos),fr(co[i].val); if(co[i].opt==1) cover[co[i].pos]=Hmax(cover[co[i].pos],co[i].val); } for(int i(1);i&lt;=k;++i) if(cover[i]&gt;a[i]) ro[++cnt]=(CoFuc){2,i,cover[i]-a[i],0.0}; for(int i(1);i&lt;=n;++i) if(co[i].opt!=1) ro[++cnt]=co[i]; sort(ro+1,ro+1+cnt,CMP); for(int i(1);i&lt;=k;++i) cover[i]=a[i]; for(int i(1);i&lt;=cnt;++i) if(ro[i].opt==2) { ro[i].dlt=1.0*(cover[ro[i].pos]+ro[i].val)/(1.0*cover[ro[i].pos]); cover[ro[i].pos]+=ro[i].val; } else if(ro[i].opt==3) ro[i].dlt=ro[i].val*1.0; sort(ro+1,ro+1+cnt,RMP); for(int i(1);i&lt;=Hmin(m,cnt);++i) if(ro[i].opt==2) a[ro[i].pos]+=ro[i].val; else if(ro[i].opt==3) (ans*=ro[i].val)%=MOD; for(int i(1);i&lt;=k;++i) (ans*=a[i])%=MOD; fw((ans+MOD)%MOD,1); Heriko Deltana;} 「C」 不是这怎么还出特判题呐？ 「C」题目简述小明有 $1$ 到 $n$ 共 $n$ 包零食，同时他又有 $1$ 到 $n$ 共 $n$ 个朋友。 昨天，小明的 $n$ 个朋友都到他家来玩了。他的 $n$ 个朋友瓜分了他的 $n$ 包零食，每个人都恰好吃了一包零食，没有两个人吃了同一包零食。 小明发现，第 $i$ 个朋友吃第 $j$ 包零食能获得的愉悦值是 $i\\bmod j$。 今天，小明想回忆起每个朋友吃的是哪包零食，他想不起来了，但是他却记得了所有人的愉悦值之和 $s$。于是，小明找上了你，请你构造出一种可能的方案。 由于小明记忆力不好，他有可能记错了 $s$，所以可能会存在无解的情况。 「C」思路简述特判题（ $s$ 的上界为 $\\dfrac{n \\times (n+1)}{2}$，超过乆输出无解。 $s=0,1,2,\\dfrac{n \\times (n+1)}{2}-1$ 的时候详见代码，$n\\le 3$ 时同理。 剩余情况我们只需要构造出 $2 \\to n-1$ 的答案。 「C」Code 这里的 fw 函数不太一样，放一下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130template&lt;typename J&gt;I void fw(bool g,J x,bool k){ if(!g) { puts(&quot;SPFA is dead!&quot;); Heriko; } if(x&lt;0) x=-x,putchar('-'); static short stak[35];short top(0); do { stak[top++]=x%10; x/=10; } while(x); while(top) putchar(stak[--top]+'0'); k?puts(&quot;&quot;):putchar(' ');}CI MXX(1e6+1);LL n,s,res,ans[MXX],flg;bitset&lt;MXX&gt; co;S main(){ Files(); fr(n),fr(s); if(s&gt;((n*(n-1))&gt;&gt;1)) Heriko fw(0,114514,1919810),Deltana; if(n==1) { if(!s) puts(&quot;1&quot;); else Heriko fw(0,114514,1919810),Deltana; Heriko Deltana; } else if(n==2) { if(!s) puts(&quot;1\\n2&quot;); else if(s==1) puts(&quot;2\\n1&quot;); else Heriko fw(0,114514,1919810),Deltana; Heriko Deltana; } else if(n==3) { if(!s) puts(&quot;1\\n2\\n3&quot;); else if(s==1) puts(&quot;2\\n1\\n3&quot;); else if(s==2) puts(&quot;3\\n1\\n2&quot;); else if(s==3) puts(&quot;1\\n3\\n2&quot;); else Heriko fw(0,114514,1919810),Deltana; Heriko Deltana; } if(!s) { for(int i(1);i&lt;=n;++i) fw(1,i,1); Heriko Deltana; } else if(s==1) { puts(&quot;2\\n1&quot;); for(int i(3);i&lt;=n;++i) fw(1,i,1); Heriko Deltana; } else if(s==2) { puts(&quot;3\\n1\\n2&quot;); for(int i(4);i&lt;=n;++i) fw(1,i,1); Heriko Deltana; } else if(s==((n*(n-1))&gt;&gt;1)-1) { if(n&amp;1) { ans[1]=3,ans[2]=1,ans[n]=2; for(int i(3);i&lt;n;++i) ans[i]=i+1; } else { ans[1]=1;ans[n]=2; for(int i(2);i&lt;n;++i) ans[i]=i+1; } for(int i(1);i&lt;=n;++i) fw(1,ans[i],1); Heriko Deltana; } ans[n]=1;--s; for(int i(n-1);i&gt;=2;--i) { if(s&gt;=i and s-i!=1) s-=i; else ans[i]=i,co[i]=1; } int nw(n); for(int i(n-1);i;--i) if(!ans[i]) { ans[i]=nw,co[nw]=1; while(co[nw]) --nw; } for(int i(1);i&lt;=n;++i) fw(1,ans[i],1); Heriko Deltana;} 「Day12」✅ 21-NOIP21-20D-D12 已经整理完，博客为：总之就是 | ZROI NOIP21 冲刺 Day12。 「Day13」⬜ 21-NOIP21-20D-D13 「启」今天倒是没挂 A，但是大家都切 A，所以我挂 B 了/cy 缺省源使用「V5」. 「A」切了好耶（ Time:1s Memory:512MiB. 「A」题目简述要求找出满足下列条件最小的数： 这是一个正整数； 这个数至少有四个不同的因子； 这个数的任意两个因子之间的差不小于输入的 $n(n \\le 10^5)$ 「A」思路简述因为要求两个任意两个因子之间的差不小于输入的 $n$，所以想到选取质数。 而题目要求至少要有四个不同的因子，而一个数最小的因子是 $1$，最大的因子是自己，所以我们只需要找到大于 $n+1$ 的第一个质数和大于等于第一个选出来的质数 $+n$ 后的最小的质数即可。 用一个欧拉筛解决质数问题即可。 「A」Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859CI MXX(1e7+5);LL prime[MXX],cnt;bool nopr[MXX];I void Es(LL x){ nopr[1]=1; for(LL i(2);i&lt;=x;++i) { if(!nopr[i]) prime[++cnt]=i; for(int j(1);j&lt;=cnt and prime[j]*i&lt;=x;++j) { nopr[i*prime[j]]=1; if(i%prime[j]==0) break; } }}LL n,T;S main(){ Files(); Es(MXX); fr(T); while(T--) { fr(n);LL fst(0),fstid(0),sed(0); for(int i(1);i&lt;=cnt;++i) if(prime[i]&gt;=n+1) { fst=prime[i]; fstid=i; break; } for(int i(fstid);i&lt;=cnt;++i) if(prime[i]&gt;=fst+n) { sed=prime[i]; break; } fw(sed*fst,1); } Heriko Deltana;} 「B」挂了好耶（ Time:1s Memory:512MiB. 「B」题目简述给出一个有 $n(n\\le 1000)$ 个点的无向完全图，每次在图上去掉一个生成树中的所有边，问最多能进行多少次，并且输出每次要删掉哪些边。 「B」思路简述首先能知道 $n$ 个点的完全图的总边数为 $\\dfrac{n(n-1)}{2}$，而一个生成树的边数为 $n-1$，所以能得出最多能进行 $\\left\\lfloor\\frac{n}{2}\\right\\rfloor$ 次删除操作。 那么下面考虑如何构造出每次删掉的生成树，场上是想的 DFS 删除，但是没判环于是挂掉了。 考完之后看题解发现可以反着来，考虑从 $n-2$ 转移到 $n$ 的时候，对于之前的每一个生成树 $i$ 连上 $2i-1$ 和 $n-1$、$2i$ 和 $n$，然后如果是偶数就再建一个新的，连边同理。 「B」Code123456789101112131415161718192021222324252627int n,m;S main(){ Files(); int T;fr(T); for(int ct(1);ct&lt;=T;++ct) { fr(n);m=(n&gt;&gt;1); printf(&quot;Case #%d: %d\\n&quot;,ct,m); for(int i(1);i&lt;=m;++i) { if(!(n&amp;1)) fw((i+m)%n+1,0),fw(i+m,1); for(int j(1);j&lt;=(n-1)&gt;&gt;1;++j) { fw((i-j+n)%n+1,0),fw((i+j-1)%n+1,1); fw((i+j-1)%n+1,0),fw((i-j+n-1)%n+1,1); } } } Heriko Deltana;} 「C」写不出 Check 好耶（ Time:3s Memory:512MiB. 「C」题目简述现在要将一个 $n(n\\le10^5)$ 个结点的无向树分割成 $k$ 个子树，使得这些子树中结点权值和最大的一颗最小。 「C」思路简述这个题的答案求解……嗯是二分没错了，那么下面的问题就是如何去写 Check（ 然而场上没写出来 T_T 所以这个的 Check 怎么写呢（ 考虑 DFS 去解决（ 设 $f(i)$ 表示当前结点 $i$ 所在的联通块的点权和。对于每一个节点，将其所有孩子的 $f$ 排序以后，从小到大依次往父亲里塞。 塞不下的，就只能切断了，也就是形成单独的联通块，塞进父亲里的，更新到父亲的 $f$ 中，可以继续和上面的节点合并，然后就能求出最大值。 排序和统计用个 vector 即可。 「C」Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y) {Heriko x&gt;y?x:y;}CI MXX(1e5+1);struct Node{ int nex,to;}r[MXX&lt;&lt;1];int cnt,head[MXX];I void Add(int x,int y){ r[++cnt]=(Node){head[x],y};head[x]=cnt; r[++cnt]=(Node){head[y],x};head[y]=cnt;}int n,k;LL val[MXX],ans,f[MXX],sz[MXX];vector&lt;LL&gt; sub[MXX];void DFS(LL lmt,int x,int fa){ f[x]=sz[x]=0;sub[x].clear(); int res(0);sz[x]=val[x]; for(int i(head[x]);i;i=r[i].nex) { int y(r[i].to); if(y==fa) continue; DFS(lmt,y,x);++res;sub[x].push_back(sz[y]);f[x]+=f[y]; } sort(sub[x].begin(),sub[x].end()); for(auto i:sub[x]) if(sz[x]+i&lt;=lmt) sz[x]+=i,--res; else break; f[x]+=res;}I bool Check(LL x){ for(int i(1);i&lt;=n;++i) if(x&lt;val[i]) Heriko Deltana; DFS(x,1,0); Heriko f[1]&lt;k;}S main(){ Files(); int T;fr(T); for(int ct(1);ct&lt;=T;++ct) { fr(n),fr(k);cnt=0;mst(head,0); for(int i(1),x,y;i&lt;n;++i) fr(x),fr(y),Add(x,y); LL sm(0),mx(0); for(int i(1);i&lt;=n;++i) fr(val[i]),sm+=val[i],mx=Hmax(mx,val[i]); if(n==k) { printf(&quot;Case #%d: %lld\\n&quot;,ct,mx); continue; } LL l(0),r(sm); while(l&lt;=r) { LL mid((l+r)&gt;&gt;1); if(Check(mid)) r=mid-1,ans=mid; else l=mid+1; } printf(&quot;Case #%d: %lld\\n&quot;,ct,ans); } Heriko Deltana;} 「Day14」⬜ 21-NOIP21-20D-D14 「启」哈哈又啥都没有，还是使用惊艳骗分。 缺省源使用「V5」. 「A」不知道该说啥。 Time:2s,Memory:512MiB. 「A」题目简述求一颗 $n(n \\le 2000)$ 的树上有多少点集 $S$ 内的任意两点的最短距离为 $d.$ 「A」思路简述先处理出深度，然后按照深度从浅到深跑 DFS，每次选取之前已经选取过的点，然后计算子集大小 $O(1)$ 回答询问。 「A」Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475CI MXX(2001),MOD(1e9+7);struct Node{ int nex,to;}r[MXX&lt;&lt;1];int cnt,head[MXX];I void Add(int x,int y){ r[++cnt]=(Node){head[x],y};head[x]=cnt; r[++cnt]=(Node){head[y],x};head[y]=cnt;}int n,dep[MXX],id[MXX];LL pw2[MXX],tot[MXX],ans[MXX];void DFS1(int x){ for(int i(head[x]);i;i=r[i].nex) if(!dep[r[i].to]) dep[r[i].to]=dep[x]+1,DFS1(r[i].to);}bitset&lt;MXX&gt; vis;void DFS2(int x,int fa,int stp){ if(vis[x]) ++tot[stp]; for(int i(head[x]);i;i=r[i].nex) if(r[i].to!=fa) DFS2(r[i].to,x,stp+1);}S main(){ Files(); fr(n); for(int i(1);i&lt;=n;++i) id[i]=i; pw2[0]=1; for(int i(1);i&lt;=n;++i) pw2[i]=(pw2[i-1]&lt;&lt;1)%MOD; for(int i(1),x,y;i&lt;n;++i) fr(x),fr(y),Add(x,y); dep[1]=1;DFS1(1);sort(id+1,id+1+n,[](int x,int y){Heriko dep[x]&lt;dep[y];}); for(int i(1);i&lt;=n;++i) { vis[id[i]]=1;int tmp(1); memset(tot,0,sizeof(LL)*(n+1)); DFS2(id[i],0,0); for(int j(1);j&lt;=n;++j) { (ans[j]+=(pw2[tot[j]]-1)*(pw2[tmp-1]))%=MOD; tmp+=tot[j]; } } int T;fr(T); while(T--) { int x;fr(x);fw(ans[x],1); } Heriko Deltana;} 「Day15」⬜ 21-NOIP21-20D-D15 「启」哈哈又挂了 A，还是只有垃圾 $10$ 分暴力。 缺省源使用「V5.1」. 「A」挂了。 Time:1s,Memory:1GiB. 「A」题目简述从 $n(n \\le 50)$ 个数中选出一个非空子集，求满足异或和等于与和，每个数都满足 $\\le 2^13.$ 「A」思路简述我们设 $f(i,j,k)$ 表示选取前 $i$ 个数，与和为 $j$，异或和为 $k$ 的方案数，那么显然答案为 $\\sum\\limits_{i=1}^{2^{n}}f(i,j,k)\\times[j=k].$ 因为直接开会炸空间，所以我们滚掉第一维，状态就变成了 $f(0/1,j,k)$，然后我们用一个栈来优化一下复杂度，要不然还是过不去（ 「A」Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253CI NXX(51),MXX(1&lt;&lt;13),SXX(1&lt;&lt;21);bitset&lt;MXX&gt; co[MXX]; int n,m,a[NXX],top[2];LL f[2][MXX][MXX];pair&lt; int,int &gt; stk[2][SXX];LL ans;S main(){ Files(); fr(n); for(int i(1);i&lt;=n;++i) fr(a[i]),m|=a[i]; int nw(0);f[nw][m][0]=1;stk[nw][++top[nw]]=mkp(m,0); for(int i(1),x,y;i&lt;=n;++i) { nw^=1;int lst(nw^1); for(int j(1);j&lt;=top[nw];++j) x=stk[nw][j].first,y=stk[nw][j].second,f[nw][x][y]=0; top[nw]=0; for(int j(0);j&lt;=m;++j) co[j]=0; for(int j(1);j&lt;=top[lst];++j) { x=stk[lst][j].first,y=stk[lst][j].second; f[nw][x&amp;a[i]][y^a[i]]+=f[lst][x][y]; if((x&amp;a[i])==(y^a[i])) ans+=f[lst][x][y]; f[nw][x][y]+=f[lst][x][y]; if(!co[x][y]) co[x][y]=1,stk[nw][++top[nw]]=mkp(x,y); x&amp;=a[i],y^=a[i]; if(!co[x][y]) co[x][y]=1,stk[nw][++top[nw]]=mkp(x,y); } } fw(ans,1); Heriko Deltana;} 「Day16」⬜ 21-NOIP21-20D-D16 因为某些原因未参加。 「SC1」⬜ 21-NOIP21-20D-SC1 同上。 「SC2」⬜ 21-NOIP21-20D-SC2 「启」因为某些事情，前几场考试没参加，这一场听说是信心场还 unr，就打一打玩。 缺省源使用「V5.2」. 「A」诈骗题，但是场上写的结论少了点东西所以只有 $80.$ 「A」题目简述一个长度为 $N$ 的字符串，字典集大小为 $M$，要求连续长度为 $K$ 的子串都必须是回文串，求方案数。 「A」思路简述看起来没啥东西所以就觉得很诈骗（ 分为以下几种情况： $k&gt;n$ 或 $k=1$ 时，答案为 $m^n.$ $k=n$ 时，答案为 $m^{\\frac{n-1}{2}}.$ 否则，当 $k$ 为 $2$ 的倍数的时候，答案为 $m^2$，若不是 $2$ 的倍数，答案为 $m.$ 「A」Code12345678910111213141516171819202122232425262728293031323334353637CI MOD(1e9+7);int n,m,k;I int FstPow(int x,int y){ int res(1); while(y) { if(y&amp;1) (res*=1ll*x)%=MOD; (x*=1ll*x)%=MOD; y&gt;&gt;=1; } Heriko res;}S main(){ Files(); fr(n),fr(m),fr(k); if(k&gt;n or k==1) fw(FstPow(m,n)%MOD,1); else if(k==n) fw(FstPow(m,(n+1)&gt;&gt;1),1); else if(k&amp;1) fw((m*m)%MOD,1); else if(!(k&amp;1)) fw((m+MOD)%MOD,1); Heriko Deltana;} 「B」考场写了个暴力，然后乆润了。 「B」题目简述每次可以在矩阵中选择一行或一列加到答案中，然后把选择的这一列的每一项都减去 $p.$ 「B」思路简述考虑把行和列的操作拆开先预处理，然后最后合并答案的时候减去互相的影响。 「B」Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y){ Heriko x&gt;y?x:y;}CI MXX(1001),KXX(1e5+1);CL INF(1145141919810);int n,m,k,p,a[MXX][MXX];LL ans(-INF),f[KXX],coi[KXX],coj[KXX],g[KXX];priority_queue&lt;LL&gt; q;S main(){ Files(); fr(n),fr(m),fr(k),fr(p); for(int i(1);i&lt;=n;++i) for(int j(1);j&lt;=m;++j) fr(a[i][j]); for(int i(1);i&lt;=n;++i) for(int j(1);j&lt;=m;++j) coi[i]+=a[i][j],coj[j]+=a[i][j]; for(int i(1);i&lt;=n;++i) q.push(coi[i]); for(int i(1);i&lt;=k;++i) { LL x(q.top()); q.pop(); f[i]=f[i-1]+x,x-=p*m; q.push(x); } while(q.size()) q.pop(); for(int i(1);i&lt;=m;++i) q.push(coj[i]); for(int i(1);i&lt;=k;++i) { LL x(q.top()); q.pop(); g[i]=g[i-1]+x,x-=p*n; q.push(x); } for(int i(0);i&lt;=k;++i) ans=Hmax(ans,f[i]+g[k-i]-(1ll*i*(k-i)*p)); fw(ans,1); Heriko Deltana;} 「C」是个大模拟，先不补。 「Day17」⬜ 21-NOIP21-20D-D17 缺省源使用「V5.2」. 「启」没啥好说的。 「A」场上做出来了。 题目。 「A」思路简述我们考虑对于每个点都用两个长度为 $m$ 的二进制数来存储，分别记录第 $i$ 位对应着第 $i$ 次操作的时候的 $X$ 或 $Y$ 归属状态，那么最终两个点 $i,j$ 之间是否有连边就等同于 $X_i \\operatorname{and} Y_j$ 的 $1$ 的个数是否为奇数加上 $X_j \\operatorname{and} Y_i$ 的 $1$ 的个数再减去两者交集。 「A」Code1234567891011121314151617181920212223242526272829303132333435CI NXX(2e4+1),MXX(64);bitset&lt;MXX&gt; X[NXX],Y[NXX];int n,m;LL ans;char s[NXX];S main(){ Files(); fr(n),fr(m); for(int i(1);i&lt;=m;++i) { scanf(&quot;%s&quot;,s+1); for(int j(1);j&lt;=n;++j) { Y[j][i]=(s[j]^48)&amp;1; X[j][i]=((s[j]^48)&gt;&gt;1)&amp;1; } } for(int i(1);i&lt;n;++i) for(int j(i+1);j&lt;=n;++j) ans+=((X[i]&amp;Y[j]).count()+((Y[i]&amp;X[j])^((X[i]&amp;Y[j])&amp;(Y[i]&amp;X[j]))).count())&amp;1; fw(ans,1); Heriko Deltana;} 「B」题目。 「B」思路简述看到这个问题，就很自然地想到二分，于是设 $b_i = a_i - x$，然后去二分这个 $x.$ 然后把 $b$ 的前缀和求出来，求长度为 $k$ 的 LIS. 「B」Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162template&lt;typename J&gt;I J Hmax(const J &amp;x,const J &amp;y){ Heriko x&gt;y?x:y;}CI MXX(2e5+1);const double INF(1e9);int n,k,a[MXX],mx;double ans,b[MXX],f[MXX];I bool Check(double x){ for(int i(1);i&lt;=n;++i) b[i]=b[i-1]+a[i]-x; int hd(0); f[hd]=INF; for(int i(1);i&lt;=n;++i) { if(b[i]&lt;0.0 or b[i]&gt;b[n]) continue; int pos(lower_bound(f,f+1+hd,b[i])-f); f[pos]=b[i]; if(pos==hd) f[++hd]=INF; } Heriko hd&gt;=k;}S main(){ Files(); fr(n),fr(k); for(int i(1);i&lt;=n;++i) fr(a[i]),mx=Hmax(mx,a[i]); double l(0),r(mx*1.0); while(l+(1e-4)&lt;r) { double mid((l+r)/2.0); if(Check(mid)) l=mid,ans=mid; else r=mid; } printf(&quot;%.4lf&quot;,ans); Heriko Deltana;} 「C」题目。 「C」思路简述首先把每个无向边改为两个有向边，然后在每个结点上，可以任意匹配来自两条不同树边的边。 总的方案数为 $2^{n-1}$，但是还有重复的方案，减去即可。 「C」Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960CI MXX(1e6+1),MOD(1e9+7);LL f[MXX],n,inv[MXX],fac[MXX],r[MXX],sum[MXX],tot[MXX],ans(1);I LL FstPow(LL x,LL y){ LL res(1); while(y) { if(y&amp;1) (res*=x)%=MOD; (x*=x)%=MOD; y&gt;&gt;=1; } Heriko res;}S main(){ Files(); fr(n); inv[0]=fac[0]=inv[1]=fac[1]=1; for(int i(2);i&lt;=n;++i) { inv[i]=(MOD-MOD/i)*1ll*inv[MOD%i]%MOD; fac[i]=(fac[i-1]*1ll*i)%MOD; } for(int i(1);i&lt;n;++i) { int x,y; fr(x),fr(y); ++r[x],++r[y]; } f[0]=tot[0]=sum[0]=1; for(int i(1);i&lt;=n;++i) { f[i]=(tot[i-1]+sum[i-1])%MOD; f[i]=(f[i]-f[i-1]+MOD)%MOD; f[i]=(1ll*f[i]*((MOD+1)&gt;&gt;1)%MOD*inv[i]%MOD); sum[i]=(sum[i-1]+f[i])%MOD; tot[i]=(tot[i-1]+sum[i])%MOD; } (ans*=FstPow(2,n-1))%=MOD; for(int i=1;i&lt;=n;i++) ans=1ll*ans*fac[r[i]]%MOD*f[r[i]]%MOD; fw((ans+MOD)%MOD,1); Heriko Deltana;}","link":"/2021/10/29/ZRNOIP21-20D/"}],"tags":[{"name":"Me","slug":"Me","link":"/tags/Me/"},{"name":"OI","slug":"OI","link":"/tags/OI/"},{"name":"About Blog","slug":"About-Blog","link":"/tags/About-Blog/"},{"name":"F1","slug":"F1","link":"/tags/F1/"}],"categories":[{"name":"About Me","slug":"About-Me","link":"/categories/About-Me/"},{"name":"Nothing","slug":"Nothing","link":"/categories/Nothing/"},{"name":"OI-TravelNotes","slug":"OI-TravelNotes","link":"/categories/OI-TravelNotes/"},{"name":"OI-Solutions","slug":"OI-Solutions","link":"/categories/OI-Solutions/"},{"name":"MyBlog","slug":"MyBlog","link":"/categories/MyBlog/"},{"name":"Other","slug":"Other","link":"/categories/Other/"},{"name":"OI-Theorem","slug":"OI-Theorem","link":"/categories/OI-Theorem/"},{"name":"OI-Algorithm","slug":"OI-Algorithm","link":"/categories/OI-Algorithm/"}]}